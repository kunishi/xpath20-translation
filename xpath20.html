<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="JA">
<head>
<meta name="generator" content=
"HTML Tidy for Mac OS X (vers 1 September 2005), see www.w3.org" />
<title>XML 経路言語 (XPath) 2.0</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-CR.css" />
</head>
<body>
<p>訳注: この文書は<a href=
"http://www.w3.org/TR/2006/CR-xpath20-20060608/">http://www.w3.org/TR/2006/CR-xpath20-20060608/</a>を国島丈生(<a href="mailto:kunishi@acm.org">kunishi@acm.org</a>)が訳したものです。この日本語訳はあくまで参考であり、また翻訳には誤りが含まれる可能性があります。ご利用は自己責任でお願いします。一部に翻訳未完成の部分が含まれている場合があります。</p>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XML 経路言語 (XPath) 2.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C勧告候補 8 June
2006</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2006/CR-xpath20-20060608/">http://www.w3.org/TR/2006/CR-xpath20-20060608/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></dd>
<dt>Previous versions:</dt>
<dd><a href=
"http://www.w3.org/TR/2005/CR-xpath20-20051103/">http://www.w3.org/TR/2005/CR-xpath20-20051103/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xpath20-20050915/">http://www.w3.org/TR/2005/WD-xpath20-20050915/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xpath20-20050404/">http://www.w3.org/TR/2005/WD-xpath20-20050404/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xpath20-20050211/">http://www.w3.org/TR/2005/WD-xpath20-20050211/</a>
<a href=
"http://www.w3.org/TR/2004/WD-xpath20-20040723/">http://www.w3.org/TR/2004/WD-xpath20-20040723/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xpath20-20031112/">http://www.w3.org/TR/2003/WD-xpath20-20031112/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xpath20-20030822/">http://www.w3.org/TR/2003/WD-xpath20-20030822/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xpath20-20030502/">http://www.w3.org/TR/2003/WD-xpath20-20030502/</a></dd>
<dt>Editors:</dt>
<dd>Anders Berglund (XSL WG), IBM Research <a href=
"mailto:alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd>
<dd>Scott Boag (XSL WG), IBM Research <a href=
"mailto:scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>
<dd>Don Chamberlin (XML Query WG), IBM Almaden Research Center
<a href=
"mailto:chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>
<dd>Mary F. Fernández (XML Query WG), AT&amp;T Labs <a href=
"mailto:mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>
<dd>Michael Kay (XSL WG), Saxonica<a href=
"http://www.saxonica.com/">http://www.saxonica.com/</a></dd>
<dd>Jonathan Robie (XML Query WG), DataDirect Technologies <a href=
"mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>
<dd>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center
<a href=
"mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd>
</dl>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2006/CR-xpath20-20060608/xpath20.xml">XML</a>
and&nbsp;<a href=
"http://www.w3.org/TR/2006/CR-xpath20-20060608/diff-from-20051103.html">Recent
revisions</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2006&nbsp;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p class="xpath">XPath 2.0は<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>で定義されるデータモデルに適合する値を処理できる式言語で
ある。そのデータモデルはXML文書の木表現を提供し、その他に、整数、文字列、
ブール値といった原子値や、XML文書中の節点への参照や原子値からなる列を提
供する。XPath式の結果は、入力文書から選択された節点、原子値、または、さ
らに一般的に言えば、データモデルで許される任意の列である。この言語の名 前は、最も特徴的な機能である経路式(path
expression)に由来している。経路 式はXML木中の節点の階層的な位置を表す手段を提供する。 XPath
2.0は<a href="#XPath">[XPath 1.0]</a>の上位互換になっており、XPath 1.0に、よ
り豊富なデータ型の支援、文書がXML Schemaを用いて妥当性検証されるときに
有効になる型情報の利用などの機能を加えている。ほとんどすべてのXPath 1.0式について、XPath
2.0でも引き続き同じ結果を得ることを保証するために、 後方互換性モードを提供する。この方針に関する例外を[<a href=
"#id-backwards-compatibility"><b>I XPath 1.0
との後方互換性</b></a>]に記している。</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>On 3 November 2005, this specification <span class=
"xpath"><a href=
"http://www.w3.org/TR/2005/CR-xpath20-20051103/">was
published</a></span> as a <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR">Candidate
Recommendation</a>, and a Call for Implementations was announced.
This revision is published in order to give visibility to the
technical decisions that have been made so far during this phase of
the process and to allow review by W3C Members and other interested
parties. The maturity level of the specification remains unchanged,
and the work is on track to move forward to the <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
Recommendation</a> stage when the exit criteria for the current
phase have been met.</p>
<p>Publication as a Candidate Recommendation does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress. This specification will remain a Candidate Recommendation
until at least 28 February 2006.</p>
<p>The <a href="http://www.w3.org/XML/Query/test-suite/">XPath and
XML Query Test Suite</a> is under development. Implementors are
encouraged to run this test suite and report their results.</p>
<p><span class="xpath">This document was jointly produced by the
<a href="http://www.w3.org/XML/Query">XML Query Working Group</a>
and the <a href="http://www.w3.org/Style/XSL">XSL Working
Group</a>, both of which are part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>.</span></p>
<p>This draft includes corrections and changes based on <a href=
"http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=XPath&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=2005-04-04&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">
public comments</a> recorded in the W3C public Bugzilla repository
(<a href=
"http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</a>)
used for Last Call issues tracking. A list of substantive changes
since the publication of the <a href=
"http://www.w3.org/TR/2005/CR-xpath20-20051103/">Candidate
Recommendation</a> of 03 November 2005 can be found in <a href=
"#id-revisions-log"><b>J Revision Log</b></a>.</p>
<p>Comments on this document are invited and should be made in
W3C's <a href="http://www.w3.org/Bugs/Public/">public Bugzilla
system</a> (instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery mailing list, <a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string <span class=
"xpath">[XPath]</span> in the subject line of your comment, whether
made in Bugzilla or in email. Each Bugzilla entry and email message
should contain only one comment. Archives of the comments and
responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>
.</p>
<p>This document was produced by <span class="xpath">groups</span>
operating under the <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2002/08/xmlquery-IPR-statements">public list of
any patent disclosures</a> made in connection with the deliverables
of the XML Query Working Group <span class="xpath">and also
maintains a <a href=
"http://www.w3.org/Style/XSL/Disclosures">public list of any patent
disclosures</a> made in connection with the deliverables of the XSL
Working Group; those pages also include</span> instructions for
disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> with respect to this specification should
disclose the information in accordance with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">まえがき</a><br />
2 <a href="#id-basics">基本事項</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#context">式文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 <a href=
"#static_context">静的文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 <a href=
"#eval_context">動的文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href=
"#id-processing-model">処理モデル</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 <a href=
"#id-data-model-generation">データモデルの生成</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 <a href=
"#id-schema-import-processing">スキーマの輸入処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 <a href=
"#id-expression-processing">式の処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1
<a href="#id-static-analysis">静的解析相</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2
<a href="#id-dynamic-evaluation">動的評価相</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 <a href=
"#id-serialization">直列化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.5 <a href=
"#id-consistency-constraints">無矛盾性制約</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#errors">エラー処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href=
"#id-kinds-of-errors">エラーの種類</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <a href=
"#id-identifying-errors">エラーの識別と報告</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <a href=
"#id-handling-dynamic">動的エラーの処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.4 <a href=
"#id-errors-and-opt">エラーと最適化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href=
"#id-important-concepts">概念</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href=
"#id-document-order">文書順</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <a href=
"#id-atomization">原子化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 <a href=
"#id-ebv">有効ブール値</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.4 <a href=
"#id-input-sources">入力源</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#id-types">型</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 <a href=
"#id-predefined-types">既定義スキーマ型</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.2 <a href=
"#id-typed-value">型付けされた値と文字列値</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.3 <a href=
"#id-sequencetype-syntax">SequenceTypeの文法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4 <a href=
"#id-sequencetype-matching">SequenceTypeの照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.1
<a href="#id-matching-value">SequenceTypeと値の照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.2
<a href="#id-matching-item">ItemTypeと項目の照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.3
<a href="#id-element-test">要素テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.4
<a href="#id-schema-element-test">スキーマ要素テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.5
<a href="#id-attribute-test">属性テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.6
<a href="#id-schema-attribute-test">スキーマ属性テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#comments">コメント</a><br />
3 <a href="#id-expressions">式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href=
"#id-primary-expressions">基本式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <a href=
"#id-literals">リテラル</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 <a href=
"#id-variables">変数参照</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <a href=
"#id-paren-expressions">括弧式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <a href=
"#id-context-item-expression">文脈項目式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <a href=
"#id-function-calls">関数呼び出し</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href=
"#id-path-expressions">経路式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <a href=
"#id-steps">ステップ</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.1
<a href="#axes">軸</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.2
<a href="#node-tests">節点テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <a href=
"#id-predicates">述語</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 <a href=
"#unabbrev">非省略構文</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.4 <a href=
"#abbrev">省略構文</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href=
"#id-sequence-expressions">列式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <a href=
"#construct_seq">列の構成</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <a href=
"#id-filter-expr">選別式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <a href=
"#combining_seq">節点列の結合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#id-arithmetic">算術式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#id-comparisons">比較式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.1 <a href=
"#id-value-comparisons">値比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.2 <a href=
"#id-general-comparisons">汎用比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.3 <a href=
"#id-node-comparisons">節点比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.6 <a href=
"#id-logical-expressions">論理式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.7 <a href=
"#id-for-expressions">For式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.8 <a href=
"#id-conditionals">条件式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.9 <a href=
"#id-quantified-expressions">限量式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.10 <a href=
"#id-expressions-on-datatypes">SequenceTypes上の式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.1 <a href=
"#id-instance-of">Instance Of</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.2 <a href=
"#id-cast">Cast</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.3 <a href=
"#id-castable">Castable</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.4 <a href=
"#id-constructor-functions">構成子関数</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.5 <a href=
"#id-treat">Treat</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XPathの文法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#id-grammar">EBNF</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.1 <a href=
"#EBNFNotation">記法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.2 <a href=
"#extra-grammatical-constraints">特別な文法上の制約</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.3 <a href=
"#notes-on-parsing">文法に関する備考</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href=
"#lexical-structure">字句構造</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.1 <a href=
"#terminal-symbols">終端記号</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.2 <a href=
"#id-terminal-delimitation">終端記号の区切り</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3 <a href=
"#id-eol-handling">行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.1
<a href="#id-xml10-eol-handling">XML 1.0の行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.2
<a href="#id-xml11-eol-handling">XML 1.1の行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4 <a href=
"#whitespace-rules">空白規則</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.1
<a href="#DefaultWhitespaceHandling">デフォルト空白処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.2
<a href="#ExplicitWhitespaceHandling">明示的空白処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.3 <a href=
"#id-reserved-fn-names">予約済関数名</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.4 <a href=
"#id-precedence-order">優先順位</a><br />
B <a href=
"#id-type-promotion-and-operator-mapping">型の昇格と演算子の写像</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.1 <a href="#promotion">型の昇格</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.2 <a href="#mapping">演算子の写像</a><br />
C <a href="#id-xp-context-components">文脈の構成要素</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href=
"#id-xp-static-context-components">静的文脈の構成要素</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href=
"#id-xp-evaluation-context-components">動的文脈の構成要素</a><br />
D <a href="#id-impl-defined-items">実装定義の項目</a><br />
E <a href="#id-references">参考文献</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.1 <a href=
"#id-normative-references">規格</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.2 <a href=
"#id-non-normative-references">参考</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.3 <a href=
"#id-background-material">背景資料</a><br />
F <a href="#id-xpath-conformance">適合性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;F.1 <a href=
"#id-xpath-static-typing">静的型付け機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F.1.1 <a href=
"#id-xpath-static-extensions">静的型付け拡張</a><br />
G <a href="#id-errors">エラー条件</a><br />
H <a href="#id-glossary">用語集</a> (Non-Normative)<br />
I <a href="#id-backwards-compatibility">XPath 1.0 との後方互換性</a>
(Non-Normative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;I.1 <a href=
"#id-incompat-in-true-mode">互換モードが true のときの非互換性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.2 <a href=
"#id-incompat-in-false-mode">互換性モードが false のときの非互換性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.3 <a href=
"#id-incompat-when-using-schema">スキーマを用いた場合の非互換性</a><br />
J <a href="#id-revisions-log">Revision Log</a>
(Non-Normative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;J.1 <a href="#id-log-050707">10 May
2006</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="id-introduction" id="id-introduction"></a>1 まえがき</h2>
<p class="xpath">XPathの主な目的は<a href="#XML">[XML
1.0]</a>もしくは<a href="#XML1.1">[XML 1.1]</a>の木の節点を指し示すことである。
XPathの名前は、XML文書の階層的構造を巡航するのに経路記述を用いることに由来している。
XPathは簡潔な非XML記法を用い、URIやXMLの属性値中でのXPathの利用を容易にしている。</p>
<p>[<a name="dt-datamodel" id="dt-datamodel" title=
"data model">Definition</a>: XPathは、XML文書の抽象
的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<b>データモデル</b>と呼ばれ、<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>で定義されている。]</p>
<p class="xpath">XPathは、<a href="#XSLT">[XSLT 2.0]</a>や<a href=
"#xquery">[XQuery]</a>などの<b>ホスト言語</b>に埋め込めるように設計されている。XPathには、照合(節点がパターンに照合されるかどうかのテスト)に使用できる自然な部分集合がある。このXPathの使い方は<a href="#XSLT">[XSLT
2.0]</a>で記述されている。</p>
<p>XQueryバージョン1.0はXPathバージョン2.0の拡張である。XPath2.0でもXQuery
1.0でも構文的に正しく、かつ正常に実行される式はすべて、いずれの言語でも同じ結果を返す。これらの言語は非常に密接に関連しているため、これらの言語の文法や言語記述は、一貫性を保つために共通のソースから生成されており、これらの仕様書の編者は密に協力して作業を進めている。</p>
<p>またXPathは、以下の仕様書に依存しており、密接に関連している。</p>
<ul>
<li>
<p><a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>では、すべてのXPath式の基礎となるデータモデルを定義する。</p>
</li>
<li>
<p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal
Semantics]</a>では、XPathの静的な意味を定義する。また動的な意味に関して、形式的ではあるが規範ではない記述を含んでいる。これは、実装を行う人や形式的定義を必要とする人に有用である。</p>
</li>
<li>
<p>XPathの型システムは<a href="#XMLSchema">[XML Schema]</a>に基づいている。</p>
</li>
<li>
<p>XPathで支援されている組み込み関数ライブラリや演算子は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義される。</p>
</li>
</ul>
<p>この文書は<a href="#XML">[XML
1.0]</a>で用いられているのと同じ基本的なEBNF記法を用いて、XPathの文法を規定する。特に注釈を加えない限り(<a href="#lexical-structure"><b>A.2
字句構造</b></a>)、空白は<span class=
"xpath">式</span>中では意味を持たない。文法の生成規則は、それが記述している特徴とともに紹介される。また、完全な文法は付録
[<a href="#nt-bnf"><b>A XPathの文法</b></a>]で示される。この付録は規定版である。</p>
<p>
この文書中の文法の生成規則では、名前を持つ記号には下線を引き、リテラルテキストは二重引用符で囲む。例えば、次の生成規則は関数呼び出しの構文を記述している:</p>
<h5><a name="d2e286" id="d2e286"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="fakeid_doc-xpath-FunctionCall" id=
"fakeid_doc-xpath-FunctionCall"></a>[48]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>この生成規則は次のように読むべきである:
関数呼び出しは、一つの開き括弧が続く一つのQNameからなる。その開き括弧の次には、省略可能な引数リストが続く。引数リストは(もし存在するならば)1つ以上の式からなり、それらはコンマで区切られる。省略可能な引数リストの次には、1つの閉じ括弧が続く。</p>
<p>
この仕様書では、言語処理のいくつかの面について、<b>実装定義</b>または<b>実装依存</b>という言葉で記述している。</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>実装定義</b>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>実装依存</b>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。]</p>
</li>
</ul>
<p class="xpath">
この仕様書で<b>実装定義</b>または<b>実装依存</b>と記述されている言語の側面は、XPathが埋め込まれているホスト言語の仕様書からさらに制限を受けるかもしれない。</p>
<p>この文書はXPathの動的な意味を規定として定義する。XPathの静的な意味は<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>において規定として定義されている。この文書では、例、および「Note:」というラベルの付けられた資料は説明の目的で用意されたものであり、参考(not
normative)である。</p>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>2 基本事項</h2>
<p>XPathの基本的な構成ブロックは<b>式</b>である。これは<a href=
"#Unicode">[Unicode]</a>文字(使用されるUnicodeの版は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。)の列である。この言語には、キーワード、記号、演算数などから構成される様々な種類の式が用意されている。一般的に、式の演算数は別の式である。XPathでは、式は完全に一般的な入れ子であってもよい。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>この仕様書では、<a href=
"#Unicode">[Unicode]</a>文字の文字列の文字符号化方式に関して、何も仮定しないし、何も要求しない。</p>
</div>
<p>
XMLと同様に、XPathは大文字小文字を区別する言語である。XPathのキーワードは小文字を用い、かつ予約されていない。すなわち、XPath式に出現する名前はXPath言語のキーワードと同じであってもよい。ただし<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>に挙げられている接頭語なし関数名を除く。</p>
<p>[<a name="dt-value" id="dt-value" title="value">Definition</a>:
<a title="data model" href=
"#dt-datamodel">データモデル</a>では、<b>値</b>は常に<a title="sequence" href=
"#dt-sequence">列</a>である。] [<a name="dt-sequence" id="dt-sequence"
title="sequence">Definition</a>: <b>列</b>は0個以上の<a title="item"
href="#dt-item">項目</a>の順序付きコレクションである。] [<a name="dt-item" id=
"dt-item" title="item">Definition</a>: <b>項目</b>は<a title=
"atomic value" href="#dt-atomic-value">原子値</a>か<a title="node"
href="#dt-node">節点</a>である。] [<a name="dt-atomic-value" id=
"dt-atomic-value" title="atomic value">Definition</a>:
<b>原子値</b>は<a href="#XMLSchema">[XML
Schema]</a>で定義される<b>原子型</b>の値空間に含まれる値である。] [<a name="dt-node" id=
"dt-node" title="node">Definition</a>: <b>節点</b>は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>で定義されている<b>節点の種類</b>のいずれかのインスタンスである。]
各節点は唯一の<b>節点識別性</b>、1つの<b>型付けされた値</b>、そして1つの<b>文字列値</b>を持つ。これに加え、いくつかの節点は<b>名前</b>を持つ。節点の<b>型付けされた値</b>は0個以上の原子値からなる列である。節点の<b>文字列値</b>は<code>xs:string</code>型の値である。節点の<b>名前</b>は<code>xs:QName</code>型の値である。</p>
<p>[<a name="dt-singleton" id="dt-singleton" title=
"singleton">Definition</a>:
ただ一つの項目しか含まない列を<b>単一値列</b>という。]項目は、その項目を含む単一値列と同一である。列が入れ子になることは決してない。例えば1,
(2, 3), () という値を一つの列に結合した結果は (1, 2, 3)になる。[<a name=
"dt-empty-sequence" id="dt-empty-sequence" title=
"empty sequence">Definition</a>: 0個の項目を含む列を<b>空列</b>という。]</p>
<p>[<a name="dt-data-model-instance" id="dt-data-model-instance"
title="XDM instance">Definition</a>:
<b>XDMインスタンス</b>という用語は<b>値</b>という用語と同義であり、<a title="data model"
href="#dt-datamodel">データモデル</a>中の<a title="node" href=
"#dt-node">節点</a>や<a title="atomic value" href=
"#dt-atomic-value">原子値</a>からなる制約なしの列を表す。]</p>
<p>XPathにおける名前は<b>QName</b>と呼ばれ、<a href="#XMLNAMES">[XML
Names]</a>中の文法に従う。[<a name="dt-qname" id="dt-qname" title=
"QName">Definition</a>:
字句としては、<b>QName</b>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。]
字句としてのQNameは、<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>[<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]を用いて名前空間接頭辞を名前空間URIに解決することにより、<b>展開済QName</b>に変換することができる。
[<a name="dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName">Definition</a>:
<b>展開済QName</b>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。]名前空間URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>のためのルールに従って、空白に関して正規化される。2つの展開済QNameが等しいとは、それらの名前空間URIが等しく、かつそれらの局所名が等しいときである(それらの名前空間接頭辞が等しくなくてもよい)。名前空間URIと局所名はコード位置に基づいて比較され、それ以上の正規化は行われない。</p>
<p><span class=
"xpath">この文書では、以下の名前空間接頭辞を、以下に列挙する名前空間URIを表すものとして用いる。この文書でのこれらの名前空間接頭辞の束縛は参考である。</span></p>
<ul>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>err = http://www.w3.org/2005/xqt-errors</code> (<a href=
"#id-identifying-errors"><b>2.3.2 エラーの識別と報告</b></a>を見よ)</p>
</li>
</ul>
<p>要素節点は<b>有効範囲内名前空間</b>と呼ばれる性質を持つ。[<a name=
"dt-in-scope-namespaces" id="dt-in-scope-namespaces" title=
"in-scope namespaces">Definition</a>:
要素節点の<b>有効範囲内名前空間</b>性質は、<b>名前空間束縛</b>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。]</p>
<p class="xpath"><a href="#XPath">[XPath
1.0]</a>では、要素節点の有効範囲内名前空間は、<b>名前空間軸</b>上に配置される<b>名前空間節点</b>のコレクションとして表される。XPathバージョン2.0では、名前空間軸は推奨されず、ホスト言語によって支援される必要もない。名前空間軸を支援しないホスト言語では、名前空間束縛を節点の形で表現する必要はない。</p>
<p>[<a name="dt-URI" id="dt-URI" title="URI">Definition</a>:
この仕様書では、<b>URI</b>という用語は、<a href=
"#RFC3986">[RFC3986]</a>で定義され<a href=
"#RFC3987">[RFC3987]</a>で新しい名前<b>IRI</b>として拡張されたUniversal Resource
Identifierを表す。] ただし、IRIよりもURIという用語を好んで残している。"Base
URI"のように、すべてのXML関連の仕様書で定義され、また参照されてきた概念に新しい名前を与えることを避けるためである。</p>
<div class="div2">
<h3><a name="context" id="context"></a>2.1 式文脈</h3>
<p>[<a name="dt-expression-context" id="dt-expression-context"
title="expression context">Definition</a>:
ある式に対する<b>式文脈</b>は、その式の結果に影響を与えうるすべての情報からなる。] この情報は<a title=
"static context" href="#dt-static-context">静的文脈</a>と<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>という2種類に分けられる。</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>2.1.1
静的文脈</h4>
<p>[<a name="dt-static-context" id="dt-static-context" title=
"static context">Definition</a>:
式の<b>静的文脈</b>は、その式の評価よりも静的解析において有効である情報である。] この情報は、式が<a title=
"static error" href=
"#dt-static-error">静的エラー</a>を含むかどうか決定するのに用いることができる。もし式の解析が、<a title="static context"
href=
"#dt-static-context">静的文脈</a>中の値を割り当てられていない構成要素に依存するならば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する [<a title=
"err:XPST0001" href="#ERRXPST0001">err:XPST0001</a>]。</p>
<p><a title="static context" href=
"#dt-static-context">静的文脈</a>の構成要素を以下にまとめる。<span class=
"xpath">各構成要素のデフォルト初期値はホスト言語で指定されていてもよい。各構成要素の有効範囲は<a href=
"#id-xp-static-context-components"><b>C.1
静的文脈の構成要素</b></a>で指定されている。</span></p>
<ul>
<li>
<p>[<a name="dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode">Definition</a>: <b>XPath
1.0互換モード</b>。<span class=
"xpath">この値が<code>true</code>であるのは、XPathバージョン1.0への後方互換性のためのルールが有効である場合である。そうでない場合は<code>false</code>になる。</span>]</p>
</li>
<li>
<p>[<a name="dt-static-namespaces" id="dt-static-namespaces" title=
"statically known namespaces">Definition</a>:
<b>静的既知名前空間</b>。これは、組(接頭辞,
URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。] URIの値は<a href=
"#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">有効範囲内名前空間</a>と<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の違いに注意せよ。前者は要素節点の動的性質であり、後者は式の静的性質である。</p>
</li>
<li>
<p>[<a name="dt-def-elemtype-ns" id="dt-def-elemtype-ns" title=
"default element/type namespace">Definition</a>:
<b>デフォルト要素/型名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。]
URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-def-fn-ns" id="dt-def-fn-ns" title=
"default function namespace">Definition</a>:
<b>デフォルト関数名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。]
URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-issd" id="dt-issd" title=
"in-scope schema definitions">Definition</a>:
<b>有効範囲内スキーマ定義</b>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。]
次の3つの部分を含む。</p>
<ul>
<li>
<p>[<a name="dt-is-types" id="dt-is-types" title=
"in-scope schema type">Definition</a>: <b>有効範囲内スキーマ型</b>。各スキーマ型定義は、
<a title="expanded QName" href="#dt-expanded-qname">展開済QName</a>
(<b>名前付けされた型</b>に対して) か<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の型識別子
(<b>無名型</b>に対して)のいずれかで識別される。有効範囲内スキーマ型は<a href=
"#id-predefined-types"><b>2.5.1 既定義スキーマ型</b></a>で述べられる既定義スキーマ型を含む。
]</p>
</li>
<li>
<p>[<a name="dt-is-elems" id="dt-is-elems" title=
"in-scope element declarations">Definition</a>:
<b>有効範囲内要素定義</b>。各要素定義は、<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位要素定義に対して)か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の要素識別子
(局所要素定義に対して)のいずれかで識別される。] 要素定義は、その要素の<a title="substitution group"
href="#dt-substitution-group">置換グループ</a>の加入に関する情報を含む。</p>
<p>[<a name="dt-substitution-group" id="dt-substitution-group"
title="substitution group">Definition</a>: <b>置換グループ</b>は<a href=
"#XMLSchema">[XML Schema]</a>第1部,
2.2.2.2節で定義されている。直観的には、与えられた要素(<b>先導要素</b>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。]</p>
</li>
<li>
<p>[<a name="dt-is-attrs" id="dt-is-attrs" title=
"in-scope attribute declarations">Definition</a>: <b>有効範囲内属性定義</b>
各属性定義は<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位属性定義に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の属性識別子
(局所属性定義に対して)のいずれかで識別される。]</p>
</li>
</ul>
</li>
<li>
<p>[<a name="dt-in-scope-variables" id="dt-in-scope-variables"
title="in-scope variables">Definition</a>: <b>有効範囲内変数</b>。これは組
(展開済QName, 型) の集合であり、式中で参照可能な変数の集合を定義する。<a title="expanded QName"
href="#dt-expanded-qname">展開済QName</a>は変数名、型はその変数の<a title=
"static type" href="#dt-static-type">静的型</a>である。]</p>
<p>変数を束縛する式 (<code>for</code>式, <code>some</code>式,
<code>every</code>式など)は、その式の部分式の<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>を新しく束縛された変数とその型によって拡張する。</p>
</li>
<li>
<p>[<a name="dt-context-item-static-type" id=
"dt-context-item-static-type" title=
"context item static type">Definition</a>:
<b>文脈項目の静的型</b>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<a title=
"static type" href="#dt-static-type">静的型</a>を定義する。]</p>
</li>
<li>
<p>[<a name="dt-function-signature" id="dt-function-signature"
title="function signature">Definition</a>:
<b>関数のシグネチャ</b>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<a title=
"expanded QName" href="#dt-expanded-qname">展開済QName</a>と次数 (引数の数)
によって一意に識別される。] 名前と次数に加え、関数のシグネチャはそれぞれ、その関数の引数と結果の<a title=
"static type" href="#dt-static-type">静的型</a>を指定する。</p>
<p><a title="function signature" href=
"#dt-function-signature">関数のシグネチャ</a>は、<a title=
"constructor function" href=
"#dt-constructor-function">構成子関数</a>のシグネチャを含む。これについては<a href=
"#id-constructor-functions"><b>3.10.4 構成子関数</b></a>で議論する。</p>
</li>
<li>
<p>[<a name="dt-static-collations" id="dt-static-collations" title=
"statically known collations">Definition</a>: <b>静的既知照合順序</b>。これは組
(URI, 照合順序)の<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の集合である。式の処理に用いることのできる照合順序の名前を定義する。]
[<a name="dt-collation" id="dt-collation" title=
"collation">Definition</a>:
<b>照合順序</b>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>を見よ。]</p>
</li>
<li>
<p>[<a name="dt-def-collation" id="dt-def-collation" title=
"default collation">Definition</a>:
<b>デフォルト照合順序</b>。これは、明示的に照合順序が指定されていないときに、<a title=
"statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型
(およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。]</p>
</li>
<li>
<p>[<a name="dt-base-uri" id="dt-base-uri" title=
"base URI">Definition</a>: <b>基底URI</b>。 これは絶対URIであり、
(例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。]
URIの値は<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-known-docs" id="dt-known-docs" title=
"statically known documents">Definition</a>: <b>静的既知文書</b>。
これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<a title="static type"
href="#dt-static-type">静的型</a>である。]
<code>fn:doc</code>の引数が<b>静的既知文書</b>にはない文字列リテラルであるとき、<code>fn:doc</code>の<a title="static type"
href=
"#dt-static-type">静的型</a>は<code>document-node()?</code>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<b>静的既知文書</b>の目的は静的型情報を提供することであり、どの文書が利用可能かを決定することではない。URIが<b>静的既知文書</b>中になくても、<code>fn:doc</code>を用いてアクセスできる。</p>
</div>
</li>
<li>
<p>[<a name="dt-known-collections" id="dt-known-collections" title=
"statically known collections">Definition</a>:
<b>静的既知コレクション</b>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。]
<code>fn:collection</code>の引数が<b>静的既知コレクション</b>にない文字列リテラルであるとき、<code>fn:collection</code>の<a title="static type"
href="#dt-static-type">静的型</a>は<code>node()*</code>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<b>静的既知コレクション</b>の目的は静的型情報を提供することで、どのコレクションが利用可能かを決定することではない。URIが<b>静的既知コレクション</b>になくても、<code>fn:collection</code>を用いてアクセスできる。</p>
</div>
</li>
<li>
<p>[<a name="dt-known-default-collection" id=
"dt-known-default-collection" title=
"statically known default collection type">Definition</a>:
<b>静的既知デフォルトコレクション型</b>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。]
実装によって他の値に初期化されない限り、<b>静的既知デフォルトコレクション型</b>の値は<code>node()*</code>である。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>2.1.2 動的文脈</h4>
<p>[<a name="dt-dynamic-context" id="dt-dynamic-context" title=
"dynamic context">Definition</a>:
式の<b>動的文脈</b>は、その式が評価されているときに利用可能な情報として定義される。] 式の評価が<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>のうち値が割り当てられていない部分に依存するとき、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する [<a title=
"err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
<p><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の個々の構成要素を以下にまとめる。これらの構成要素の意味を支配する詳細なルールは<a href="#id-xp-evaluation-context-components"><b>C.2
動的文脈の構成要素</b></a>にある。</p>
<p><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>は<a title="static context" href=
"#dt-static-context">静的文脈</a>の部分要素すべて、および以下に列挙する追加構成要素を含む。</p>
<p>[<a name="dt-focus" id="dt-focus" title="focus">Definition</a>:
<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の最初の3つの構成要素
(文脈項目、文脈位置、文脈サイズ)を、式の<b>焦点</b>という。]
焦点を用いると、処理器はどの項目が式によって処理されているかを追跡することができる。</p>
<p>ある種の言語の構成要素、すなわち<a title="path expression" href=
"#dt-path-expression">経路式</a> <code>E1/E2</code>と<a title=
"predicate" href="#dt-predicate">述語</a>
<code>E1[E2]</code>は、部分式の評価の際に新しい焦点を作成する。これらの構成要素では、<code>E1</code>を評価した結果の列中の項目それぞれに対し、<code>E2</code>が1回評価される。
<code>E2</code>が評価されるたびに、異なる焦点で評価が行われる。<code>E2</code>を評価する焦点を<b>内部焦点</b>、<code>E1</code>を評価する焦点を<b>外部焦点</b>という。内部焦点は、<code>E2</code>が評価されている間のみ存在する。この評価が終了するとき、含むほうの式の評価が元の焦点のまま行われる。</p>
<ul>
<li>
<p>[<a name="dt-context-item" id="dt-context-item" title=
"context item">Definition</a>:
<b>文脈項目</b>は現在処理している項目である。項目は原子値か節点である。][<a name="dt-context-node"
id="dt-context-node" title="context node">Definition</a>:
文脈項目が節点であるとき、<b>文脈節点</b>と呼ぶこともできる。]
文脈項目は1つのドット(<code>.</code>)からなる式によって得られる。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E1</code>を評価して得られる列中の項目それぞれが、<code>E2</code>の評価に対する内部焦点の文脈項目となる。</p>
</li>
<li>
<p>[<a name="dt-context-position" id="dt-context-position" title=
"context position">Definition</a>:
<b>文脈位置</b>は、現在処理されている項目列中での文脈項目の位置である。]文脈項目が変化するたび、文脈位置も変化する。焦点が定義されているとき、文脈位置の値は0より大きい整数である。式<code>fn:position()</code>によって文脈位置が返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点での文脈位置は、<code>E1</code>を評価して得られる列中の文脈項目の位置である。列の最初の項目の位置は常に1である。文脈位置は常に、文脈サイズより小さいか等しい。</p>
</li>
<li>
<p>[<a name="dt-context-size" id="dt-context-size" title=
"context size">Definition</a>:
<b>文脈サイズ</b>は、現在処理されている項目列に含まれる項目数である。]
文脈サイズの値は常に0より大きい整数である。式<code>fn:last()</code>によって文脈サイズが返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点の文脈サイズは、<code>E1</code>の評価で得られる列に含まれる項目数である。</p>
</li>
<li>
<p>[<a name="dt-variable-values" id="dt-variable-values" title=
"variable values">Definition</a>: <b>変数の値</b>。これは、組 (展開済QName,
値)の集合である。式の<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>と同じ<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が含まれる。]</p>
</li>
<li>
<p>[<a name="dt-function-implementation" id=
"dt-function-implementation" title=
"function implementation">Definition</a>: <b>関数の実装</b>。<a title=
"function signature" href=
"#dt-function-signature">関数のシグネチャ</a>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。]</p>
</li>
<li>
<p>[<a name="dt-date-time" id="dt-date-time" title=
"current dateTime">Definition</a>:
<b>現在のdateTime</b>。この情報は<span class=
"xpath">式</span>の処理の間のある<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<span class="xpath">式</span>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。]</p>
</li>
<li>
<p>[<a name="dt-timezone" id="dt-timezone" title=
"implicit timezone">Definition</a>: <b>暗黙タイムゾーン</b>。これは、タイムゾーンを持たない
data, time,
dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<a title="implementation defined"
href=
"#dt-implementation-defined">実装定義</a>の値である。タイムゾーンの正しい値の範囲については<a href="#XMLSchema">[XML
Schema]</a>を見よ。]</p>
</li>
<li>
<p>[<a name="dt-available-docs" id="dt-available-docs" title=
"available documents">Definition</a>:
<b>利用可能文書</b>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<a title=
"data model" href=
"#dt-datamodel">データモデル</a>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。]
利用可能文書の集合は<a title="statically known documents" href=
"#dt-known-docs">静的既知文書</a>の集合に限定されず、また空集合でもよい。</p>
</li>
<li>
<p>[<a name="dt-available-collections" id=
"dt-available-collections" title=
"available collections">Definition</a>:
<b>利用可能コレクション</b>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。]
利用可能コレクションの集合は<a title="statically known collections" href=
"#dt-known-collections">静的既知コレクション</a>の集合に限定されず、また空集合でもよい。</p>
</li>
<li>
<p>[<a name="dt-default-collection" id="dt-default-collection"
title="default collection">Definition</a>:
<b>デフォルトコレクション</b>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。]
<b>デフォルトコレクション</b>の値は実装によって初期化されてもよい。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>2.2
処理モデル</h3>
<p>XPathは<a title="data model" href=
"#dt-datamodel">データモデル</a>と<a title="expression context" href=
"#dt-expression-context">式文脈</a>に基づいて定義される。</p>
<img src="ProcMod-XPath.gif" alt="Processing Model Overview" />
<p>図1: 処理モデルの概要</p>
<p>
図1は、この後詳細を述べる処理段階の概要を図で示したものである。このうちいくつかの段階は完全にXPathの範疇外である。図1では、これらの段階は言語の境界を表す実線の外側、<b>外部処理</b>とラベル付けされた領域に描かれている。外部処理域には、問合せが行われるデータを表現する<a title="XDM instance"
href="#dt-data-model-instance">XDMインスタンス</a>の生成(<a href=
"#id-data-model-generation"><b>2.2.1
データモデルの生成</b></a>を見よ)、スキーマの輸入処理(<a href=
"#id-schema-import-processing"><b>2.2.2
スキーマの輸入処理</b></a>を見よ)、直列化(<a href="#id-serialization"><b>2.2.4
直列化</b></a>を見よ)などが含まれる。言語の境界の内側は<span class=
"xpath">XPath処理域</span>と呼ばれ、静的解析段階と動的評価段階(<a href=
"#id-expression-processing"><b>2.2.3 式の処理</b></a>を見よ)が含まれる。
<span class="xpath">XPath</span>処理域上の無矛盾性制約は<a href=
"#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>で定義される。</p>
<div class="div3">
<h4><a name="id-data-model-generation" id=
"id-data-model-generation"></a>2.2.1 データモデルの生成</h4>
<p><span class="xpath">式</span>が処理できるようになる前に、式の入力データが<a title=
"XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>として表現されなければならない。この処理はXPathの範囲外で発生し、そのため図1ではこの処理を外部処理域に置いている。以下にXML文書を<a title="XDM instance"
href="#dt-data-model-instance">XDMインスタンス</a>に変換する段階を示す。</p>
<ol class="enumar">
<li>
<p>文書が、<b>XML情報集合</b>(<a href="#XINFO">[XML
Infoset]</a>を見よ)を生成するXMLパーザによって解析される。解析された文書は1つ以上のスキーマに対して妥当性検証されてもよい。この処理は<a href="#XMLSchema">[XML
Schema]</a>に記述されているが、この結果、<b>検証後情報集合</b>(Post-Schema Validation
Infoset,
PSVI)と呼ばれる抽象情報構造が得られる。もし文書に関連するスキーマがなければ、文書の情報集合が保存される。(図1のDM1を見よ。)</p>
</li>
<li>
<p>情報集合もしくはPSVIが、<a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>に書かれている処理によって<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>に変換される。(図1のDM2を見よ。)</p>
</li>
</ol>
<p>上に述べた段階は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>がどのように構築されるかという一例を提供している。XDMインスタンスは関係データベースから直接合成されるかもしれないし、他の方法(図1のDM3を見よ)で構築されるかもしれない。XPathは<a title="data model"
href=
"#dt-datamodel">データモデル</a>に基づいて定義されるが、XDMインスタンスがどのように構築されるかについては、制約を何も置かない。</p>
<p>[<a name="dt-type-annotation" id="dt-type-annotation" title=
"type annotation">Definition</a>: <a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の要素節点や属性節点はそれぞれ<b>型注釈</b>(<a href="#datamodel">[XQuery/XPath
Data Model
(XDM)]</a>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<a title=
"schema type" href="#dt-schema-type">スキーマ型</a>であり、節点の<a title=
"string value" href="#dt-string-value">文字列値</a>と<a title=
"typed value" href="#dt-typed-value">型付けされた値</a>の関連を記述する。]
<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>が<a href=
"http://www.w3.org/TR/xpath-datamodel/#const-psvi">3.3 Construction
from a PSVI</a><sup xmlns=
""><small>DM</small></sup>に述べられているように妥当なXML文書から導出されたならば、要素節点や属性節点の型注釈はスキーマ妥当性検証から導出される。
XPathは要素節点や属性節点の型注釈に直接アクセスする方法は用意しない。</p>
<p>属性の値は属性節点によって直接表される。型が不明な属性節点(スキーマのない文書に出現する場合など)には<a title=
"type annotation" href="#dt-type-annotation">型注釈</a>
<code>xs:untypedAtomic</code>が与えられる。</p>
<p>要素の値はその要素の子たちによって表される。子にはテキスト節点やほかの要素節点が含まれてもよい。要素節点の<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>は、その子テキスト節点の値がどのように解釈されるかを示す。妥当性検証されていない要素(スキーマのない文書中に出現する場合など)には、<code>xs:untyped</code>というスキーマ型が注釈付けされる。妥当性検証されて部分的に妥当だとされた要素には<code>xs:anyType</code>というスキーマ型が注釈付けされる。もし要素が<code>xs:untyped</code>と注釈付けされているなら、そのすべての子孫要素節点もまた<code>xs:untyped</code>と注釈付けされる。しかし、もし要素が<code>xs:anyType</code>と注釈付けされているなら、その子孫要素節点のいくつかには、より詳細な<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が付けられるかもしれない。</p>
</div>
<div class="div3">
<h4><a name="id-schema-import-processing" id=
"id-schema-import-processing"></a>2.2.2 スキーマの輸入処理</h4>
<p class="xpath"><a title="static context" href=
"#dt-static-context">静的文脈</a>内での<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>はホスト言語によって用意され(図1の段階SI1を見よ)、<a href=
"#id-consistency-constraints"><b>2.2.5
無矛盾性制約</b></a>で定義される無矛盾性制約を満たさなければならない。</p>
</div>
<div class="div3">
<h4><a name="id-expression-processing" id=
"id-expression-processing"></a>2.2.3 式の処理</h4>
<p>XPathは、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>と<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>という2つの処理相を定義する(図1を参照)。静的解析相では、<a title="static error"
href="#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、または<a title="type error" href=
"#dt-type-error">型エラー</a>が発生することがある。動的評価相では、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>と<a title=
"type error" href=
"#dt-type-error">型エラー</a>のみ発生することがある。これらの種類のエラーは<a href=
"#id-kinds-of-errors"><b>2.3.1 エラーの種類</b></a>で定義される。</p>
<p>それぞれの相について、実装はこの文書の仕様に従う結果を得る戦略やアルゴリズムを自由に使ってよい。</p>
<div class="div4">
<h5><a name="id-static-analysis" id=
"id-static-analysis"></a>2.2.3.1 静的解析相</h5>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: <b>静的解析相</b>は式自身と<a title=
"static context" href=
"#dt-static-context">静的文脈</a>に依存する。<b>静的解析相</b>は入力データ(スキーマを除く)には依存しない。]</p>
<p>静的解析相では、<span class=
"xpath">XPath式</span>は構文解析され、<b>演算木</b>と呼ばれる内部表現となる(図1の段階SQ1)。構文解析エラーは<a title="static error"
href="#dt-static-error">静的エラー</a>として発生する [<a title="err:XPST0003"
href="#ERRXPST0003">err:XPST0003</a>]。次に<a title="static context"
href="#dt-static-context">静的文脈</a>が実装によって初期化される(段階SQ2)。<a title=
"static context" href=
"#dt-static-context">静的文脈</a>はスキーマ型名、関数名、名前空間接頭辞、変数名などを解決するのに用いられる(段階SQ4)。もし、<b>演算木</b>中のこれらの種類のいずれかの名前が<a title="static context"
href="#dt-static-context">静的文脈</a>になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>([<a title="err:XPST0008" href=
"#ERRXPST0008">err:XPST0008</a>]もしくは[<a title="err:XPST0017" href=
"#ERRXPST0017">err:XPST0017</a>])が発生する(ただし、<a href=
"#id-element-test"><b>2.5.4.3 要素テスト</b></a>および<a href=
"#id-attribute-test"><b>2.5.4.5 属性テスト</b></a>にあるこのルールの例外を見よ)。</p>
<p>次に、<b>演算木</b>は、<a title="atomization" href=
"#dt-atomization">原子化</a>、あるいは<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>の展開といった暗黙的演算を明示化することで、<b>正規化</b>される。正規化処理については<a href="#XQueryFormalSemantics">[XQuery
1.0 and XPath 2.0 Formal Semantics]</a>で記述されている。</p>
<p>次に、各式に<a title="static type" href=
"#dt-static-type">静的型</a>が付与される(段階SQ6)。[<a name="dt-static-type"
id="dt-static-type" title="static type">Definition</a>:
式の<b>静的型</b>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。] もし<a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が支援されているなら、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>に書かれているルールに従って、さまざまな式の<a title="static type" href=
"#dt-static-type">静的型</a>が推論される。もし<a title="static typing feature"
href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が支援されていないなら、割り当てられる静的型は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>では、もし<a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が機能しており、かつ式の演算数が、その演算数に適切でない<a title="static type"
href="#dt-static-type">静的型</a>を持つと分かったならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。静的型検査でエラーが発生せず<a title=
"static type" href=
"#dt-static-type">静的型</a>Tが式に割り当てられたならば、正当な入力データに対しその式を実行すると、型Tの値が生成されるか<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>となることが保証される。</p>
<p><a title="static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>の目的は、<a title=
"type error" href=
"#dt-type-error">型エラー</a>の早期検出を提供し、式評価の最適化に役立つ型情報を推論することである。</p>
</div>
<div class="div4">
<h5><a name="id-dynamic-evaluation" id=
"id-dynamic-evaluation"></a>2.2.3.2 動的評価相</h5>
<p>[<a name="dt-dynamic-evaluation" id="dt-dynamic-evaluation"
title="dynamic evaluation phase">Definition</a>:
<b>動的評価相</b>は式の値を計算する相である。] 動的評価相は<a title="static analysis phase"
href="#dt-static-analysis">静的解析相</a>が完了した後に行われる。</p>
<p>動的評価相は、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>でエラーが検出されなかった場合に限り行うことができる。もし<a title="static typing feature"
href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が機能しているなら、静的解析の間にすべての<a title="type error"
href="#dt-type-error">型エラー</a>が検出され、動的評価相の実行を妨げるのに役立つ。</p>
<p>動的評価相は、評価している式の<b>演算木</b>(段階DQ1)、入力データ(段階DQ4)、<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>(段階DQ5)に依存し、さらに外部環境(段階DQ3)や<a title=
"dynamic context" href=
"#dt-dynamic-context">静的文脈</a>(段階DQ2)から情報を引き出す。動的評価相は新しいデータモデル値を生成したり(段階DQ4)、値を変数に束縛するなどによりそれを<a title="dynamic context"
href="#dt-dynamic-context">動的文脈</a>に展開してもよい(段階DQ5)。</p>
<p>[<a name="dt-dynamic-type" id="dt-dynamic-type" title=
"dynamic type">Definition</a>:
<b>動的型</b>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<a title=
"static type" href=
"#dt-static-type">静的型</a>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。]</p>
<p>もし式の演算数が、その演算数に適切でない<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>を持っていると分かったならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>式が評価される前に静的型付けで多くの<a title="type error" href=
"#dt-type-error">型エラー</a>がとらえられるとしても、静的解析では検出されなかったエラーが評価時に発生することはあり得る。例えば、式に文字列から整数への型変換が含まれているかもしれない。これは静的には正しい。しかし、もし実行時の実際の文字列の値が整数に変換できないならば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する。同様に、式中で<a title=
"static type" href=
"#dt-static-type">静的型</a>が<code>xs:untypedAtomic</code>であるような値に算術演算子を適用しているかもしれない。これは<a title="static error"
href="#dt-static-error">静的エラー</a>ではない。しかし実行時では、もしその値が<a title=
"numeric" href="#dt-numeric">数</a>型にうまく変換できなければ、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する。</p>
<p><a title="static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が有効であるとき、式の静的解析において<a title="type error"
href=
"#dt-type-error">型エラー</a>を発生させることは、たとえある入力に対してその式が正常に実行されるとしても、可能である。例えば、引数として要素を要求する関数が式に含まれており、静的解析相でその関数の引数の<a title="static type"
href=
"#dt-static-type">静的型</a>が省略可能な要素であると推論されたとする。この場合は、たとえ省略可能な要素が存在するような入力データに対してこの関数呼び出しが正常に行われるとしても、<a title="type error"
href="#dt-type-error">型エラー</a>として扱われ、評価が妨げられる。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization" id="id-serialization"></a>2.2.4
直列化</h4>
<p>[<a name="dt-serialization" id="dt-serialization" title=
"serialization">Definition</a>: <b>直列化</b>は<a title="XDM instance"
href=
"#dt-data-model-instance">XDMインスタンス</a>をオクテット列に変換する処理である(図1の段階DM4)。]
直列化の一般的な枠組は<a href="#serialization">[XSLT 2.0 and XQuery 1.0
Serialization]</a>に記述されている。</p>
<p class="xpath">ホスト言語が直列化のオプションを用意していてもよい。</p>
</div>
<div class="div3">
<h4><a name="id-consistency-constraints" id=
"id-consistency-constraints"></a>2.2.5 無矛盾性制約</h4>
<p>XPathが明確に定義されるためには、入力となる<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>、<a title="static context"
href="#dt-static-context">静的文脈</a>、<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>が互いに無矛盾でなければならない。以下に列挙する無矛盾性制約はXPathの実装が正しく動作するための前提条件である。これらの無矛盾性制約をどのように強制させるかはこの仕様書の範囲外である。この仕様書は、これらの制約が1つ以上満たされない条件の下での<span class="xpath">式</span>の結果を定義しない。</p>
<p>無矛盾性制約のいくつかでは<b>データモデルスキーマ</b>という用語を用いる。[<a name=
"dt-data-model-schema" id="dt-data-model-schema" title=
"data model schema">Definition</a>: <a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中のある節点に対して、<b>データモデルスキーマ</b>は、その節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が導出されたスキーマとして定義される。]
スキーマ妥当性検証以外の処理によって構成された節点に対しては、<b>データモデルスキーマ</b>は、単に、その節点の<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>によって表現されるスキーマ型定義から成る。</p>
<ul>
<li>
<p>型注釈を持つ各節点について、その型注釈が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>(ISSD)中にあるなら、ISSD中の定義は<a title=
"data model schema" href=
"#dt-data-model-schema">データモデルスキーマ</a>中の定義と等価でなければならない。さらに、<a title="data model schema"
href=
"#dt-data-model-schema">データモデルスキーマ</a>中のある型から拡張によって導出されるすべての型は、それと等価な定義がISSD中にもなければならない。</p>
</li>
<li>
<p><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中と<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>(ISSD)中の両方にある要素名<em>EN</em>のそれぞれについて、<em>EN</em>を先頭とする<a title="substitution group"
href="#dt-substitution-group">置換グループ</a>中にあると分かっている<a title=
"data model schema" href=
"#dt-data-model-schema">データモデルスキーマ</a>中のすべての要素は、また<em>EN</em>を先頭とする<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあると分かっているISSD中の要素でなければならない。</p>
</li>
<li>
<p>要素名、属性名、<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>や<a title="function signature"
href=
"#dt-function-signature">関数のシグネチャ</a>から参照されているスキーマ型名は、いずれも<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中になければならない。ただし、<a href=
"#doc-xpath-ElementTest">ElementTest</a>の部分から参照されている要素名、<a href=
"#doc-xpath-AttributeTest">AttributeTest</a>の部分から参照されている属性名は除く。</p>
</li>
<li>
<p><a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中に、大域的要素、属性、型名に対する参照がある場合は、対応する要素、属性、型の定義を<a title="in-scope schema definitions"
href="#dt-issd">有効範囲内スキーマ定義</a>中に持っていなければならない。</p>
</li>
<li>
<p>文字列から<a title="available documents" href=
"#dt-available-docs">利用可能な文書</a>中の文書節点への写像それぞれについて、もし同じ文字列から<a title="statically known documents"
href="#dt-known-docs">静的既知文書</a>中の文書型への写像が存在するなら、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、文書節点はその文書型に照合されなければならない。</p>
</li>
<li>
<p>文字列から<a title="available collections" href=
"#dt-available-collections">利用可能コレクション</a>中の節点列への写像それぞれについて、もし同じ文字列から<a title="statically known collections"
href="#dt-known-collections">静的既知コレクション</a>中の型への写像が存在するなら、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、節点列はその型に照合されなければならない。</p>
</li>
<li>
<p><a title="default collection" href=
"#dt-default-collection">デフォルトコレクション</a>中の節点列は、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、<a title=
"statically known default collection type" href=
"#dt-known-default-collection">静的既知デフォルトコレクション</a>に照合されなければならない。</p>
</li>
<li>
<p><a title="context item" href=
"#dt-context-item">文脈項目</a>の値は、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、<a title=
"context item static type" href=
"#dt-context-item-static-type">文脈項目静的型</a>に照合されなければならない。</p>
</li>
<li>
<p><a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>中の2つ組 (変数, 型)のそれぞれと、<a title=
"variable values" href="#dt-variable-values">変数の値</a>中で対応する2つ組 (変数,
値)のうち変数名が等しいものについて、<a href="#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、値と型が照合されなければならない。</p>
</li>
<li>
<p><a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の中で、接頭辞<code>xml</code>は<code>http://www.w3.org/XML/1998/namespace</code>以外の名前空間URIに束縛されてはならず、またこの名前空間URIには<code>xml</code>以外の接頭辞が束縛されてはならない。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.3 エラー処理</h3>
<div class="div3">
<h4><a name="id-kinds-of-errors" id="id-kinds-of-errors"></a>2.3.1
エラーの種類</h4>
<p><a href="#id-expression-processing"><b>2.2.3
式の処理</b></a>で述べたように、XPathは入力データに依存しない<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>と入力データに依存する<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>を定義する。エラーはいずれの相でも発生してよい。</p>
<p>[<a name="dt-static-error" id="dt-static-error" title=
"static error">Definition</a>:
<b>静的エラー</b>は静的解析相で検出されなければならないエラーである。構文エラーは<a title="static error"
href="#dt-static-error">静的エラー</a>の例である。]</p>
<p>[<a name="dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error">Definition</a>:
<b>動的エラー</b>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。]</p>
<p>[<a name="dt-type-error" id="dt-type-error" title=
"type error">Definition</a>:
<b>型エラー</b>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<a title=
"static type" href=
"#dt-static-type">静的型</a>とその式の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href=
"#dt-type-error">型エラー</a>が発生する。動的評価相では、値の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>とその値の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する。]</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>の結果は、成功か、1つ以上の<a title="type error"
href="#dt-type-error">型エラー</a>、<a title="static error" href=
"#dt-static-error">静的エラー</a>、静的に検出される<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>のいずれかである。<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>の結果は、結果の値か、1つの<a title=
"type error" href="#dt-type-error">型エラー</a>か、1つの<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>のいずれかである。</p>
<p>
1つ以上のエラーが現れたり、エラー条件がこの仕様で定義される1つ以上のエラーの範囲内に入ったりすると、これらのエラーの空でない集合が報告されてもよい。</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>では、<a title="static typing feature"
href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が機能しており、かつ<code>()</code>もしくは<code>data(())</code>以外の式に割り当てられる<a title="static type"
href=
"#dt-static-type">静的型</a>が<code>empty-sequence()</code>であるならば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0005"
href="#ERRXPST0005">err:XPST0005</a>]。これにより、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に存在しない要素や属性を問合せが参照している場合がとらえられる。これは綴りの誤りの可能性があるためである。</p>
<p><a title="static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が機能しているかどうかに関わらず、もし<a title="static analysis phase"
href="#dt-static-analysis">静的解析相</a>で、ある式が評価されると<a title=
"type error" href="#dt-type-error">型エラー</a>や<a title=
"dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する必要がある、ということを実装が決定できるならば、実装は<a title="static analysis phase"
href=
"#dt-static-analysis">静的解析相</a>でエラーを通知してもよい(しかし通知することを要求されるわけではない)。しかし、<code>fn:error()</code>関数は<a title="static analysis phase"
href="#dt-static-analysis">静的解析相</a>では評価されてはならない。</p>
<p>[<a name="dt-warning" id="dt-warning" title=
"warning">Definition</a>: <a title="static error" href=
"#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、<a title="type error" href=
"#dt-type-error">型エラー</a>に加えて、XPathの実装は、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>、<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>のいずれかで<b>警告</b>を発生してもよい。警告が発生する状況や、警告を処理する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。]</p>
<p>この仕様書で定義されるエラーに加えて、実装は、この仕様書の範囲外の理由により<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。例えば、さまざまなオブジェクトの最大数や最大サイズに制限があってもよい。このような制限や、これらを越えることによる結果は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
</div>
<div class="div3">
<h4><a name="id-identifying-errors" id=
"id-identifying-errors"></a>2.3.2 エラーの識別と報告</h4>
<p>
この仕様書で定義されるエラーは、<code>err:XPYYnnnn</code>という形式を持つQNameで識別される。ここで:</p>
<ul>
<li>
<p>
<code>err</code>はXPathおよびXQueryのエラーのための名前空間、<code>http://www.w3.org/2005/xqt-errors</code>を表す。この名前空間接頭辞<code>err</code>の束縛はこの文書内の便宜上用いており、参考である。</p>
</li>
<li>
<p><code>XP</code>は、そのエラーがXPathのエラーであることを識別する。</p>
</li>
<li>
<p><code>YY</code>はエラーの分類を示し、次のような符号化を用いる:</p>
<ul>
<li>
<p><code>ST</code>は静的エラーを表す。</p>
</li>
<li>
<p><code>DY</code>は動的エラーを表す。</p>
</li>
<li>
<p><code>TY</code>は型エラーを表す。</p>
</li>
</ul>
</li>
<li>
<p><code>nnnn</code>は一意に決まる数字コードである。</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
XPathのバージョンが変わっても、XPathとXQueryのエラーのための名前空間URIが変わることは期待されない。しかし、この名前空間の内容は、エラー定義が追加されることによって拡張されてよい。</p>
</div>
<p>XPath処理器がエラー情報を外部環境に報告する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</p>
<p>
エラーは、エラーQNameから導出されるURI参照によって次のように表すことができる。名前空間URI<em><code>NS</code></em>と局所名<em><code>LP</code></em>を持つエラーは、URI参照<em><code>NS</code></em><code>#</code><em><code>LP</code></em>で表すことができる。例えば、QNameが<code>err:XPST0017</code>であるエラーは<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>で表せる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
エラーを識別するコードとともに、実装は、エラーの場所やエラーが検出された処理相などの付加的な情報を返してもよい。実装が付加的な情報を返すことを選択する場合は、この情報を返すのに用いられる機構は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-handling-dynamic" id=
"id-handling-dynamic"></a>2.3.3 動的エラーの処理</h4>
<p>この文書で示した以外に、もし式の演算数が<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生するならば、その式もまた<a title=
"dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。もし式が正常に値を返すことも動的エラーを発生することもできるのであれば、実装は、値を返すか動的エラーを発生するか選択してよい。例えば、論理式<code>expr1
and
expr2</code>は、いずれかの演算数が<code>false</code>を返すならば値<code>false</code>を返してもよい。またいずれかの演算数が動的エラーを発生すれば動的エラーを発生してもよい。</p>
<p>
もし式中の1つ以上の演算数がエラーを発生するならば、実装は、どのエラーがその式によって発生するかを選択してよい。例えば、次の式を考える:</p>
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
<p>部分式<code>($x div
$y)</code>と<code>xs:decimal($z)</code>はともにエラーを発生するかもしれない。実装は式"<code>+</code>"によってどちらのエラーが発生するか選択してよい。いったん1つの演算数がエラーを発生すれば、実装が他の演算数を評価することは要求されないが、評価してもよい。</p>
<p>[<a name="dt-error-value" id="dt-error-value" title=
"error value">Definition</a>:
識別可能なQNameに加え、動的エラーは、説明的な文字列や、<b>エラー値</b>と呼ばれる1つ以上の付加的な値を伴ってもよい。]
実装は、アプリケーションで定義されるエラー処理器がエラー値を処理し診断メッセージを生成する機構を提供してもよい。</p>
<p>動的エラーは<a title="built-in function" href=
"#dt-built-in-function">組み込み関数</a>や演算子によって発生してもよい。例えば<code>div</code>演算子は、その演算数が<code>xs:decimal</code>値でかつ第2演算数が0に等しいならば、例外を発生する。組み込み関数や演算子によって発生するエラーは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。</p>
<p>
動的エラーは明示的に<code>fn:error</code>関数を呼び出すことによっても発生する。この関数はエラーを1つ発生させるだけで、値は返さない。この関数は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている。例えば、次に示す関数呼び出しは動的エラーを発生する。発生する動的エラーは、エラーを識別するQName、説明的な文字列、診断値からなる(接頭辞<code>app</code>が、アプリケーションで定義されるエラーコードを含む名前空間に束縛されていると仮定している)。</p>
<div class="exampleInner">
<pre>
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</pre></div>
</div>
<div class="div3">
<h4><a name="id-errors-and-opt" id="id-errors-and-opt"></a>2.3.4
エラーと最適化</h4>
<p>
実装が異なると、式を評価したり最適化したりする方法として異なるものを選ぶかもしれないので、この節で述べるように、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>の検出や報告についてのある側面は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<p>実装は常に、演算子の演算数をどのような順序で評価しても自由である。</p>
<p>
場合によっては、処理器は、形式的な式の意味によって内含されるすべてのデータにアクセスすることなく、式の結果を決定することができる。例えば、<a title="filter expression"
href=
"#dt-filter-expression">選別式</a>の形式的記述では、<code>$s[1]</code>は列<code>$s</code>のすべての項目を検査し、述語<code>position()=1</code>を満たす項目をすべて選ぶことによって評価されるべきであると推奨している。実際は、多くの実装は、列の最初の項目を取ってきて終了してもこの式を評価することができる、と認識している。もし<code>$s</code>が<code>//book[author
eq
'Berners-Lee']</code>と言った式で定義されるならば、この戦略は大きな文書全体の走査を避け、性能を大幅に改善するかもしれない。しかし、この戦略の結果として、式の評価が早く終了してしまうと、式の意味に厳密に従っていれば検出できたであろう動的エラーや型エラーが全く検出できないかもしれない。この例では、もし1個以上の<code>author</code>部分要素を持つ<code>book</code>要素が入力中にあると、このようなエラーが発生するかもしれない。</p>
<p>エラーを検出しないコストに関して、処理器がデータへのアクセスを最適化するかもしれない外延は、次のルールで定義される。</p>
<p>
演算数(部分式)に<em>E</em>を持つ式<em>Q</em>を考えよう。一般には<em>E</em>の値は列である。列の評価の中間段階では、その項目のいくつかは分かっているが、残りは未知である。もし、評価の中間段階で、処理器が<em>Q</em>を評価した結果として2つの可能性しかない、すなわち値<em>V</em>かエラーの可能性しかないと証明できるならば、処理器は、演算数<em>E</em>の残りの項目を評価することなく結果<em>V</em>を出してもよい。この目的のために、2つの項目の節点と値がともに同一であるならば、2つの値は同じ結果を表現していると考えられる。ここで、節点が同じ識別子を持っているならば、それらの節点は同一である。また、2つの値が等値でかつ全く同じ型を持っているならば、それらの値は同一である。</p>
<p>このルールには例外がある。もし処理器が演算数 <em>E</em> を (その全体であれ部分的にであれ)
評価するならば、処理器は、<em>E</em>の演算数の実際の値が濃度に関するどんな制約にも反しないことを証明する必要がある。例えば、式<code>$e
eq
0</code>は、<code>$e</code>の値が2個以上の項目を含んでいれば、型エラーという結果になる。処理器は、<code>$e</code>の値の最初の項目を評価した後、可能な結果は、値<code>true</code>か、濃度の違反による型エラーだけである、と決定することは許されない。<code>$e</code>の値が1個以下の項目しか含まないことを証明しなければならない。</p>
<p>
このルールは、式の演算数として考えられるすべての組み合わせに適用される。したがって、式が2つの演算数<em>E1</em>と<em>E2</em>を持っているならば、上のルールを満たすそれぞれの列のどんな例を用いて評価されてもよい。</p>
<p>
このルールは連鎖する。<em>A</em>が<em>B</em>の演算数で、<em>B</em>が<em>C</em>の演算数であるならば、処理器は<em>C</em>の値を決めるために充分な数の<em>B</em>の例だけを評価すればよく、さらに<em>B</em>の例を決めるために充分な数の<em>A</em>の例だけを評価すればよい。</p>
<p>
これらのルールの効果として、処理器は、列中のあるところより先の項目が、エラーを発生させるかもしれないということ以外に結果に影響を及ぼさないと証明できれば、直ちにその先の項目の検査を止めても構わない。例えば、処理器は、2つの列から等しい値の2つ組を見つければ、直ちに<code>S1
= S2</code>の結果として<code>true</code>を返してもよい。</p>
<p>
これらのルールのもう一つの結果として、列中のどの項目も式の結果に貢献しないとき、処理器はその列のどの部分も評価する義務を負わない。しかし、繰り返すが、処理器は要求される濃度の検査は、せずに済ますことができない。対象とする文脈で空列が許されなければ、処理器は、演算数が空列でないことを保証しなければならない。</p>
<p>例:</p>
<ul>
<li>
<p>
下の例において、実装が<code>$expr1</code>によって返される項目のうち少なくとも1つが<code>47</code>という値を持つと知ることができる(例えば索引を用いて)ならば、<code>some</code>式の結果として<code>true</code>を返すことが許される。このとき、<code>$expr1</code>によって返される他の項目に、評価するとエラーを発生させるものがあるか探す必要はない。</p>
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</li>
<li>
<p>
以下の例において、実装が、値が<code>47</code>であるような子節点<code>id</code>を持つ<code>product</code>要素節点を見つけられれば(例えば索引を用いて)、<a title="path expression"
href=
"#dt-path-expression">経路式</a>の結果としてこれらの節点を返すことが許される。このとき、他の<code>product</code>節点に、整数を値としない<code>id</code>子節点があるためにエラーを発生させるものがあるか探す必要はない。</p>
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</li>
</ul>
<p>
最適化など、さまざまな理由により、実装は式を等価な式に書き換えることは自由である。エラーを発生させるか発生させないかという点を除いて、等価な式を評価した結果は、元の式を評価した結果と等しくなければならない。式の書換えを以下の例で説明する。</p>
<ul>
<li>
<p>式<code>//part[color eq
"Red"]</code>を考えよう。実装はこの式を<code>//part[color = "Red"][color eq
"Red"]</code>と書き換えることを選択するかもしれない。この実装では、この式を次のように処理するかもしれない。まず part
に関する索引を color によって引き、color が Red であるような part
すべてを素早く見つけ、"<code>=</code>" 述語を処理する。次にこれらの part それぞれについて
"<code>eq</code>" 述語を処理し、確かに一つの color
しか持っていないか検査する。結果は以下のようになる。</p>
<ul>
<li>
<p>Redという1つの color しか持っていない part が返される。</p>
</li>
<li>
<p>ある part が Red という color と他の color を共に持っていれば、エラーが発生する。</p>
</li>
<li>
<p>Red という color を持たず Red でない color を複数持つ part
が存在してもエラーは引き起こさない。</p>
</li>
</ul>
</li>
<li>
<p>
以下の例の式は、書かれている順に(すなわち左から右へ)正確に評価されれば、型変換エラーを起こすことはできない。どちらの述語も文脈位置に依存しているので、実装は、(例えば索引を利用することで)よりよい性能を得るために、述語を並び替えることを選択するかもしれない。述語を並べ替えることで、式がエラーを引き起こすかもしれない。</p>
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
<p>
式の書き換えによって引き起こされる想定外のエラーを避けるために、動的エラーを防ぐために設計されたテストを、条件式を用いて表現するべきである。条件式は、実際に選択された分岐中で発生する動的エラーのみ引き起こす。したがって、前の例とは異なり、以下の例では<code>@x</code>が<code>xs:date</code>に型変換されなくても動的エラーは起こらない。</p>
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>2.4 概念</h3>
<p>この節では、XPath式の処理で重要な概念をいくつか説明する。</p>
<div class="div3">
<h4><a name="id-document-order" id="id-document-order"></a>2.4.1
文書順</h4>
<p><b>文書順</b>と呼ばれる順序は、ある<span class=
"xpath">式</span>の処理中にアクセス可能なすべての節点の間で定義され、1つ以上の<b>木</b>(文書もしくはその一部)から構成されていてもよい。文書順は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>で定義されているが、便宜上その定義をここでも繰り返す。[<a name=
"dt-reverse-document-order" id="dt-reverse-document-order" title=
"reverse document order">Definition</a>:
文書順の逆順であるような節点の順序を<b>逆文書順</b>という。]</p>
<p>文書順は全順序である。ただし、節点間の相対順序は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。[<a name=
"dt-document-order" id="dt-document-order" title=
"document order">Definition</a>:
直観的には、<b>文書順</b>は直列化されたXML文書中で節点が出現する順序である。] [<a name="stable" id=
"stable" title="stable">Definition</a>:
文書順は<b>安定</b>である。ここで安定とは、ある<span class=
"xpath">式</span>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であっても)ことを意味する。]</p>
<p>木では、文書順は次の制約を満たす。</p>
<ol class="enumar">
<li>
<p>根節点は最初の節点である。</p>
</li>
<li>
<p>いずれの節点も、その子および子孫のどれよりも前に出現する。</p>
</li>
<li>
<p>名前空間節点は、それが関連づけられている要素節点の直後に出現する。名前空間節点の相対順序は安定であるが<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
</li>
<li>
<p>属性節点は、それが関連づけられている要素節点の<span class=
"xpath">名前空間節点</span>の直後に出現する。属性節点の相対順序は安定であるが<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
</li>
<li>
<p>兄弟間の相対順序は、親節点の性質<code>children</code>中で出現する順序である。</p>
</li>
<li>
<p>子および子孫は、弟よりも先に出現する。</p>
</li>
</ol>
<p>異なる木の節点間の相対順序は安定であるが<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であり、次の制約に従う。与えられた木T1中のある節点が、別の木T2中のすべての節点より前に出現するならば、木T1中のすべての節点が木T2のすべての節点より前に出現する。</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>2.4.2 原子化</h4>
<p>いくつかのXPath演算子の意味は<a title="atomization" href=
"#dt-atomization">原子化</a>という処理に依存している。原子化がある値に対して適用されるのは、原子値の列が必要となる文脈でその値が用いられるときである。原子化の結果は、原子値の列か<a title="type error"
href="#dt-type-error">型エラー</a> [err:FOTY0012] のいずれかである。[<a name=
"dt-atomization" id="dt-atomization" title=
"atomization">Definition</a>: 列の<b>原子化</b>は、<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。]</p>
<p>
便宜上、<code>fn:data</code>の意味を繰り返す。<code>fn:data</code>の結果は、入力列中の各項目に以下のルールを適用して生成される原子値の列である。</p>
<ul>
<li>
<p>その項目が原子値であれば、その項目を返す。</p>
</li>
<li>
<p>その項目が節点であれば、その<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>を返す。(もしその節点が型付けされた値を持たないならば、err:FOTY0012が発生する。)</p>
</li>
</ul>
<p>原子化は以下の式の型を処理するのに用いられる。</p>
<ul>
<li>
<p>算術式</p>
</li>
<li>
<p>比較式</p>
</li>
<li>
<p>関数呼び出しと関数からの戻り</p>
</li>
<li>
<p>型変換式</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>2.4.3 有効ブール値</h4>
<p>ある状況の下では(以下に列挙する)、値の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を得る必要がある。[<a name="dt-ebv" id="dt-ebv" title=
"effective boolean value">Definition</a>:
ある値の<b>有効ブール値</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and
Operators]</a>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。]</p>
<p>便宜上、<code>fn:boolean</code>の動的意味を繰り返す。</p>
<ol class="enumar">
<li>
<p>演算数が空列であれば、<code>fn:boolean</code>は<code>false</code>を返す。</p>
</li>
<li>
<p>
演算数が、最初の項目が節点であるような列であれば、<code>fn:boolean</code>は<code>true</code>を返す。</p>
</li>
<li>
<p>
演算数が<code>xs:boolean</code>型もしくは<code>xs:boolean</code>から導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は演算数の値を変化せずに返す。</p>
</li>
<li>
<p>
演算数が<code>xs:string</code>型、<code>xs:untypedAtomic</code>型、もしくはこれらのいずれかから導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は、演算数の値の長さが0の場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</li>
<li>
<p>演算数が<a title="numeric" href=
"#dt-numeric">数</a>型、もしくは数型から導出される型の<a title="singleton" href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は、演算数の値が<code>NaN</code>もしくは数として0に等しい場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</li>
<li>
<p>これ以外のすべての場合について、<code>fn:boolean</code>は型エラー
[err:FORG0006]を引き起こす。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>fn:boolean</code>の静的意味は<a href=
"http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">7.2.4 The
fn:boolean function</a><sup xmlns=
""><small>FS</small></sup>で定義されている。</p>
</div>
<p>列の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>は、以下のような式の型の処理で暗黙的に計算される。</p>
<ul>
<li>
<p>論理式(<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p><code>fn:not</code>関数</p>
</li>
<li>
<p>ある形式の<a title="predicate" href=
"#dt-predicate">述語</a>。例えば<code>a[b]</code></p>
</li>
<li>
<p>条件式(<code>if</code>)</p>
</li>
<li>
<p>限量式(<code>some</code>, <code>every</code>)</p>
</li>
<li>
<p><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 互換モード</a>における、一般比較</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>の定義は、例えば<code>cast</code>式のような<code>xs:boolean</code>型への型変換、あるいは引数として<code>xs:boolean</code>型を期待する関数に値を渡すときには、<em>使わない</em>。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>2.4.4
入力源</h4>
<p>
XPathは、入力データへのアクセスを提供する関数集合を持っている。これらの関数は、式が文書や文書の集まりを参照できる方法を用意しているため、特に重要である。ここでは、入力関数について直観的に記述する。これらは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。</p>
<p>式が入力データにアクセスするには、入力関数の一つを呼び出すか、外部環境によって初期化される<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の一部、例えば<a title="variable values"
href="#dt-variable-values">変数</a>や<a title="context item" href=
"#dt-context-item">文脈項目</a>を参照するか、いずれかによる。</p>
<p>XPathで支援されている入力関数は以下の通りである:</p>
<ul>
<li>
<p><code>fn:doc</code>関数はURIを含む文字列を受け取る。そのURIが<a title=
"available documents" href=
"#dt-available-docs">有効文書</a>中の文書と関連づけられていれば、<code>fn:doc</code>はその文書の<a title="data model"
href="#dt-datamodel">データモデル</a>表現を内容とするような文書節点を返す。それ以外の場合、<a title=
"" href="#">動的エラー</a>を引き起こす(詳細は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>を見よ)。</p>
</li>
<li>
<p>1引数の<code>fn:collection</code>関数は、URIを含む文字列を受け取る。そのURIが<a title=
"available collections" href=
"#dt-available-collections">有効コレクション</a>中のコレクションと関連づけられていれば、<code>fn:collection</code>はそのコレクションのデータモデル表現を返す。それ以外の場合、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>を引き起こす(詳細は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>を見よ)。コレクションは任意の節点列であってもよい。例えば、式<code>fn:collection("http://example.org")//customer</code>は、URIが<code>http://example.org</code>であるようなコレクション中の節点の子孫である<code>customer</code>要素すべてを指し示す。</p>
</li>
<li>
<p>引数を持たない<code>fn:collection</code>関数は、<a title=
"default collection" href=
"#dt-default-collection">デフォルトコレクション</a>を返す。これは<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の節点列である。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-types" id="id-types"></a>2.5 型</h3>
<p>XPathの型システムは<a href="#XMLSchema">[XML
Schema]</a>に基づいており、<a href="#XQueryFormalSemantics">[XQuery 1.0 and
XPath 2.0 Formal Semantics]</a>で形式的に定義されている。</p>
<p>[<a name="dt-sequence-type" id="dt-sequence-type" title=
"sequence type">Definition</a>: <b>列型</b>(sequence type)は<a href=
"#doc-xpath-SequenceType">SequenceType</a>の構文を用いて表現することのできる型である。列型は、XPath式で型を参照する必要があるときにはいつでも用いられる。<b>列型</b>という用語は、この構文がXPathの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。]</p>
<p>[<a name="dt-schema-type" id="dt-schema-type" title=
"schema type">Definition</a>: <b>スキーマ型</b>(schema type)は<a href=
"#XMLSchema">[XML Schema]</a>の機能(<a href="#XMLSchema">[XML
Schema]</a>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<b>複合型</b>か<b>単純型</b>のいずれかである。単純型はさらに<b>リスト型</b>、<b>共用体型</b>、<b>原子型</b>に分けられる(これらの用語の定義と説明は<a href="#XMLSchema">[XML
Schema]</a>を見よ)。]</p>
<p>原子型は<a title="sequence type" href=
"#dt-sequence-type">列型</a>と<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>という種類の間の集合積を表現している。原子型、例えば<code>xs:integer</code>や<code>my:hatsize</code>は<a title="sequence type"
href="#dt-sequence-type">列型</a>でもあり<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>でもある。</p>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>2.5.1 既定義スキーマ型</h4>
<p class="xpath"><a title="static context" href=
"#dt-static-context">静的文脈</a>内の<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>は、ホスト言語で定義されている既定義スキーマ型の集合で初期化される。この集合には<code>http://www.w3.org/2001/XMLSchema</code>名前空間内のスキーマ型の一部またはすべてが含まれていてもよい。この文書では、この名前空間を名前空間接頭辞<code>xs</code>で表している。この名前空間のスキーマ型は
<a href="#XMLSchema">[XML Schema]</a> で定義され、<a href=
"#datamodel">[XQuery/XPath Data Model (XDM)]</a>
で定義された方を追加することで拡張されている。この名前空間内のスキーマ型は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>で定義されており、以下にその概略を示す。</p>
<ol class="enumar">
<li>
<p>[<a name="dt-untyped" id="dt-untyped" title=
"xs:untyped">Definition</a>:
<code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>として用いられる。]
<code>xs:untyped</code>からは既定義スキーマ型は何も導出されない。</p>
</li>
<li>
<p>[<a name="dt-untypedAtomic" id="dt-untypedAtomic" title=
"xs:untypedAtomic">Definition</a>:
<code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。]
<code>skip</code>モードで妥当性検証された属性は、<a title="data model" href=
"#dt-datamodel">データモデル</a>中では<code>xs:untypedAtomic</code>という<a title="type annotation"
href=
"#dt-type-annotation">型注釈</a>のついた属性節点として表現される。<code>xs:untypedAtomic</code>からは、既定義スキーマ型は何も導出されない。</p>
</li>
<li>
<p>[<a name="dt-dayTimeDuration" id="dt-dayTimeDuration" title=
"xs:dayTimeDuration">Definition</a>:
<code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。]</p>
</li>
<li>
<p>[<a name="dt-yearMonthDuration" id="dt-yearMonthDuration" title=
"xs:yearMonthDuration">Definition</a>:
<code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。]</p>
</li>
<li>
<p>[<a name="dt-anyAtomicType" id="dt-anyAtomicType" title=
"xs:anyAtomicType">Definition</a>:
<code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>,
<code>xs:string</code>,
<code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyAtomicType</code>は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の実際の値の型には出現しない。</p>
</div>
</li>
</ol>
<p><code>xs</code>名前空間中のスキーマ型の間の関連を図2に示す。XPathの型階層のより完全な記述は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>にある。</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>図2: XPathで用いられるスキーマ型の階層</p>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>2.5.2
型付けされた値と文字列値</h4>
<p>すべての節点は<b>型付けされた値</b>と<b>文字列値</b>とを持っている。[<a name=
"dt-typed-value" id="dt-typed-value" title=
"typed value">Definition</a>:
節点の<b>型付けされた値</b>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。]
[<a name="dt-string-value" id="dt-string-value" title=
"string value">Definition</a>:
節点の<b>文字列値</b>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。]
<code>fn:data</code>と<code>fn:string</code>の定義は<a href=
"#">[FunctionsAndOprators]</a>にある。</p>
<p>実装は、節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>と<a title="string value" href=
"#dt-string-value">文字列値</a>をともに格納してもよいし、これらの一方だけを格納して、必要なときにもう一方を導出してもよい。節点の文字列値は、その節点の型付けされた値の正しい字句表現でなければならないが、その節点は元のソース文書から文字列表現を保存している必要はない。例えば、ある節点の型付けされた値が<code>xs:integer</code>の値<code>30</code>であったとすると、その文字列値は
"<code>30</code>" でも "<code>0030</code>" でもよい。</p>
<p class="xpath">節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>、<a title="string value" href=
"#dt-string-value">文字列値</a>、および<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>は密接に関連している。節点が情報集合またはPSVIからの写像で作られたのであれば、これらの性質の関連は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>中のルールによって定義される。</p>
<p>読者の便宜のため、さまざまな種類の節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>と<a title="string value" href=
"#dt-string-value">文字列値</a>の関連について以下にまとめ、例を用いて説明する。</p>
<ol class="enumar">
<li>
<p>
テキスト節点と文書節点では、型付けされた値と文字列値は等しく、<code>xs:untypedAtomic</code>型のインスタンスである。文書節点の文字列値は、そのすべての子孫のテキスト節点の文字列値を<a title="document order"
href="#dt-document-order">文書順</a>に連接して得られる。</p>
</li>
<li>
<p>コメント、<span class=
"xpath">名前空間</span>、処理命令節点について、型付けされた値は文字列値に等しい。<code>xs:string</code>型のインスタンスである。</p>
</li>
<li>
<p><a title="type annotation" href=
"#dt-type-annotation">型注釈</a><code>xs:anySimpleType</code>または<code>xs:untypedAtomic</code>のついた属性節点の型付けされた値は、文字列値に等しく、<code>xs:untypedAtomic</code>型のインスタンスである。その他の型注釈のついた属性節点の型付けされた値は、対応する型に関して<a href="#XMLSchema">[XML
Schema]</a>第2部で定義される字句から値空間への写像を用いて、文字列値や型注釈から導出される。</p>
<p>例: A1
は文字列値<code>"3.14E-2"</code>と型注釈<code>xs:double</code>を持つ属性である。A1の型付けされた値は、字句表現として<code>3.14E-2</code>を持つ<code>xs:double</code>の値である。</p>
<p>例: A2
は型注釈<code>xs:IDREFS</code>を持つ属性であり、各項目の型が原子データ型<code>xs:IDREF</code>であるようなリストデータ型である。A2の文字列値は"<code>bar
baz
faz</code>"である。A2の型付けされた値は、それぞれ<code>xs:IDREF</code>型である3つの原子値("<code>bar</code>",
"<code>baz</code>",
"<code>faz</code>")の列である。節点の型付けされた値は、名前付けされたリスト型のインスタンスとは決して扱われない。そのかわり、節点の型注釈がリスト型(<code>xs:IDREFS</code>など)であれば、型付けされた値は、それが導出される原子型(<code>xs:IDREF</code>など)の列として扱われる。</p>
</li>
<li>
<p>要素節点については、型付けされた値と文字列値の関連はその要素の<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>に依存する。以下の通り:</p>
<ol class="enumla">
<li>
<p>
型注釈が<code>xs:untyped</code>、<code>xs:anySimpleType</code>、もしくは混在内容を伴う複合型(<code>xs:anyType</code>を含む)を表していれば、その節点の型付けされた値は文字列値に等しく、<code>xs:untypedAtomic</code>のインスタンスである。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列である。</p>
<p>例: E1
は型注釈<code>xs:untyped</code>と文字列値"<code>1999-05-31</code>"を持つ要素節点である。E1の型付けされた値は"<code>1999-05-31</code>"であり、<code>xs:untypedAtomic</code>のインスタンスである。</p>
<p>例:
E2は、型注釈<code>formula</code>を持つ要素節点である。この型注釈は混在内容を伴う複合型である。E2の内容は文字"<code>H</code>"、<code>subscript</code>と名付けられ文字列値"<code>2</code>"を持つ子要素、文字"<code>O</code>"からなる。E2の型付けされた値は"<code>H2O</code>であり、<code>xs:untypedAtomic</code>の印寸タンスである。</p>
</li>
<li>
<p>
型注釈が単純型、もしくは単純内容を伴う複合型を表していれば、その節点の型付けされた値は、スキーマ妥当性検証と同じ方法で、文字列値と型注釈から導出される。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列になる。</p>
<p>例:
E3は型注釈<code>cost</code>を持つ要素節点である。この型はいろいろな属性を持ち、かつ<code>xs:decimal</code>型の単純内容を持つ複合型である。E3の文字列値は"<code>74.95</code>"である。E3の型付けされた値は<code>74.95</code>であり、<code>xs:decimal</code>のインスタンスである。</p>
<p>例:
E4は型注釈<code>hatsizelist</code>を持つ要素節点である。この型は原子型<code>hatsize</code>から導出された単純型であり、<code>hatsize</code>はさらに<code>xs:integer</code>から導出されている。E4の文字列値は"<code>7
8 9</code>"である。E4の型付けされた値は3つの値(<code>7</code>, <code>8</code>,
<code>9</code>)からなる列であり、3つの値はいずれも<code>hatsize</code>型である。</p>
<p>例:
E5は、メンバの型が<code>xs:integer</code>と<code>xs:string</code>の共用体型<code>my:integer-or-string</code>という型注釈を持つ要素節点である。E5の文字列値は"<code>47</code>"である。E5の型付けされた値は、<code>xs:integer</code>としての<code>47</code>である。なぜならば、E5の内容を妥当性検証したメンバ型が<code>xs:integer</code>であるからである。一般的に、節点の型注釈が共用体型であるときは、その節点の型付けされた値は、共用体のいずれかのメンバ型のインスタンスである。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
実装が節点の文字列値しか格納しておらず、その節点の型注釈が共用体型であるならば、実装はその節点の型付けされた値を適切なメンバ型のインスタンスとして配布しなければならない。</p>
</div>
</li>
<li>
<p>型注釈が空内容を伴う複合型を表していれば、その節点の型付けされた値は空列であり、文字列値は長さ0の文字列である。</p>
</li>
<li>
<p>
型注釈が要素だけからなる内容を伴う複合型を表していれば、その節点の型付けされた値は未定義である。<code>fn:data</code>関数は、このような節点に対して適用されると<a title=""
href="#">型エラー</a>
[err:FOTY0012]を引き起こす。このような節点の文字列値は、すべての子孫テキスト節点の文字列値を文書順に連接した文字列値と等しい。</p>
<p>例:
E6は型注釈が<code>weather</code>である要素節点である。この型は、内容型が<code>element-only</code>と指定されている複合型である。E6は<code>temperature</code>および<code>precipitation</code>と名付けられた2つの子節点を持つ。E6の型付けされた値は未定義であり、<code>fn:data</code>関数をE6に適用するとエラーを引き起こす。</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-sequencetype-syntax" id=
"id-sequencetype-syntax"></a>2.5.3 SequenceTypeの文法</h4>
<p>XPath式中の型を参照する必要があるときはいつでも、<a href=
"#doc-xpath-SequenceType">SequenceType</a>の文法が用いられる。</p>
<h5><a name="d2e3223" id="d2e3223"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SequenceType" id=
"doc-xpath-SequenceType"></a>[50]&nbsp;&nbsp;&nbsp;</td>
<td><code>SequenceType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xpath-ItemType">ItemType</a> <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ItemType" id=
"doc-xpath-ItemType"></a>[52]&nbsp;&nbsp;&nbsp;</td>
<td><code>ItemType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | ("item" "("
")") | <a href="#doc-xpath-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-OccurrenceIndicator" id=
"doc-xpath-OccurrenceIndicator"></a>[51]&nbsp;&nbsp;&nbsp;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AtomicType" id=
"doc-xpath-AtomicType"></a>[53]&nbsp;&nbsp;&nbsp;</td>
<td><code>AtomicType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-KindTest" id=
"doc-xpath-KindTest"></a>[54]&nbsp;&nbsp;&nbsp;</td>
<td><code>KindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xpath-ElementTest">ElementTest</a><br />
| <a href="#doc-xpath-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xpath-PITest">PITest</a><br />
| <a href="#doc-xpath-CommentTest">CommentTest</a><br />
| <a href="#doc-xpath-TextTest">TextTest</a><br />
| <a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DocumentTest" id=
"doc-xpath-DocumentTest"></a>[56]&nbsp;&nbsp;&nbsp;</td>
<td><code>DocumentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xpath-ElementTest">ElementTest</a> | <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementTest" id=
"doc-xpath-ElementTest"></a>[64]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" "(" (<a href=
"#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xpath-TypeName">TypeName</a> "?"?)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SchemaElementTest" id=
"doc-xpath-SchemaElementTest"></a>[66]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xpath-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementDeclaration" id=
"doc-xpath-ElementDeclaration"></a>[67]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeTest" id=
"doc-xpath-AttributeTest"></a>[60]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SchemaAttributeTest" id=
"doc-xpath-SchemaAttributeTest"></a>[62]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xpath-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeDeclaration" id=
"doc-xpath-AttributeDeclaration"></a>[63]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementNameOrWildcard" id=
"doc-xpath-ElementNameOrWildcard"></a>[65]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementName" id=
"doc-xpath-ElementName"></a>[69]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttribNameOrWildcard" id=
"doc-xpath-AttribNameOrWildcard"></a>[61]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeName" id=
"doc-xpath-AttributeName"></a>[68]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TypeName" id=
"doc-xpath-TypeName"></a>[70]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PITest" id=
"doc-xpath-PITest"></a>[59]&nbsp;&nbsp;&nbsp;</td>
<td><code>PITest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#doc-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CommentTest" id=
"doc-xpath-CommentTest"></a>[58]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TextTest" id=
"doc-xpath-TextTest"></a>[57]&nbsp;&nbsp;&nbsp;</td>
<td><code>TextTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AnyKindTest" id=
"doc-xpath-AnyKindTest"></a>[55]&nbsp;&nbsp;&nbsp;</td>
<td><code>AnyKindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p>特別な型<code>empty-sequence()</code>を除き、<a title="sequence type"
href=
"#dt-sequence-type">列型</a>は、列中の各項目の型に制約を加える<b>項目型</b>、および列の項目数に制約を加える<b>濃度</b>からなる。項目型<code>item()</code>は任意の種類の項目を許すが、これを除き、項目型は<b>節点型</b>(<code>element()</code>など)と<b>原子型</b>(<code>xs:integer</code>など)に分けられる。</p>
<p>要素節点や属性節点を表す項目型は、これらの節点の必要な<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>を、<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>の形式で指定してもよい。したがって、項目型<code>element(*,
us:address)</code>は、<code>us:address</code>と名付けられたスキーマ型(あるいはこの型から導出される型)を型注釈とする要素節点を表す。</p>
<p>以下に、XPath式で用いられる<a title="sequence type" href=
"#dt-sequence-type">列型</a>の例をいくつか示す。</p>
<ul>
<li>
<p>
<code>xs:date</code>は、<code>xs:date</code>と名付けられた組み込み原子スキーマ型を参照する。</p>
</li>
<li>
<p><code>attribute()?</code>は省略可能な属性節点を参照する。</p>
</li>
<li>
<p><code>element()</code>は任意の要素節点を参照する。</p>
</li>
<li>
<p><code>element(po:shipto,
po:address)</code>は、<code>po:shipto</code>という名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
</li>
<li>
<p><code>element(*,
po:address)</code>は、任意の名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
</li>
<li>
<p>
<code>element(customer)</code>は、<code>customer</code>と名付けられ、かつ任意の型注釈を持つ要素節点を参照する。</p>
</li>
<li>
<p>
<code>schema-element(customer)</code>は、名前が<code>customer</code>であり(もしくは<code>customer</code>を先頭とする置換グループの中にあり)、かつ型注釈が、<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中の<code>customer</code>要素のために定義されたスキーマ型に照合するような要素節点を参照する。</p>
</li>
<li>
<p><code>node()*</code>は、任意の種類の節点0個以上からなる列を参照する。</p>
</li>
<li>
<p><code>item()+</code>は、1個以上の節点もしくは原子値からなる列を参照する。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>2.5.4 SequenceTypeの照合</h4>
<p>[<a name="dt-sequencetype-matching" id=
"dt-sequencetype-matching" title=
"SequenceType matching">Definition</a>: 式の評価の間、既知の<a title=
"dynamic type" href="#dt-dynamic-type">動的型</a>が期待される<a title=
"sequence type" href=
"#dt-sequence-type">列型</a>に「照合」されるか決定する必要があることがある。この処理を<b>SequenceTypeの照合</b>という。]
例えば、式<code>instance of</code>は、与えられた値の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が与えられた<a title="sequence type" href=
"#dt-sequence-type">列型</a>に照合されれば<code>true</code>を返し、照合されなければ<code>false</code>を返す。</p>
<p><a title="sequence type" href=
"#dt-sequence-type">列型</a>中に出現するQNameは、<a title="" href=
"#">静的既知名前空間</a>と(もし適用可能であれば)<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を用いて名前空間URIに展開される接頭辞を持つ。接頭辞のない属性
QName はどの名前空間にも属さない。QName の等価性は <code>eq</code> 演算子によって定義される。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールは、値の<a title=
"dynamic type" href="#dt-dynamic-type">動的型</a>を、期待される<a title=
"sequence type" href=
"#dt-sequence-type">列型</a>と比較する。これらのルールは<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で定義される、値と期待される型との照合を行う形式的ルールの部分集合である。なぜなら、Formal
Semanticsは、<a href=
"#doc-xpath-SequenceType">SequenceType</a>の文法を用いて表現できない型に対して値を照合することができなければならないからである。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールのいくつかでは、与えられたスキーマ型が期待されるスキーマ型と同じかまたは導出されるかを決定する必要がある。与えられたスキーマ型は"既知"(<a title="in-scope schema definitions"
href="#dt-issd">有効範囲内スキーマ定義</a>で定義されている)か、または"未定義"(<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>で定義されていない)のいずれかであってもよい。未定義スキーマ型は、例えば、ソース文書が<a title="static context"
href=
"#dt-static-context">静的文脈</a>に輸入されていないスキーマを用いて妥当性検証されている場合などに現れるかもしれない。この場合、実装は、未定義のスキーマ型が期待されるスキーマ型から導出されるか決定する<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>の機構を用意することが許される(しかし用意しておく必要はない)。
例えば、実装は型階層に関する情報を含むデータ辞書を管理していてもよい。</p>
<p>[<a name="dt-subtype-substitution" id="dt-subtype-substitution"
title="subtype substitution">Definition</a>: <a title=
"dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される型から導出されるような値を用いることを<b>部分型置換</b>という。]
部分型置換は、値の実際の型は変更しない。例えば、<code>xs:integer</code>の値を<code>xs:decimal</code>の値が期待される場所で用いても、その値の型は<code>xs:integer</code>のまま保たれる。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>の定義は、<code>derives-from(</code><em>AT,
ET</em><code>)</code>という名前の擬似関数に頼っている。この関数は、実際の単純スキーマ型もしくは複合スキーマ型<em>AT</em>と、期待される単純スキーマ型もしくは複合スキーマ型<em>ET</em>をとり、ブール値を返すか、<a title="type error"
href="#dt-type-error">型エラー</a> [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]を発生する。
擬似関数<code>derives-from</code>は以下で定義され、また<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で形式的に定義されている。</p>
<ul>
<li>
<p>
<em>ET</em>が既知の型で、以下の3つの条件のいずれかが真であるとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<code>true</code>を返す。</p>
<ol class="enumar">
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中にあるスキーマ型で、<em>ET</em>と同じか、<em>ET</em>から制限もしくは拡張によって導出される。</p>
</li>
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>には含まれないスキーマ型で、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構により<em>AT</em>が<em>ET</em>から制限により導出されると決定できる。</p>
</li>
<li>
<p><code>derives-from(</code><em>IT,
ET</em><code>)</code>と<code>derives-from(</code><em>AT,
IT</em><code>)</code>が真であるようなスキーマ型<em>IT</em>が存在する。</p>
</li>
</ol>
</li>
<li>
<p>
<em>ET</em>が既知の型で、以下の条件のうち1番目と3番目、もしくは2番目と3番目が真であるとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<code>false</code>を返す。</p>
<ol class="enumar">
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中にあるスキーマ型で、<em>ET</em>と等しくなく、<em>ET</em>から制限または拡張によって導出されない。</p>
</li>
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>にないスキーマ型で、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構により<em>AT</em>が制限によって<em>ET</em>から導出されない。</p>
</li>
<li>
<p><code>derives-from(</code><em>IT,
ET</em><code>)</code>と<code>derives-from(</code><em>AT,
IT</em><code>)</code>がともに真であるようなスキーマ型<em>IT</em>が存在しない。</p>
</li>
</ol>
</li>
<li>
<p>以下のとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<a title="type error" href=
"#dt-type-error">型エラー</a> [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]を発生する。</p>
<ol class="enumar">
<li>
<p><em>ET</em>が未定義の型である。もしくは</p>
</li>
<li>
<p>
<em>AT</em>が未定義の型で、実装は、<em>AT</em>が制限によって<em>ET</em>から導出されるか決定できない。</p>
</li>
</ol>
</li>
</ul>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールを以下に述べ、例を示す(例は説明が目的であり、可能な場合をすべて網羅しているわけではない)。</p>
<div class="div4">
<h5><a name="id-matching-value" id="id-matching-value"></a>2.5.4.1
SequenceTypeと値の照合</h5>
<ul>
<li>
<p><a title="sequence type" href="#dt-sequence-type">列型</a>
<code>empty-sequence()</code>は、空列である値と照合される。</p>
</li>
<li>
<p><a href="#">OccurrenceIndicator</a>のない<a href=
"#doc-xpath-ItemType">ItemType</a>がただ1つの項目を含む任意の値と照合されるのは、その<a href="#doc-xpath-ItemType">ItemType</a>がその項目と照合されるときである(<a href="#id-matching-item"><b>2.5.4.2
ItemTypeと項目の照合</b></a>を見よ)。</p>
</li>
<li>
<p><a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>のある<a href=
"#doc-xpath-ItemType">ItemType</a>が値と照合されるのは、その値の項目の数が<a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>と照合され、<a href="#doc-xpath-ItemType">ItemType</a>がその値の各項目と照合されるときである。</p>
</li>
</ul>
<p><a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>は列中の項目数を以下のように指定する。</p>
<ul>
<li>
<p><code>?</code>は0個もしくは1個の項目と照合される</p>
</li>
<li>
<p><code>*</code>は0個以上の項目と照合される</p>
</li>
<li>
<p><code>+</code>は1個以上の項目と照合される</p>
</li>
</ul>
<p>これらのルールの結果として、<a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>が<code>*</code>もしくは<code>?</code>であるような任意の<a title="sequence type"
href="#dt-sequence-type">列型</a>は、空列である値と照合される。</p>
</div>
<div class="div4">
<h5><a name="id-matching-item" id="id-matching-item"></a>2.5.4.2
ItemTypeと項目の照合</h5>
<ul>
<li>
<p>QNameのみからなる<a href="#doc-xpath-ItemType">ItemType</a>は<a href=
"#doc-xpath-AtomicType">AtomicType</a>と解釈される。AtomicType
<em>AtomicType</em>が実際の型が<em>AT</em>である原子値と照合されるのは、<code>derives-from(</code><em>AT,
AtomicType</em><code>)</code>が<code>true</code>の場合である。もし<a href=
"#doc-xpath-AtomicType">AtomicType</a>として用いられているQNameが<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ定義</a>中の原子型として定義されていないならば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する [<a title=
"err:XPST0051" href="#ERRXPST0051">err:XPST0051</a>]。</p>
<p>例: <a href="#doc-xpath-AtomicType">AtomicType</a>
<code>xs:decimal</code>は値<code>12.34</code>
(実数リテラル)と照合される。もし<code>shoesize</code>が<code>xs:decimal</code>から制限によって導出される原子型であれば、<code>xs:decimal</code>はまた、型が<code>shoesize</code>であるような値とも照合される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<code>xs:IDREFS</code>のように原子型でない型の名前は、この文脈では認められないが、しばしば、<code>xs:IDREF+</code>のように出現標識を伴った原子型によって置き換えることができる。</p>
</div>
</li>
<li>
<p><code>item()</code>は任意の単一項目と照合される。</p>
<p>例:
<code>item()</code>は、原子値<code>1</code>や要素<code>&lt;a/&gt;</code>と照合される。</p>
</li>
<li>
<p><code>node()</code>は任意の節点と照合される。</p>
</li>
<li>
<p><code>text()</code>は任意のテキスト節点と照合される。</p>
</li>
<li>
<p><code>processing-instruction()</code>は任意の処理命令節点と照合される。</p>
</li>
<li>
<p>
<code>processing-instruction(</code><em>N</em><code>)</code>は、処理命令節点のうち名前(XMLでは処理命令の"PITarget"という)が<em>N</em>に等しいものに照合される。ここで<em>N</em>はNCNameである。</p>
<p>例:
<code>processing-instruction(xml-stylesheet)</code>は、処理命令のうちPITargetが<code>xml-stylesheet</code>であるものに照合される。</p>
<p>XPath1.0との後方互換性のため、処理命令のPITargetは文字列リテラルとしても表されてもよい。例えばこの例の通り:
<code>processing-instruction("xml-stylesheet")</code></p>
</li>
<li>
<p><code>comment()</code>は任意のコメント節点に照合される。</p>
</li>
<li>
<p><code>document-node()</code>は任意の文書節点に照合される。</p>
</li>
<li>
<p>
<code>document-node(</code><em>E</em><code>)</code>は、文書節点のうちただ1つの要素節点を含むものに照合される。1つ以上のコメント節点や処理命令節点が含まれていてもよい。ここで<em>E</em>は、その要素節点に照合される<a href="#doc-xpath-ElementTest">ElementTest</a>または<a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>である(<a href="#id-element-test"><b>2.5.4.3
要素テスト</b></a>および<a href="#id-schema-element-test"><b>2.5.4.4
スキーマ要素テスト</b></a>を見よ)。</p>
<p>例:
<code>document-node(element(book))</code>は、文書節点のうち、ElementTest
<code>element(book)</code>によって照合されるようなただ1つの文書節点を含むものに照合される。</p>
</li>
<li>
<p><a href="#doc-xpath-ElementTest">ElementTest</a>、<a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>、<a href=
"#doc-xpath-AttributeTest">AttributeTest</a>、または<a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>であるような<a href="#doc-xpath-ItemType">ItemType</a>は、以下の節で述べる要素節点または属性節点に照合される。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-element-test" id="id-element-test"></a>2.5.4.3
要素テスト</h5>
<p><a href=
"#doc-xpath-ElementTest">ElementTest</a>は、要素節点をその名前や<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>と照合するのに用いられる。<a href=
"#doc-xpath-ElementTest">ElementTest</a>は以下の形式のどれをとってもよい。これらの形式では、<a href="#doc-xpath-ElementName">ElementName</a>は<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>中にある必要はないが、<a href=
"#doc-xpath-TypeName">TypeName</a>は<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>中になければならない。なお、<a title=
"substitution group" href=
"#dt-substitution-group">置換グループ</a>は、<a href=
"#doc-xpath-ElementTest">ElementTest</a>の意味には影響を及ぼさない。</p>
<ol class="enumar">
<li>
<p>
<code>element()</code>と<code>element(*)</code>は任意の単一要素節点に照合され、その名前や型注釈とは関係しない。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>)</code>は、要素節点のうち名前が<a href="#doc-xpath-ElementName">ElementName</a>であるようなものに照合され、その型注釈や<code>nilled</code>性質とは関係しない。</p>
<p>例:
<code>element(person)</code>は、要素節点のうち名前が<code>person</code>のものと照合される。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>は、要素節点のうち名前が<a href="#doc-xpath-ElementName">ElementName</a>のものに照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xpath-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。</p>
<p>例: <code>element(person,
surgeon)</code>は、nilledでない要素節点のうち名前が<code>person</code>であり、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a>, <a href=
"#doc-xpath-TypeName">TypeName</a><code>?)</code>は、要素節点のうち名前が<a href="#doc-xpath-ElementName">ElementName</a>のものに照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>が<code>true</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(person,
surgeon?)</code>は、nilledもしくはnilledでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xpath-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。</p>
<p>例: <code>element(*,
surgeon)</code>は、nilledでない要素節点のうち、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a>
<code>?)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xpath-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(*,
surgeon?)</code>は、nilledであるかnilledでない要素節点のうち、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-element-test" id=
"id-schema-element-test"></a>2.5.4.4 スキーマ要素テスト</h5>
<p><a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>は、要素節点のうち、<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中にある対応する要素定義に対して照合される。これは次のような形式をとる。</p>
<p><code>schema-element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>)</code></p>
<p>もし<a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>中で指定されている<a href="#doc-xpath-ElementName">ElementName</a>が<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>にないならば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0008"
href="#ERRXPST0008">err:XPST0008</a>]。</p>
<p><a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>は、以下の3つの条件がすべて満たされるとき、候補要素節点に照合される。</p>
<ol class="enumar">
<li>
<p>候補節点の名前が、指定された<a href=
"#doc-xpath-ElementName">ElementName</a>に照合されるか、<a href=
"#doc-xpath-ElementName">ElementName</a>と名付けられた要素を先頭とする<a title=
"substitution group" href=
"#dt-substitution-group">置換グループ</a>中の要素名に照合される。</p>
</li>
<li>
<p><code>derives-from(</code><em>AT,
ET</em><code>)</code>が<code>true</code>である。ここで<em>AT</em>はその候補節点の型注釈、<em>ET</em>は<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>中で要素<a href=
"#doc-xpath-ElementName">ElementName</a>のために定義されたスキーマ型である。</p>
</li>
<li>
<p><a title="in-scope element declarations" href=
"#dt-is-elems">有効範囲内要素定義</a>中の<a href=
"#doc-xpath-ElementName">ElementName</a>のための要素定義が<code>nillable</code>でないならば、その候補節点の<code>nilled</code>性質は<code>false</code>である。</p>
</li>
</ol>
<p>例: <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>
<code>schema-element(customer)</code>は候補要素節点に照合される。ただし照合されるのは<code>customer</code>が<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中の最上位要素定義であり、候補節点の名前が<code>customer</code>であるか<code>customer</code>を先頭とする<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあり、候補節点の型注釈が<code>customer</code>要素のために定義されたスキーマ型と同じか導出されており、候補節点が<code>nilled</code>であるか<code>customer</code>が<code>nillable</code>と定義されているときである。</p>
</div>
<div class="div4">
<h5><a name="id-attribute-test" id="id-attribute-test"></a>2.5.4.5
属性テスト</h5>
<p><a href=
"#doc-xpath-AttributeTest">AttributeTest</a>は、属性節点をその名前や<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>と照合するのに用いられる。<a href=
"#doc-xpath-AttributeTest">AttributeTest</a>は以下の形式のどれをとってもよい。これらの形式で、<a href="#doc-xpath-AttributeName">AttributeName</a>は<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>中にある必要はないが、<a href=
"#doc-xpath-TypeName">TypeName</a>は<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>中にはなければならない。</p>
<ol class="enumar">
<li>
<p>
<code>attribute()</code>と<code>attribute(*)</code>は任意の単一属性節点に照合され、その名前や型注釈とは関係しない。</p>
</li>
<li>
<p><code>attribute(</code><a href=
"#doc-xpath-AttributeName">AttributeName</a><code>)</code>は、属性節点のうち名前が<a href="#doc-xpath-AttributeName">AttributeName</a>のものに照合され、その型注釈とは関係しない。</p>
<p>例:
<code>attribute(price)</code>は、名前が<code>price</code>である任意の属性節点に照合される。</p>
</li>
<li>
<p><code>attribute(</code><a href="#">AttributeName</a>, <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>は、属性節点のうち名前が<a href="#">AttributeName</a>であり、<code>derives-from(</code><em>AT</em>,
<a href="#doc-xpath-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であるようなものに照合される。ここで<em>AT</em>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(price,
currency)</code>は、属性節点のうち名前が<code>price</code>で型注釈が<code>currency</code>である
(もしくは<code>currency</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>attribute(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>は、名前に関係なく属性節点のうち<code>derives-from(</code><em>AT</em>,
<a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code>が<code>true</code>であるようなものに照合される。ここで<em>AT</em>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(*,
currency)</code>は、属性節点のうち型注釈が<code>currency</code>である
(もしくは<code>currency</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-attribute-test" id=
"id-schema-attribute-test"></a>2.5.4.6 スキーマ属性テスト</h5>
<p><a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>は、属性節点のうち、<a title="in-scope attribute declarations"
href=
"#dt-is-attrs">有効範囲内属性定義</a>中の対応する属性定義に対する属性節点に照合される。これは次のような形式をとる。</p>
<p><code>schema-attribute(</code><a href=
"#doc-xpath-AttributeName">AttributeName</a><code>)</code></p>
<p>もし<a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>中で指定される<a href="#doc-xpath-AttributeName">AttributeName</a>が<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0008"
href="#ERRXPST0008">err:XPST0008</a>]。</p>
<p><a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>は、以下の条件が2つとも満たされるとき、候補属性に照合される。</p>
<ol class="enumar">
<li>
<p>候補節点の名前が指定された<a href=
"#doc-xpath-AttributeName">AttributeName</a>に照合される。</p>
</li>
<li>
<p><code>derives-from(</code><em>AT,
ET</em><code>)</code>が<code>true</code>である。ここで<em>AT</em>は候補節点の型注釈、<em>ET</em>は<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>中の属性<a href=
"#doc-xpath-AttributeName">AttributeName</a>に対して定義されるスキーマ型である。</p>
</li>
</ol>
<p>例: <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>
<code>schema-attribute(color)</code>は候補属性節点に照合される。ただし照合されるのは<code>color</code>が<a title="in-scope attribute declarations"
href=
"#dt-is-attrs">有効範囲内属性定義</a>中の最上位属性定義であり、候補節点の名前が<code>color</code>であり、候補節点の型注釈が<code>color</code>属性に対して定義されたスキーマ型と等しいか、それから導出されるときである。</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>2.6 コメント</h3>
<h5><a name="d2e4716" id="d2e4716"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Comment" id=
"doc-xpath-Comment"></a>[77]&nbsp;&nbsp;&nbsp;</td>
<td><code>Comment</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(:" (<a href=
"#doc-xpath-CommentContents">CommentContents</a> | <a href=
"#doc-xpath-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CommentContents" id=
"doc-xpath-CommentContents"></a>[82]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>コメントは<span class=
"xpath">式</span>のための参考的注釈を提供するのに用いてもよい。コメントは字句的な構成要素だけであり<span class="xpath">式</span>の処理には影響を与えない。</p>
<p>
コメントは文字列であり、記号<code>(:</code>と<code>:)</code>によって区切られる。コメントは入れ子になってもよい。</p>
<p>コメントは<a title="ignorable whitespace" href=
"#IgnorableWhitespace">無視できる空白記号</a>が許されるところにはどこで用いてもよい(<a href=
"#DefaultWhitespaceHandling"><b>A.2.4.1 デフォルト空白処理</b></a>を見よ)。</p>
<p>以下がコメントの例である。</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>3 式</h2>
<p>
この章では、基本的な式の種類について一つ一つ議論する。それぞれの式の種類は<code>PathExpr</code>のような名前を持つ。この名前は、式を定義する文法生成規則の左辺に導入される。XPathは構成可能な言語なので、それぞれの種類の式は、演算子がより高い優先度を持つような別の式を用いて定義される。このようにして、演算子の優先度は、文法中で明示的に表される。</p>
<p>
この文書中で式が議論される順番は、演算子の優先度の順番を反映していない。一般に、この文書では、最も単純な種類の式を最初に導入し、続いて、より複雑な式を導入する。完全な文法については、付録を見よ
[<a href="#nt-bnf"><b>A XPathの文法</b></a>]。</p>
<p><span class="xpath">XPathの文法の最高位にあるシンボルはXPathである。</span></p>
<h5><a name="d2e4780" id="d2e4780"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-XPath" id=
"doc-xpath-XPath"></a>[1]&nbsp;&nbsp;&nbsp;</td>
<td><code>XPath</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Expr" id=
"doc-xpath-Expr"></a>[2]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ExprSingle" id=
"doc-xpath-ExprSingle"></a>[3]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExprSingle</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a><br />
| <a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xpath-IfExpr">IfExpr</a><br />
| <a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p>最も優先度の低いXPath演算子は<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>である。これは、2つの演算数をつないで1つの列を作るのに用いられる。文法に示す通り、一般の式(<a href="#doc-xpath-Expr">Expr</a>)は複数の<a href="#doc-xpath-ExprSingle">ExprSingle</a>演算数から構成することができる。このとき演算数はコンマで区切られる。名前<a href="#doc-xpath-ExprSingle">ExprSingle</a>は最上位の<a title="comma operator"
href="#dt-comma-operator">コンマ演算子</a>を含まない式を表す。(その名前に反して、<a href=
"#doc-xpath-ExprSingle">ExprSingle</a>は1つ以上の項目を含む列を評価してもよい。)</p>
<p>シンボル<a href=
"#doc-xpath-ExprSingle">ExprSingle</a>は、文法中で式の最上位にコンマを含むことが許されないようなあちこちの場所で使われている。例えば、関数呼び出しの各引数は<a href="#doc-xpath-ExprSingle">ExprSingle</a>でなければならない。なぜなら、関数呼び出しの引数を区切るのにコンマが使われているからである。</p>
<p>コンマの次に低い優先度を持つ式は<span class="xpath"><a href=
"#doc-xpath-ForExpr">ForExpr</a>,</span> <a href=
"#doc-xpath-QuantifiedExpr">QuantifiedExpr</a>, <a href=
"#doc-xpath-IfExpr">IfExpr</a>, そして<a href=
"#doc-xpath-OrExpr">OrExpr</a>である。これらの式は各々、この文書の別の節で述べる。</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>3.1 基本式</h3>
<p>[<a name="dt-primary-expression" id="dt-primary-expression"
title="primary expression">Definition</a>: <b>基本式</b>(primary
expression)はXPath言語の基本原式である。これにはリテラル、変数参照、文脈項目式、関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。]</p>
<h5><a name="d2e4869" id="d2e4869"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PrimaryExpr" id=
"doc-xpath-PrimaryExpr"></a>[41]&nbsp;&nbsp;&nbsp;</td>
<td><code>PrimaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a> | <a href=
"#doc-xpath-VarRef">VarRef</a> | <a href=
"#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#doc-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#doc-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>3.1.1 リテラル</h4>
<p>[<a name="dt-literal" id="dt-literal" title=
"literal">Definition</a>: <b>リテラル</b>は原子値の直接的構文表現である。]
XPathは2種類のリテラルを支援する。数リテラルと文字列リテラルである。</p>
<h5><a name="d2e4898" id="d2e4898"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Literal" id=
"doc-xpath-Literal"></a>[42]&nbsp;&nbsp;&nbsp;</td>
<td><code>Literal</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a> |
<a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NumericLiteral" id=
"doc-xpath-NumericLiteral"></a>[43]&nbsp;&nbsp;&nbsp;</td>
<td><code>NumericLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a> |
<a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IntegerLiteral" id=
"doc-xpath-IntegerLiteral"></a>[71]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntegerLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DecimalLiteral" id=
"doc-xpath-DecimalLiteral"></a>[72]&nbsp;&nbsp;&nbsp;</td>
<td><code>DecimalLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DoubleLiteral" id=
"doc-xpath-DoubleLiteral"></a>[73]&nbsp;&nbsp;&nbsp;</td>
<td><code>DoubleLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href=
"#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-StringLiteral" id=
"doc-xpath-StringLiteral"></a>[74]&nbsp;&nbsp;&nbsp;</td>
<td><code>StringLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href="#doc-xpath-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href="#doc-xpath-EscapeApos">EscapeApos</a>
| [^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-EscapeQuot" id=
"doc-xpath-EscapeQuot"></a>[75]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeQuot</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-EscapeApos" id=
"doc-xpath-EscapeApos"></a>[76]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeApos</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Digits" id=
"doc-xpath-Digits"></a>[81]&nbsp;&nbsp;&nbsp;</td>
<td><code>Digits</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p><b>数リテラル</b>の値のうち"<code>.</code>"と文字<code>e</code>,
<code>E</code>を含まないものは<code>xs:integer</code>型の原子値である。数リテラルの値のうち、"<code>.</code>"を含むが文字<code>e</code>も<code>E</code>も含まないものは<code>xs:decimal</code>型の原子値である。数リテラルの値のうち、文字<code>e</code>か<code>E</code>を含むものは<code>xs:double</code>型の原子値である。これらの数リテラルの値は、<a href="http://www.w3.org/TR/xpath-functions/#casting-from-strings">17.1.1
Casting from xs:string and xs:untypedAtomic</a><sup xmlns=
""><small>FO</small></sup>で指定されているように、<code>xs:untypedAtomic</code>から数型へ型変換するためのルールにしたがって、適切な型へ変換することにより決定される。</p>
<p><b>文字列リテラル</b>の値は、
<code>xs:string</code>を型とし、区切りの一重引用符または二重引用符の間の文字によって表される文字列を値とするような原子値である。リテラルが一重引用符で区切られているとき、リテラル中で隣り合った2つの一重引用符は1つの一重引用符と解釈される。同様に、リテラルが二重引用符で区切られているとき、リテラル中で隣り合った2つの二重引用符は1つの二重引用符と解釈される。</p>
<p>リテラル式の例をいくつか示す。</p>
<ul>
<li>
<p><code>"12.5"</code>は、文字 '1', '2', '.', '5'からなる文字列を表す。</p>
</li>
<li>
<p><code>12</code>は<code>xs:integer</code>の値12を表す。</p>
</li>
<li>
<p><code>12.5</code>は<code>xs:decimal</code>の値12.5を表す。</p>
</li>
<li>
<p><code>125E2</code>は、<code>xs:double</code>の値12500を表す。</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code>は2つの二重引用符と1つの
一重引用符を含む文字列を表す。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
XMLの属性の中など、一重引用符が特別な意味を持つ文脈にXPath式が埋め込まれるときは、さらにエスケープ処理が必要になるかもしれない。</p>
</div>
</li>
</ul>
<p>
<code>xs:boolean</code>の値<code>true</code>と<code>false</code>は、それぞれ<a title="built-in function"
href="#dt-built-in-function">組み込み関数</a>
<code>fn:true()</code>と<code>fn:false()</code>の呼び出しによって表現することができる。</p>
<p>その他の原子型の値は、与えられた型に対する<a title="constructor function" href=
"#dt-constructor-function">構成子関数</a>を呼び出すことにより構成することができる。XML
Schemaの組み込み型に対する構成子関数は<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>で定義されている。一般的に、ある型の構成子関数の名前は、その型の名前(名前空間を含む)と等しい。例えば:</p>
<ul>
<li>
<p><code>xs:integer("12")</code>は整数値12を返す。</p>
</li>
<li>
<p>
<code>xs:date("2001-08-25")</code>は、型が<code>xs:date</code>で、値が2001年8月25日という日付を表す項目を返す。</p>
</li>
<li>
<p>
<code>xs:dayTimeDuration("PT5H")</code>は、型が<code>xs:dayTimeDuration</code>で、値が5時間という時間を表す項目を返す。</p>
</li>
</ul>
<p>また構成子関数は、以下の例のように、リテラル表現を持たない特別な値を生成することもできる。</p>
<ul>
<li>
<p><code>xs:float("NaN")</code>は、"数でない"(Not a
Number)という特別な浮動小数点数の値を返す。</p>
</li>
<li>
<p><code>xs:double("INF")</code>は"正の無限大"という特別な二倍長浮動小数点数の値を返す。</p>
</li>
</ul>
<p>また、<code>cast</code>式を用いてさまざまな型の値を構成することもできる。例えば以下の通り。</p>
<ul>
<li>
<p><code>9 cast as
hatsize</code>は、型が<code>hatsize</code>である原子値<code>9</code>を返す。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>3.1.2 変数参照</h4>
<h5><a name="d2e5147" id="d2e5147"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-VarRef" id=
"doc-xpath-VarRef"></a>[44]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href="#doc-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-VarName" id=
"doc-xpath-VarName"></a>[45]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-variable-reference" id="dt-variable-reference"
title="variable reference">Definition</a>:
<b>変数参照</b>は$記号にQNameを続けたものである。]
2つの変数参照が同値であるとは、それらの局所名が等しく、かつそれらの名前空間接頭辞が<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中の同じ名前空間URIに束縛されていることである。接頭辞のない変数参照はどの名前空間にも属さない。</p>
<p>変数参照はそれぞれ<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>内の名前に照合されなければならない。有効範囲内変数には以下の出所からの変数が含まれる。</p>
<ol class="enumar">
<li>
<p><a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の変数によって拡大されてもよい。</p>
</li>
<li>
<p>変数はXPath式によって束縛されてもよい。<span class=
"xpath">変数を束縛することのできる式の種類は<code>for</code>式 (<a href=
"#id-for-expressions"><b>3.7 For式</b></a>) と限量式 (<a href=
"#id-quantified-expressions"><b>3.9 限量式</b></a>)である。</span></p>
</li>
</ol>
<p>
変数束縛はそれぞれ静的有効範囲を持つ。有効範囲は、変数への参照が正しく出現できる場所を定義する。有効範囲の中にない変数を参照すると、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0008" href=
"#ERRXPST0008">err:XPST0008</a>] である。ある式に対して、変数が<a title=
"static context" href=
"#dt-static-context">静的文脈</a>内で束縛されれば、その変数は式全体に対する有効範囲に含まれる。</p>
<p>
変数参照が有効範囲内の2つ以上の変数束縛に照合されたときは、その参照は、より内側の束縛、すなわち有効範囲がより小さいほうの束縛を参照すると解釈される。評価時には、変数参照の値は、対応する変数が束縛されている式の値である。変数束縛の有効範囲は、変数を束縛することのできる式それぞれについて個別に定義される。</p>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>3.1.3 括弧式</h4>
<h5><a name="d2e5212" id="d2e5212"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ParenthesizedExpr" id=
"doc-xpath-ParenthesizedExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(" <a href="#doc-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>括弧は、複数の演算子を含む式の評価順序をある順に強制するのに用いてもよい。例えば、式<code>(2 + 4) *
5</code>を評価すると30になる。なぜなら括弧式<code>(2 +
4)</code>が最初に評価され、その結果に5が掛けられるからである。括弧をつけなければ、式<code>2 + 4 *
5</code>を評価すると22になる。なぜなら乗算演算子は加算演算子より優先度が高いからである。</p>
<p>空の括弧は、<a href="#construct_seq"><b>3.3.1
列の構成</b></a>にある通り、空列を表すのに用いられる。</p>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>3.1.4 文脈項目式</h4>
<h5><a name="d2e5240" id="d2e5240"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ContextItemExpr" id=
"doc-xpath-ContextItemExpr"></a>[47]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContextItemExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p><b>文脈項目式</b>を評価すると<a title="context item" href=
"#dt-context-item">文脈項目</a>が得られる。これは節点(式<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>中のように)か、原子値(式<code>(1
to 100)[. mod 5 eq 0]</code>中のように)のいずれかである。</p>
<p><a title="context item" href=
"#dt-context-item">文脈項目</a>が未定義であれば、文脈項目式は動的エラーを引き起こす[<a title=
"err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>3.1.5
関数呼び出し</h4>
<p>[<a name="dt-built-in-function" id="dt-built-in-function" title=
"built-in function">Definition</a>:
XPathで支援されている<b>組み込み関数</b>は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。]
<span class="xpath">その他の関数が<a title="static context" href=
"#dt-static-context">静的文脈</a>で用意されていてもよい。XPathそれ自体では関数を定義する方法は用意されていないが、ホスト言語でそのような仕組みが用意されていてもよい。</span></p>
<h5><a name="d2e5285" id="d2e5285"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-FunctionCall" id=
"doc-xpath-FunctionCall"></a>[48]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>
<b>関数呼び出し</b>は、QNameの後ろに0個以上の式の括弧付きリストが続くような構成をしている。この括弧付きリストを<b>引数</b>という。関数呼び出しのQNameが名前空間接頭辞を持っていなければ、<a title="default function namespace"
href="#dt-def-fn-ns">デフォルト関数名前空間</a>に属するとみなす。</p>
<p>関数呼び出しの<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>や引数の数が<a title="static context"
href="#dt-static-context">静的文脈</a>中の<a title="function signature"
href="#dt-function-signature">関数シグネチャ</a>の名前や次数に照合されなければ、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する[<a title=
"err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>]。</p>
<p>関数呼び出しは次のように評価される。</p>
<ol class="enumar">
<li>
<p>引数の式が評価され、引数値を生成する。引数の評価順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>であり、ある引数を評価することなく関数の本体が評価できるならば、関数はその引数を評価する必要はない。</p>
</li>
<li>
<p>以下に挙げる関数変換ルールを適用して、引数値がそれぞれ変換される。</p>
</li>
<li>
<p>
変換された引数値を用いて関数が評価される。結果は、関数の定義済返り型のインスタンスか、動的エラーである。関数の結果の<a title=
"dynamic type" href=
"#dt-dynamic-type">動的型</a>は定義済返り型から導出される型であってもよい。関数によって引き起こされるエラーは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>に定義されている。</p>
</li>
</ol>
<p>
<b>関数変換ルール</b>は、引数値を、引数として期待される型に変換するのに用いられる。すなわち、関数の<span class="xpath">引数</span>の定義済型に変換するのに用いられる。期待される型は<a title="sequence type"
href=
"#dt-sequence-type">列型</a>として表現される。与えられた値に対して、関数変換ルールは以下のように適用される。</p>
<ul>
<li>
<p><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であり、かつ引数が期待される型でないならば、以下のような変換が順に引数値Vに適用される。</p>
<ol class="enumar">
<li>
<p>期待される型が単一項目もしくは省略可能な単一項目 (例: <code>xs:string</code>,
<code>xs:string?</code>, <code>xs:untypedAtomic</code>,
<code>xs:untypedAtomic?</code>, <code>node()</code>,
<code>node()?</code>, <code>item()</code>,
<code>item()?</code>)を要求するならば、値VはV[1]に置き換えられる。</p>
</li>
<li>
<p>
期待される型が<code>xs:string</code>または<code>xs:string?</code>であるならば、値<code>V</code>は<code>fn:string(V)</code>に置き換えられる。</p>
</li>
<li>
<p>
期待される型が<code>xs:double</code>または<code>xs:double?</code>であるならば、値<code>V</code>は<code>fn:number(V)</code>に置き換えられる。</p>
</li>
</ol>
</li>
<li>
<p>期待される型が原子型の列 (出現標識<code>*</code>, <code>+</code>,
<code>?</code>を伴っていてもよい)であるならば、以下の変換が適用される。</p>
<ol class="enumar">
<li>
<p>与えられた値に<a title="atomization" href=
"#dt-atomization">原子化</a>が行われ、原子値の列が結果として得られる。</p>
</li>
<li>
<p>
原子列の項目のうち<code>xs:untypedAtomic</code>型のものそれぞれに対し、期待される原子型への型変換が行われる。<a title="built-in function"
href="#dt-built-in-function">組み込み関数</a>のうち期待される型が<a title="numeric"
href=
"#dt-numeric">数</a>と指定されているものについて、<code>xs:untypedAtomic</code>型の引数が<code>xs:double</code>に型変換される。</p>
</li>
<li>
<p>原子列中の<a title="numeric" href="#dt-numeric">数</a>項目のうち、<a href=
"#promotion"><b>B.1 型の昇格</b></a>に書かれている数昇格を用いて期待される原子型に<a title=
"type promotion" href=
"#dt-type-promotion">昇格</a>できるものについて、昇格が行われる。</p>
</li>
<li>
<p>原子列中の<code>xs:anyURI</code>型の項目のうち、<a href="#promotion"><b>B.1
型の昇格</b></a>に書かれているURI昇格を用いて期待される原子型に<a title="type promotion"
href="#dt-type-promotion">昇格</a>できるものについて、昇格が行われる。</p>
</li>
</ol>
</li>
<li>
<p>上記の変換を行った後、結果の値が、<a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールに従って期待される型に照合されないときは、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する[<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。 <a title="SequenceType matching"
href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールは、導出された型の値を基礎型の値として置換することを許していることに注意せよ。</p>
</li>
</ul>
<p>関数呼び出しの引数はコンマで区切られているので、最上位の<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>を含む引数式は、括弧で囲まなければならない。以下は、関数呼び出しの例とその説明である。</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2,
3)</code>は3つの引数を持つ関数呼び出しである。</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2),
3)</code>は2つの引数を持つ関数呼び出しであり、1つ目の引数は2つの値の列である。</p>
</li>
<li>
<p><code>my:two-argument-function(1,
())</code>は2つの引数を持つ関数呼び出しであり、2つ目の引数は空列である。</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2,
3))</code>は1つの引数を持つ関数呼び出しであり、その引数は3つの値の列である。</p>
</li>
<li>
<p><code>my:one-argument-function((
))</code>は1つの引数を持つ関数呼び出しであり、その引数は空列である。</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code>は引数のない関数呼び出しである。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>3.2
経路式</h3>
<h5><a name="d2e5541" id="d2e5541"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PathExpr" id=
"doc-xpath-PathExpr"></a>[25]&nbsp;&nbsp;&nbsp;</td>
<td><code>PathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("/" <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-RelativePathExpr" id=
"doc-xpath-RelativePathExpr"></a>[26]&nbsp;&nbsp;&nbsp;</td>
<td><code>RelativePathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a> (("/" | "//")
<a href="#doc-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-path-expression" id="dt-path-expression" title=
"path expression">Definition</a>:
<b>経路式</b>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の <a title="step" href=
"#dt-step">ステップ</a>の並びからなり、各ステップは "<code>/</code>" または
"<code>//</code>", で区切られている。また、経路式は "<code>/</code>" または
"<code>//</code>"で始まる場合もある。]先頭の "<code>/</code>" または
"<code>//</code>"
は、以下に述べるように、経路式の先頭に暗黙的に追加される1つ以上の初期ステップの省略形である。</p>
<p>単一のステップからなる経路式は<a href="#id-steps"><b>3.2.1
ステップ</b></a>に述べるように評価される。</p>
<p>経路式の先頭にある "<code>/</code>" は初期ステップ<code>fn:root(self::node())
treat as document-node()/</code>の省略形である (ただし、もし "<code>/</code>"
が経路式全体であるならば、末尾の "<code>/</code>"
は展開から省かれる)。この初期ステップの効果は、その経路が文脈節点を含む木の根節点から始まる、ということである。文脈項目が節点でない場合は、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。評価時に、文脈節点より上にある根節点が文書節点でなければ、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
<p>経路式の先頭にある "<code>//</code>" は初期ステップ<code>fn:root(self::node())
treat as document-node()/descendant-or-self::node()/</code>の省略形である
(ただし、"<code>//</code>" それ自身は正しい経路式ではない [<a title="err:XPST0003"
href=
"#ERRXPST0003">err:XPST0003</a>])。これらの初期ステップの効果は、文脈節点の存在する木の根を含み、この根の子孫にすべての節点があるような初期節点列を確立するということである。この節点列は、経路式中の次のステップの入力として用いられる。文脈項目が節点でなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。評価時に、文脈節点より上にある根節点が文書節点でなければ、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>節点の子孫には属性節点<span class="xpath">や名前空間節点</span>は含まれない。</p>
</div>
<p>経路式中の先頭ではない場所に出現する "<code>//</code>" は<a href="#abbrev"><b>3.2.4
省略構文</b></a>に述べるように展開され、 "<code>/</code>"
で区切られるステップの列になる。次に、このステップ列が左から右へ評価される。それぞれの演算
<code>E1/E2</code>は次のように評価される:
式<code>E1</code>が評価され、結果が(空かもしれない)節点列でなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0019" href=
"#ERRXPTY0019">err:XPTY0019</a>]。
次に、<code>E1</code>の評価の結果得られる節点それぞれが、<a href=
"#eval_context"><b>2.1.2
動的文脈</b></a>にあるように、さらに<code>E2</code>の評価のための<b>内部焦点</b>を提供する。
<code>E2</code>の評価すべてから得られた列が以下のように結合される:</p>
<ol class="enumar">
<li>
<p>
<code>E2</code>の評価それぞれが(空かもしれない)節点列を返すなら、これらの列が結合され、節点の識別性に基づき、重複する節点が除去される。<span class="xpath">結果の節点列は<a title="document order"
href="#dt-document-order">文書順</a>で返される。</span></p>
</li>
<li>
<p><code>E2</code>の評価それぞれが(空かもしれない)原子値列を返すなら、これらの列が<span class=
"xpath">順に</span>連接され、返される。</p>
</li>
<li>
<p>複数の<code>E2</code>の評価の結果、節点と原子値が少なくとも1つずつ返ってきたならば、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する [<a title=
"err:XPTY0018" href="#ERRXPTY0018">err:XPTY0018</a>]。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
経路の各ステップが次のステップのための文脈節点を用意するため、その結果、経路の最後のステップしか、原子値列を返すことは許されない。</p>
</div>
<p>
経路式の例として、<code>child::div1/child::para</code>は、文脈節点の子要素<code>div1</code>の子要素<code>para</code>を選択する。言い換えれば、文脈節点の孫要素<code>para</code>のうち<code>div1</code>を親として持つものが選択される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">文字 "<code>/</code>"
は、完全な経路式としても、"<code>/*</code>"
のようなさらに長い経路式の先頭としても用いることができる。また、"<code>*</code>"
は、乗算演算子であるとともに経路式のワイルドカードでもある。このことにより、"<code>/</code>" が
"<code>*</code>" の左側に出現するとき、構文解析が難しくなる。これは、<a href=
"#parse-note-leading-lone-slash">leading-lone-slash</a>
制約を用いることにより、解決できる。例えば、"<code>/*</code>" と "<code>/ *</code>"
はワイルドカードを含む正しい経路式であるが、"<code>/*5</code>" と "<code>/ * 5</code>"
は構文エラーを引き起こす。<code>/</code>" を演算子の左側で用いる時は、"<code>(/) * 5</code>"
のように、括弧をつけなければならない。同様に、"<code>4 + / * 5</code>"
は構文エラーを引き起こすが、"<code>4 + (/) * 5</code>" は正しい式である。式 "<code>4 +
/</code>" もまた正しい。なぜなら<code>/</code>が演算子の左側に出現していないからである。</p>
</div>
<div class="div3">
<h4><a name="id-steps" id="id-steps"></a>3.2.1 ステップ</h4>
<h5><a name="d2e5793" id="d2e5793"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-StepExpr" id=
"doc-xpath-StepExpr"></a>[27]&nbsp;&nbsp;&nbsp;</td>
<td><code>StepExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-FilterExpr">FilterExpr</a> | <a href=
"#doc-xpath-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AxisStep" id=
"doc-xpath-AxisStep"></a>[28]&nbsp;&nbsp;&nbsp;</td>
<td><code>AxisStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xpath-ReverseStep">ReverseStep</a> |
<a href="#doc-xpath-ForwardStep">ForwardStep</a>) <a href=
"#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForwardStep" id=
"doc-xpath-ForwardStep"></a>[29]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xpath-ForwardAxis">ForwardAxis</a>
<a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ReverseStep" id=
"doc-xpath-ReverseStep"></a>[32]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xpath-ReverseAxis">ReverseAxis</a>
<a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PredicateList" id=
"doc-xpath-PredicateList"></a>[39]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-step" id="dt-step" title="step">Definition</a>:
<b>ステップ</b>は<a title="path expression" href=
"#dt-path-expression">経路式</a>の一部であり、項目の列を生成し、その列を0個以上の<a title=
"predicate" href=
"#dt-predicate">述語</a>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<a title="axis step"
href="#dt-axis-step">軸ステップ</a>または<a title="filter expression" href=
"#dt-filter-expression">選別式</a>のいずれかである。] 選別式の説明は<a href=
"#id-filter-expr"><b>3.3.2 選別式</b></a>にある。</p>
<p>[<a name="dt-axis-step" id="dt-axis-step" title=
"axis step">Definition</a>:
<b>軸ステップ</b>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<b>軸</b>はステップでの
"移動方向" を定義し、<a title="node test" href=
"#dt-node-test">節点テスト</a>は節点の種類、名前、<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>により節点を選択する。]
文脈項目が節点であれば、軸ステップは0個以上の節点からなる列を返す。それ以外の場合は、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。<span class=
"xpath">得られる節点列は<a title="document order" href=
"#dt-document-order">文書順</a>で返される。</span>
軸ステップは<b>前向きステップ</b>かまたは<b>逆向きステップ</b>のいずれかであり、0個以上の<a title=
"predicate" href="#dt-predicate">述語</a>がそれに続く。</p>
<p>ステップの<b>省略構文</b>では、軸は省略可能であり、また<a href="#abbrev"><b>3.2.4
省略構文</b></a>にあるように、その他の短縮記法も利用できる。</p>
<p>
軸ステップの非省略構文は軸名と節点テストからなり、これらは2つのコロンで区切られる。ステップの結果は、指定された軸を通して文脈節点から到達可能な節点のうち、節点テストで指定される節点の種類、名前、<a title="type annotation"
href=
"#dt-type-annotation">型注釈</a>を持つものからなる。例えば、ステップ<code>child::para</code>は、文脈節点の子要素<code>para</code>を選択する。ここで<code>child</code>が軸の名前であり、<code>para</code>がこの軸上で選択される要素節点の名前である。利用できる軸の説明は<a href="#axes"><b>3.2.1.1
軸</b></a>にある。利用できる節点テストの説明は<a href="#node-tests"><b>3.2.1.2
節点テスト</b></a>にある。ステップの例は<a href="#unabbrev"><b>3.2.3
非省略構文</b></a>や<a href="#abbrev"><b>3.2.4 省略構文</b></a>で示されている。</p>
<div class="div4">
<h5><a name="axes" id="axes"></a>3.2.1.1 軸</h5>
<h5><a name="d2e5940" id="d2e5940"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForwardAxis" id=
"doc-xpath-ForwardAxis"></a>[30]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ReverseAxis" id=
"doc-xpath-ReverseAxis"></a>[33]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p class="xpath">
XPathは文書を行ったり来たりするための<b>軸</b>の完全な集合を定義しているが、<b>ホスト言語</b>がこれらの軸の部分集合を定義してもよい。以下の軸が定義されている。</p>
<ul>
<li>
<p><code>child</code>軸は文脈節点の子を含む。これらの節点は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>にある<code>dm:children</code>アクセサにより返される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
子を持つのは文書節点と要素節点だけである。文脈節点がこれ以外の種類の節点であるか、文脈節点が空の文書節点もしくは要素節点であったならば、child軸は空列である。文書節点や要素節点の子は、要素節点、処理命令節点、コメント節点、テキスト節点のいずれかである。属性節点<span class="xpath">、名前空間節点</span>、文書節点は決して子として出現することはない。</p>
</div>
</li>
<li>
<p><code>descendant</code>軸はchild軸の推移的閉包として定義される。この軸には文脈節点の子孫
(子、子の子、など) が含まれる。</p>
</li>
<li>
<p><code>parent</code>軸は<a href="#datamodel">[XQuery/XPath Data
Model
(XDM)]</a>にある<code>dm:parent</code>アクセサにより返される列を含む。このアクセサは文脈節点の親を返す。ただし、文脈節点が親を持たない場合は空列を返す。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>属性節点はその親として要素節点を持っていてもよい。ただしその場合も、その属性節点はその要素節点の子ではない。</p>
</div>
</li>
<li>
<p><code>ancestor</code>軸はparent軸の推移的閉包として定義される。この軸には文脈節点の先祖
(親、親の親、など) が含まれる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>ancestor軸には、文脈節点のある木の根節点が含まれる。ただし、文脈節点が根節点の場合は含まれない。</p>
</div>
</li>
<li>
<p>
<code>following-sibling</code>軸は文脈節点の後に続く兄弟を含む。すなわち文脈節点の親の子のうち、<a title="document order"
href=
"#dt-document-order">文書順</a>で文脈節点の後ろに出現する節点を含む。もし文脈節点が属性節点<span class="xpath">または名前空間節点</span>であれば、<code>following-sibling</code>軸は空である。</p>
</li>
<li>
<p>
<code>preceding-sibling</code>軸は文脈節点の前にある兄弟を含む。すなわち文脈節点の親の子のうち、<a title="document order"
href=
"#dt-document-order">文書順</a>で文脈節点より前に出現する節点を含む。もし文脈節点が属性節点<span class="xpath">または名前空間節点</span>であれば、<code>preceding-sibling</code>軸は空である。</p>
</li>
<li>
<p><code>following</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より後ろに出現するものすべてを含む。</p>
</li>
<li>
<p><code>preceding</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より前に出現するものすべてを含む。</p>
</li>
<li>
<p><code>attribute</code>軸は、文脈節点の属性を含む。これらは<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>にある<code>dm:attributes</code>アクセサによって返される節点である。文脈節点が要素でなければ、この軸は空である。</p>
</li>
<li>
<p><code>self</code>軸は文脈節点自身のみを含む。</p>
</li>
<li>
<p><code>descendant-or-self</code>軸は、文脈節点と、文脈節点の子孫を含む。</p>
</li>
<li>
<p>
<code>ancestor-or-self</code>軸は、文脈節点と、文脈節点の先祖を含む。したがって、ancestor-or-self軸は常に根節点を含む。</p>
</li>
<li>
<p><code>namespace</code>軸は、文脈節点の名前空間節点を含む。これらは<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>にある<code>dm:namespace-nodes</code>アクセサにより返される節点である。文脈節点が要素節点でなければ、この軸は空である。<code>namespace</code>節点はXPath
2.0 では推奨されない。もし<a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、<code>namespace</code>軸は支援されなければならない。もし<a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>false</code>であれば、<code>namespace</code>軸の支援は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。<a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>false</code>であるとき<code>namespace</code>軸を支援しない実装では、この軸が使われると<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0010" href=
"#ERRXPST0010">err:XPST0010</a>]を発生させなければならない。要素の<a title=
"in-scope namespaces" href=
"#dt-in-scope-namespaces">有効範囲内名前空間</a>に関する情報を必要とするアプリケーションは、<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>で定義される<code>fn:in-scope-prefixes</code>関数や<code>fn:namespace-uri-for-prefix</code>関数を使うべきである。</p>
</li>
</ul>
<p>軸は<b>前向き軸</b>と<b>逆向き軸</b>とに分類することができる。文脈節点または<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より後ろの節点のみ含む軸は、前向き軸である。文脈節点または<a title="document order"
href="#dt-document-order">文書順</a>で文脈節点より前の節点のみ含む軸は、逆向き軸である。</p>
<p><code>parent</code>軸, <code>ancestor</code>軸,
<code>ancestor-or-self</code>軸, <code>preceding</code>軸,
<code>preceding-sibling</code>軸は逆向き軸である。それ以外の軸はすべて前向き軸である。<code>ancestor</code>軸,
<code>descendant</code>軸, <code>following</code>軸,
<code>preceding</code>軸, <code>self</code>軸は文書を分割する
(属性節点<span class=
"xpath">と名前空間節点</span>は無視する)。これらの軸は互いに重複がなく、すべてを合わせると文書中のすべての節点を含む。</p>
<p>[<a name="dt-principal-node-kind" id="dt-principal-node-kind"
title="principal node kind">Definition</a>:
軸はそれぞれ<b>主要節点種類</b>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。]
したがって:</p>
<ul>
<li>
<p>attribute軸に対しては、主要節点種類は属性である。</p>
</li>
<li>
<p>namespace軸に対しては、主要節点種類は名前空間である。</p>
</li>
<li>
<p>それ以外のすべての軸に対しては、主要節点種類は要素である。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>3.2.1.2 節点テスト</h5>
<p>[<a name="dt-node-test" id="dt-node-test" title=
"node test">Definition</a>: <b>節点テスト</b>は、<a title="step" href=
"#dt-step">ステップ</a>によって選択された節点それぞれについて真にならなければならない条件である。]
この条件は、節点の種類 (要素、属性、テキスト、文書、コメント、処理命令)、節点の名前、(要素節点、属性節点、文書節点の場合には)
節点の<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>に基づいていてもよい。</p>
<h5><a name="d2e6233" id="d2e6233"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NodeTest" id=
"doc-xpath-NodeTest"></a>[35]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | <a href=
"#doc-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NameTest" id=
"doc-xpath-NameTest"></a>[36]&nbsp;&nbsp;&nbsp;</td>
<td><code>NameTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#doc-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Wildcard" id=
"doc-xpath-Wildcard"></a>[37]&nbsp;&nbsp;&nbsp;</td>
<td><code>Wildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-name-test" id="dt-name-test" title=
"name test">Definition</a>:
QNameまたはワイルドカードのみからなる節点テストを<b>名前テスト</b>という。]
名前テストが真になるのは、節点の<b>種類</b>がそのステップの軸の<a title="principal node kind"
href="#dt-principal-node-kind">主要節点種類</a>であり、節点の<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>が節点テストで指定されている<a title=
"expanded QName" href="#dt-expanded-qname">展開済QName</a>と
(<code>eq</code> 演算子で定義されているように)
一致するとき、かつそのときに限る。例えば、<code>child::para</code>は、文脈節点の<code>para</code>子要素を選択する。文脈節点の子に<code>para</code>要素がなければ、節点の空集合を選択する。<code>attribute::abc:href</code>は、QName<code>abc:href</code>を持つ文脈節点の属性を選択する。文脈節点がそのような属性を持たなければ、節点の空集合を選択する。</p>
<p>節点テスト中のQNameは、式文脈の<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>に解決される。QNameの接頭辞が静的既知名前空間のどれにも一致しなければ、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]である。接頭辞のないQNameは、<a title=
"principal node kind" href=
"#dt-principal-node-kind">主要節点種類</a>が要素である軸上で名前テストとして用いられると、式文脈の<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>の名前空間URIを持つ。これ以外の用いられ方の場合、名前空間URIを持たない。</p>
<p>名前テストの<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>と名前が一致しないような要素節点に対しては、その名前テストは満たされない。たとえその名前がその名付けられた節点を先頭とするような<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあったとしても、その名前テストは満たされない。</p>
<p>節点テスト<code>*</code>は、そのステップの軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>であるような任意の節点に対して、真である。例えば、<code>child::*</code>は文脈節点のすべての子要素を選択する。また<code>attribute::*</code>は、文脈節点のすべての属性を選択する。</p>
<p>
節点テストは<code>NCName:*</code>という形式を持つことができる。この場合、接頭辞はQNameと同じ方法で展開される。このとき、<a title="static context"
href="#dt-static-context">静的文脈</a>中の<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いる。その接頭辞が静的既知名前空間中になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0081"
href=
"#ERRXPST0081">err:XPST0081</a>]。このような形式の節点テストが真になるのは、ステップの軸のうち<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>が接頭辞の束縛されている名前空間URIを持っているものについて、その軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>の任意の節点に対してである。その名前の局所部分には関係しない。</p>
<p>
節点テストは<code>*:NCName</code>という形式を持つこともできる。この場合、節点テストが真になるのは、そのステップの軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>の節点のうち、局所名が与えられたNCNameに一致するものに対してである。節点の名前空間や、節点の名前空間の有無には関係しない。</p>
<p>[<a name="dt-kind-test" id="dt-kind-test" title=
"kind test">Definition</a>:
節点テストのもう一つの形式は<b>種類テスト</b>と呼ばれる。これは、節点の種類、名前、<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>に基づき、節点を選択することができる。]
種類テストの構文と意味についての記述は<a href="#id-sequencetype-syntax"><b>2.5.3
SequenceTypeの文法</b></a>と<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある。種類テストが<a title="node test" href=
"#dt-node-test">節点テスト</a>内で用いられるとき、指定された軸上の節点のうち、その種類テストに照合されるものだけが選択される。以下に示すのは、経路式中で用いられている種類テストの例のいくつかである。</p>
<ul>
<li>
<p><code>node()</code>は任意の節点に照合される。</p>
</li>
<li>
<p><code>text()</code>は任意のテキスト節点に照合される。</p>
</li>
<li>
<p><code>comment()</code>は任意のコメント節点に照合される。</p>
</li>
<li>
<p><code>element()</code>は任意の要素節点に照合される。</p>
</li>
<li>
<p>
<code>schema-element(person)</code>は、要素節点のうち、名前が<code>person</code>
(または<code>person</code>を先頭とする<a title="substitution group" href=
"#dt-substitution-group">置換グループ</a>に含まれる)であり、型注釈が<a title=
"in-scope element declarations" href=
"#dt-is-elems">有効範囲内要素定義</a>中の<code>person</code>要素の定義型と同じ(もしくは導出される)であるようなものに照合される。</p>
</li>
<li>
<p>
<code>element(person)</code>は、要素節点のうち、名前が<code>person</code>であるようなものに照合される。その節点の型注釈には関係しない。</p>
</li>
<li>
<p><code>element(person,
surgeon)</code>は、nillでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>または<code>surgeon</code>から導出されるものに照合される。</p>
</li>
<li>
<p><code>element(*,
surgeon)</code>は、nillでない要素節点のうち、型注釈が<code>surgeon</code>
(または<code>surgeon</code>から導出される)であるようなものに照合される。その節点の名前には関係しない。</p>
</li>
<li>
<p><code>attribute()</code>は任意の属性節点に照合される。</p>
</li>
<li>
<p>
<code>attribute(price)</code>は、属性節点のうち名前が<code>price</code>であるものに照合される。その節点の型注釈には関係しない。</p>
</li>
<li>
<p><code>attribute(*,
xs:decimal)</code>は属性節点のうち型注釈が<code>xs:decimal</code>である
(または<code>xs:decimal</code>から導出される) ものに照合される。その節点の名前には関係しない。</p>
</li>
<li>
<p><code>document-node()</code>は任意の文書節点に照合される。</p>
</li>
<li>
<p><code>document-node(element(book))</code>は、文書節点のうち内容が<a title=
"kind test" href="#dt-kind-test">種類テスト</a>
<code>element(book)</code>を満たす単一要素節点と、0個以上のコメントや処理命令が交差しているようなものに照合される。</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-predicates" id="id-predicates"></a>3.2.2 述語</h4>
<h5><a name="d2e6510" id="d2e6510"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Predicate" id=
"doc-xpath-Predicate"></a>[40]&nbsp;&nbsp;&nbsp;</td>
<td><code>Predicate</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"[" <a href="#doc-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-predicate" id="dt-predicate" title=
"predicate">Definition</a>:
<b>述語</b>は式からなり、角括弧で囲まれる。この式のことを<b>述語式</b>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。]
複数の隣接する述語の場合は、述語が左から右に適用され、それぞれの述語を適用した結果が次に続く述語の入力列になる。</p>
<p>入力列のそれぞれの項目に対して、述語式は <b>内部焦点</b> を用いて以下のように評価される:
文脈項目は、その述語によって現在評価されている項目である。文脈サイズは入力列中の項目数である。文脈位置は、入力列中の文脈項目の位置である。述語中での文脈位置を評価する目的で、入力列は以下のように整列されているとみなす:
述語が前向き軸のステップ中にあるなら文書順、述語が後ろ向き軸のステップ中にあるなら逆文書順、述語がステップ内にないなら元の順である。</p>
<p>入力列の項目それぞれに対して、
述語式の結果は<code>xs:boolean</code>の値に強制される。この値を<b>述語真偽値</b>といい、以下の通りになる。述語真偽値が<code>true</code>であるような項目が残され、述語真偽値が<code>false</code>であるような項目が捨てられる。</p>
<p>述語真偽値は以下のルールを順に適用することで導出される。</p>
<ol class="enumar">
<li>
<p>述語式の値が<a title="numeric" href="#dt-numeric">数</a>型または<a title=
"numeric" href="#dt-numeric">数</a>型から導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>原子値であるなら、述語真偽値は次のようになる。述語式の値が(<code>eq</code>演算子によって)<b>文脈位置</b>と等しい場合は<code>true</code>、それ以外の場合は<code>false</code>になる。
[<a name="dt-numeric-predicate" id="dt-numeric-predicate" title=
"numeric predicate">Definition</a>: 述語式が数型を返す述語を<b>数述語</b>という。]</p>
</li>
<li>
<p>これ以外の場合は、述語真偽値は、その述語式の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>である。</p>
</li>
</ol>
<p>以下に、述語を含む<a title="axis step" href=
"#dt-axis-step">軸ステップ</a>の例をいくつか示す。</p>
<ul>
<li>
<p>この例は、文脈節点の子要素のうち、2番目の<code>chapter</code>要素を選択する。</p>
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</li>
<li>
<p>
この例は、文脈節点の子孫のうち、名前が<code>"toy"</code>であり、その<code>color</code>属性の値が<code>"red"</code>であるような要素を選択する。</p>
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</li>
<li>
<p>
この例は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>子要素と<code>assistant</code>子要素をともに持つものを選択する。</p>
<div class="exampleInner">
<pre>
child::employee[secretary][assistant]
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><b>逆向き軸</b>を用いて選択された節点列に<a title="predicate" href=
"#dt-predicate">述語</a>を用いる場合、このような列の文脈位置は<a title=
"reverse document order" href=
"#dt-reverse-document-order">逆文書順</a>に割り当てられることを覚えておくことが重要である。例えば、<code>preceding::foo[1]</code>は<a title="reverse document order"
href=
"#dt-reverse-document-order">逆文書順</a>に最初に限定される<code>foo</code>要素を返す。なぜなら、この述語は逆向き軸を用いた<a title="axis step"
href=
"#dt-axis-step">軸ステップ</a>の一部であるからである。一方、<code>(preceding::foo)[1]</code>は<a title="document order"
href=
"#dt-document-order">文書順</a>に最初に限定される<code>foo</code>要素を返す。なぜなら、括弧によって<code>(preceding::foo)</code>が<a title="primary expression"
href=
"#dt-primary-expression">優先式</a>と解釈され、この式の中で文脈位置が文書順に割り当てられるからである。同様に、<code>ancestor::*[1]</code>は最も近い先祖要素を返す。なぜなら<code>ancestor</code>軸は逆向き軸であるからである。一方<code>(ancestor::*)[1]</code>は根要素
(文書順で最初の先祖) を返す。</p>
<p>
後ろ向き軸のステップでは述語を評価する目的で文脈位置が逆文書順で割り当てられているという事実があっても、ステップの最終結果は常に文書順であるという事実は変わらない。</p>
</div>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>3.2.3 非省略構文</h4>
<p>この節では経路式の例をいくつか出すが、これらは、各<a title="step" href=
"#dt-step">ステップ</a>で軸が明示的に指定されている。これらの例で用いられている構文は<b>非省略構文</b>と呼ばれる。多くの場合に共通して、<b>省略構文</b>を用いて経路式をより簡潔に書くことが可能である。この構文については<a href="#abbrev"><b>3.2.4
省略構文</b></a>で説明する。</p>
<ul>
<li>
<p><code>child::para</code>は文脈節点の子である<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::*</code>は文脈節点の子である要素すべてを選択する。</p>
</li>
<li>
<p><code>child::text()</code>は文脈節点の子であるテキスト節点すべてを選択する。</p>
</li>
<li>
<p>
<code>child::node()</code>は、文脈節点の子すべてを選択する。属性節点は返されないことに注意すること。なぜなら属性は子ではないからである。</p>
</li>
<li>
<p><code>attribute::name</code>は文脈節点の<code>name</code>属性を選択する。</p>
</li>
<li>
<p><code>attribute::*</code>は、文脈節点の属性すべてを選択する。</p>
</li>
<li>
<p>
<code>parent::node()</code>は、文脈節点の親を選択する。文脈節点が属性節点であれば、この式はその属性が付けられている要素節点
(もしあれば) を返す。</p>
</li>
<li>
<p>
<code>descendant::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>ancestor::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>ancestor-or-self::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。さらに文脈節点が<code>div</code>要素であれば、文脈節点自身も選択する。</p>
</li>
<li>
<p>
<code>descendant-or-self::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。さらに文脈節点が<code>para</code>要素であれば、文脈節点自身も選択する。</p>
</li>
<li>
<p>
<code>self::para</code>は、文脈節点が<code>para</code>要素である場合は文脈節点自身を選択する。それ以外の場合には空列を返す。</p>
</li>
<li>
<p>
<code>child::chapter/descendant::para</code>は、文脈節点の<code>chapter</code>子要素の子孫の<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>child::*/child::para</code>は、文脈節点の孫の<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/</code>は、文脈節点の含まれる木の根を選択する。ただし、この根が文書節点でなければ動的エラーを発生する。</p>
</li>
<li>
<p>
<code>/descendant::para</code>は、文脈節点と同じ文書中にある<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/descendant::list/child::member</code>は、<code>list</code>要素を親とする<code>member</code>要素で、文脈節点と同じ文書中にあるものすべてを選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
1]</code>は、文脈節点の子のうち最初の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
fn:last()]</code>は、文脈節点の子のうち最後の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
fn:last()-1]</code>は、文脈節点の子のうち最後から2番目の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() &gt;
1]</code>は、文脈要素の子の<code>para</code>要素のうち、1番目以外のものをすべて選択する。</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() =
1]</code>は、文脈要素の弟の<code>chapter</code>のうち、最初に出現するものを選択する。</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() =
1]</code>は、文脈要素の兄の<code>chapter</code>のうち、直前に出現するものを選択する。</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() =
42]</code>は、文脈要素を含む文書中で42番目に出現する<code>figure</code>を選択する。</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() =
2]</code>は、文脈要素を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p>
</li>
<li>
<p><code>child::para[attribute::type eq
"warning"]</code>は、文脈要素の子の<code>para</code>のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p>
</li>
<li>
<p><code>child::para[attribute::type eq 'warning'][fn:position() =
5]</code>は、文脈節点の<code>para</code>子要素で、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの5番目のものを選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type eq
"warning"]</code>は、文脈節点の子のうち5番目の<code>para</code>要素を選択する。ただし、その要素が<code>type</code>属性を持ち、その値が<code>warning</code>である場合に限られる。</p>
</li>
<li>
<p><code>child::chapter[child::title =
'Introduction']</code>は、文脈節点の子の<code>chapter</code>のうち、<a title=
"typed value" href=
"#dt-typed-value">型付けされた値</a>が文字列<code>Introduction</code>に等しいような<code>title</code>子要素を1つ以上持つようなものを選択する。</p>
</li>
<li>
<p>
<code>child::chapter[child::title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1つ以上の<code>title</code>子要素を持つものを選択する。</p>
</li>
<li>
<p><code>child::*[self::chapter or
self::appendix]</code>は、文脈節点の子の<code>chapter</code>と<code>appendix</code>を選択する。</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code>は、文脈節点の子の<code>chapter</code>または<code>appendix</code>のうち、最後のものを選択する。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>3.2.4 省略構文</h4>
<h5><a name="d2e7020" id="d2e7020"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AbbrevForwardStep" id=
"doc-xpath-AbbrevForwardStep"></a>[31]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"@"? <a href=
"#doc-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AbbrevReverseStep" id=
"doc-xpath-AbbrevReverseStep"></a>[34]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>省略構文では、次の省略記法が認められる。</p>
<ol class="enumar">
<li>
<p>
attribute軸<code>attribute::</code>は<code>@</code>と略記できる。例えば、経路式<code>para[@type="warning"]</code>は<code>child::para[attribute::type="warning"]</code>の短縮形であり、<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものを選択する。</p>
</li>
<li>
<p><a title="axis step" href=
"#dt-axis-step">軸ステップ</a>から軸名が省略されると、軸ステップが<a href=
"#doc-xpath-AttributeTest">AttributeTest</a>または <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>
を含まない限り、デフォルトの軸は<code>child</code>になる。AttributeTestを含む場合は、デフォルトの軸は<code>attribute</code>になる。例えば、経路式<code>section/para</code>は<code>child::section/child::para</code>の省略形であり、経路式<code>section/@id</code>は<code>child::section/attribute::id</code>の省略形である。同様に、<code>section/attribute(id)</code>は<code>child::section/attribute::attribute(id)</code>の省略形である。後者の式は軸指定と<a title="node test"
href="#dt-node-test">節点テスト</a>をともに含んでいることに注意せよ。</p>
</li>
<li>
<p>
経路式の処理中、先頭以外に出現する<code>//</code>は<code>/descendant-or-self::node()/</code>に置き換えられる。例えば、<code>div1//para</code>は<code>child::div1/descendant-or-self::node()/child::para</code>の短縮形であり、<code>div1</code>子要素の<code>para</code>子孫要素を選択する。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
経路式<code>//para[1]</code>は、経路式<code>/descendant::para[1]</code>と同じであるということを意味<em>しない</em>。後者は、最初の<code>para</code>子孫要素を選択する。前者は<code>para</code>子孫要素のうち、その親の最初の<code>para</code>子要素であるものをすべて選択する。</p>
</div>
</li>
<li>
<p>
<code>..</code>からなるステップは<code>parent::node()</code>の短縮形である。例えば、<code>../title</code>は<code>parent::node()/child::title</code>の短縮形であり、文脈節点の親の<code>title</code>子要素を選択する。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>式<code>.</code>は、<b>文脈項目式</b>と呼ばれ、<a title="primary expression"
href="#dt-primary-expression">基本式</a>である。これについての説明は<a href=
"#id-context-item-expression"><b>3.1.4 文脈項目式</b></a>にある。</p>
</div>
</li>
</ol>
<p>以下に示すのは、省略構文を用いた経路の例である。</p>
<ul>
<li>
<p><code>para</code>は、文脈節点の<code>para</code>子要素を選択する。</p>
</li>
<li>
<p><code>*</code>は、文脈節点の子要素すべてを選択する。</p>
</li>
<li>
<p><code>text()</code>は、文脈節点の子であるテキスト節点すべてを選択する。</p>
</li>
<li>
<p><code>@name</code>は、文脈節点の<code>name</code>属性を選択する。</p>
</li>
<li>
<p><code>@*</code>は、文脈節点の属性すべてを選択する。</p>
</li>
<li>
<p>
<code>para[1]</code>は、文脈節点の<code>para</code>子要素のうち最初のものを選択する。</p>
</li>
<li>
<p>
<code>para[fn:last()]</code>は、文脈節点の<code>para</code>子要素のうち最後のものを選択する。</p>
</li>
<li>
<p><code>*/para</code>は、文脈節点の<code>para</code>孫要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/book/chapter[5]/section[2]</code>は、文脈節点を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p>
</li>
<li>
<p>
<code>chapter//para</code>は、文脈節点の<code>chapter</code>子要素の子孫である<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>//para</code>は、根である文書節点の子孫の<code>para</code>をすべて選択する。すなわち、文脈節点と同じ文書内にあるすべての<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>//@version</code>は、文脈節点と同じ文書内にあるすべての<code>version</code>属性を選択する。</p>
</li>
<li>
<p>
<code>//list/member</code>は、文脈節点と同じ文書内にある<code>member</code>要素のうち、<code>list</code>を親に持つものをすべて選択する。</p>
</li>
<li>
<p><code>.//para</code>は、文脈節点の子孫の<code>para</code>要素をすべて選択する。</p>
</li>
<li>
<p><code>..</code>は文脈節点の親を選択する。</p>
</li>
<li>
<p><code>../@lang</code>は、文脈節点の親の<code>lang</code>属性を選択する。</p>
</li>
<li>
<p>
<code>para[@type="warning"]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p>
</li>
<li>
<p>
<code>para[@type="warning"][5]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの中から5番目を選択する。</p>
</li>
<li>
<p>
<code>para[5][@type="warning"]</code>は、文脈節点の5番目の<code>para</code>子要素が、<code>type</code>属性を持ち、その値が<code>warning</code>であるなら、それを選択する。</p>
</li>
<li>
<p>
<code>chapter[title="Introduction"]</code>は、文脈節点の<code>chapter</code>子要素のうち、<a title="typed value"
href=
"#dt-typed-value">型付けされた値</a>が文字列<code>Introduction</code>であるような<code>title</code>子要素を1つ以上持つものを選択する。</p>
</li>
<li>
<p>
<code>chapter[title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1個以上の<code>title</code>子要素を持つものを選択する。</p>
</li>
<li>
<p><code>employee[@secretary and
@assistant]</code>は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>属性と<code>assistant</code>属性をともに持つものをすべて選択する。</p>
</li>
<li>
<p>
<code>book/(chapter|appendix)/section</code>は、<code>section</code>要素のうち親が<code>chapter</code>要素か<code>appendix</code>要素のいずれかであり、さらにそれが文脈節点の子の<code>book</code>の子であるようなものを選択する。</p>
</li>
<li>
<p><code>E</code>が節点列を返す式であるとき、式<code>E/.</code>は同じ節点列を<a title=
"document order" href=
"#dt-document-order">文書順</a>で返す。ただし、節点の識別性に基づき重複が除去される。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>3.3 列式</h3>
<p>XPathは<a title="item" href="#dt-item">項目</a>の<a title="sequence"
href=
"#dt-sequence">列</a>を構成したり選別したり結合したりする演算を支援している。列は決して入れ子にならない。例えば、値<code>1</code>,
<code>(2, 3)</code>, <code>( )</code>を結合して1つの列にすると、結果は列<code>(1, 2,
3)</code>になる。</p>
<div class="div3">
<h4><a name="construct_seq" id="construct_seq"></a>3.3.1 列の構成</h4>
<h5><a name="d2e7466" id="d2e7466"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_N12B76.doc-xpath-Expr" id=
"noid_N12B76.doc-xpath-Expr"></a>[2]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-RangeExpr" id=
"doc-xpath-RangeExpr"></a>[11]&nbsp;&nbsp;&nbsp;</td>
<td><code>RangeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> ( "to"
<a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-comma-operator" id="dt-comma-operator" title=
"comma operator">Definition</a>:
列を構成する1つの方法は、<b>コンマ演算子</b>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。]
空の括弧は空列を表すのに用いることができる。</p>
<p>
列は原子値や節点を重複して含んでいてもよいが、列が別の列の項目になることは決してない。2つ以上の入力列を連接して新たな列を生成する場合、新たな列は、入力列の項目すべてを含み、かつその長さは入力列の長さの総和になる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>関数呼び出しの引数など、文法中で<a href=
"#doc-xpath-ExprSingle">ExprSingle</a>が必要とされる場所では、最上位のコンマ演算子を含む式はすべて括弧で囲まなければならない。</p>
</div>
<p>列を構成する式の例をいくつか示す。</p>
<ul>
<li>
<p>この式の結果は、5つの整数の列である。</p>
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</li>
<li>
<p>この式はそれぞれ長さ1, 2, 0, 2である4つの列を結合し、長さ5の1つの列にする。この式の結果は列<code>10, 1,
2, 3, 4</code>になる。</p>
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</li>
<li>
<p>
この式の結果は、文脈節点のすべての<code>salary</code>子節点の後ろにすべての<code>bonus</code>子節点が続くような列である。</p>
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</li>
<li>
<p>
<code>$price</code>が値<code>10.50</code>に束縛されているとすると、この式の結果は列<code>10.50,
10.50</code>である。</p>
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</li>
</ul>
<p>
<b>範囲式</b>は連続した整数の列を構成するのに用いることができる。<code>to</code>演算子の演算数はそれぞれ、期待される引数の型が<code>xs:integer?</code>であるような関数の引数であるかのように、変換される。いずれかの演算数が空列であるか、第1演算数から導出される整数が第2演算数から導出される整数より大きければ、範囲式の結果は空列である。2つの演算数の変換結果が同じ整数になれば、範囲式の結果はその整数である。それ以外の場合は、結果は、2つの整数演算数、および2つの演算数の間の整数すべてからなる列であり、昇順に並べられる。</p>
<ul>
<li>
<p>この例では、列を構成する演算数の1つに範囲式を用いている。これを評価すると列<code>10, 1, 2, 3,
4</code>になる。</p>
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</li>
<li>
<p>この例では、1つの整数<code>10</code>を含む長さ1の列を構成している。</p>
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</li>
<li>
<p>この例の結果は長さ0の列である。</p>
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</li>
<li>
<p>
この例では、<code>fn:reverse</code>を用いて6つの整数の降順列を構成している。これを評価すると列<code>15,
14, 13, 12, 11, 10</code>となる。</p>
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-filter-expr" id="id-filter-expr"></a>3.3.2 選別式</h4>
<h5><a name="d2e7589" id="d2e7589"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-FilterExpr" id=
"doc-xpath-FilterExpr"></a>[38]&nbsp;&nbsp;&nbsp;</td>
<td><code>FilterExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a> <a href=
"#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N12C1D.doc-xpath-PredicateList" id=
"noid_N12C1D.doc-xpath-PredicateList"></a>[39]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-filter-expression" id="dt-filter-expression" title=
"filter expression">Definition</a>:
<b>選別式</b>は、単に、1つの<b>基本式</b>の後ろに0個以上の<a title="predicate" href=
"#dt-predicate">述語</a>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。]
述語が全く指定されなければ、結果は単に基本式の結果である。選別式によって返される項目の順序は、基本式の結果の順序と同じである。項目に割り当てられる文脈位置は、結果の列中の順序位置に基づいて決められる。最初の文脈位置は1である。</p>
<p>選別式の例を以下に示す。</p>
<ul>
<li>
<p>productsの列が変数で与えられているとすると、これらのproductsのうちpriceが100以上のものを返す。</p>
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</li>
<li>
<p>
1から100までの整数のうち5で割り切れるものをすべて列挙する(<code>to</code>演算子についての説明は<a href=
"#construct_seq"><b>3.3.1 列の構成</b></a>を見よ)。</p>
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</li>
<li>
<p>以下の式の結果は整数25である。</p>
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</li>
<li>
<p>以下の例は、変数 <code>$orders</code> に束縛されている列の5番目から9番目までを返す。</p>
<div class="exampleInner">
<pre>
$orders[fn:position() = (5 to 9)]
</pre></div>
</li>
<li>
<p>次に示すのは、選別式を<a title="path expression" href=
"#dt-path-expression">経路式</a>の<a title="step" href=
"#dt-step">ステップ</a>として用いている例である。これは、変数<code>$book</code>に束縛されている本の中からchapterまたはappendixのうち最後のものを返す。</p>
<div class="exampleInner">
<pre>
$book/(chapter | appendix)[fn:last()]
</pre></div>
</li>
<li>
<p>次に示すのも、選別式を<a title="path expression" href=
"#dt-path-expression">経路式</a>の<a title="step" href=
"#dt-step">ステップ</a>として用いている例である。これは、指定された文書中の要素節点のうち、IDの値が<code>tiger</code>であるようなものを返す。</p>
<div class="exampleInner">
<pre>
fn:doc("zoo.xml")/fn:id('tiger')
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="combining_seq" id="combining_seq"></a>3.3.3
節点列の結合</h4>
<h5><a name="d2e7681" id="d2e7681"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-UnionExpr" id=
"doc-xpath-UnionExpr"></a>[14]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"
| "|") <a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IntersectExceptExpr" id=
"doc-xpath-IntersectExceptExpr"></a>[15]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> (
("intersect" | "except") <a href=
"#doc-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XPathでは、節点列を結合する演算として次のようなものを用意している。</p>
<ul>
<li>
<p>
<code>union</code>演算子と<code>|</code>演算子は等価である。これらは2つの節点列を演算数として取り、いずれかの演算数中に出現するすべての節点を含む列を返す。</p>
</li>
<li>
<p>
<code>intersect</code>演算子は2つの節点列を演算数として取り、どちらの演算数にも出現するすべての節点を含む列を返す。</p>
</li>
<li>
<p>
<code>except</code>演算子は2つの節点列を演算数として取り、第1演算数には出現するが第2演算数には出現しない節点をすべて含む列を返す。</p>
</li>
</ul>
<p>これらの演算子はすべて、節点の識別性に基づき結果の列から重複した節点を取り除く。<span class=
"xpath">結果の列は<a title="document order" href=
"#dt-document-order">文書順</a>で返される。</span></p>
<p><code>union</code>, <code>intersect</code>,
<code>except</code>の演算数が節点でない項目を含んでいたならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>以下に、列を結合する式の例をいくつか示す。3つの要素節点が存在すると仮定しよう。これらをA, B,
Cという記号名で参照する。また、変数<code>$seq1</code>, <code>$seq2</code>,
<code>$seq3</code>が、先に挙げた節点からなる以下のような列に束縛されていると仮定する。</p>
<ul>
<li>
<p><code>$seq1</code>は (A, B) に束縛されている</p>
</li>
<li>
<p><code>$seq2</code>は (A, B) に束縛されている</p>
</li>
<li>
<p><code>$seq3</code>は (B, C)に束縛されている</p>
</li>
</ul>
<p>このとき:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code>を評価すると列 (A, B) になる。</p>
</li>
<li>
<p><code>$seq2 union $seq3</code>を評価すると列 (A, B, C) になる。</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code>を評価すると列 (A, B) になる。</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code>を評価すると B のみを含む列になる。</p>
</li>
<li>
<p><code>$seq1 except $seq2</code>を評価すると空列になる。</p>
</li>
<li>
<p><code>$seq2 except $seq3</code>を評価すると A のみを含む列になる。</p>
</li>
</ul>
<p>ここで述べた列に関する演算子に加えて、<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>には、添字を通して項目や列の部分列にアクセスするための関数、添字を通して列中から項目を削除したり列中に項目を挿入するための関数、列から重複した項目を削除するための関数がある。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-arithmetic" id="id-arithmetic"></a>3.4 算術式</h3>
<p>XPathは、加算、減算、乗算、除算、法などの算術演算子を、通常の単項や二項の形で用意している。</p>
<h5><a name="d2e7821" id="d2e7821"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AdditiveExpr" id=
"doc-xpath-AdditiveExpr"></a>[12]&nbsp;&nbsp;&nbsp;</td>
<td><code>AdditiveExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-MultiplicativeExpr" id=
"doc-xpath-MultiplicativeExpr"></a>[13]&nbsp;&nbsp;&nbsp;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-UnaryExpr" id=
"doc-xpath-UnaryExpr"></a>[20]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("-" | "+")* <a href=
"#doc-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ValueExpr" id=
"doc-xpath-ValueExpr"></a>[21]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
</table>
<p>
減算演算子の前には空白を置かなければならない。そうしなければ、直前の字句の一部と解釈されることがある。例えば、<code>a-b</code>は1つの名前と解釈されるが、<code>a
- b</code>や<code>a -b</code>は算術式と解釈される。(空白処理の詳細は<a href=
"#whitespace-rules"><b>A.2.4 空白規則</b></a>を見よ。)</p>
<p>算術式の評価は、まず演算数を評価することから始まる。演算数を評価する順番は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<p class="xpath"><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0
互換モード</a>が<code>true</code>であれば、各演算数は以下のステップを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が演算数に適用される。この操作の結果は<b>原子化済演算数</b>と呼ばれる。</p>
</li>
<li>
<p>
原子化済演算数が空列であれば、算術式の結果は<code>xs:double</code>の値<code>NaN</code>であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p>
</li>
<li>
<p>原子化済演算数が長さ1以上の列であれば、その列の先頭の項目から後ろの項目は捨てられる。</p>
</li>
<li>
<p>この結果、原子化済演算数が<code>xs:boolean</code>型, <code>xs:string</code>型,
<code>xs:decimal</code>型 (<code>xs:integer</code>を含む),
<code>xs:float</code>型,
<code>xs:untypedAtomic</code>型のいずれかのインスタンスになれば、<code>fn:number</code>関数を適用することで<code>xs:double</code>に変換される。(<code>fn:number</code>は、演算数が数に変換できない場合は値<code>NaN</code>を返すことに注意せよ。)</p>
</li>
</ol>
<p><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0
互換モード</a>が<code>false</code>であれば、各</span>演算数は以下のステップを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が演算数に適用される。この操作の結果は<b>原子化済演算数</b>と呼ばれる。</p>
</li>
<li>
<p>
原子化済演算数が空列であれば、算術式の結果は空列であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p>
</li>
<li>
<p>原子化済演算数が長さ1より大きい列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:double</code>に型変換される。型変換に失敗すれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する。 [err:FORG0001]</p>
</li>
</ol>
<p>
演算数の評価の後、演算数の型が与えられた算術演算子について正しい組み合わせであれば、演算子が演算数に適用される。結果は、原子値または<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>となる。
(例えば、0で除算を行った結果はエラーになるかもしれない。)
さまざまな算術演算子に受け入れられる原子型の組み合わせ、算術演算子の結果として期待される型については<a href=
"#mapping"><b>B.2
演算子の写像</b></a>に列挙されている。ここには、それぞれの型の組み合わせに対して演算子の意味を定義する<a title=
"operator function" href=
"#dt-operator-function">演算子関数</a>についても記述がある。演算子関数の定義は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>にある。</p>
<p>演算数の型が、評価の後、与えられた演算子について正しい組み合わせでないならば、<a href="#mapping"><b>B.2
演算子の写像</b></a>のルールに従って、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>
XPathは<code>div</code>と<code>idiv</code>という2種類の除算演算子を支援する。これらの演算子は、2つの演算数として任意の<a title="numeric"
href="#dt-numeric">数</a>型の値を許す。<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>の説明の通り、<code>$arg1 idiv $arg2</code>は<code>($arg1 div
$arg2) cast as xs:integer?</code>と等しい。ただしエラーの場合は除く。</p>
<p>以下に、算術式の例をいくつか示す。</p>
<ul>
<li>
<p>
以下の最初の式は<code>xs:decimal</code>の値<code>-1.5</code>を返し、2番目の式は<code>xs:integer</code>の値<code>-1</code>を返す。</p>
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</li>
<li>
<p>2つの日付値の差の結果は<code>xs:dayTimeDuration</code>型の値になる。</p>
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</li>
<li>
<p>この例は減算演算子とハイフンの違いを示している。</p>
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</li>
<li>
<p>単項演算子は二項演算子より優先度が高い。もちろんこれは、括弧の利用に左右される。従って、次の2つの例は異なる意味となる。</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops"><a href="#XPath">[XPath
1.0]</a>との互換性のため、XPathでは複数の単項算術演算子が連続して出現することが許される。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-comparisons" id="id-comparisons"></a>3.5 比較式</h3>
<p>
比較式は、2つの値を比較することを許す。XPathは、3種類の比較式を用意している。それぞれ、値比較、汎用比較、節点比較という。</p>
<h5><a name="d2e8063" id="d2e8063"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ComparisonExpr" id=
"doc-xpath-ComparisonExpr"></a>[10]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComparisonExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#doc-xpath-ValueComp">ValueComp</a><br />
| <a href="#doc-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xpath-NodeComp">NodeComp</a>) <a href=
"#doc-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ValueComp" id=
"doc-xpath-ValueComp"></a>[23]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-GeneralComp" id=
"doc-xpath-GeneralComp"></a>[22]&nbsp;&nbsp;&nbsp;</td>
<td><code>GeneralComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NodeComp" id=
"doc-xpath-NodeComp"></a>[24]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p class="xpath">
XPath式がXML文書中に書かれる場合は、特殊文字に関するXMLのエスケープルールに従わなければならない。従って、"<code>&lt;</code>"
は "<code>&amp;lt;</code>" と書き換えられなければならない。</p>
</div>
<div class="div3">
<h4><a name="id-value-comparisons" id=
"id-value-comparisons"></a>3.5.1 値比較</h4>
<p>値比較演算子は<code>eq</code>, <code>ne</code>, <code>lt</code>,
<code>le</code>, <code>gt</code>,
<code>ge</code>である。値比較は単一値を比較するのに用いられる。</p>
<p>値比較の評価で最初に行われるのは演算数の評価である。演算数が評価される順番は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。各演算数は以下のステップを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が演算数に対して適用される。この操作の結果は<b>原子化済演算数</b>と呼ばれる。</p>
</li>
<li>
<p>
原子化済演算数が空列であれば、値比較の結果は空列であり、実装は、他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p>
</li>
<li>
<p>原子化済演算数が長さ1より大きい列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:string</code>に型変換される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
このルールの目的は、値比較を推移的にするためである。利用者は、汎用比較演算子は<code>xs:untypedAtomic</code>演算数に関する別の型変換ルールを持っていることに気づくべきである。また利用者は、型変換での正確さを犠牲にすることで、値比較の推移性が妥協されてもよいということにも気づくべきである
(例えば、ほんの少し異なる2つの<code>xs:integer</code>の値は、<code>xs:float</code>が<code>xs:interger</code>よりも正確さに欠けるために、同じ<code>xs:float</code>の値だとみなされてもよい)。</p>
</div>
</li>
</ol>
<p>次に、可能ならば、<a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>や<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>によって2つの演算数がそれらの最小共通型に変換される。例えば、演算数が
<code>hatsize</code> 型 (<code>xs:integer</code> から導出される) と
<code>shoesize</code> 型 (<code>xs:float</code> から導出される)
であれば、それらの最小共通型は <code>xs:float</code> である。</p>
<p>
最後に、演算数の型が与えられた演算子について正しい組み合わせであれば、演算子が演算数に対して適用される。さまざまな値比較演算子について、認められる原子型の組み合わせや、その演算子の結果として期待される型は<a href="#mapping"><b>B.2
演算子の写像</b></a>にある。ここではまた<a title="operator function" href=
"#dt-operator-function">演算子関数</a>についても記述されている。これは、型の組み合わせそれぞれに対して演算子の意味を定義するものである。演算子関数の定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>にある。</p>
<p>
直観的には、2つの原子化済演算数がともにまったく1つの原子値からなっているならば、比較の結果は次のようになる。もし第1演算数の値が第2演算数の値
(に等しい, に等しくない, より小さい, より小さいか等しい, より大きい, より大きいか等しい)
ならば、結果は<code>true</code>である。それ以外の場合には、比較の結果は<code>false</code>である。</p>
<p>演算数を評価した後、その演算数の型が与えられた演算数について正しくない組み合わせであれば、<a href=
"#mapping"><b>B.2 演算子の写像</b></a>のルールに従って、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>以下に、値比較の例をいくつか示す。</p>
<ul>
<li>
<p>
次の比較は、式<code>$book/author</code>によって返される節点を原子化する。比較が真になるのは、原子化の結果が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての値
"Kennedy"
である場合だけである。原子化の結果が空列であれば、比較の結果は空列になる。原子化の結果が2個以上の値を含む列であれば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</li>
<li>
<p>次の<a title="path expression" href=
"#dt-path-expression">経路式</a>は、重さが100以上の製品を選択する述語を含む。<code>weight</code>部分要素を持たない製品については、この述語の値は空列であり、その製品は選択されない。この例では、<code>weight</code>
は検証された要素であり、数型であると仮定している。</p>
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</li>
<li>
<p>
次の比較が真になるのは、<code>my:hatsize</code>と<code>my:shoesize</code>がともに、原子型<a title="numeric"
href="#dt-numeric">numeric</a>から制限によって導出されるユーザ定義型である場合である。</p>
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</li>
<li>
<p>以下の比較は true である。<code>eq</code> は2つの QName について、それらの名前空間 URI
と局所名をコード位置により比較を行うことにより、比較する。名前空間接頭辞は無視する。</p>
<div class="exampleInner">
<pre>
fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-general-comparisons" id=
"id-general-comparisons"></a>3.5.2 汎用比較</h4>
<p>汎用比較演算子は<code>=</code>, <code>!=</code>, <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>である。汎用比較は存在限量比較であり、任意の長さの列の演算数に適用してもよい。汎用比較の結果は、エラーが発生しないときは常に<code>true</code>か<code>false</code>である。</p>
<p class="xpath"><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、汎用比較は以下のルールを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p>
どちらかの演算数が単一の原子値かつ<code>xs:boolean</code>のインスタンスであれば、もう一方の演算数は、その<a title="effective boolean value"
href="#dt-ebv">有効ブール値</a>を取ることにより<code>xs:boolean</code>に変換される。</p>
</li>
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>がそれぞれの演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p>
</li>
<li>
<p>比較演算子が<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>であれば、両演算数の列中の各項目が、<code>fn:number</code>関数を適用することにより、<code>xs:double</code>に変換される。
(<code>fn:number</code>は、演算数が数に変換できない場合は値<code>NaN</code>を返すことに注意せよ。)</p>
</li>
<li>
<p>
比較の結果は次のようになる。原子値の組で、一方が第1演算数の列、もう一方が第2演算数の列であり、要求される<b>大小関係</b>を持っているものがあれば、結果は<code>true</code>である。そうでなければ、比較の結果は<code>false</code>である。2つの原子値間の<b>大小関係</b>は以下のルールを適用することで決定される。これらのルールから呼び出した<code>cast</code>演算子が成功しなければ、動的エラーが発生する。
[err:FORG0001]</p>
<ol class="enumla">
<li>
<p>2つの原子値のうち少なくとも一方が<a title="numeric" href=
"#dt-numeric">数</a>型のインスタンスであれば、原子値はともに、<code>fn:number</code>関数を適用することにより、<code>xs:double</code>型に変換される。</p>
</li>
<li>
<p>
2つの原子値のうち少なくとも一方が<code>xs:string</code>のインスタンスであるか、原子値がともに<code>xs:untypedAtomic</code>のインスタンスであれば、原子値はともに<code>xs:string</code>型に型変換される。</p>
</li>
<li>
<p>
原子値の一方が<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>,
<code>xs:untypedAtomic</code>, あるいはどの<a title="numeric" href=
"#dt-numeric">数</a>型のいずれでもなければ、<code>xs:untypedAtomic</code>の値が、もう一方の値の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>に型変換される。</p>
</li>
<li>
<p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>,
<code>lt</code>, <code>le</code>, <code>gt</code>,
<code>ge</code>のいずれか一つを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>,
<code>&gt;=</code>のどれであったかに依存する。値が要求された<b>大小関係</b>を持っているのは、この値比較の結果が<code>true</code>であるとき、かつそのときに限る。</p>
</li>
</ol>
</li>
</ol>
<p><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>false</code>のとき、</span>汎用比較は以下のルールを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が各演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p>
</li>
<li>
<p>
比較の結果が<code>true</code>になるのは、原子値の組が存在し、その1つは第1演算数の列、もう一方が第2演算数の列であり、それらが要求された<b>大小関係</b>を持っているとき、かつその時に限る。それ以外の場合には、比較の結果は<code>false</code>になる。2つの原子値間の<b>大小関係</b>は、以下のルールを順に適用することで決定される。これらのルールによって呼び出される<code>cast</code>演算子が成功しなければ、動的エラーが発生する。
[err:FORG0001]</p>
<ol class="enumla">
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<a title="numeric"
href=
"#dt-numeric">数</a>型のインスタンスであれば、<code>xs:untypedAtomic</code>の値が<code>xs:double</code>型に型変換される。</p>
</li>
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:untypedAtomic</code>または<code>xs:string</code>のインスタんであれば、<code>xs:untypedAtomic</code>の値
(または両方) が<code>xs:string</code>型に型変換される。</p>
</li>
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>,
<code>xs:untypedAtomic</code>, または任意の<a title="numeric" href=
"#dt-numeric">数</a>型のどれでもなければ、<code>xs:untypedAtomic</code>の値がもう一方の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>に型変換される。</p>
</li>
<li>
<p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>,
<code>lt</code>, <code>le</code>, <code>gt</code>,
<code>ge</code>のいずれかを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>,
<code>&gt;=</code>のどれであったかに依存する。値が、要求される<b>大小関係</b>を持つのは、この値比較の結果が<code>true</code>である場合、かつその時に限る。</p>
</li>
</ol>
</li>
</ol>
<p>
いずれかの演算数が項目の列である汎用比較を評価するとき、実装は、第1演算数と第2演算数から、要求される<b>大小関係</b>を持つ項目を1つずつ見つけると直ちに<code>true</code>を返してもよい。同様に、汎用比較は、いずれかの演算数を評価しているときや2つの演算数から選んだ項目の組を比較するときにエラーが生じれば、直ちに<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。これらのルールの結果として、エラーが存在するときには、汎用比較の結果は決定的ではない。</p>
<p>以下に、汎用比較の例をいくつか示す。</p>
<ul>
<li>
<p>
以下の比較は、<code>$book1</code>の任意の部分要素<code>author</code>について、その<a title="typed value"
href=
"#dt-typed-value">型付けされた値</a>が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての
"Kennedy" であるとき、trueになる。</p>
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</li>
<li>
<p>
以下の例は3つの汎用比較を含む。初めの2つの比較の値は<code>true</code>であり、3つ目の比較の値は<code>false</code>である。この例は、汎用比較は推移的ではないという事実を示している。</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>
以下の例は2つの汎用比較を含む。これらはいずれも<code>true</code>である。この例は、<code>=</code>と<code>!=</code>は互いに逆ではないという事実を示している。</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p><code>$a</code>, <code>$b</code>,
<code>$c</code>がそれぞれ、型注釈<code>xs:untypedAtomic</code>を持ち、<a title=
"string value" href="#dt-string-value">文字列値</a> "<code>1</code>",
"<code>2</code>"、および"<code>2.0</code>" を持つ要素節点に束縛されているとする。このとき
<code>($a, $b) = ($c,
3.0)</code>は<code>false</code>を返す。なぜなら<code>$b</code>と<code>$c</code>は文字列として比較されるためである。しかし<code>($a,
$b) = ($c,
2.0)</code>は<code>true</code>を返す。なぜなら<code>$b</code>と<code>2.0</code>は数として比較されるためである。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-node-comparisons" id=
"id-node-comparisons"></a>3.5.3 節点比較</h4>
<p>節点比較は、2つの節点を識別性または<a title="document order" href=
"#dt-document-order">文書順</a>に基づいて比較するのに用いられる。節点比較の結果は以下のルールにより定義される。</p>
<ol class="enumar">
<li>
<p>節点比較の演算数が<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順で評価される。</p>
</li>
<li>
<p>各演算数は単一の節点か空列でなければならない。そうでない場合は<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
いずれかの演算数が空列であれば、比較の結果は空列であり、実装は他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p>
</li>
<li>
<p>
<code>is</code>演算子による比較が<code>true</code>を返すのは、2つの演算数が同じ識別性を持っており、したがって同じ節点である場合である。そうでない場合は<code>false</code>を返す。節点の識別性の定義は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>を見よ。</p>
</li>
<li>
<p>
<code>&lt;&lt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<a title="document order"
href=
"#dt-document-order">文書順</a>で前にある場合である。そうでない場合は<code>false</code>を返す。</p>
</li>
<li>
<p>
<code>&gt;&gt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<a title="document order"
href=
"#dt-document-order">文書順</a>で後ろにある場合である。そうでない場合は<code>false</code>を返す。</p>
</li>
</ol>
<p>以下に、節点比較の例をいくつか示す。</p>
<ul>
<li>
<p>次の比較が真になるのは、左辺と右辺を評価した結果がそれぞれ完全に同じ単一節点になる場合のみである。</p>
<div class="exampleInner">
<pre>
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</pre></div>
</li>
<li>
<p>
次の比較が真になるのは、左辺によって識別される節点が、右辺によって識別される節点よりも文書順で前に出現する場合のみである。</p>
<div class="exampleInner">
<pre>
/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>3.6 論理式</h3>
<p>
<b>論理式</b>は<b>and式</b>か<b>or式</b>のいずれかである。ある論理式がエラーを発生しない場合、結果は常にブール値<code>true</code>か<code>false</code>のいずれかである。</p>
<h5><a name="d2e8823" id="d2e8823"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-OrExpr" id=
"doc-xpath-OrExpr"></a>[8]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#doc-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AndExpr" id=
"doc-xpath-AndExpr"></a>[9]&nbsp;&nbsp;&nbsp;</td>
<td><code>AndExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> (
"and" <a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p>論理式の評価は、まず各演算数の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を見つけることから始まる (<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>を見よ)。</p>
<p>and式の値は、演算数の有効ブール値 (EBV) により、次の表のように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>EBV<sub>2</sub>でエラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>エラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、<code>false</code>。そうでない場合は<code>false</code>かエラー。</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub>でエラー</td>
<td>エラー</td>
<td><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、エラー。そうでない場合は<code>false</code>かエラー</span></td>
<td>エラー</td>
</tr>
</tbody>
</table>
<p>or式の値は、演算数の有効ブール値 (EBV) により、次の表にあるように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>EBV<sub>2</sub>でエラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、<code>true</code>。そうでない場合は<code>true</code>かエラー</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>エラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub>でエラー</td>
<td><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、エラー。そうでない場合は<code>true</code>かエラー。</span></td>
<td>エラー</td>
<td>エラー</td>
</tr>
</tbody>
</table>
<p class="xpath"><a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>true</code>であれば、論理式の演算数を評価する順番が事実上決定される。特に、結果を決定するのに第2演算数を評価する必要がないとき、第2演算数を評価した結果エラーが発生する必要はない。</p>
<p><span class="xpath"><a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>が<code>false</code>であれば、論理式の演算数を評価する順番は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。この場合、</span>or-式は、1番目の式を評価するとtrueになれば、<code>true</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。同様に、and式は、1番目の式を評価するとfalseになれば、<code>false</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。これらのルールの結果として、論理式は、エラーが存在する場合、非決定的である。その例を以下に示す。</p>
<p>以下に、論理式の例をいくつか示す。</p>
<ul>
<li>
<p>次の式は<code>true</code>を返す。</p>
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</li>
<li>
<p>次の式は<code>false</code>を返すか<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する <span class="xpath">(<a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 互換モード</a>では、結果は<code>false</code>でなければならない)</span>。</p>
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>次の式は<code>true</code>を返すか<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する <span class="xpath">(<a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0互換モード</a>では、結果は<code>true</code>でなければならない)</span>。</p>
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>次の式は<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生しなければならない。</p>
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</li>
</ul>
<p>
and式、or式に加え、XPathは<code>fn:not</code>という関数を用意している。これは引数として一般の列をとり、ブール値を返す。<code>fn:not</code>関数の定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。<code>fn:not</code>関数は、引数を<a title=
"effective boolean value" href=
"#dt-ebv">有効ブール値</a>に縮退する。そして、引数の有効ブール値が<code>false</code>であれば<code>true</code>を返し、引数の有効ブール値が<code>true</code>であれば<code>false</code>を返す。引数の有効ブール値を求める際にエラーが起これば、<code>fn:not</code>は同じエラーを発生する。</p>
</div>
<div class="div2">
<h3><a name="id-for-expressions" id="id-for-expressions"></a>3.7
For式</h3>
<p>XPathは<b>for式</b>と呼ばれる繰り返し機能を用意している。</p>
<h5><a name="d2e9159" id="d2e9159"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForExpr" id=
"doc-xpath-ForExpr"></a>[4]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a>
"return" <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SimpleForClause" id=
"doc-xpath-SimpleForClause"></a>[5]&nbsp;&nbsp;&nbsp;</td>
<td><code>SimpleForClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"for" "$" <a href="#doc-xpath-VarName">VarName</a> "in"
<a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
</table>
<p><code>for</code>式は以下のように評価される。</p>
<ol class="enumar">
<li>
<p>
<code>for</code>式が複数の変数を用いていれば、まず、入れ子の<code>for</code>式の集合に展開される。これらはそれぞれ、ただ1つの変数しか用いない。例えば、式
<code>for $x in X, $y in Y return $x + $y</code> は <code>for $x in
X return for $y in Y return $x + $y</code>と展開される。</p>
</li>
<li>
<p>
1つの変数を用いる<code>for</code>式では、その変数を<b>範囲変数</b>、キーワード<code>in</code>に続く式の値を<b>束縛列</b>、キーワード<code>return</code>に続く式の値を<b>return式</b>という。<code>for</code>式の結果は、束縛列中の項目それぞれに対し<code>return</code>式を1回評価することで得られる。このとき範囲変数は束縛列中のその項目に束縛される。結果の列は、それが導出された束縛列中の項目の順に
(<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>を用いたように) 連接される。</p>
</li>
</ol>
<p class="xpath">
次に示すのは、<code>for</code>式を入力文書の再構成に用いた例である。この例では、以下の入力を基にしている。</p>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>
以下の例では、この入力文書を、各著者の名前が1回ずつ出現し、その著者による本の題目のリストが続くようなリストに変換する。この例では、文脈項目が入力文書中の<code>bib</code>要素であると仮定している。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $a in fn:distinct-values(book/author)
return (book/author[. = $a][1], book[author = $a]/title)</span>
</pre></div>
<p>
上の式の結果は以下のような要素の列からなる。与えられた著者による本の題目が、その著者の名前に続いている。結果中の<code>author</code>要素の順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>であり、<code>fn:distinct-values</code>関数の意味に依存している。</p>
<div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre></div>
<p>次に示すのは、1つ以上の変数を含む<code>for</code>式の例である。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span>
</pre></div>
<p>上の式の結果は数の列として表現され、以下の通りである: <code>11, 12, 21, 22</code></p>
<p>
<code>for</code>式中で束縛された変数の有効範囲は、<code>for</code>式の部分式のうち変数の束縛より後ろに出現するものすべてから構成される。有効範囲には、その変数が束縛される式は含まれない。以下に示すのは、変数束縛が、同じ<code>for</code>式中でそれより前に束縛された別の変数を参照してもよいという例である。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span>
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<code>for</code>式の<code>return</code>節の評価のための焦点は、その<code>for</code>式の評価のための焦点そのものに等しい。次の例では、order-item
の集合の合計値を求めようとしているのだが、先に述べたような理由で誤りである。</p>
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return @price * @qty)
</pre></div>
<p>代わりに、この式は、<code>for</code>節の中で束縛される変数を用いて書かれなければならない。</p>
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-conditionals" id="id-conditionals"></a>3.8 条件式</h3>
<p>XPathはキーワード<code>if</code>, <code>then</code>,
<code>else</code>に基づく条件式を支援する。</p>
<h5><a name="d2e9323" id="d2e9323"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IfExpr" id=
"doc-xpath-IfExpr"></a>[7]&nbsp;&nbsp;&nbsp;</td>
<td><code>IfExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"if" "(" <a href="#doc-xpath-Expr">Expr</a> ")" "then"
<a href="#doc-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>
キーワード<code>if</code>に続く式を<b>テスト式</b>という。またキーワード<code>then</code>や<code>else</code>に続く式をそれぞれ<b>then式</b>、<b>else式</b>という。</p>
<p>条件式を処理する最初の段階は、テスト式の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を求めることである。これは<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>に定義されている通りである。</p>
<p>条件式の値は以下のように定義される:
テスト式の有効ブール値が<code>true</code>であれば、then式の値が返される。テスト式の有効ブール値が<code>false</code>であれば、else式の値が返される。</p>
<p>条件式には、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>の伝搬に関する特別なルールがある。テスト式の有効値が<code>true</code>であれば、条件式は、else式から起こる動的エラーをすべて無視する
(発生させない)。この場合、else式は観測可能な作用を持たなくてもよいため、評価される必要はない。同様に、テスト式の有効値が<code>false</code>であれば、条件式は、then式から起こる<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>をすべて無視し、then式は評価される必要はない。</p>
<p>以下に、条件式の例をいくつか示す。</p>
<ul>
<li>
<p>この例では、テスト式は比較式である。</p>
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre></div>
</li>
<li>
<p>
この例では、テスト式は<code>discounted</code>という属性の有無を調べている。その属性の値には依存しない。</p>
<div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>3.9 限量式</h3>
<p>
限量式は存在限量子と全称限量子を支援する。限量式の値は常に<code>true</code>か<code>false</code>である。</p>
<h5><a name="d2e9414" id="d2e9414"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-QuantifiedExpr" id=
"doc-xpath-QuantifiedExpr"></a>[6]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuantifiedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>
<b>限量式</b>は<b>限量子</b>で始まる。これはキーワード<code>some</code>か<code>every</code>である。これに1つ以上のin節が続き、変数を束縛するのに用いられる。さらにキーワード<code>satisfies</code>とテスト式が続く。各in節は、項目の列を返す式に変数を関連づける。この列のことを、その変数に対する<b>束縛列</b>という。in節は変数束縛の組を生成する。これには、それぞれの変数に対する束縛列中の項目の組み合わせ各々に対応する組が含まれる。概念的には、テスト式は、変数束縛の組それぞれについて評価される。結果はテスト式の<a title="effective boolean value"
href="#dt-ebv">有効ブール値</a>に依存する。これは<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>で定義されている通りである。限量式の値は以下のルールによって定義される。</p>
<ol class="enumar">
<li>
<p>限量子が<code>some</code>であれば、限量式は、テスト式の評価のうち少なくとも1つが<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>
<code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>false</code>であることが分かる。</p>
</li>
<li>
<p>限量子が<code>every</code>であれば、限量式は、テスト式の評価がすべて<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>
<code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>true</code>であることが分かる。</p>
</li>
</ol>
<p>
限量式中で束縛された変数の有効範囲は、その限量式の部分式のうちその変数束縛の後ろで出現したものすべてから構成される。有効範囲にはその変数が束縛される式は含まれない。</p>
<p>テスト式がさまざまな変数束縛組に対して評価される順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>である。限量子が<code>some</code>であれば、実装は、テスト式が<code>true</code>という<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>を持つ束縛組を1つ見つけたら直ちに<code>true</code>を返してもよい。また、テスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。同様に、限量式が<code>every</code>であれば、実装は、テスト式が<code>false</code>という<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>を持つ束縛組を1つ見つけたら直ちに<code>false</code>を返してよい。またテスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。これらのルールの結果として、以下の例で示すように、限量式の値は、エラーが存在する場合には決定的ではない。</p>
<p>以下に、限量式の例をいくつか示す。</p>
<ul>
<li>
<p>この式は、すべての<code>part</code>要素が<code>discounted</code>属性を持つならば
(これらの属性の値に関わらず)、<code>true</code>である。</p>
<div class="exampleInner">
<pre>
every $part in /parts/part satisfies $part/@discounted
</pre></div>
</li>
<li>
<p>
この式は、少なくとも1つの<code>employee</code>要素が与えられた比較式を満たすならば<code>true</code>である。</p>
<div class="exampleInner">
<pre>
some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</li>
<li>
<p>以下の例では、各限量式がテスト式を9つの変数束縛の組上で評価する。9つの変数束縛とは、列<code>(1, 2,
3)</code>と<code>(2, 3,
4)</code>の直積から構成される。<code>some</code>で始まる式を評価すると<code>true</code>であり、<code>every</code>で始まる式を評価すると<code>false</code>である。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span>
</pre></div>
<div class="exampleInner">
<pre>
<span class="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span>
</pre></div>
</li>
<li>
<p>この限量式は<code>true</code>を返すか、<a title="type error" href=
"#dt-type-error">型エラー</a>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>true</code>を返し、別の変数束縛に対して<a title="type error"
href="#dt-type-error">型エラー</a>を発生するからである。</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>この限量式は<code>false</code>を返すか<a title="type error" href=
"#dt-type-error">型エラー</a>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>false</code>を返し、別の変数束縛に対して<a title="type error"
href="#dt-type-error">型エラー</a>を発生するからである。</p>
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-expressions-on-datatypes" id=
"id-expressions-on-datatypes"></a>3.10 SequenceTypes上の式</h3>
<p><a title="sequence type" href=
"#dt-sequence-type">列型</a>は<code>instance of</code>式,
<code>cast</code>式, <code>castable</code>式,
<code>treat</code>式で使われている。</p>
<div class="div3">
<h4><a name="id-instance-of" id="id-instance-of"></a>3.10.1
Instance Of</h4>
<h5><a name="d2e9650" id="d2e9650"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-InstanceofExpr" id=
"doc-xpath-InstanceofExpr"></a>[16]&nbsp;&nbsp;&nbsp;</td>
<td><code>InstanceofExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a> ( "instance"
"of" <a href="#doc-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>ブール演算子<code>instance of</code>は、第1演算数の値が第2演算数の<a href=
"#doc-xpath-SequenceType">SequenceType</a>に照合されるとき、<code>true</code>を返す。これは<a title="SequenceType matching"
href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>にあるルールに従う。そうでない場合は<code>false</code>を返す。例えば:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が与えられた型のインスタンスであるからである。</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>
この例は<code>true</code>を返す。なぜなら与えられた値が整数リテラルで、<code>xs:integer</code>が制限によって<code>xs:decimal</code>から導出されるからである。</p>
</li>
<li>
<p><code>(5, 6) instance of xs:integer+</code></p>
<p>
この例は<code>true</code>を返す。なぜなら与えられた列は2つの整数を含んでおり、指定された型の正しいインスタンスであるからである。</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>
文脈項目が要素節点のとき、この例は<code>true</code>を返す。文脈項目が定義されているが要素節点ではないとき、この例は<code>false</code>を返す。文脈項目が未定義であれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0002"
href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-cast" id="id-cast"></a>3.10.2 Cast</h4>
<h5><a name="d2e9733" id="d2e9733"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CastExpr" id=
"doc-xpath-CastExpr"></a>[19]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SingleType" id=
"doc-xpath-SingleType"></a>[49]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>
場合によっては、値を指定されたデータ型に変換する必要が生じる。この目的のため、XPathは<code>cast</code>式を用意している。これは、すでにある値に基づき、指定された型の値を新たに生成する。<code>cast</code>式は2つの演算数を取る。<b>入力式</b>と<b>目的型</b>である。入力式の型を<b>入力型</b>という。目的型は原子型で、<a title="in-scope schema type"
href=
"#dt-is-types">有効範囲内スキーマ型</a>に含まれており、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また原子型の後ろに出現標識
"<code>?</code>" を置き、空列を許すということを示してもよい [<a title="err:XPST0080"
href=
"#ERRXPST0080">err:XPST0080</a>]。目的型が名前空間接頭辞を持たないならば、その目的型は<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>に属するとみなされる。<code>cast</code>式の意味は以下の通りである。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が入力式に対して行われる。</p>
</li>
<li>
<p>原子化の結果が長さ1より大きい原子値の列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>原子化の結果が空列であれば:</p>
<ol class="enumla">
<li>
<p>目的型の後ろに<code>?</code>が指定してあれば、<code>cast</code>式の結果は空列である。</p>
</li>
<li>
<p>目的型の後ろに<code>?</code>が指定してなければ、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
</ol>
</li>
<li>
<p>
原子化の結果が単一の原子値であれば、cast式の結果は入力型と目的型に依存する。一般的に、cast式は、入力値に基づき目的型の値を新たに生成しようと試みる。ある種の入力型と目的型の組み合わせだけが支援されている。このルールの概要を以下に列挙する。これらのルールの規範的定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。これらのルールの目的のため、実装は、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>を検査したり、あるいはその代替としてデータ辞書のような<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構を用いて、ある型が別の型から制限によって導出されると決定してもよい。</p>
<ol class="enumla">
<li>
<p><code>cast</code>は、<a href=
"http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1
Casting from primitive types to primitive types</a><sup xmlns=
""><small>FO</small></sup>に列挙されている入力型と目的型の組み合わせに対して支援される。これらの組み合わせそれぞれについて、入力型と目的型は基本<a title="schema type"
href=
"#dt-schema-type">スキーマ型</a>である。例えば、<code>xs:string</code>型の値はスキーマ型<code>xs:decimal</code>に型変換することができる。これらの組み込みの組み合わせについては、型変換の意味が<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で指定されている。</p>
<p>
<code>cast</code>式の目的型が<code>xs:QName</code>であるか、<code>xs:QName</code>または<code>xs:NOTATION</code>から導出される型であるか、入力の基礎型が目的型の基礎型と等しくないならば、入力式は文字列リテラルでなければならない
[<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
このルールの理由は、これらの目的型の1つのインスタンスを文字列から構成するには名前空間の束縛に関する知識が必要になる、ということである。入力式がリテラルでない文字列であれば、名前空間の束縛が<a title="statically known namespaces"
href="#dt-static-namespaces">静的既知名前空間</a>と異なる入力文書から導出されるかもしれない。</p>
</div>
</li>
<li>
<p>
<code>cast</code>は、入力型が基本でない原子型で、目的型から制限によって導出される場合に支援される。この場合、入力値は目的型の値空間に写像され、その型以外には変更されない。例えば、<code>shoesize</code>が制限によって<code>xs:integer</code>から導出されるならば、型<code>shoesize</code>の値はスキーマ型<code>xs:integer</code>に型変換することができる。</p>
</li>
<li>
<p>
<code>cast</code>は、目的型が基本でない原子型で、入力型が<code>xs:string</code>または<code>xs:untypedAtomic</code>である場合に支援される。入力値はまず、目的型に対する空白の正規化ルールを適用する（<a href="#XMLSchema">[XML
Schema]</a>で定義されているように）ことで、目的型の字句空間中の値に変換される。結果の字句値が目的型のパターンの相
(facet) を満たさないならば、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a> [err:FORG0001]
が発生する。次に字句値は、目的型のスキーマ定義ルールを用いて、目的型の値空間に変換される。結果の値が目的型のすべての相を満たさないならば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a> [err:FORG0001] が発生する。</p>
</li>
<li>
<p>
<code>cast</code>は、目的型が基本型でない原子型であり、かつ入力型から制限によって導出されるならば、支援される。入力値は目的型のすべての相を満たさなければならない
(パターンの相の場合には、これは、<code>xs:string</code>への型変換ルールを用いて、入力値の文字列表現を生成することで検査される)。結果の値は入力値と等しい。ただし<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>は異なる。</p>
</li>
<li>
<p>基本型 P1 が基本型 P2 に型変換されるならば、制限によって P1 から導出される任意の型は、制限によって P2
から導出される任意の型に型変換できる。そして、目的型の相が満たされると規定される。まず、上のルール (b) を用いて、入力値が P1
に型変換される。次に、上のルール (a) を用いて、P1 型の値が P2 型に変換される。最後に、上のルール (d) を用いて、P2
型の値が目的型に変換される。</p>
</li>
<li>
<p>上に列挙されていない入力型と目的型の組み合わせに対して、<code>cast</code>式は<a title=
"type error" href="#dt-type-error">型エラー</a> [<a title=
"err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]を発生する。</p>
</li>
</ol>
</li>
</ol>
<p>
入力型から目的型への型変換が支援されているが、にもかかわらず入力値を目的型の値空間に型変換することが不可能であれば、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する。
[err:FORG0001] これは、目的型のどの相も満たされない場合を含む。例えば、式<code>"2003-02-31" cast
as xs:date</code>は<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。</p>
</div>
<div class="div3">
<h4><a name="id-castable" id="id-castable"></a>3.10.3 Castable</h4>
<h5><a name="d2e9953" id="d2e9953"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CastableExpr" id=
"doc-xpath-CastableExpr"></a>[18]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastableExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N1495E.doc-xpath-SingleType" id=
"noid_N1495E.doc-xpath-SingleType"></a>[49]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>XPathは、与えられた値が与えられた目的型に型変換可能かテストする式を用意している。目的型は原子型で、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>に含まれていなければならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また、空列を許すことを示すために出現標識
"<code>?</code>" を後ろに付けることができる [<a title="err:XPST0080" href=
"#ERRXPST0080">err:XPST0080</a>]。式<code>V castable as
T</code>が<code>true</code>を返すのは、<code>cast</code>式を用いて値<code>V</code>が目的型<code>T</code>に型変換することに成功する場合である。そうでない場合は<code>false</code>を返す。<code>castable</code>式を<a title="predicate"
href=
"#dt-predicate">述語</a>として用い、評価時のエラーを避けることも可能である。また、適切な型を選択して与えられた値を処理することにも利用できる。以下に例を示す。</p>
<div class="exampleInner">
<pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</pre></div>
</div>
<div class="div3">
<h4><a name="id-constructor-functions" id=
"id-constructor-functions"></a>3.10.4 構成子関数</h4>
<p><a title="in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中の原子型それぞれについて
(<code>xs:NOTATION</code>および<code>xs:anyAtomicType</code>を除く。これらはインスタンスを生成できない)、<b>構成子関数</b>が暗黙的に定義される。それぞれの場合について、構成子関数の名前は目的型の名前
(名前空間を含む)と同じである。型<em>T</em>の構成子関数のシグネチャは以下の通りである。</p>
<div class="exampleInner">
<pre>
<em>T</em>($arg as xs:anyAtomicType?) as <em>T?</em>
</pre></div>
<p>[<a name="dt-constructor-function" id="dt-constructor-function"
title="constructor function">Definition</a>:
与えられた型に対する<b>構成子関数</b>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数
<code>T($arg)</code>の意味は式<code>($arg cast as
T?)</code>と同じであると定義される。]</p>
<p>
<code>xs:QName</code>、あるいは<code>xs:QName</code>や<code>xs:NOTATION</code>から導出される型に対する構成子関数では、文字列リテラルの引数か、目的型の基礎型と同じ基礎型を持つ引数を要求する。そうでない場合は型エラー
[<a title="err:XPST0004" href="#ERRXPST0004">err:XPST0004</a>]
が発生する。このルールは、<a href="#id-cast"><b>3.10.2
Cast</b></a>に定義されているこれらの型に対する<code>cast</code>式の意味と一貫している。</p>
<p>構成子関数の使い方を以下の例で示す。</p>
<ul>
<li>
<p>この例は<code>("2000-01-01" cast as xs:date?)</code>に等しい。</p>
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</li>
<li>
<p>この例は<code>(($floatvalue * 0.2E-5) cast as
xs:decimal?)</code>に等しい。</p>
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</li>
<li>
<p>
この例は、21日に等しい<code>xs:dayTimeDuration</code>の値を返す。これは<code>("P21D"
cast as xs:dayTimeDuration?)</code>と同値である。</p>
<div class="exampleInner">
<pre>
xs:dayTimeDuration("P21D")
</pre></div>
</li>
<li>
<p><code>usa:zipcode</code>がユーザ定義の原子型であり<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中にあるならば、以下の式は、式<code>("12345" cast as
usa:zipcode?)</code>と同値である。</p>
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>名前空間中にない原子型のインスタンスは、以下のいずれかの方法で構成することができる。</p>
<ul>
<li>
<p>もし<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>が "none"
であれば、<code>cast</code>式を用いる。</p>
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</li>
<li>
<p>もし<a title="default function namespace" href=
"#dt-def-fn-ns">デフォルト関数名前空間</a>が "none" であれば、構成子関数を用いる。</p>
<div class="exampleInner">
<pre>
apple(17)
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-treat" id="id-treat"></a>3.10.5 Treat</h4>
<h5><a name="d2e10138" id="d2e10138"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TreatExpr" id=
"doc-xpath-TreatExpr"></a>[17]&nbsp;&nbsp;&nbsp;</td>
<td><code>TreatExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>XPathは<code>treat</code>と呼ばれる式を用意している。これは、演算数の<a title=
"static type" href="#dt-static-type">静的型</a>を変更するのに用いることができる。</p>
<p><code>cast</code>のように、<code>treat</code>式は2つの演算数をとる。式と<a href=
"#doc-xpath-SequenceType">SequenceType</a>である。しかし、<code>cast</code>とは異なり、<code>treat</code>はその演算数の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>や値は変更しない。そのかわり、<code>treat</code>の目的は、式が評価時に期待される動的型を持つことを保証することである。</p>
<p><em><code>expr1</code></em> <code>treat as</code>
<em><code>type1</code></em>の意味は以下の通りである。</p>
<ul>
<li>
<p>静的解析時:</p>
<p><code>treat</code>式の<a title="static type" href=
"#dt-static-type">静的型</a>は<em><code>type1</code></em>である。これにより、<em><code>type1</code></em>の引数を必要とする関数の引数として、その式を用いることが可能となる。</p>
</li>
<li>
<p>式の評価時:</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のルールを用いて<em><code>expr1</code></em>が<em><code>type1</code></em>と照合されるならば、<code>treat</code>式は<em><code>expr1</code></em>の値を返す。そうでない場合は<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a> [<a title="err:XPDY0050" href=
"#ERRXPDY0050">err:XPDY0050</a>]が発生する。<em><code>expr1</code></em>の値が返るならば、その識別性は保存される。<code>treat</code>式は、その式の演算数の値が実行時に期待される型にしたがうことを保証する。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
<p><code>$myaddress</code>の<a title="static type" href=
"#dt-static-type">静的型</a>は<code>element(*,
Address)</code>であってもよい。これは<code>element(*,
USAddress)</code>より詳しくない型である。しかし実行時には、<code>$myaddress</code>の値は、<a title="dynamic error"
href=
"#dt-dynamic-error">SequenceTypeの照合</a>のルールを用いて、型<code>element(*,
USAddress)</code>に照合されなければならない。そうでない場合は<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="nt-bnf" id="nt-bnf"></a>A XPathの文法</h2>
<div class="div2">
<h3><a name="id-grammar" id="id-grammar"></a>A.1 EBNF</h3>
<p>XPathの文法は、単純な拡張バッカス記法 (EBNF) を用いる。これは<a href="#XML">[XML
1.0]</a>と同じものであるが、以下に述べるように、若干の違いがある。</p>
<ul>
<li>
<p>名前づけられた記号はすべて、大文字で始まる名前を持つ。</p>
</li>
<li>
<p>外部の仕様の生成規則を参照するための記法を加える。</p>
</li>
<li>
<p>コメントや、文法の生成規則に関する特別な文法的制限を '/*' と '*/' という記号の間に置く。</p>
<ul>
<li>
<p>'xgc:' 接頭辞は特別な文法的制限であり、その詳細は<a href=
"#extra-grammatical-constraints"><b>A.1.2
特別な文法上の制約</b></a>に説明がある。</p>
</li>
<li>
<p>'ws:' 接頭辞は生成規則に対する空白のルールであり、その詳細は<a href=
"#whitespace-rules"><b>A.2.4 空白規則</b></a>に説明がある。</p>
</li>
<li>
<p>'gn:' 接頭辞は '文法上の備考' (Grammar
Note)の意味であり、ルール解釈を明確にすることを意味する。これについては<a href=
"#notes-on-parsing"><b>A.1.3
文法に関する備考</b></a>に説明されている。これらの備考は参考である。</p>
</li>
</ul>
</li>
</ul>
<p>この文法の終端記号には、既出の生成規則で用いられた引用符付き文字列や、<a href=
"#terminal-symbols"><b>A.2.1 終端記号</b></a>で定義された終端記号が含まれる。</p>
<p>EBNF記法についてのより詳しい説明は<a href="#EBNFNotation"><b>A.1.1
記法</b></a>にある。</p>
<p>
可読性を上げるため、この文書の本体のEBNFでは記法上の特徴をいくつか省略している。この附録はEBNFの参考バージョンである。</p>
<h5><a name="BNF-Grammar" id="BNF-Grammar"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-XPath" id=
"prod-xpath-XPath"></a>[1]&nbsp;&nbsp;&nbsp;</td>
<td><code>XPath</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Expr" id=
"prod-xpath-Expr"></a>[2]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a> (","
<a href="#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ExprSingle" id=
"prod-xpath-ExprSingle"></a>[3]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExprSingle</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForExpr" id=
"prod-xpath-ForExpr"></a>[4]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-SimpleForClause">SimpleForClause</a>
"return" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SimpleForClause" id=
"prod-xpath-SimpleForClause"></a>[5]&nbsp;&nbsp;&nbsp;</td>
<td><code>SimpleForClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"for" "$" <a href="#prod-xpath-VarName">VarName</a> "in"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-QuantifiedExpr" id=
"prod-xpath-QuantifiedExpr"></a>[6]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuantifiedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IfExpr" id=
"prod-xpath-IfExpr"></a>[7]&nbsp;&nbsp;&nbsp;</td>
<td><code>IfExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"if" "(" <a href="#prod-xpath-Expr">Expr</a> ")" "then"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-OrExpr" id=
"prod-xpath-OrExpr"></a>[8]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#prod-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AndExpr" id=
"prod-xpath-AndExpr"></a>[9]&nbsp;&nbsp;&nbsp;</td>
<td><code>AndExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> (
"and" <a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ComparisonExpr" id=
"prod-xpath-ComparisonExpr"></a>[10]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComparisonExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#prod-xpath-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath-NodeComp">NodeComp</a>) <a href=
"#prod-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-RangeExpr" id=
"prod-xpath-RangeExpr"></a>[11]&nbsp;&nbsp;&nbsp;</td>
<td><code>RangeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AdditiveExpr" id=
"prod-xpath-AdditiveExpr"></a>[12]&nbsp;&nbsp;&nbsp;</td>
<td><code>AdditiveExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-MultiplicativeExpr" id=
"prod-xpath-MultiplicativeExpr"></a>[13]&nbsp;&nbsp;&nbsp;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-UnionExpr" id=
"prod-xpath-UnionExpr"></a>[14]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IntersectExceptExpr" id=
"prod-xpath-IntersectExceptExpr"></a>[15]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> (
("intersect" | "except") <a href=
"#prod-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-InstanceofExpr" id=
"prod-xpath-InstanceofExpr"></a>[16]&nbsp;&nbsp;&nbsp;</td>
<td><code>InstanceofExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a> (
"instance" "of" <a href="#prod-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TreatExpr" id=
"prod-xpath-TreatExpr"></a>[17]&nbsp;&nbsp;&nbsp;</td>
<td><code>TreatExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CastableExpr" id=
"prod-xpath-CastableExpr"></a>[18]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastableExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CastExpr" id=
"prod-xpath-CastExpr"></a>[19]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-UnaryExpr" id=
"prod-xpath-UnaryExpr"></a>[20]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("-" | "+")* <a href=
"#prod-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ValueExpr" id=
"prod-xpath-ValueExpr"></a>[21]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-GeneralComp" id=
"prod-xpath-GeneralComp"></a>[22]&nbsp;&nbsp;&nbsp;</td>
<td><code>GeneralComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ValueComp" id=
"prod-xpath-ValueComp"></a>[23]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NodeComp" id=
"prod-xpath-NodeComp"></a>[24]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PathExpr" id=
"prod-xpath-PathExpr"></a>[25]&nbsp;&nbsp;&nbsp;</td>
<td><code>PathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("/" <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">xgs:
leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-RelativePathExpr" id=
"prod-xpath-RelativePathExpr"></a>[26]&nbsp;&nbsp;&nbsp;</td>
<td><code>RelativePathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a> (("/" | "//")
<a href="#prod-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-StepExpr" id=
"prod-xpath-StepExpr"></a>[27]&nbsp;&nbsp;&nbsp;</td>
<td><code>StepExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-FilterExpr">FilterExpr</a> |
<a href="#prod-xpath-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AxisStep" id=
"prod-xpath-AxisStep"></a>[28]&nbsp;&nbsp;&nbsp;</td>
<td><code>AxisStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xpath-ReverseStep">ReverseStep</a> |
<a href="#prod-xpath-ForwardStep">ForwardStep</a>) <a href=
"#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForwardStep" id=
"prod-xpath-ForwardStep"></a>[29]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xpath-ForwardAxis">ForwardAxis</a>
<a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForwardAxis" id=
"prod-xpath-ForwardAxis"></a>[30]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AbbrevForwardStep" id=
"prod-xpath-AbbrevForwardStep"></a>[31]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"@"? <a href=
"#prod-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ReverseStep" id=
"prod-xpath-ReverseStep"></a>[32]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xpath-ReverseAxis">ReverseAxis</a>
<a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ReverseAxis" id=
"prod-xpath-ReverseAxis"></a>[33]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AbbrevReverseStep" id=
"prod-xpath-AbbrevReverseStep"></a>[34]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NodeTest" id=
"prod-xpath-NodeTest"></a>[35]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | <a href=
"#prod-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NameTest" id=
"prod-xpath-NameTest"></a>[36]&nbsp;&nbsp;&nbsp;</td>
<td><code>NameTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#prod-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Wildcard" id=
"prod-xpath-Wildcard"></a>[37]&nbsp;&nbsp;&nbsp;</td>
<td><code>Wildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-FilterExpr" id=
"prod-xpath-FilterExpr"></a>[38]&nbsp;&nbsp;&nbsp;</td>
<td><code>FilterExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a>
<a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PredicateList" id=
"prod-xpath-PredicateList"></a>[39]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Predicate" id=
"prod-xpath-Predicate"></a>[40]&nbsp;&nbsp;&nbsp;</td>
<td><code>Predicate</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"[" <a href="#prod-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PrimaryExpr" id=
"prod-xpath-PrimaryExpr"></a>[41]&nbsp;&nbsp;&nbsp;</td>
<td><code>PrimaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a> | <a href=
"#prod-xpath-VarRef">VarRef</a> | <a href=
"#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#prod-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#prod-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Literal" id=
"prod-xpath-Literal"></a>[42]&nbsp;&nbsp;&nbsp;</td>
<td><code>Literal</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a> |
<a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NumericLiteral" id=
"prod-xpath-NumericLiteral"></a>[43]&nbsp;&nbsp;&nbsp;</td>
<td><code>NumericLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a> |
<a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-VarRef" id=
"prod-xpath-VarRef"></a>[44]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href="#prod-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-VarName" id=
"prod-xpath-VarName"></a>[45]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ParenthesizedExpr" id=
"prod-xpath-ParenthesizedExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(" <a href="#prod-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ContextItemExpr" id=
"prod-xpath-ContextItemExpr"></a>[47]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContextItemExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-FunctionCall" id=
"prod-xpath-FunctionCall"></a>[48]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgs:
reserved-function-names</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SingleType" id=
"prod-xpath-SingleType"></a>[49]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SequenceType" id=
"prod-xpath-SequenceType"></a>[50]&nbsp;&nbsp;&nbsp;</td>
<td><code>SequenceType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xpath-ItemType">ItemType</a> <a href=
"#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-OccurrenceIndicator" id=
"prod-xpath-OccurrenceIndicator"></a>[51]&nbsp;&nbsp;&nbsp;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <a href="#parse-note-occurrence-indicators">xgs:
occurrence-indicators</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ItemType" id=
"prod-xpath-ItemType"></a>[52]&nbsp;&nbsp;&nbsp;</td>
<td><code>ItemType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | ("item" "("
")") | <a href="#prod-xpath-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AtomicType" id=
"prod-xpath-AtomicType"></a>[53]&nbsp;&nbsp;&nbsp;</td>
<td><code>AtomicType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-KindTest" id=
"prod-xpath-KindTest"></a>[54]&nbsp;&nbsp;&nbsp;</td>
<td><code>KindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xpath-PITest">PITest</a><br />
| <a href="#prod-xpath-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath-TextTest">TextTest</a><br />
| <a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AnyKindTest" id=
"prod-xpath-AnyKindTest"></a>[55]&nbsp;&nbsp;&nbsp;</td>
<td><code>AnyKindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DocumentTest" id=
"prod-xpath-DocumentTest"></a>[56]&nbsp;&nbsp;&nbsp;</td>
<td><code>DocumentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xpath-ElementTest">ElementTest</a> | <a href=
"#prod-xpath-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TextTest" id=
"prod-xpath-TextTest"></a>[57]&nbsp;&nbsp;&nbsp;</td>
<td><code>TextTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CommentTest" id=
"prod-xpath-CommentTest"></a>[58]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PITest" id=
"prod-xpath-PITest"></a>[59]&nbsp;&nbsp;&nbsp;</td>
<td><code>PITest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeTest" id=
"prod-xpath-AttributeTest"></a>[60]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttribNameOrWildcard" id=
"prod-xpath-AttribNameOrWildcard"></a>[61]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SchemaAttributeTest" id=
"prod-xpath-SchemaAttributeTest"></a>[62]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xpath-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeDeclaration" id=
"prod-xpath-AttributeDeclaration"></a>[63]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementTest" id=
"prod-xpath-ElementTest"></a>[64]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" "(" (<a href=
"#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#prod-xpath-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementNameOrWildcard" id=
"prod-xpath-ElementNameOrWildcard"></a>[65]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SchemaElementTest" id=
"prod-xpath-SchemaElementTest"></a>[66]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xpath-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementDeclaration" id=
"prod-xpath-ElementDeclaration"></a>[67]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeName" id=
"prod-xpath-AttributeName"></a>[68]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementName" id=
"prod-xpath-ElementName"></a>[69]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TypeName" id=
"prod-xpath-TypeName"></a>[70]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="EBNFNotation" id="EBNFNotation"></a>A.1.1 記法</h4>
<p>以下の定義は、この解説を正確に定義するのに役立つ。</p>
<p>[<a name="symbol" id="symbol" title="symbol">Definition</a>:
文法中の各規則は1つの<b>記号</b>を定義する。ここで用いられる形式は以下の通りである。</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
]
<p>[<a name="terminal" id="terminal" title=
"terminal">Definition</a>:
<b>終端記号</b>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。]
以下の構成要素が、長さ1以上の文字からなる文字列で終端記号中にあるものと照合されて用いられる。</p>
<dl>
<dt class="label">[a-zA-Z]</dt>
<dd>
<p>任意の<a href=
"#prod-xpath-Char">Char</a>で、示された範囲(すべての)中の値であるようなものと照合される。</p>
</dd>
<dt class="label">[abc]</dt>
<dd>
<p>任意の<a href=
"#prod-xpath-Char">Char</a>で、列挙された文字のどれかの値であるようなものと照合される。<span>列挙と範囲を1つの角括弧の中で混ぜることもできる。</span></p>
</dd>
<dt class="label">[^abc]</dt>
<dd>
<p>任意の<a href=
"#prod-xpath-Char">Char</a>で、与えられた文字のどれでもない値と照合される。<span>禁止される値の列挙と範囲を1つの角括弧のなかで混ぜることもできる。</span></p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>二重引用符の中に出現する文字の列と照合される。</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>一重引用符の中に出現する文字の列と照合される。</p>
</dd>
<dt class="label">
[http://www.w3.org/TR/REC-example/#NT-Example]</dt>
<dd>
<p>用意された参照の通りの外部仕様で定義される生成規則によって照合される文字列と照合される。</p>
</dd>
</dl>
<p>パターン (上記の構成要素を含む)
を文法構成子で組み合わせ、より複雑なパターンを形成することができる。このようなパターンは文字列の複雑な集合に照合される。以下の例では、AとBは(部分)パターンを表す。</p>
<dl>
<dt class="label">(A)</dt>
<dd>
<p><code>A</code>は1つの単位として扱われ、このリスト中に記述されているように組み合わせても構わない。</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>
<code>A</code>に照合されるか、何とも照合されない。すなわち省略可能な<code>A</code>と照合される。</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>
<code>A</code>の後ろに<code>B</code>が続くものと照合される。この演算子は代替よりも優先度が高い。従って<code>A
B | C D</code>は<code>(A B) | (C D)</code>と同じである。</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p><code>A</code>または<code>B</code>に照合される。ただし両方同時には照合されない。</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p><code>A</code>に照合されるが、<code>B</code>には照合されないすべての文字列に照合される。</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p><code>A</code>の1回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A+ |
B+</code>は<code>(A+) | (B+)</code>と同じである。</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p><code>A</code>の0回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A* |
B*</code>は<code>(A*) | (B*)</code>と同じである。</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="extra-grammatical-constraints" id=
"extra-grammatical-constraints"></a>A.1.2 特別な文法上の制約</h4>
<p>
この節はEBNFの生成規則の制約を含む。これらは正当な文を解釈するのに必要となる。以下の備考は、次のような記法で、生成規則の右辺から参照される:
<em>/* xgc: &lt;id&gt; */</em>。</p>
<div class="constraint">
<p class="prefix"><a name="parse-note-leading-lone-slash" id=
"parse-note-leading-lone-slash"></a><b>Constraint:
leading-lone-slash</b></p>
<p>単一のスラッシュは、完全経路式として出現するか、<a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>の後に続く経路式の最初の部分として出現するかのいずれかである。後者の場合、<a href="#doc-xpath-NameTest">NameTest</a>
("*" または QName)の形式を取る。"*", "union"
などの演算子が出現しうる文脈では、構文解析器は演算子とNameTestを区別するのが困難であってもよい。例えば、先読みをしなければ、式
"/ * 5" の最初の部分は例えば容易に "/ *" という完全経路式だととられる。これは全く異なる解釈を持つ
("/"の子節点)。</p>
<p>そこで、先読みの必要を削減するため、スラッシュの直後に続くトークンが "*"
またはキーワードである場合は、スラッシュは<a href=
"#doc-xpath-PathExpr">PathExpr</a>の先頭でなければならないが、その全体であってはならない
(そして、それに続くトークンは<a href=
"#doc-xpath-NameTest">NameTest</a>でなければならず、演算子であってはならない)。</p>
<p>単一のスラッシュは、括弧で囲むことにより、演算子の左側の引数として用いてもよい: <code>(/) *
5</code>。一方、式<code>5 * /</code>は括弧なしでも正しい式である。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-xml-version" id=
"parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
<p>実装が<a href="#XML">[XML 1.0]</a>と<a href="#XMLNAMES">[XML
Names]</a>の字句定義、あるいは<a href="#XML1.1">[XML 1.1]</a>と<a href=
"#XMLNAMES11">[XML Names
1.1]</a>の字句定義のいずれを支援することを選択するかによって、この生成規則の定義を得る外部文書が決定される。EBNFではバージョン1.0への参照しか持たせていない。ある場合には、XML
1.0とXML
1.1の定義は全く同じであるかもしれない。また、これらの外部定義は、その仕様の空白のルールに従い、この仕様のルール、特に<a href="#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>には従わないことに注意すること。したがって<code>prefix :
localname</code>は、XML文書中では許されないのと同様に、この仕様では正しくないQNameである。またコメントはコロンのどちら側にも許されない。また整形式制約のような特別な文法的制約を考慮しなければならない。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-reserved-function-names" id=
"parse-note-reserved-function-names"></a><b>Constraint:
reserved-function-names</b></p>
<p>
言語のキーワードと同じように綴られた接頭辞なしの関数名は、言語の認識を困難にするかもしれない。例えば<code>if(foo)</code>は、<a href="#doc-xpath-FunctionCall">FunctionCall</a>とも、<a href="#doc-xpath-IfExpr">IfExpr</a>の先頭ともとれる。そのため、<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>中の名前のいずれかと一致する接頭辞なし名前の関数を呼び出すことは、文法的に誤りである。</p>
<p>"if"という名前の関数は、その名前空間をある接頭辞に束縛し、接頭辞付きの形式を用いれば、呼び出すことができる:
"if(foo)" の代わりに "library:if(foo)" というようにである。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-occurrence-indicators" id=
"parse-note-occurrence-indicators"></a><b>Constraint:
occurrence-indicators</b></p>
<p>すでに書いたように、<a href="#nt-bnf"><b>A XPathの文法</b></a>の文法は '+' と '*'
の Kleene
演算子を用いたある種の形式について、曖昧である。この曖昧性は以下のようにして解消される。これらの演算子は<a href=
"#doc-xpath-SequenceType">SequenceType</a>式と強く結合しており、これらの記号を他の用途で用いた場合より高い優先度を持つ。列型に続いて
'?' ばかりでなく '+' や '*' が出現しても、出現標識であると仮定される。すなわち、<a href=
"#doc-xpath-ItemType">ItemType</a>の直後に出現する "+", "*", "?" は<a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>でなければならない。したがって、<code>4
treat as item() + - 5</code>は<code>(4 treat as item()+) -
5</code>と解釈されなければならない。つまり '+' は OccurrenceIndicator として、'-'
は減算演算子として解釈されなければならない。"+" を強制的に加算演算子と解釈するには (その結果として "-"
は単項のマイナスと解釈される)、括弧を用いてもよい: <code>(4 treat as item()) +
-5</code>という形で、<a href=
"#doc-xpath-SequenceType">SequenceType</a>式を括弧で囲むと、期待される解釈を導く。</p>
<p>このルールの結果として、このルールを用いなければ正しくかつ曖昧性のないある種の形式は、認識されない。"4 treat as
item() + 5" では、"+" は<a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>ととられ、演算子とは見なされない。そのため、この式は正しい式ではないと解釈される。</p>
</div>
</div>
<div class="div3">
<h4><a name="notes-on-parsing" id="notes-on-parsing"></a>A.1.3
文法に関する備考</h4>
<p>
この節は、EBNFの生成規則についての一般的な備考を含む。これらはEBNFをどのように解釈し、またどのように実装するかを理解する助けとなるかもしれない。これらの備考は規範的である。以下の備考は、<em>/*
gn: &lt;id&gt; */</em>という形式で、生成規則の右辺から参照される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<dl>
<dt class="label"><a name="parse-note-parens" id=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p><a href="#doc-xpath-FunctionCall">FunctionCall</a>を、<a href=
"#doc-xpath-Comment">Comment</a>の続くQNameやキーワードと区別するには、先読みが必要である。例えば:
<code>address (: this may be empty
:)</code>は、先読みを用いないと、"address"という名前の関数の呼び出しと間違われるかもしれない。
別の例は<code>for (: whom the bell :) $tolls in 3 return
$tolls</code>である。これはキーワード "for" を関数名と間違ってはならない。</p>
</dd>
<dt class="label"><a name="parse-note-comments" id=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>コメントは<a title="ignorable whitespace" href=
"#IgnorableWhitespace">無視可能な空白</a>が許される場所にならどこでも許される。<a href=
"#doc-xpath-Comment">Comment</a>記号は生成規則の右辺に明示的に出現はしない
(それ自身の生成規則を除く)。<a href="#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>を見よ。</p>
<p>コメントはコメントを入れ子で含むことができる。ただし、すべての "(:" と ":)"
パターンの対応が取れている限りにおいてである。さらに外側のコメントの中で発生するかには関係しない。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>字句解析では概して、入れ子のコメントを扱うのに各 "(:" パターンでカウンタを1増やし、各 ":)"
パターンでカウンタを1減らすという方法を用いるかもしれない。そのコメントは、カウンタが0に戻るまでずっと終了しない。</p>
</div>
<p>いくつか例で説明する。</p>
<ul>
<li>
<p><code>(: commenting out a (: comment :) may be confusing, but
often helpful
:)</code>は正しいコメントである。なぜなら対応の取れたコメントの入れ子は許されるからである。</p>
</li>
<li>
<p><code>"this is just a string :)"</code>は正しい式である。しかし、<code>(:
"this is just a string :)" :)</code>は構文エラーを引き起こす。同様に<code>"this is
another string (:"</code>は正しい式だが、<code>(: "this is another string
(:"
:)</code>は構文エラーを引き起こす。入れ子のコメントの限界として、リテラル内容により対応の取れない入れ子コメントが生じる。</p>
</li>
<li>
<p><code>for (: set up loop :) $i in $x return
$i</code>は、コメントを無視すると、構文的には正しい。</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of
xs:integer</code>もまた構文的に正しい。</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="lexical-structure" id="lexical-structure"></a>A.2
字句構造</h3>
<p>上の文法で仮定されている終端記号を、この節で述べる。</p>
<p>生成規則中に出現する引用符つき文字列は終端記号である。</p>
<p>その他の終端記号は<a href="#terminal-symbols"><b>A.2.1
終端記号</b></a>で定義されている。</p>
<p class="xpath"><b>ホスト言語</b>は、<a href="#XML">[XML
1.0]</a>や<a href="#XMLNAMES">[XML Names]</a>の字句規則に従うか、あるいは<a href=
"#XML1.1">[XML 1.1]</a>や<a href="#XMLNAMES11">[XML Names
1.1]</a>の字句規則に従うか、選択してよい。</p>
<p>トークンを切り出すときには、現在の文脈で正しい照合のうち、最長のものが使われる。</p>
<p>
すべてのキーワードは大文字小文字を区別する。キーワードは予約されない。すなわち、任意のQNameはキーワードと重複してよい。ただし、<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>に述べるものを除く。</p>
<div class="div3">
<h4><a name="terminal-symbols" id="terminal-symbols"></a>A.2.1
終端記号</h4>
<h5><a name="d2e11414" id="d2e11414"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IntegerLiteral" id=
"prod-xpath-IntegerLiteral"></a>[71]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntegerLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DecimalLiteral" id=
"prod-xpath-DecimalLiteral"></a>[72]&nbsp;&nbsp;&nbsp;</td>
<td><code>DecimalLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href=
"#prod-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DoubleLiteral" id=
"prod-xpath-DoubleLiteral"></a>[73]&nbsp;&nbsp;&nbsp;</td>
<td><code>DoubleLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("." <a href="#prod-xpath-Digits">Digits</a>) |
(<a href="#prod-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]?
<a href="#prod-xpath-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-StringLiteral" id=
"prod-xpath-StringLiteral"></a>[74]&nbsp;&nbsp;&nbsp;</td>
<td><code>StringLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href="#prod-xpath-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href="#prod-xpath-EscapeApos">EscapeApos</a>
| [^'])* "'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-EscapeQuot" id=
"prod-xpath-EscapeQuot"></a>[75]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeQuot</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-EscapeApos" id=
"prod-xpath-EscapeApos"></a>[76]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeApos</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Comment" id=
"prod-xpath-Comment"></a>[77]&nbsp;&nbsp;&nbsp;</td>
<td><code>Comment</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(:" (<a href=
"#prod-xpath-CommentContents">CommentContents</a> | <a href=
"#prod-xpath-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-QName" id=
"prod-xpath-QName"></a>[78]&nbsp;&nbsp;&nbsp;</td>
<td><code>QName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NCName" id=
"prod-xpath-NCName"></a>[79]&nbsp;&nbsp;&nbsp;</td>
<td><code>NCName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Char" id=
"prod-xpath-Char"></a>[80]&nbsp;&nbsp;&nbsp;</td>
<td><code>Char</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml#NT-Char]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
</table>
<p>以下の記号は、終端記号の定義中でのみ用いられる。これらは<a href="#id-grammar"><b>A.1
EBNF</b></a>の文法の終端記号ではない。</p>
<h5><a name="d2e11524" id="d2e11524"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Digits" id=
"prod-xpath-Digits"></a>[81]&nbsp;&nbsp;&nbsp;</td>
<td><code>Digits</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CommentContents" id=
"prod-xpath-CommentContents"></a>[82]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="id-terminal-delimitation" id=
"id-terminal-delimitation"></a>A.2.2 終端記号の区切り</h4>
<p class="xpath">XPath 2.0の式は<a href=
"#terminal-symbols">終端記号</a>と<a title="symbol separators" href=
"#symbolseparators">記号区切り</a>からなる。</p>
<p>終端記号には2種類ある。区切り終端記号と非区切り終端記号である。</p>
<p class="xpath">[<a name="delimiting-token" id="delimiting-token"
title="delimiting terminal symbol">Definition</a>: <b>区切り終端記号</b>は:
",", "$", "(", ")", "=", "!=", "&lt;=", "&gt;", "&gt;=",
"&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?",
"-", "+", "&lt;", <a href="#prod-xpath-Comment">Comment</a>, "/",
"//", ":"]</p>
<p class="xpath">[<a name="non-delimiting-token" id=
"non-delimiting-token" title=
"non-delimiting terminal symbol">Definition</a>: <b>非区切り終端記号</b>は:
"return", "for", "in", "some", "every", "satisfies", "if", "then",
"else", "eq", "ne", "lt", "le", "gt", "ge", "is", "child",
"descendant", "attribute", "self", "descendant-or-self",
"following-sibling", "following", "namespace", "parent",
"ancestor", "preceding-sibling", "preceding", "ancestor-or-self",
"empty-sequence", "item", "node", "document-node", "text",
"comment", "processing-instruction", "schema-attribute", "element",
"schema-element", <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>, "external", <a href=
"#prod-xpath-EscapeQuot">EscapeQuot</a>, <a href=
"#prod-xpath-EscapeApos">EscapeApos</a>, <a href=
"#prod-xpath-QName">QName</a>, <a href=
"#prod-xpath-NCName">NCName</a>, <a href=
"#prod-xpath-Char">Char</a>, <a href=
"#prod-xpath-Digits">Digits</a>]</p>
<p>[<a name="symbolseparators" id="symbolseparators" title=
"symbol separators">Definition</a>: <b>記号区切り</b>としての<a title=
"whitespace" href="#Whitespace">空白</a>や<a href=
"#doc-xpath-Comment">Comments</a>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<a href="#ws-explicit">/*
ws: explicit */</a>という備考や、<a href="#parse-note-xml-version">/* xgs:
xml-version */</a>という備考で禁止されている場所を除く。]</p>
<p>通例として、連続した終端記号は<a title="whitespace" href=
"#Whitespace">空白</a>や<a href=
"#doc-xpath-Comment">Comments</a>で区切る。しかし、このことが要求されるのは、そうしなければ2つの非区切り終端記号が互いに隣接してしまう場合のみである。この例外が2つある。"."
と "-" がQNameやNCNameに続くならば、その間に<a title="symbol separators" href=
"#symbolseparators">記号区切り</a>が必要である。</p>
</div>
<div class="div3">
<h4><a name="id-eol-handling" id="id-eol-handling"></a>A.2.3
行末処理</h4>
<p>XPath処理器は、入力中にあるすべての行末を、構文解析前に正規化するように振る舞わなければならない。正規化は、<a href=
"#XML">[XML 1.0]</a>か<a href="#XML1.1">[XML
1.1]</a>かいずれの字句処理を支援すると選択するかに従って行われるべきである。</p>
<div class="div4">
<h5><a name="id-xml10-eol-handling" id=
"id-xml10-eol-handling"></a>A.2.3.1 XML 1.0の行末処理</h5>
<p><a href="#XML">[XML 1.0]</a>の処理では、以下のすべてが単一の文字 #xA
に変換されなければならない。</p>
<ol class="enumar">
<li>
<p>2文字の列 #xD #xA</p>
</li>
<li>
<p>#xA の直後に続かない #xD 文字</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-xml11-eol-handling" id=
"id-xml11-eol-handling"></a>A.2.3.2 XML 1.1の行末処理</h5>
<p><a href="#XML1.1">[XML 1.1]</a>の処理では、以下のすべてが単一の文字 #xA
に変換されなければならない。</p>
<ol class="enumar">
<li>
<p>2文字の列 #xD #xA</p>
</li>
<li>
<p>2文字の列 #xD #x85</p>
</li>
<li>
<p>単一の文字 #x85</p>
</li>
<li>
<p>単一の文字 #x2028</p>
</li>
<li>
<p>#xA または #x85 の直後に続かない #xD 文字</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="whitespace-rules" id="whitespace-rules"></a>A.2.4
空白規則</h4>
<div class="div4">
<h5><a name="DefaultWhitespaceHandling" id=
"DefaultWhitespaceHandling"></a>A.2.4.1 デフォルト空白処理</h5>
<p>[<a name="Whitespace" id="Whitespace" title=
"whitespace">Definition</a>: <b>空白</b>文字は、<a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>で定義される任意の文字である。]</p>
<p>[<a name="IgnorableWhitespace" id="IgnorableWhitespace" title=
"ignorable whitespace">Definition</a>: <b>無視可能な空白</b>は、<a title=
"whitespace" href="#Whitespace">空白</a>文字のうち<a title="terminal"
href="#terminal">終端記号</a>の間に出現してもよいものである。ただし、これらの文字が<a href=
"#ExplicitWhitespaceHandling">ws:explicit</a>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない
(<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
明示的空白処理</b></a>を見よ)。]
無視可能な空白文字は、式の意味には影響しない。空白は、モジュールの最初の終端記号の前や、最後の終端記号の後ろにも許される。空白は、任意の2つの<a title="terminal"
href="#terminal">終端記号</a>の間に許される。<a href=
"#doc-xpath-Comment">Comments</a>もまた "空白"
として振舞い、2つの隣接した終端記号を1つだと認識されることを防いでもよい。いくつか例で説明する。</p>
<ul>
<li>
<p><code>foo- foo</code>は構文エラーになる。"foo-" が QName として認識される。</p>
</li>
<li>
<p><code>foo -foo</code>は構文的には<code>foo -
foo</code>、すなわち減算演算子によって区切られた2つのQNameと同値である。</p>
</li>
<li>
<p><code>foo(: This is a comment :)- foo</code>は構文的には<code>foo -
foo</code>と等価である。これは、コメントによって、2つの隣接した終端記号が1つのものとして認識されるのが防がれているからである。</p>
</li>
<li>
<p><code>foo-foo</code>は構文的には1つのQNameと等価である。これは、"-"
がQName中の正しい文字だからである。名前の文字の後ろで演算子として使うときには、"-"
は、例えば空白や括弧によって、名前から区切らなければならない。</p>
</li>
<li>
<p><code>10div 3</code>は構文エラーになる。</p>
</li>
<li>
<p><code>10 div3</code>もまた構文エラーになる。</p>
</li>
<li>
<p><code>10div3</code>もまた構文エラーになる。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="ExplicitWhitespaceHandling" id=
"ExplicitWhitespaceHandling"></a>A.2.4.2 明示的空白処理</h5>
<p>
EBNFの生成規則では、空白処理がデフォルトルールと異なる場合、以下に示す記述で明示的空白処理を指定する。この記述は継承されない。言い換えると、EBNFルールが
/* ws: explicit */ と目印付けされているならば、この記述は、そのルールの '子' の EBNF
生成規則いずれにも自動的には適用されない。</p>
<dl>
<dt class="label"><a name="ws-explicit" id="ws-explicit"></a>ws:
explicit</dt>
<dd>
<p>/* ws: explicit */ は、EBNF記述で、<code>S</code>もしくは他の方法により、<a title=
"whitespace" href=
"#Whitespace">空白文字</a>の許される場所が明示的に記述されていることを意味している。備考 /* ws:
explicit */ を持つ生成規則では、<a href=
"#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>は適用されない。<a href=
"#doc-xpath-Comment">Comments</a>もまたこれらの生成規則中では許されない。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-reserved-fn-names" id=
"id-reserved-fn-names"></a>A.3 予約済関数名</h3>
<p>以下の名前は、接頭辞のない形式の関数名としては許されない。なぜなら、式の構文のほうが優先するからである。</p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty-sequence</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>schema-attribute</code></p>
</li>
<li>
<p><code>schema-element</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>キーワード<code>typeswitch</code>は XPath
では用いられないが、XQueryとの互換性のため予約済関数とみなされる。</p>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-precedence-order" id="id-precedence-order"></a>A.4
優先順位</h3>
<p><a href="#id-grammar"><b>A.1
EBNF</b></a>中の文法では、XPathの演算子の間の組み込み優先順位を規定として定義している。これらの演算子をここでまとめ、優先度を低い順から高い順に明らかにする。より低い優先度順位を持つ演算子を、より高い優先度順位を持つ演算子が含むことはできない。結合性の欄は、式中で同じ優先度を持つ演算子が適用される順番を表している。</p>
<table border="1">
<tbody>
<tr>
<th>#</th>
<th>演算子</th>
<th>結合性</th>
</tr>
<tr>
<td>1</td>
<td>, (comma)</td>
<td>左から右</td>
</tr>
<tr>
<td>3</td>
<td><span class="xpath"><a href=
"#doc-xpath-ForExpr">for</a>,</span> <a href=
"#doc-xpath-QuantifiedExpr">some, every</a>, <a href=
"#doc-xpath-IfExpr">if</a></td>
<td>左から右</td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xpath-OrExpr">or</a></td>
<td>左から右</td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xpath-AndExpr">and</a></td>
<td>左から右</td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xpath-ValueComp">eq, ne, lt, le, gt, ge</a>,
<a href="#doc-xpath-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xpath-NodeComp">is</a>, <a href=
"#doc-xpath-NodeComp">&lt;&lt;, &gt;&gt;</a></td>
<td>左から右</td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xpath-RangeExpr">to</a></td>
<td>左から右</td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xpath-AdditiveExpr">+, -</a></td>
<td>左から右</td>
</tr>
<tr>
<td>9</td>
<td><a href="#doc-xpath-MultiplicativeExpr">*, div, idiv,
mod</a></td>
<td>左から右</td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xpath-UnionExpr">union, |</a></td>
<td>左から右</td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xpath-IntersectExceptExpr">intersect,
except</a></td>
<td>左から右</td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xpath-InstanceofExpr">instance of</a></td>
<td>左から右</td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xpath-TreatExpr">treat</a></td>
<td>左から右</td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xpath-CastableExpr">castable</a></td>
<td>左から右</td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xpath-CastExpr">cast</a></td>
<td>左から右</td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xpath-UnaryExpr">-(unary), +(unary)</a></td>
<td>右から左</td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xpath-OccurrenceIndicator">?,
*(OccurrenceIndicator), +(OccurrenceIndicator)</a></td>
<td>左から右</td>
</tr>
<tr>
<td>18</td>
<td><a href="#doc-xpath-PathExpr">/, //</a></td>
<td>左から右</td>
</tr>
<tr>
<td>19</td>
<td><a href="#doc-xpath-Predicate">[ ]</a>, <a href=
"#doc-xpath-ParenthesizedExpr">( )</a>, {}</td>
<td>左から右</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-type-promotion-and-operator-mapping" id=
"id-type-promotion-and-operator-mapping"></a>B 型の昇格と演算子の写像</h2>
<div class="div2">
<h3><a name="promotion" id="promotion"></a>B.1 型の昇格</h3>
<p>[<a name="dt-type-promotion" id="dt-type-promotion" title=
"type promotion">Definition</a>:
ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<a href=
"#id-function-calls"><b>3.1.5 関数呼び出し</b></a>を見よ)や演算子の評価 (<a href=
"#mapping"><b>B.2 演算子の写像</b></a>を見よ)のときに、<b>型の昇格</b>が用いられる。]
以下のような型の昇格が許されている。</p>
<ol class="enumar">
<li>
<p>数型の昇格:</p>
<ol class="enumla">
<li>
<p><code>xs:float</code>型
(もしくは<code>xs:float</code>型から制限によって導出される任意の型)
の値は<code>xs:double</code>型に昇格させることができる。結果は、元の値と等しい<code>xs:double</code>の値である。</p>
</li>
<li>
<p><code>xs:decimal</code>型
(もしくは<code>xs:decimal</code>から制限によって導出される任意の型)
の値は、<code>xs:float</code>型、もしくは<code>xs:double</code>型のいずれかに昇格させることができる。この昇格の結果は、元の値を要求された型に型変換することで生成される。この種の昇格は、正確さを損なうことを引き起こすかもしれない。</p>
</li>
</ol>
</li>
<li>
<p>URI型の昇格: <code>xs:anyURI</code>型
(もしくは<code>xs:anyURI</code>から制限によって導出される任意の型)
の値は、<code>xs:string</code>型に昇格させることができる。この昇格の結果は、元の値を<code>xs:string</code>型に型変換することで生成される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<code>xs:anyURI</code>の値は<code>xs:string</code>に昇格させることができるので、<a title="default collation"
href="#dt-def-collation">デフォルト照合順序</a>を用いて文字列を比較する関数や演算子は、<a title=
"default collation" href=
"#dt-def-collation">デフォルト照合順序</a>を用いて<code>xs:anyURI</code>の値も比較する。このことにより、文字列や<code>xs:anyURI</code>の値、またはこれら2つの型の組み合わせを含む順序は、一定でかつはっきり定義されることが保証される。</p>
</div>
</li>
</ol>
<p><a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>は<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>とは異なることに注意すること。例えば:</p>
<ul>
<li>
<p>
<code>xs:float</code>型の引数<code>$p</code>を期待する関数は、<code>xs:decimal</code>型の値を与えて呼び出すことができる。これは<a title="type promotion"
href=
"#dt-type-promotion">型の昇格</a>の例である。この値は期待される型に実際に変換される。関数の本体の内部では、<code>$p
instance of xs:decimal</code>は<code>false</code>を返す。</p>
</li>
<li>
<p>
<code>xs:decimal</code>型の引数<code>$p</code>を期待する関数は、<code>xs:integer</code>型の値を与えて呼び出すことができる。これは<a title="subtype substitution"
href=
"#dt-subtype-substitution">部分型置換</a>の例である。この値は元の型のまま残されている。関数の本体の内部では、<code>$p
instance of xs:integer</code>は<code>true</code>を返す。</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="mapping" id="mapping"></a>B.2 演算子の写像</h3>
<p>この節の演算子の写像表は、さまざまなXPathの演算子に対して定義される方の組み合わせを列挙する。[<a name=
"dt-operator-function" id="dt-operator-function" title=
"operator function">Definition</a>:
各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<b>演算子関数</b>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。]
演算子関数の定義は<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and
Operators]</a>で与えられている。演算子の結果、その演算子関数によってエラーが発生してもよい。これに関する定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。ある場合には、演算子関数は与えられた演算子の完全な意味を実装しない。各演算子の定義
(空列や長さが1より大きい列に対する振舞いを含む) については、この文書の主部分中の記述を見よ。</p>
<p>
<code>and</code>や<code>or</code>演算子は、この文書の主部分に直接定義されており、演算子の写像表には出現していない。</p>
<p>演算子の写像表中の演算子が型 <em>ET</em> の演算数を要求するとき、<a title="type promotion"
href="#dt-type-promotion">型の昇格</a>や<a title="subtype substitution"
href="#dt-subtype-substitution">部分型置換</a>によって型 <em>AT</em> が型
<em>ET</em> に変換されるならば、その演算子は型 <em>AT</em> の演算数に適用することができる。
例えば、表のエントリに<code>gt</code>演算子を2つの<code>xs:date</code>演算数に適用してよく、そのとき<code>xs:boolean</code>を返すと示しているものがある。したがって、<code>gt</code>演算子は2つの<code>xs:date</code>の部分型
(これらは異なることもある) に適用してもよく、この場合も<code>xs:boolean</code>を返す。</p>
<p>[<a name="dt-numeric" id="dt-numeric" title=
"numeric">Definition</a>:
型を参照するとき、<b>数</b>という用語は<code>xs:integer</code>型,
<code>xs:decimal</code>型, <code>xs:float</code>型,
<code>xs:double</code>型を表す。] 演算数と結果が<a title="numeric" href=
"#dt-numeric">数</a>と指定されている演算子は、4つの演算子、すなわち数型それぞれに対し1つの演算子を表していると考えられる。例えば、数型の<code>+</code>演算子は、以下の4つの演算子を表していると考えられる:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">演算子</td>
<td align="center">第1演算数の型</td>
<td align="center">第2演算数の型</td>
<td align="center">結果の型</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p><a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>や<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>によって型 <em>AT</em>
が4つの数型のいずれかに変換可能であれば、
数演算子は型<em>AT</em>の演算数に正しく適用してよい。演算子の結果の型が数と列挙されていれば、その意味は "順序リスト
<code>(xs:integer, xs:decimal, xs:float,
xs:double)</code>のうち、すべての演算数が<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>や<a title="type promotion"
href="#dt-type-promotion">型の昇格</a>により変換することのできる型の最初のもの"
である。例として、型<code>hatsize</code>が<code>xs:integer</code>から導出されており、型<code>shoesize</code>が<code>xs:float</code>から導出されているとしよう。このとき、<code>+</code>演算子が、型<code>hatsize</code>と<code>shoesize</code>の演算数を伴って実行されるならば,
型<code>xs:float</code>の結果を返す。同様に、<code>+</code>が型<code>hatsize</code>の2つの演算数を伴って実行されるならば、型<code>xs:integer</code>の結果を返す。</p>
<p>[<a name="dt-gregorian" id="dt-gregorian" title=
"Gregorian">Definition</a>:
演算子の写像表で、<b>Gregorian</b>という用語は、<code>xs:gYearMonth</code>型,
<code>xs:gYear</code>型, <code>xs:gMonthDay</code>型,
<code>xs:gDay</code>型, <code>xs:gMonth</code>型を表す。]
2つのGregorian型の演算数を取ることのできる2項演算子について、演算数はともに同じ型でなければならない。
(例えば、1つの演算数が<code>xs:gDay</code>型であれば、もう一方の演算数も<code>xs:gDay</code>でなければならない。)</p>
<table border="1" summary="Binary operators" class="small">
<caption>2項演算子</caption>
<tbody>
<tr>
<th>演算子</th>
<th>型(A)</th>
<th>型(B)</th>
<th>関数</th>
<th>結果の型</th>
</tr>
<tr>
<td>A + B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-add(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:dateTime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dateTime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-subtract(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:subtract-dates(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:subtract-dateTimes(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-multiply(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:yearMonthDuration</td>
<td>数</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>xs:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:dayTimeDuration</td>
<td>数</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>xs:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-integer-divide(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-divide(A, B)</td>
<td>数; ただし、演算数がともに xs:integer であれば xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>数</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>数</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A mod B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-mod(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A eq B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>op:duration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hex-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>数</td>
<td>数</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>fn:not(op:duration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hex-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer*</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
</tbody>
</table>
<table border="1" summary="Unary operators" class="small">
<caption>単項演算子</caption>
<tbody>
<tr>
<th>演算子</th>
<th>演算数の型</th>
<th>関数</th>
<th>結果の型</th>
</tr>
<tr>
<td>+ A</td>
<td>数</td>
<td>op:numeric-unary-plus(A)</td>
<td>数</td>
</tr>
<tr>
<td>- A</td>
<td>数</td>
<td>op:numeric-unary-minus(A)</td>
<td>数</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xp-context-components" id=
"id-xp-context-components"></a>C 文脈の構成要素</h2>
<p>この節の表は、静的文脈や動的文脈のさまざまな構成要素の有効範囲 (適用可能な範囲) を記述する。</p>
<div class="div2">
<h3><a name="id-xp-static-context-components" id=
"id-xp-static-context-components"></a>C.1 静的文脈の構成要素</h3>
<p>以下の表では、<b>静的文脈</b>の構成要素について記述する。構成要素それぞれについて、"大域" とは、構成要素の値が
XPath 式の全体を通して適用するということを表し、一方 "字句"
とは、構成要素の値が、それが定義されている部分式の中でしか適用しないことを表している。</p>
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>静的文脈の構成要素</caption>
<tbody>
<tr>
<th>構成要素</th>
<th>有効範囲</th>
</tr>
<tr>
<td>XPath 1.0 互換モード</td>
<td>大域</td>
</tr>
<tr>
<td>静的既知名前空間</td>
<td>大域</td>
</tr>
<tr>
<td>デフォルト要素/型名前空間</td>
<td>大域</td>
</tr>
<tr>
<td>デフォルト関数名前空間</td>
<td>大域</td>
</tr>
<tr>
<td>有効範囲内スキーマ型</td>
<td>大域</td>
</tr>
<tr>
<td>有効範囲内要素定義</td>
<td>大域</td>
</tr>
<tr>
<td>有効範囲内属性定義</td>
<td>大域</td>
</tr>
<tr>
<td>有効範囲内変数</td>
<td>字句; for式と限量式では新しい変数を束縛することができる</td>
</tr>
<tr>
<td>文脈項目静的型</td>
<td>字句</td>
</tr>
<tr>
<td>関数のシグネチャ</td>
<td>大域</td>
</tr>
<tr>
<td>静的既知照合</td>
<td>大域</td>
</tr>
<tr>
<td>デフォルト照合</td>
<td>大域</td>
</tr>
<tr>
<td>基底URI</td>
<td>大域</td>
</tr>
<tr>
<td>静的既知文書</td>
<td>大域</td>
</tr>
<tr>
<td>静的既知コレクション</td>
<td>大域</td>
</tr>
<tr>
<td>静的既知デフォルトコレクション型</td>
<td>大域</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="id-xp-evaluation-context-components" id=
"id-xp-evaluation-context-components"></a>C.2 動的文脈の構成要素</h3>
<p>
以下の表では、<b>動的文脈</b>のさまざまな構成要素に値がいかに割り当てられるかを記述している。これらの構成要素はホスト言語で定義される機構で初期化される。構成要素それぞれについて、"大域"
とは、構成要素の値が、XPath式の評価の間ずっと変化しないことを表す。一方 "動的"
とは、構成要素の値が、部分式の評価によって変更可能であることを表す。</p>
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>動的文脈の構成要素</caption>
<tbody>
<tr>
<th>構成要素</th>
<th>有効範囲</th>
</tr>
<tr>
<td>文脈項目</td>
<td>動的; 経路式や述語の評価の間変化する</td>
</tr>
<tr>
<td>文脈位置</td>
<td>動的; 経路式や述語の評価の間変化する</td>
</tr>
<tr>
<td>文脈サイズ</td>
<td>動的; 経路式や述語の評価の間変化する</td>
</tr>
<tr>
<td>変数の値</td>
<td>動的; for式と限量式では新しい変数を束縛することができる</td>
</tr>
<tr>
<td>現在の日付と時間</td>
<td>大域; 実装によって初期化されなければならない</td>
</tr>
<tr>
<td>暗黙的タイムゾーン</td>
<td>大域; 実装によって初期化されなければならない</td>
</tr>
<tr>
<td>利用可能文書</td>
<td>大域; 実装によって初期化されなければならない</td>
</tr>
<tr>
<td>利用可能コレクション</td>
<td>大域; 実装によって初期化されなければならない</td>
</tr>
<tr>
<td>デフォルトコレクション</td>
<td>大域; 実装によって上書き可能</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-impl-defined-items" id=
"id-impl-defined-items"></a>D 実装定義の項目</h2>
<p>この仕様中の以下の項目は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である:</p>
<ol class="enumar">
<li>
<p>式を構成するUnicodeの版</p>
</li>
<li>
<p><a title="statically known collations" href=
"#dt-static-collations">静的既知照合順序</a></p>
</li>
<li>
<p><a title="implicit timezone" href=
"#dt-timezone">暗黙的タイムゾーン</a></p>
</li>
<li>
<p><a title="warning" href=
"#dt-warning">警告</a>が発生する状況、および警告が処理される方法</p>
</li>
<li>
<p>エラーが外部処理環境に通知される方法</p>
</li>
<li>
<p>実装が<a href="#XML">[XML 1.0]</a>や<a href="#XMLNAMES">[XML
Names]</a>のルール、<a href="#XML1.1">[XML 1.1]</a>や<a href=
"#XMLNAMES11">[XML Names
1.1]</a>のルールのいずれに基づいているか。これらのルール集合のうち1つが、実装のすべての局面で常に適用されなければならない。</p>
</li>
<li>
<p>実装が名前空間軸を支援するかどうか。</p>
</li>
<li>
<p>実装によって支援される任意の<a title="static typing extension" href=
"#dt-xpath-static-typing-extension">静的型付け拡張</a>。ただし、<a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>が支援される場合のみ。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>追加の<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の項目が<a href=
"#datamodel">[XQuery/XPath Data Model (XDM)]</a>や<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>に列挙されている。</p>
</div>
</div>
<div class="div1">
<h2><a name="id-references" id="id-references"></a>E 参考文献</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 規格</h3>
<dl>
<dt class="label"><a name="RFC2119" id="RFC2119"></a>RFC 2119</dt>
<dd>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://rfc.net/rfc2119.html">http://www.ietf.org/rfc/rfc2119.txt</a>.</dd>
<dt class="label"><a name="RFC2396" id="RFC2396"></a>RFC2396</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 2396. See
<a href=
"http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>
<dt class="label"><a name="RFC3986" id="RFC3986"></a>RFC3986</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</dd>
<dt class="label"><a name="RFC3987" id="RFC3987"></a>RFC3987</dt>
<dd>M. Duerst and M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</dd>
<dt class="label"><a name="ISO10646" id="ISO10646"></a>ISO/IEC
10646</dt>
<dd>ISO (International Organization for Standardization).
<em>ISO/IEC 10646:2003. Information technology—Universal
Multiple-Octet Coded Character Set (UCS)</em>, ただし,
日々修正されたり、新しい版に置き換えられたり、新しい部の追加によって拡張されたりする。 [Geneva]: International
Organization for Standardization. (最新版については<a href=
"http://www.iso.ch">http://www.iso.ch</a>を見よ。)</dd>
<dt class="label"><a name="Unicode" id="Unicode"></a>Unicode</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard</em> Reading,
Mass.: Addison-Wesley, 2003,
ただし、日々新たな版が公表されることにより更新される。最新版、およびこの標準の版や Unicode Character
Databaseに関する追加情報については、<a href=
"http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</a>を見よ。使用される
Unicode の版は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。ただし、実装は最新の Unicode
の版を使用することが推奨される。</dd>
<dt class="label"><a name="XML" id="XML"></a>XML 1.0</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML)
1.0. (Third Edition)</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a></dd>
<dt class="label"><a name="XML1.1" id="XML1.1"></a>XML 1.1</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML)
1.1.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></dd>
<dt class="label"><a name="XMLNAMES" id="XMLNAMES"></a>XML
Names</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>
<dt class="label"><a name="XMLNAMES11" id="XMLNAMES11"></a>XML
Names 1.1</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></dd>
<dt class="label"><a name="XMLID" id="XMLID"></a>XML ID</dt>
<dd>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C
Proposed Recommendation. See <a href=
"http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></dd>
<dt class="label"><a name="XMLSchema" id="XMLSchema"></a>XML
Schema</dt>
<dd>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2
(Second Edition)</em>. W3C Recommendation, 28 October 2004. See
<a href=
"http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
<a href=
"http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</dd>
<dt class="label"><a name="datamodel" id=
"datamodel"></a>XQuery/XPath Data Model (XDM)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Data
Model (XDM)</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>
<dt class="label"><a name="XQueryFormalSemantics" id=
"XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal
Semantics</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>
<dt class="label"><a name="FunctionsAndOperators" id=
"FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0
Functions and Operators</em> W3C Candidate Recommendation, 03 Nov.
2005. See <a href=
"http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a>.</dd>
<dt class="label"><a name="serialization" id=
"serialization"></a>XSLT 2.0 and XQuery 1.0 Serialization</dt>
<dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery 1.0
Serialization</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 参考</h3>
<dl>
<dt class="label"><a name="XPath-Requirements" id=
"XPath-Requirements"></a>XPath 2.0 Requirements</dt>
<dd>World Wide Web Consortium. <em>XPath Requirements Version
2.0</em>. W3C Working Draft 22 August 2003. See <a href=
"http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.</dd>
<dt class="label"><a name="xquery" id="xquery"></a>XQuery</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0: An XML Query
Language</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>.</dd>
<dt class="label"><a name="XSLT" id="XSLT"></a>XSLT 2.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT)
2.0.</em> W3C Candidate Recommendation, 03 Nov. 2005. See <a href=
"http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>
<dt class="label"><a name="DOM" id="DOM"></a>Document Object
Model</dt>
<dd>World Wide Web Consortium. <em>Document Object Model (DOM)
Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004.
See <a href=
"http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</dd>
<dt class="label"><a name="XINFO" id="XINFO"></a>XML Infoset</dt>
<dd>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>
<dt class="label"><a name="XPath" id="XPath"></a>XPath 1.0</dt>
<dd>World Wide Web Consortium. <em>XML Path Language (XPath)
Version 1.0</em>. W3C Recommendation, Nov. 16, 1999. See <a href=
"http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
<dt class="label"><a name="XPTR" id="XPTR"></a>XPointer</dt>
<dd>World Wide Web Consortium. <em>XML Pointer Language
(XPointer).</em> W3C Last Call Working Draft 8 January 2001. See
<a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-material" id=
"id-background-material"></a>E.3 背景資料</h3>
<dl>
<dt class="label"><a name="CHARMOD" id="CHARMOD"></a>Character
Model</dt>
<dd>World Wide Web Consortium. <em>Character Model for the World
Wide Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</dd>
<dt class="label"><a name="XSLT1" id="XSLT1"></a>XSLT 1.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT)
1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="id-xpath-conformance" id="id-xpath-conformance"></a>F
適合性</h2>
<p>XPathは主に他の仕様で用いることができる構成要素を意図している。そのため、XPathはそれが用いられる仕様
(<a href="#XPTR">[XPointer]</a>や<a href="#XSLT">[XSLT 2.0]</a>など)
に依存して、それぞれの環境に対してXPathの適合性規範が指定される。XPathの用い方に対して適合性規範を指定している仕様は、XPathの構文や意味の定義をこの仕様で与えられたものから変更してはならない。ただし、一部だけを使用したり、互換性のある拡張を行うことは許される。</p>
<div class="div2">
<h3><a name="id-xpath-static-typing" id=
"id-xpath-static-typing"></a>F.1 静的型付け機能</h3>
<p>[<a name="dt-xpath-static-typing-feature" id=
"dt-xpath-static-typing-feature" title=
"static typing feature">Definition</a>:
<b>静的型付け機能</b>はXPathの選択可能な機能であり、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>に定義されている静的型の支援を提供し、実装が<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>における<a title="type error" href=
"#dt-type-error">型エラー</a>を検出し通知するのに必要である。]
XPathを用いる仕様は、静的型付け機能を用いるための適合性を指定してもよい。</p>
<p>実装が<a title="static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>を支援していないが、それにもかかわらず静的解析相において、ある式を実行時に評価すると型エラーが必然的に発生する、ということが決定できるならば、実装は、静的解析相においてエラーを発生させてもよい。このようなエラーを発生させるかどうかの選択は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
<div class="div3">
<h4><a name="id-xpath-static-extensions" id=
"id-xpath-static-extensions"></a>F.1.1 静的型付け拡張</h4>
<p>ある場合には、<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath
2.0 Formal Semantics]</a>で定義されている静的型付けルールはあまり詳細ではない (例えば、parent,
ancestor, ancestor-or-self
など先祖に関する軸や<code>fn:root</code>関数に関する型推論ルールを見よ)。実装によっては、より詳細な静的型付けルールの支援を期待してもよい。</p>
<p><a title="static typing feature" href=
"#dt-xpath-static-typing-feature">静的型付け機能</a>を実装する適合性実装は、1つ以上の<b>静的型付け拡張</b>も用意してもよい。[<a name="dt-xpath-static-typing-extension"
id="dt-xpath-static-typing-extension" title=
"static typing extension">Definition</a>: <b>静的型付け拡張</b>は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の型推論ルールであり、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>の型推論ルールによる推論よりもより詳細な静的型を推論する。]静的型付け拡張に関する制約の形式的定義については、<a href="http://www.w3.org/TR/xquery-semantics/#id-static-extensions">6.1.1
Static Typing Extensions</a><sup xmlns=
""><small>FS</small></sup>を見よ。</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>G エラー条件</h2>
<dl>
<dt><a name="ERRXPST0001" id="ERRXPST0001"></a>err:XPST0001</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式の解析が、値の割り当てられていない<a title=
"static context" href=
"#dt-static-context">静的文脈</a>の構成要素に依存している。</p>
</dd>
<dt><a name="ERRXPDY0002" id="ERRXPDY0002"></a>err:XPDY0002</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、式の評価が、値の割り当てられていない<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の部分に依存している。</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式が<a href="#id-grammar"><b>A.1
EBNF</b></a>で定義されている文法の正しいインスタンスではない。</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>において、式が、その式の出現する文脈に適さない<a title=
"static type" href="#dt-static-type">静的型</a>を持っていると分かったり、<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>において、値の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>の照合ルールで指定された要求型と照合されない。</p>
</dd>
<dt><a name="ERRXPST0005" id="ERRXPST0005"></a>err:XPST0005</dt>
<dd>
<p>静的解析における<a title="static error" href=
"#dt-static-error">型エラー</a>であり、<code>()</code>または<code>data(())</code>以外の式に割り当てられた<a title="static type"
href=
"#dt-static-type">静的型</a>が<code>empty-sequence()</code>である。</p>
</dd>
<dt><a name="ERRXPTY0006" id="ERRXPTY0006"></a>err:XPTY0006</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPTY0007" id="ERRXPTY0007"></a>err:XPTY0007</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPST0008" id="ERRXPST0008"></a>err:XPST0008</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式が<a title="static context" href=
"#dt-static-context">静的文脈</a>で定義されていない要素名、属性名、スキーマ型名、名前空間接頭辞、変数名を参照している。ただし、<a href="#doc-xpath-ElementTest">ElementTest</a>や<a href="#doc-xpath-AttributeTest">AttributeTest</a>の中での参照を除く。</p>
</dd>
<dt><a name="ERRXPST0010" id="ERRXPST0010"></a>err:XPST0010</dt>
<dd>
<p>実装は、その実装が支援しない軸の参照に出会うと、<a title="static error" href=
"#dt-static-error">静的エラー</a>を発生しなければならない。</p>
</dd>
<dt><a name="ERRXPST0017" id="ERRXPST0017"></a>err:XPST0017</dt>
<dd>
<p><span class="xpath">エラー (ホスト言語環境はこのエラーを<a title="static error"
href="#dt-static-error">静的エラー</a>と定義しても<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>と定義してもよい)</span>であり、関数呼び出し中の引数の展開済QNameや引数の数が、<a title="static context"
href="#dt-static-context">静的文脈</a>中の<a title="function signature"
href="#dt-function-signature">関数シグネチャ</a>の名前や次数と一致しない。</p>
</dd>
<dt><a name="ERRXPTY0018" id="ERRXPTY0018"></a>err:XPTY0018</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、経路式の最後のステップの結果が節点も原子値も含んでいない。</p>
</dd>
<dt><a name="ERRXPTY0019" id="ERRXPTY0019"></a>err:XPTY0019</dt>
<dd>
<p><a title="type error" href="#dt-type-error">型エラー</a>であり、経路式のステップ
(最後のステップ以外) の結果が原子値を含んでいる。</p>
</dd>
<dt><a name="ERRXPTY0020" id="ERRXPTY0020"></a>err:XPTY0020</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、軸ステップで文脈項目が節点ではない。</p>
</dd>
<dt><a name="ERRXPDY0021" id="ERRXPDY0021"></a>err:XPDY0021</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPDY0050" id="ERRXPDY0050"></a>err:XPDY0050</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、<code>treat</code>式の演算数の<a title=
"dynamic type" href=
"#dt-dynamic-type">動的型</a>が<code>treat</code>式で指定された<a title=
"sequence type" href=
"#dt-sequence-type">静的型</a>と一致しない。このエラーは、"<code>/</code>" や
"<code>//</code>"
で始まる経路式のうち、その文脈節点が文書節点を根とする木の中にないときも発生する。これは、経路式の先頭の
"<code>/</code>" や "<code>//</code>" が、節<code>treat as
document-node()</code>を含む初期ステップの省略形だからである。</p>
</dd>
<dt><a name="ERRXPST0051" id="ERRXPST0051"></a>err:XPST0051</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a href=
"#doc-xpath-SequenceType">SequenceType</a>中の<a href=
"#doc-xpath-AtomicType">AtomicType</a>として用いられるQNameが、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中で原子型として定義されていない。</p>
</dd>
<dt><a name="ERRXPST0080" id="ERRXPST0080"></a>err:XPST0080</dt>
<dd>
<p><code>cast</code>式や<code>castable</code>式の目的型は原子型で、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中になくてはならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。後ろに出現標識
"<code>?</code>" が続いてもよい。そうでない場合は<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXPST0081" id="ERRXPST0081"></a>err:XPST0081</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<span class=
"xpath">式</span>で用いられているQNameが、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いても名前空間URIに展開できない名前空間接頭辞を含む。</p>
</dd>
<dt><a name="ERRXPST0083" id="ERRXPST0083"></a>err:XPST0083</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-glossary" id="id-glossary"></a>H 用語集
(Non-Normative)</h2>
<dl>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic
value</dt>
<dd><b>原子値</b>は<a href="#XMLSchema">[XML
Schema]</a>で定義される<b>原子型</b>の値空間に含まれる値である。</dd>
<dt><a name="GLdt-atomization" id=
"GLdt-atomization"></a>atomization</dt>
<dd>列の<b>原子化</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and
Operators]</a>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available collections</dt>
<dd>
<b>利用可能コレクション</b>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。</dd>
<dt><a name="GLdt-available-docs" id=
"GLdt-available-docs"></a>available documents</dt>
<dd>
<b>利用可能文書</b>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<a title=
"data model" href=
"#dt-datamodel">データモデル</a>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。</dd>
<dt><a name="GLdt-axis-step" id="GLdt-axis-step"></a>axis step</dt>
<dd>
<b>軸ステップ</b>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<b>軸</b>はステップでの
"移動方向" を定義し、<a title="node test" href=
"#dt-node-test">節点テスト</a>は節点の種類、名前、<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>により節点を選択する。</dd>
<dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base URI</dt>
<dd><b>基底URI</b>。 これは絶対URIであり、
(例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。</dd>
<dt><a name="GLdt-built-in-function" id=
"GLdt-built-in-function"></a>built-in function</dt>
<dd>XPathで支援されている<b>組み込み関数</b>は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている。</dd>
<dt><a name="GLdt-collation" id="GLdt-collation"></a>collation</dt>
<dd>
<b>照合順序</b>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>を見よ。</dd>
<dt><a name="GLdt-comma-operator" id=
"GLdt-comma-operator"></a>comma operator</dt>
<dd>
列を構成する1つの方法は、<b>コンマ演算子</b>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。</dd>
<dt><a name="GLdt-constructor-function" id=
"GLdt-constructor-function"></a>constructor function</dt>
<dd>与えられた型に対する<b>構成子関数</b>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数
<code>T($arg)</code>の意味は式<code>($arg cast as
T?)</code>と同じであると定義される。</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context
item</dt>
<dd><b>文脈項目</b>は現在処理している項目である。項目は原子値か節点である。</dd>
<dt><a name="GLdt-context-item-static-type" id=
"GLdt-context-item-static-type"></a>context item static type</dt>
<dd><b>文脈項目の静的型</b>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<a title=
"static type" href="#dt-static-type">静的型</a>を定義する。</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context
node</dt>
<dd>文脈項目が節点であるとき、<b>文脈節点</b>と呼ぶこともできる。</dd>
<dt><a name="GLdt-context-position" id=
"GLdt-context-position"></a>context position</dt>
<dd><b>文脈位置</b>は、現在処理されている項目列中での文脈項目の位置である。</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context
size</dt>
<dd><b>文脈サイズ</b>は、現在処理されている項目列に含まれる項目数である。</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current
dateTime</dt>
<dd><b>現在のdateTime</b>。この情報は<span class=
"xpath">式</span>の処理の間のある<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<span class="xpath">式</span>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
model</dt>
<dd>XPathは、XML文書の抽象 的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<b>データモデル</b>と呼ばれ、<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>で定義されている。</dd>
<dt><a name="GLdt-data-model-schema" id=
"GLdt-data-model-schema"></a>data model schema</dt>
<dd><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中のある節点に対して、<b>データモデルスキーマ</b>は、その節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が導出されたスキーマとして定義される。</dd>
<dt><a name="GLdt-def-collation" id=
"GLdt-def-collation"></a>default collation</dt>
<dd><b>デフォルト照合順序</b>。これは、明示的に照合順序が指定されていないときに、<a title=
"statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型
(およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。</dd>
<dt><a name="GLdt-default-collection" id=
"GLdt-default-collection"></a>default collection</dt>
<dd>
<b>デフォルトコレクション</b>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。</dd>
<dt><a name="GLdt-def-elemtype-ns" id=
"GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<b>デフォルト要素/型名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default
function namespace</dt>
<dd>
<b>デフォルト関数名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。</dd>
<dt><a name="GLdelimiting-token" id=
"GLdelimiting-token"></a>delimiting terminal symbol</dt>
<dd><b>区切り終端記号</b>は: ",", "$", "(", ")", "=", "!=", "&lt;=",
"&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[",
"]", ".", "?", "-", "+", "&lt;", <a href=
"#prod-xpath-Comment">Comment</a>, "/", "//", ":"</dd>
<dt><a name="GLdt-document-order" id=
"GLdt-document-order"></a>document order</dt>
<dd>直観的には、<b>文書順</b>は直列化されたXML文書中で節点が出現する順序である。</dd>
<dt><a name="GLdt-dynamic-context" id=
"GLdt-dynamic-context"></a>dynamic context</dt>
<dd>式の<b>動的文脈</b>は、その式が評価されているときに利用可能な情報として定義される。</dd>
<dt><a name="GLdt-dynamic-error" id=
"GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<b>動的エラー</b>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd><b>動的評価相</b>は式の値を計算する相である。</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic
type</dt>
<dd><b>動的型</b>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<a title=
"static type" href=
"#dt-static-type">静的型</a>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
value</dt>
<dd>ある値の<b>有効ブール値</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。</dd>
<dt><a name="GLdt-empty-sequence" id=
"GLdt-empty-sequence"></a>empty sequence</dt>
<dd>0個の項目を含む列を<b>空列</b>という。</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error
value</dt>
<dd>
識別可能なQNameに加え、動的エラーは、説明的な文字列や、<b>エラー値</b>と呼ばれる1つ以上の付加的な値を伴ってもよい。</dd>
<dt><a name="GLdt-expanded-qname" id=
"GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<b>展開済QName</b>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>ある式に対する<b>式文脈</b>は、その式の結果に影響を与えうるすべての情報からなる。</dd>
<dt><a name="GLdt-filter-expression" id=
"GLdt-filter-expression"></a>filter expression</dt>
<dd><b>選別式</b>は、単に、1つの<b>基本式</b>の後ろに0個以上の<a title="predicate" href=
"#dt-predicate">述語</a>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の最初の3つの構成要素
(文脈項目、文脈位置、文脈サイズ)を、式の<b>焦点</b>という。</dd>
<dt><a name="GLdt-function-implementation" id=
"GLdt-function-implementation"></a>function implementation</dt>
<dd><b>関数の実装</b>。<a title="function signature" href=
"#dt-function-signature">関数のシグネチャ</a>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。</dd>
<dt><a name="GLdt-function-signature" id=
"GLdt-function-signature"></a>function signature</dt>
<dd>
<b>関数のシグネチャ</b>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<a title="expanded QName"
href="#dt-expanded-qname">展開済QName</a>と次数 (引数の数) によって一意に識別される。</dd>
<dt><a name="GLdt-gregorian" id="GLdt-gregorian"></a>Gregorian</dt>
<dd>演算子の写像表で、<b>Gregorian</b>という用語は、<code>xs:gYearMonth</code>型,
<code>xs:gYear</code>型, <code>xs:gMonthDay</code>型,
<code>xs:gDay</code>型, <code>xs:gMonth</code>型を表す。</dd>
<dt><a name="GLIgnorableWhitespace" id=
"GLIgnorableWhitespace"></a>ignorable whitespace</dt>
<dd><b>無視可能な空白</b>は、<a title="whitespace" href=
"#Whitespace">空白</a>文字のうち<a title="terminal" href=
"#terminal">終端記号</a>の間に出現してもよいものである。ただし、これらの文字が<a href=
"#ExplicitWhitespaceHandling">ws:explicit</a>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない
(<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
明示的空白処理</b></a>を見よ)。</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<b>実装定義</b>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<b>実装依存</b>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
timezone</dt>
<dd><b>暗黙タイムゾーン</b>。これは、タイムゾーンを持たない data, time,
dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<a title="implementation defined"
href=
"#dt-implementation-defined">実装定義</a>の値である。タイムゾーンの正しい値の範囲については<a href="#XMLSchema">[XML
Schema]</a>を見よ。</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
attribute declarations</dt>
<dd><b>有効範囲内属性定義</b> 各属性定義は<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位属性定義に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の属性識別子
(局所属性定義に対して)のいずれかで識別される。</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd><b>有効範囲内要素定義</b>。各要素定義は、<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位要素定義に対して)か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の要素識別子
(局所要素定義に対して)のいずれかで識別される。</dd>
<dt><a name="GLdt-in-scope-namespaces" id=
"GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
要素節点の<b>有効範囲内名前空間</b>性質は、<b>名前空間束縛</b>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
definitions</dt>
<dd>
<b>有効範囲内スキーマ定義</b>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope schema
type</dt>
<dd><b>有効範囲内スキーマ型</b>。各スキーマ型定義は、 <a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (<b>名前付けされた型</b>に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の型識別子
(<b>無名型</b>に対して)のいずれかで識別される。有効範囲内スキーマ型は<a href=
"#id-predefined-types"><b>2.5.1
既定義スキーマ型</b></a>で述べられる既定義スキーマ型を含む。</dd>
<dt><a name="GLdt-in-scope-variables" id=
"GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd><b>有効範囲内変数</b>。これは組 (展開済QName, 型)
の集合であり、式中で参照可能な変数の集合を定義する。<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>は変数名、型はその変数の<a title="static type"
href="#dt-static-type">静的型</a>である。</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd><b>項目</b>は<a title="atomic value" href=
"#dt-atomic-value">原子値</a>か<a title="node" href=
"#dt-node">節点</a>である。</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>節点テストのもう一つの形式は<b>種類テスト</b>と呼ばれる。これは、節点の種類、名前、<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>に基づき、節点を選択することができる。</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd><b>リテラル</b>は原子値の直接的構文表現である。</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>QNameまたはワイルドカードのみからなる節点テストを<b>名前テスト</b>という。</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd><b>節点</b>は<a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>で定義されている<b>節点の種類</b>のいずれかのインスタンスである。</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd><b>節点テスト</b>は、<a title="step" href=
"#dt-step">ステップ</a>によって選択された節点それぞれについて真にならなければならない条件である。</dd>
<dt><a name="GLnon-delimiting-token" id=
"GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt>
<dd><b>非区切り終端記号</b>は: "return", "for", "in", "some", "every",
"satisfies", "if", "then", "else", "eq", "ne", "lt", "le", "gt",
"ge", "is", "child", "descendant", "attribute", "self",
"descendant-or-self", "following-sibling", "following",
"namespace", "parent", "ancestor", "preceding-sibling",
"preceding", "ancestor-or-self", "empty-sequence", "item", "node",
"document-node", "text", "comment", "processing-instruction",
"schema-attribute", "element", "schema-element", <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>, "external", <a href=
"#prod-xpath-EscapeQuot">EscapeQuot</a>, <a href=
"#prod-xpath-EscapeApos">EscapeApos</a>, <a href=
"#prod-xpath-QName">QName</a>, <a href=
"#prod-xpath-NCName">NCName</a>, <a href=
"#prod-xpath-Char">Char</a>, <a href=
"#prod-xpath-Digits">Digits</a></dd>
<dt><a name="GLdt-numeric" id="GLdt-numeric"></a>numeric</dt>
<dd>型を参照するとき、<b>数</b>という用語は<code>xs:integer</code>型,
<code>xs:decimal</code>型, <code>xs:float</code>型,
<code>xs:double</code>型を表す。</dd>
<dt><a name="GLdt-numeric-predicate" id=
"GLdt-numeric-predicate"></a>numeric predicate</dt>
<dd>述語式が数型を返す述語を<b>数述語</b>という。</dd>
<dt><a name="GLdt-operator-function" id=
"GLdt-operator-function"></a>operator function</dt>
<dd>
各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<b>演算子関数</b>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。</dd>
<dt><a name="GLdt-path-expression" id=
"GLdt-path-expression"></a>path expression</dt>
<dd><b>経路式</b>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の <a title="step"
href="#dt-step">ステップ</a>の並びからなり、各ステップは "<code>/</code>" または
"<code>//</code>", で区切られている。また、経路式は "<code>/</code>" または
"<code>//</code>"で始まる場合もある。</dd>
<dt><a name="GLdt-predicate" id="GLdt-predicate"></a>predicate</dt>
<dd>
<b>述語</b>は式からなり、角括弧で囲まれる。この式のことを<b>述語式</b>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd><b>基本式</b>(primary
expression)はXPath言語の基本原式である。これにはリテラル、変数参照、文脈項目式、関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。</dd>
<dt><a name="GLdt-principal-node-kind" id=
"GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
軸はそれぞれ<b>主要節点種類</b>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>QName</dt>
<dd>
字句としては、<b>QName</b>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。</dd>
<dt><a name="GLdt-reverse-document-order" id=
"GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>文書順の逆順であるような節点の順序を<b>逆文書順</b>という。</dd>
<dt><a name="GLdt-schema-type" id="GLdt-schema-type"></a>schema
type</dt>
<dd><b>スキーマ型</b>(schema type)は<a href="#XMLSchema">[XML
Schema]</a>の機能(<a href="#XMLSchema">[XML
Schema]</a>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<b>複合型</b>か<b>単純型</b>のいずれかである。単純型はさらに<b>リスト型</b>、<b>共用体型</b>、<b>原子型</b>に分けられる(これらの用語の定義と説明は<a href="#XMLSchema">[XML
Schema]</a>を見よ)。</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd><b>列</b>は0個以上の<a title="item" href=
"#dt-item">項目</a>の順序付きコレクションである。</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>sequence type</dt>
<dd><b>列型</b>(sequence type)は<a href=
"#doc-xpath-SequenceType">SequenceType</a>の構文を用いて表現することのできる型である。列型は、XPath式で型を参照する必要があるときにはいつでも用いられる。<b>列型</b>という用語は、この構文がXPathの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>式の評価の間、既知の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される<a title="sequence type" href=
"#dt-sequence-type">列型</a>に「照合」されるか決定する必要があることがある。この処理を<b>SequenceTypeの照合</b>という。</dd>
<dt><a name="GLdt-serialization" id=
"GLdt-serialization"></a>serialization</dt>
<dd><b>直列化</b>は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>をオクテット列に変換する処理である(図1の段階DM4)。</dd>
<dt><a name="GLdt-singleton" id="GLdt-singleton"></a>singleton</dt>
<dd>ただ一つの項目しか含まない列を<b>単一値列</b>という。</dd>
<dt><a name="GLstable" id="GLstable"></a>stable</dt>
<dd>文書順は<b>安定</b>である。ここで安定とは、ある<span class=
"xpath">式</span>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であっても)ことを意味する。</dd>
<dt><a name="GLdt-static-collations" id=
"GLdt-static-collations"></a>statically known collations</dt>
<dd><b>静的既知照合順序</b>。これは組 (URI, 照合順序)の<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の集合である。式の処理に用いることのできる照合順序の名前を定義する。</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically known collections</dt>
<dd>
<b>静的既知コレクション</b>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。</dd>
<dt><a name="GLdt-known-default-collection" id=
"GLdt-known-default-collection"></a>statically known default
collection type</dt>
<dd>
<b>静的既知デフォルトコレクション型</b>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically
known documents</dt>
<dd><b>静的既知文書</b>。
これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<a title="static type"
href="#dt-static-type">静的型</a>である。</dd>
<dt><a name="GLdt-static-namespaces" id=
"GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd><b>静的既知名前空間</b>。これは、組(接頭辞,
URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。</dd>
<dt><a name="GLdt-static-analysis" id=
"GLdt-static-analysis"></a>static analysis phase</dt>
<dd><b>静的解析相</b>は式自身と<a title="static context" href=
"#dt-static-context">静的文脈</a>に依存する。<b>静的解析相</b>は入力データ(スキーマを除く)には依存しない。</dd>
<dt><a name="GLdt-static-context" id=
"GLdt-static-context"></a>static context</dt>
<dd>式の<b>静的文脈</b>は、その式の評価よりも静的解析において有効である情報である。</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static
error</dt>
<dd><b>静的エラー</b>は静的解析相で検出されなければならないエラーである。構文エラーは<a title=
"static error" href="#dt-static-error">静的エラー</a>の例である。</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static
type</dt>
<dd>式の<b>静的型</b>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。</dd>
<dt><a name="GLdt-xpath-static-typing-extension" id=
"GLdt-xpath-static-typing-extension"></a>static typing
extension</dt>
<dd><b>静的型付け拡張</b>は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の型推論ルールであり、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>の型推論ルールによる推論よりもより詳細な静的型を推論する。</dd>
<dt><a name="GLdt-xpath-static-typing-feature" id=
"GLdt-xpath-static-typing-feature"></a>static typing feature</dt>
<dd><b>静的型付け機能</b>はXPathの選択可能な機能であり、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>に定義されている静的型の支援を提供し、実装が<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>における<a title="type error" href=
"#dt-type-error">型エラー</a>を検出し通知するのに必要である。</dd>
<dt><a name="GLdt-step" id="GLdt-step"></a>step</dt>
<dd><b>ステップ</b>は<a title="path expression" href=
"#dt-path-expression">経路式</a>の一部であり、項目の列を生成し、その列を0個以上の<a title=
"predicate" href=
"#dt-predicate">述語</a>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<a title="axis step"
href="#dt-axis-step">軸ステップ</a>または<a title="filter expression" href=
"#dt-filter-expression">選別式</a>のいずれかである。</dd>
<dt><a name="GLdt-string-value" id="GLdt-string-value"></a>string
value</dt>
<dd>
節点の<b>文字列値</b>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。</dd>
<dt><a name="GLdt-substitution-group" id=
"GLdt-substitution-group"></a>substitution group</dt>
<dd><b>置換グループ</b>は<a href="#XMLSchema">[XML Schema]</a>第1部,
2.2.2.2節で定義されている。直観的には、与えられた要素(<b>先導要素</b>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。</dd>
<dt><a name="GLdt-subtype-substitution" id=
"GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd><a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される型から導出されるような値を用いることを<b>部分型置換</b>という。</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>文法中の各規則は1つの<b>記号</b>を定義する。ここで用いられる形式は以下の通りである。
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
</dd>
<dt><a name="GLsymbolseparators" id="GLsymbolseparators"></a>symbol
separators</dt>
<dd><b>記号区切り</b>としての<a title="whitespace" href=
"#Whitespace">空白</a>や<a href=
"#doc-xpath-Comment">Comments</a>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<a href="#ws-explicit">/*
ws: explicit */</a>という備考や、<a href="#parse-note-xml-version">/* xgs:
xml-version */</a>という備考で禁止されている場所を除く。</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<b>終端記号</b>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。</dd>
<dt><a name="GLdt-type-annotation" id=
"GLdt-type-annotation"></a>type annotation</dt>
<dd><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の要素節点や属性節点はそれぞれ<b>型注釈</b>(<a href="#datamodel">[XQuery/XPath
Data Model
(XDM)]</a>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<a title=
"schema type" href="#dt-schema-type">スキーマ型</a>であり、節点の<a title=
"string value" href="#dt-string-value">文字列値</a>と<a title=
"typed value" href="#dt-typed-value">型付けされた値</a>の関連を記述する。</dd>
<dt><a name="GLdt-typed-value" id="GLdt-typed-value"></a>typed
value</dt>
<dd>
節点の<b>型付けされた値</b>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
error</dt>
<dd><b>型エラー</b>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<a title=
"static type" href=
"#dt-static-type">静的型</a>とその式の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href=
"#dt-type-error">型エラー</a>が発生する。動的評価相では、値の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>とその値の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する。</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type
promotion</dt>
<dd>ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<a href=
"#id-function-calls"><b>3.1.5 関数呼び出し</b></a>を見よ)や演算子の評価 (<a href=
"#mapping"><b>B.2 演算子の写像</b></a>を見よ)のときに、<b>型の昇格</b>が用いられる。</dd>
<dt><a name="GLdt-URI" id="GLdt-URI"></a>URI</dt>
<dd>この仕様書では、<b>URI</b>という用語は、<a href=
"#RFC3986">[RFC3986]</a>で定義され<a href=
"#RFC3987">[RFC3987]</a>で新しい名前<b>IRI</b>として拡張されたUniversal Resource
Identifierを表す。</dd>
<dt><a name="GLdt-value" id="GLdt-value"></a>value</dt>
<dd><a title="data model" href=
"#dt-datamodel">データモデル</a>では、<b>値</b>は常に<a title="sequence" href=
"#dt-sequence">列</a>である。</dd>
<dt><a name="GLdt-variable-reference" id=
"GLdt-variable-reference"></a>variable reference</dt>
<dd><b>変数参照</b>は$記号にQNameを続けたものである。</dd>
<dt><a name="GLdt-variable-values" id=
"GLdt-variable-values"></a>variable values</dt>
<dd><b>変数の値</b>。これは、組 (展開済QName, 値)の集合である。式の<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>と同じ<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が含まれる。</dd>
<dt><a name="GLdt-warning" id="GLdt-warning"></a>warning</dt>
<dd><a title="static error" href=
"#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、<a title="type error" href=
"#dt-type-error">型エラー</a>に加えて、XPathの実装は、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>、<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>のいずれかで<b>警告</b>を発生してもよい。警告が発生する状況や、警告を処理する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>whitespace</dt>
<dd><b>空白</b>文字は、<a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>で定義される任意の文字である。</dd>
<dt><a name="GLdt-data-model-instance" id=
"GLdt-data-model-instance"></a>XDM instance</dt>
<dd><b>XDMインスタンス</b>という用語は<b>値</b>という用語と同義であり、<a title="data model"
href="#dt-datamodel">データモデル</a>中の<a title="node" href=
"#dt-node">節点</a>や<a title="atomic value" href=
"#dt-atomic-value">原子値</a>からなる制約なしの列を表す。</dd>
<dt><a name="GLdt-xpath-compat-mode" id=
"GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd><b>XPath 1.0互換モード</b>。<span class=
"xpath">この値が<code>true</code>であるのは、XPathバージョン1.0への後方互換性のためのルールが有効である場合である。そうでない場合は<code>false</code>になる。</span></dd>
<dt><a name="GLdt-anyAtomicType" id=
"GLdt-anyAtomicType"></a>xs:anyAtomicType</dt>
<dd>
<code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>,
<code>xs:string</code>,
<code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。</dd>
<dt><a name="GLdt-dayTimeDuration" id=
"GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt>
<dd>
<code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xs:untyped</dt>
<dd>
<code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>として用いられる。</dd>
<dt><a name="GLdt-untypedAtomic" id=
"GLdt-untypedAtomic"></a>xs:untypedAtomic</dt>
<dd>
<code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。</dd>
<dt><a name="GLdt-yearMonthDuration" id=
"GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt>
<dd>
<code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-backwards-compatibility" id=
"id-backwards-compatibility"></a>I XPath 1.0 との後方互換性
(Non-Normative)</h2>
<p>この附録では、XPath 2.0 と<a href="#XPath">[XPath
1.0]</a>との非互換性の範囲についてのまとめを提供する。</p>
<p>3つの個別の場合が考えられる:</p>
<ol class="enumar">
<li>
<p>ソース文書がスキーマを持ち、XPath 1.0互換モードが true
として走らせるときに存在する非互換性。この仕様では、このような状況での非互換性の数を極力削って完全に最小になるよう設計されているが、しかしいくつかの違いは残っている。これらをそれぞれ列挙する。</p>
</li>
<li>
<p>XPath 1.0 互換モードが false
に設定されているときに生じる非互換性。この場合、互換性の失われる式の数はより多くなる。</p>
</li>
<li>
<p>ソース文書がスキーマを用いて処理されるときに生じる非互換性 (XPath 1.0互換モードが true
に設定されているかどうかに関わらず)。スキーマを用いて文書を処理すると、節点の値を解釈する方法が変化する。これにより XPath
式が異なる結果を返す。</p>
</li>
</ol>
<div class="div2">
<h3><a name="id-incompat-in-true-mode" id=
"id-incompat-in-true-mode"></a>I.1 互換モードが true のときの非互換性</h3>
<p>以下のリストには、この仕様の範囲内で、互換モードが true で動作する XPath 2.0 処理器が、XPath 1.0
処理器により同じ式を処理したときと異なる結果を生成するような既知の場合がすべて含まれている。ただし、その式は XPath 1.0
で妥当であり、ソース文書の節点は
<code>xs:untyped</code>と<code>xs:untypedAtomic</code>以外の型注釈を持たないと仮定する。</p>
<p>個々の関数の振舞いに関する非互換性はここには列挙していない。<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>の附録に含まれている。</p>
<p>XPath 1.0 も XPath 2.0
も、仕様のある面を実装定義として残しているため、特定の実装の振舞いについての非互換性で、この仕様の範囲外のものがあってもよい。それらの振舞いの面の一部はホスト言語で定義されている。</p>
<ol class="enumar">
<li>
<p><code>A &lt; B &lt; C</code>のように連続した比較演算子は XPath 1.0
では支援されるが、XPath 2.0 の文法では許されない。多くの場合、XPath 1.0
のこのような比較は直観的に明らかな意味を持たなかった。そのため、このような比較が現実に広く用いられているということは考えられない。このような構成要素が見つかれば、XPath
2.0 処理器は構文エラーを通知し、また構成要素を<code>(A &lt; B) &lt;
C</code>と書き換えることができる。</p>
</li>
<li>
<p>文字列を数に変換するとき
(明示的に<code>number</code>関数を使うときも、暗黙的に関数呼び出しを行うときも)、XPath 1.0
において特別な値 <code>NaN</code>に変換される文字列は、XPath 2.0
では<code>NaN</code>以外の値に変換される。これには<code>+</code>が先頭に書かれた数、指数による浮動小数点記法
(<code>1.0e+9</code>など)、文字列<code>INF</code>や<code>-INF</code>などが含まれる。</p>
</li>
<li>
<p>XPath 2.0
は、空白の出現なしに、数リテラルの直後に文字から始まるトークンが置かれることを許さない。例えば、<code>10div
3</code>は XPath 1.0 では許されたが、XPath 2.0 では<code>10 div
3</code>というように書かれなければならない。</p>
</li>
<li>
<p>XPath 2.0 では名前空間軸は推奨されない。実装は、XPath 1.0
との後方互換性のため名前空間軸を支援してもよいが、支援する必要はない。(XSLT 2.0 は、XPath
後方互換性モードが支援されていれば、名前空間軸もまた支援されなければならない。しかし他のホスト言語では異なる適合性ルールを定義してもよい。)</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-in-false-mode" id=
"id-incompat-in-false-mode"></a>I.2 互換性モードが false のときの非互換性</h3>
<p>XPath 1.0 互換モードが false に設定されていても、多くの XPath 式は XPath 1.0 の下でも
XPath 2.0 の下でもやはり同じ結果を生成する。例外をこの節で述べる。</p>
<p>どの場合でも、質問中の式は XPath 1.0 の下で正しいと仮定する。また、XPath 1.0 互換モードが false
であり、すべての要素と属性はそれぞれ<code>xs:untyped</code>または<code>xs:untypedAtomic</code>と注釈付けされていると仮定する。</p>
<p>以下の記述では、<em>節点集合</em>と<em>数</em>という用語を XPath 1.0
の意味で用いる。すなわち、XPath 1.0 のルールに従ってそれぞれ節点集合と数を生成する式を記述するのに用いる。</p>
<ol class="enumar">
<li>
<p>単一の節点や値を引数として期待する関数や演算子に、1個より多い節点を含む節点集合が引数として渡されたとき、XPath 1.0
のルールでは、1番目より後ろのすべての節点は捨てられる。XPath 2.0
では、1個より多い節点からなるときには型エラーが発生する。XPath 1.0
の振舞いは、述語<code>[1]</code>を用いて節点集合の最初の節点を明示的に選択することで、常に復元することが可能である。</p>
</li>
<li>
<p>XPath 1.0
では、<code>&lt;</code>演算子や<code>&gt;</code>演算子は、2つの文字列に対して適用されるときは、文字列をともに数に変換し、結果の間で算術比較を行っていた。XPath
2.0 では、これらの演算子はデフォルト照合順序列を用いて文字列比較を行う。(ただし、どちらかの値が数であれば、結果は XPath
1.0 と互換である)</p>
</li>
<li>
<p>
数を引数として期待する関数や演算子に空の節点集合が引数として渡されると、値が暗黙的にNaNに変換される、ということはなくなった。XPath
1.0
の振舞いは、<code>number</code>関数を用いて明示的に変換を行うことにより、常に復元することが可能である。</p>
</li>
<li>
<p>
より一般的には、関数や演算子の引数が要求型に暗黙的に変換されるということはなくなった。ただし、渡された引数が<code>xs:untypedAtomic</code>の場合を除く
(これはスキーマを持たない文書中の節点が引数として渡されたときの共通の場合である)。例えば、関数呼び出し<code>substring-before(10
div 3, ".")</code>は、XPath 2.0 では型エラーを発生する。XPath 1.0
の振舞いは、構成子関数や型変換を用いて要求型に明示的に変換を行うことにより、復元することが可能である。</p>
</li>
<li>
<p>節点集合とブール値を比較するルールが変更されている。XPath 1.0 では、<code>$node-set =
true()</code>のような式は、節点集合をブール値に変換した後ブール値の比較を行うことで評価していた。したがってこの式は、<code>$node-set</code>が空でなければ<code>true</code>を返す。XPath
2.0
では、列と単一値列の間の他の比較と同様の方法で処理される。この式は、原子化および型変換ルールを用いたブール値への変換の後、値が<code>true</code>であるような節点が1つ以上<code>$node-set</code>に含まれていれば<code>true</code>である。</p>
<p>このことは、<code>$node-set</code>が空であれば、XPath 2.0
の下での結果はブール型の演算数の値に関わらず、そしてどの演算子が用いられたかに関わらず、<code>false</code>である、ということを意味している。<code>$node-set</code>が空でなければ、多くの場合、ブール値と比較した結果は失敗し、動的エラーを返すことが普通である。しかし、節点が値
"0", "1", "true", "false" を持っている場合は、式の評価は成功するかもしれない。</p>
</li>
<li>
<p>数とブール値の比較、数と文字列の比較、文字列とブール値の比較は XPath 2.0
では許されない。これらは型エラーになる。XPath 1.0
では、これらの比較は許されており、一方の演算数をもう一方の演算数の型に変換することで処理されていた。したがって、例えば XPath
1.0 では<code>4 = true()</code>は true であり、<code>4 = "+4"</code>は
false (なぜなら、文字列<code>+4</code>は<code>NaN</code>に変換されるから),
<code>false = "false"</code>は false であった
(なぜなら文字列<code>"false"</code>はブール値<code>true</code>に変換されるから)。XPath
2.0 ではこれらの比較はいずれも型エラーである。</p>
</li>
<li>
<p>新たな数型が追加された。その結果、算術演算は integer, decimal,
単倍長浮動小数点、二倍長浮動小数点として計算してもよい。以前は、算術演算は常に二倍長浮動小数点として計算されていた。<code>div</code>演算子で2つの整数を除算した結果は、double
型ではなく decimal 型の値である。式<code>10 div
0</code>は、正の無限大を返すのではなく、エラーを発生する。</p>
</li>
<li>
<p>
数を文字列に変換するルールが変更されている。これにより、数をスタイルシート外部に表示する方法が影響を受けるかもしれない。絶対値が1E-6から1E+6の範囲内である数に対しては、結果は全く同じであるべきである。しかしこの範囲外では、整数でない<code>xs:float</code>や<code>xs:double</code>の値に対して科学的形式が用いられる。</p>
</li>
<li>
<p>文字列を数に変換するルールが変更されている。XPath 1.0 互換モードが true
の時に適用される変更に加えて、互換モードが false のとき、文字列
<code>Infinity</code>と<code>-Infinity</code>が正の無限大、負の無限大の表現として認識されることはなくなった。<code>number</code>関数は、すべての認識できない文字列を<code>NaN</code>に変換するという動作を続けるが、文字列を数に型変換する操作は、このような文字列に対して動的エラーを起こす。</p>
</li>
<li>
<p>XPath 2.0
の多くの演算では、1つ以上の演算数が空列であるとき、その結果として空列を生成する。演算が文字列を期待するとき、空列は通常長さ0の文字列と等価であるとみなされる。これは
XPath 1.0
の振舞いと互換である。しかし、演算が数を期待するとき、結果は等しくない。例えば、<code>@width</code>が空列を返すならば、XPath
1.0 では<code>@width+1</code>の結果は<code>NaN</code>であった。しかし XPath 2.0
では、この結果は<code>()</code>である。この影響として、<code>item[@width+1 !=
2]</code>のような選別式は、XPath 1.0
では属性<code>width</code>を持たない項目が選択されるが、XPath 2.0
ではそのような項目は選択されない。</p>
</li>
<li>
<p>XPath 2.0
におけるコメント節点、処理命令節点、名前空間節点の型付き値は<code>xs:string</code>型であり、<code>xs:untypedAtomic</code>ではない。このことは、数を期待される文脈で値が用いられても暗黙的な変換は行われない、ということを意味している。例えば、もし処理命令節点が算術演算子の演算数として用いられるならば、XPath
1.0 では節点の文字列値を数に変換しようと試みていた (そして成功すれば<code>NaN</code>を生成していた)。しかし
XPath 2.0 では型エラーを通知する。</p>
</li>
<li>
<p>XPath 1.0 では、<code>A and B</code>の形の式では、Aが false であれば B
は評価されないと定義されていた。同様に、<code>A or B</code>の場合には、A が true であれば B
は評価されなかった。XPath 2.0
では、これは保証されなくなった。実装は、2つの演算数をその順に評価しても並列に評価しても自由である。この変更により、索引により支援されるような巨大なデータコレクションに対して
XPath
式が評価されるような状況において、最適化の可能性がより大きくなる。実装は、この部分において後方互換性を保つことを選択してもよいが、そうすることは義務ではない。</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-when-using-schema" id=
"id-incompat-when-using-schema"></a>I.3 スキーマを用いた場合の非互換性</h3>
<p>
スキーマに基づいて処理された文書にXPath式を適用すると、スキーマのない同じ文書に対して同じ式を適用した場合と常に同じ結果になるとは限らない。スキーマ処理はXPath
1.0
の式の結果に影響を与えないので、このことにより更なる非互換性が起こるかもしれない。この節では、起こりうる違いについて、いくつかの例を挙げる。</p>
<p>文脈節点が要素節点であり、以下のマークアップから導出されているとする: <code>&lt;background
color="red green blue"/&gt;</code>。XPath 1.0
では、述語<code>[@color="blue"]</code>は<code>false</code>を返す。XPath 2.0
では、属性<code>color</code>がスキーマで<code>xs:NMTOKENS</code>型であると定義されていれば、同じ述語が<code>true</code>を返す。</p>
<p>同様に、式<code>@birth &lt; @death</code>を要素<code>&lt;person
birth="1901-06-06" death="1991-05-09"/&gt;</code>に適用することを考える。XPath
1.0 では、この式は false
を返す。なぜなら、2つの属性がともに数に変換され、どちらの場合も<code>NaN</code>を返すからである。XPath 2.0
では、スキーマ中にこれらの属性が日付であると注釈付けされていた場合、この式は<code>true</code>を返す。</p>
<p>
いったんスキーマ検証が適用されると、要素や属性は、異なるデータ型を期待する式の演算数や引数として用いることはできない。例えば、日付に対して<code>substring</code>関数を適用して年を取得したり、数に<code>substring</code>関数を適用して整数部分を取得したりすることはできなくなった。同様に、属性がブール型と注釈付けされていると、それを文字列<code>"true"</code>や<code>"false"</code>と比較することはできない。これらの演算はすべて型エラーになる。このようなエラーが起こるときの救済策は、明示的な変換を導入するか、同じ計算を別の方法で行うかである。例えば、<code>substring-after(@temperature,
"-")</code>は<code>abs(@temperature)</code>と書き換えられるかもしれない。</p>
<p>静的型付け機能を提供している XPath 2.0 の実装では、XPath 1.0
の下では動作していた式についてさらに多くの型エラーが通知される。例えば、<code>round(../@price)</code>のような式は静的型エラーになるかもしれない。なぜなら処理器は、<code>../@price</code>が数であるという保証を静的に推論することができないからである。</p>
<p>スキーマ検証は多くの場合、要素の内容に空白の正規化を行う
(要素の型に依存する)。これにより、<code>string-length</code>関数のような演算の結果が変化する。</p>
<p>スキーマ検証は、省略された属性や空の要素に対してデフォルト値を追加することによりデータモデルを拡張する。</p>
</div>
</div>
<div class="div1">
<h2><a name="id-revisions-log" id="id-revisions-log"></a>J Revision
Log (Non-Normative)</h2>
<p>This log records the substantive and significant editorial
changes that have been made to this document since the Candidate
Recommendation Draft of 03 November 2005. Minor editorial changes
are not included in this log.</p>
<div class="div2">
<h3><a name="id-log-050707" id="id-log-050707"></a>J.1 10 May
2006</h3>
<ol class="enumar">
<li>
<p>Deleted all references to the namespace
<code>http://www.w3.org/2005/xpath-datatypes</code>, formerly known
by the prefix <code>xdt:</code>, and moved all the schema types
defined in this namespace to the namespace
<code>http://www.w3.org/2001/XMLSchema</code>, known in this
document by the prefix <code>xs:</code>. All built-in schema types
used by XPath and XQuery are now consolidated in the
<code>xs:</code> namespace.</p>
<p>This change closes Bugzilla entry 2548. It affects many sections
throughout this document and other XPath and XQuery
specifications.</p>
</li>
<li>
<p>Deleted a paragraph requiring the functions <code>fn:doc</code>
and <code>fn:collection</code> to be stable (returning the same
results when called repeatedly.) Stability of these functions is
now covered in the Functions and Operators specification. The
functions are stable by default but an implementation may provide a
user option to relax this requirement.</p>
<p>This change closes Bugzilla entry 2553. Section affected:
<a href="#id-input-sources"><b>2.4.4 入力源</b></a></p>
</li>
<li>
<p>A cast expression or constructor function whose target type is
<code>xs:QName</code> or is derived from <code>xs:QName</code> or
<code>xs:NOTATION</code> formerly required its operand to be a
literal string. Now it accepts either a literal string or an
expression whose base type is the same as the base type of the
target type. For example, it is now possible to cast a value of
type <code>xs:QName</code> to <code>my:BigQName</code> which is
derived from <code>xs:QName</code>.</p>
<p>This change closes Bugzilla entry 2678. Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#id-cast"><b>3.10.2 Cast</b></a></p>
</li>
<li>
<p><a href="#id-constructor-functions"><b>3.10.4 構成子関数</b></a></p>
</li>
<li>
<p>Error code XPST0083 is eliminated (all casts and calls to
constructor functions with invalid operands raise XPTY0004.)</p>
</li>
</ol>
</li>
<li>
<p>Modified the definition of Effective Boolean Value to specify
that a value of type <code>xs:anyURI</code> is treated the same as
a value of type <code>xs:string</code> (a consequence of placing
<code>xs:anyURI</code> and <code>xs:string</code> in the same
promotion hierarchy).</p>
<p>This change closes Bugzilla entry 2545. Section affected:
<a href="#id-ebv"><b>2.4.3 有効ブール値</b></a></p>
</li>
<li>
<p>When a namespace prefix cannot be resolved, error code XPST0081
is raised rather than the more generic error XPST0008.</p>
<p>This change closes Bugzilla entry 2447. Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#node-tests"><b>3.2.1.2 節点テスト</b></a></p>
</li>
</ol>
</li>
<li>
<p>When the axis name is omitted from an axis step containing a
SchemaAttributeTest, the default axis is <code>attribute</code>.
Example: <code>part/schema-attribute(color)</code>.</p>
<p>This change closes Bugzilla entry 2527. Section affected:
<a href="#abbrev"><b>3.2.4 省略構文</b></a></p>
</li>
<li>
<p>Equality of QNames is defined by the <code>eq</code> operator,
which performs codepoint-comparisons of the namespace URIs and the
local names, ignoring the namespace prefixes. This is not a change,
but some editorial clarifications have been made in the XPath,
XQuery, and Functions and Operators documents. For example, phrases
such as "QNames are the same" have been replaced by "QNames are
equal as defined by the <code>eq</code> operator", and a new
example has been added to the section on Value Comparisons.</p>
<p>This change closes Bugzilla entry 2634. Sections affected: Minor
editorial changes to various sections and to the definitions of
error codes XQST0034 and XQST0049.</p>
</li>
<li>
<p>An implementation is not required to enforce cardinality
constraints on operands that are not evaluated.</p>
<p>This change closes Bugzilla entry 2708. Section affected:
<a href="#id-errors-and-opt"><b>2.3.4 エラーと最適化</b></a></p>
</li>
<li>
<p>Entries for the <code>eq</code> and <code>ne</code> operators on
the types <code>xs:yearMonthDuration</code> and
<code>xs:dateTimeDuration</code> have been removed from the
operator mapping table. These operators are now handled by
promotion to <code>xs:duration</code>.</p>
<p>This change closes Bugzilla entry 2789. Section affected:
<a href="#mapping"><b>B.2 演算子の写像</b></a></p>
</li>
<li>
<p>Editorial changes have been made to clarify that type promotions
and subtype substitutions may be performed on the operands of all
operators, including value comparisons. This is not a substantive
change.</p>
<p>This change closes Bugzilla entries 2324 and 2631. Sections
affected: <a href="#id-value-comparisons"><b>3.5.1 値比較</b></a> and
<a href="#mapping"><b>B.2 演算子の写像</b></a>.</p>
</li>
<li>
<p>Editorial changes have been made to clarify that a sequence of
adjacent predicates is processed from left to right, and to clarify
the assignment of context positions on reverse axes. This is not a
substantive change.</p>
<p>This change closes Bugzilla entry 2500. Sections affected:
<a href="#id-steps"><b>3.2.1 ステップ</b></a>, <a href=
"#axes"><b>3.2.1.1 軸</b></a>, <a href="#id-predicates"><b>3.2.2
述語</b></a>, and <a href="#id-filter-expr"><b>3.3.2 選別式</b></a>.</p>
</li>
<li>
<p>If multiple errors are detected, an implementation may report
any non-empty subset of the detected errors.</p>
<p>This change closes Bugzilla entry 3122. Section affected:
<a href="#id-kinds-of-errors"><b>2.3.1 エラーの種類</b></a>.</p>
</li>
</ol>
</div>
</div>
</div>
</body>
</html>
