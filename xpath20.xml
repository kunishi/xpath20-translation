<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="cr">
<?translation-notice?>
<header id="id-spec-header">
<title role="spec-conditional" id="x">XML 経路言語 (XPath)</title>
<version role="spec-conditional">2.0</version>
<w3c-designation>CR-xpath20-20060608</w3c-designation>
<w3c-doctype>W3C勧告候補</w3c-doctype>
<pubdate><day>8</day><month>June</month><year>2006</year></pubdate>

<publoc>

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xpath20-20060608/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2006/CR-xpath20-20060608/</loc>
</publoc>

<altlocs>
  
  
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xpath20-20060608/xpath20.xml" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xpath20-20060608/diff-from-20051103.html" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recent revisions</loc>
</altlocs>

<latestloc>

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath20/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20/</loc></latestloc>

<prevlocs>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xpath20-20051103/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xpath20-20050915/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xpath20-20050915/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xpath20-20050404/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xpath20-20050404/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xpath20-20050211/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xpath20-20050211/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/WD-xpath20-20040723/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/WD-xpath20-20040723/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xpath20-20031112/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xpath20-20031112/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xpath20-20030822/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xpath20-20030822/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xpath20-20030502/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xpath20-20030502/</loc>


</prevlocs>

<authlist>
<author role="xpath">
<name>Anders Berglund (XSL WG)</name>

<affiliation>IBM  Research</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:alrb@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">alrb@us.ibm.com</email></author>

<author>
<name>Scott Boag (XSL WG)</name>
<affiliation>IBM  Research</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:scott_boag@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">scott_boag@us.ibm.com</email>

</author><author> <name>Don Chamberlin (XML Query
WG)</name>
<affiliation>IBM Almaden Research Center</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:chamberlin@almaden.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">chamberlin@almaden.ibm.com</email>
</author>

<author><name>Mary F. Fernández (XML Query
WG)</name><affiliation>AT&amp;T Labs</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mff@research.att.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mff@research.att.com</email>
</author>



<author role="xpath">
<name>Michael Kay (XSL WG)</name>
<affiliation>Saxonica</affiliation>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.saxonica.com/</loc>
</author>

<author><name>Jonathan
Robie (XML Query WG)</name><affiliation>DataDirect Technologies</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jonathan.robie@datadirect-technologies.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jonathan.robie@datadirect-technologies.com</email></author>

<author><name>Jérôme Siméon (XML Query
WG)</name><affiliation>IBM T.J. Watson Research Center
</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:simeon@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">simeon@us.ibm.com</email></author>

</authlist>

<status id="id-status">
<p><emph>This section describes the status of this document at the
time of its publication. Other documents may supersede this document.
A list of current W3C publications and the latest revision of this
technical report can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc> at
http://www.w3.org/TR/.</emph></p>

<p>On 3 November 2005, this specification
 
<phrase role="xpath"><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xpath20-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">was published</loc></phrase>
as a
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate
Recommendation</loc>, and a Call for Implementations was announced. This revision is published in order to give visibility to the technical decisions
that have been made so far during this phase of the process
and to allow review by W3C Members and other interested parties.
The maturity
level of the specification remains unchanged, and the work is on track to
move forward to the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed
Recommendation</loc> stage when the exit criteria for
the current phase have been met.</p>

<p>Publication as a Candidate Recommendation does not imply
endorsement by the W3C Membership. This is a draft document and may be
updated, replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in progress.
This specification will remain a Candidate Recommendation until at
least 28 February 2006.</p>

<p>The
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XPath and
XML Query Test Suite</loc> is under development.
Implementors are encouraged to run this test suite and report their results.

</p>

<p>

<phrase role="xpath">This document was jointly produced by the 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> 
and the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc>, 
both of which are part of the 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</phrase></p>

<p>This draft includes corrections and changes based on 


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=XPath&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=2005-04-04&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public comments</loc> 
recorded in the W3C public Bugzilla repository 
(<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Bugs/Public/</loc>) 
used for Last Call issues tracking. A list of substantive changes since the publication of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xpath20-20051103/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc> of 03 November 2005 can be found in <specref ref="id-revisions-log"/>.</p>

<p>Comments on this document are invited and should be made in W3C's 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc> 
(instructions can be found at 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>). 
If access to that system is not feasible, you may send your comments to 
the W3C XSLT/XPath/XQuery mailing list, 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. 
It will be very helpful if you include the string 

<phrase role="xpath">[XPath]</phrase> 
in the subject 
line of your comment, whether made in Bugzilla or in email. Each Bugzilla 
entry and email message should contain only one comment.  Archives of the 
comments and responses are available at 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/ </loc>.</p>
<p>This document was produced by  
<phrase role="xpath">groups</phrase> operating under the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 
2004 W3C Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2002/08/xmlquery-IPR-statements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
patent disclosures</loc> made in connection with the deliverables of the 
XML Query Working Group <phrase role="xpath"> and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/Disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
disclosures</loc> made in connection with the deliverables of the XSL 
Working Group; those pages also include</phrase> instructions for 
disclosing a patent. An individual who has actual knowledge of a patent 
which the individual believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential 
Claim(s)</loc> with respect to this specification should disclose the 
information in accordance with  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 
6 of the W3C Patent Policy</loc>.</p>

</status>

<abstract id="id-abstract"><p role="xpath">XPath 2.0は<bibref ref="datamodel"/>で定義されるデータモデルに適合する値を処理できる式言語で
ある。そのデータモデルはXML文書の木表現を提供し、その他に、整数、文字列、
ブール値といった原子値や、XML文書中の節点への参照や原子値からなる列を提
供する。XPath式の結果は、入力文書から選択された節点、原子値、または、さ
らに一般的に言えば、データモデルで許される任意の列である。この言語の名
前は、最も特徴的な機能である経路式(path expression)に由来している。経路
式はXML木中の節点の階層的な位置を表す手段を提供する。

XPath 2.0は<bibref ref="XPath"/>の上位互換になっており、XPath 1.0に、よ
り豊富なデータ型の支援、文書がXML Schemaを用いて妥当性検証されるときに
有効になる型情報の利用などの機能を加えている。ほとんどすべてのXPath
1.0式について、XPath 2.0でも引き続き同じ結果を得ることを保証するために、
後方互換性モードを提供する。この方針に関する例外を[<specref ref="id-backwards-compatibility"/>]に記している。
</p> 

</abstract>

<langusage>
<language id="JA">Japanese</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>Working Draft. (2001;06;07)</sitem>
</slist>
</revisiondesc>
</header>
<body>

<div1 id="id-introduction">

	<head>まえがき</head> 

	 

	

	<p role="xpath">XPathの主な目的は<bibref ref="XML"/>もしくは<bibref ref="XML1.1"/>の木の節点を指し示すことである。

	XPathの名前は、XML文書の階層的構造を巡航するのに経路記述を用いることに由来している。

	XPathは簡潔な非XML記法を用い、URIやXMLの属性値中でのXPathの利用を容易にしている。</p>

<p><termdef id="dt-datamodel" term="data model">XPathは、XML文書の抽象
的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<term>データモデル</term>と呼ばれ、<bibref ref="datamodel"/>で定義されている。</termdef></p>

	<p role="xpath">XPathは、<bibref ref="XSLT"/>や<bibref ref="xquery"/>などの<term>ホスト言語</term>に埋め込めるように設計されている。XPathには、照合(節点がパターンに照合されるかどうかのテスト)に使用できる自然な部分集合がある。このXPathの使い方は<bibref ref="XSLT"/>で記述されている。</p>

	<p>XQueryバージョン1.0はXPathバージョン2.0の拡張である。XPath2.0でもXQuery 1.0でも構文的に正しく、かつ正常に実行される式はすべて、いずれの言語でも同じ結果を返す。これらの言語は非常に密接に関連しているため、これらの言語の文法や言語記述は、一貫性を保つために共通のソースから生成されており、これらの仕様書の編者は密に協力して作業を進めている。</p>


	<p>またXPathは、以下の仕様書に依存しており、密接に関連している。</p>

	<ulist>
	  <item>
            <p><bibref ref="datamodel"/>では、すべてのXPath式の基礎となるデータモデルを定義する。</p>
	  </item>

	  <item>
	  <p><bibref ref="XQueryFormalSemantics"/>では、XPathの静的な意味を定義する。また動的な意味に関して、形式的ではあるが規範ではない記述を含んでいる。これは、実装を行う人や形式的定義を必要とする人に有用である。</p></item>

          <item>
	  <p>XPathの型システムは<bibref ref="XMLSchema"/>に基づいている。</p>
	  </item>

	  <item>
	  <p>XPathで支援されている組み込み関数ライブラリや演算子は<bibref ref="FunctionsAndOperators"/>で定義される。</p>
	  </item>

	  
	  
        </ulist>
		
	
	<p>この文書は<bibref ref="XML"/>で用いられているのと同じ基本的なEBNF記法を用いて、XPathの文法を規定する。特に注釈を加えない限り(<specref ref="lexical-structure"/>)、空白は<phrase role="xpath">式</phrase>中では意味を持たない。文法の生成規則は、それが記述している特徴とともに紹介される。また、完全な文法は付録 [<specref ref="nt-bnf"/>]で示される。この付録は規定版である。</p>
<p>この文書中の文法の生成規則では、名前を持つ記号には下線を引き、リテラルテキストは二重引用符で囲む。例えば、次の生成規則は関数呼び出しの構文を記述している:</p><scrap headstyle="show"> 
		  <head/> 
		  <prod num="48" id="fakeid_doc-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		   
		</scrap><p>この生成規則は次のように読むべきである: 関数呼び出しは、一つの開き括弧が続く一つのQNameからなる。その開き括弧の次には、省略可能な引数リストが続く。引数リストは(もし存在するならば)1つ以上の式からなり、それらはコンマで区切られる。省略可能な引数リストの次には、1つの閉じ括弧が続く。</p>

		<p>この仕様書では、言語処理のいくつかの面について、<term>実装定義</term>または<term>実装依存</term>という言葉で記述している。</p>

<ulist>
  <item>
    <p><termdef id="dt-implementation-defined" term="implementation defined"><term>実装定義</term>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。</termdef></p>
  </item>
  <item>
    <p>
      <termdef id="dt-implementation-dependent" term="implementation dependent"><term>実装依存</term>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。</termdef></p>
  </item>
</ulist>

<p role="xpath">この仕様書で<term>実装定義</term>または<term>実装依存</term>と記述されている言語の側面は、XPathが埋め込まれているホスト言語の仕様書からさらに制限を受けるかもしれない。</p>

<p>この文書はXPathの動的な意味を規定として定義する。XPathの静的な意味は<bibref ref="XQueryFormalSemantics"/>において規定として定義されている。この文書では、例、および「Note:」というラベルの付けられた資料は説明の目的で用意されたものであり、参考(not normative)である。</p></div1>


<!--
====================================================================
 $Log: xpath20.xml,v $
 Revision 1.3  2006/06/08 17:22:41  matthieu
 updated

 Revision 1.60  2006/06/01 21:31:05  NormanWalsh
 Updated for publication

 Revision 1.59  2006/05/10 11:21:31  NormanWalsh
 Updates from Don (unchecked)

 Revision 1.58  2005/10/25 20:27:38  sboag
 Removed role-"parse-test" from element that holds a clearly incomplete expression.

 Revision 1.57  2005/10/21 04:27:02  sboag
 Don's latest changes.

 Revision 1.56  2005/09/01 20:36:35  NormanWalsh
 Edits from Don

 Revision 1.55  2005/07/27 02:47:41  sboag
 Added a validate of the unassembled doc for target xquery.html, as a sanity check,
 Removed <nt> brackets around QName and NCName, since the don't work and
 I'm not sure how to fix them, of if they should be fixed, at the moment, and
 added xpath- prefix to to id's that were xpath only, but had xquery equivelents
 elsewhere (escapeQuot and escapeAPos).

 Revision 1.54  2005/07/10 07:13:41  sboag
 July 10 draft.

 Revision 1.52  2005/07/08 16:53:30  sboag
 Don's latest edits.  See changes.txt for details.

 Revision 1.51  2005/03/28 14:16:14  NormanWalsh
 Updates from DC

 Revision 1.42  2004/10/26 17:23:48  NormanWalsh
 Pubrules tweaks

 Revision 1.41  2004/10/18 14:56:39  sboag
 Don's checkin.  See changes.txt (1.5) for this checkin for more info.

 Revision 1.40  2004/07/14 21:02:20  NormanWalsh
 Updated function/datatype namespaces; tweaked status; 23 July draft, pubrules clean

 Revision 1.39  2004/07/13 12:20:39  NormanWalsh
 Log update, I think. Not signficant anyway.

 Revision 1.35  2004/06/07 08:27:13  sboag
 Change of Validation stuff, according to request note from Don.

 Revision 1.33  2004/05/31 18:32:21  sboag
 Latest grammar changes, part of last call comments response.  (Sorry for lack
 of fine-grained detail, but CVS has been down for a week.)  The EBNF is a proposal,
 with change markings.

 Revision 1.31  2004/05/14 20:15:52  sboag
 Latest integration effort between Don and Scott.

 Revision 1.27  2003/12/05 01:04:09  sboag
 Change name of Predicates production to PredicateList.  Approved at Oracle F2F, 11/5/03

 Revision 1.26  2003/12/04 21:54:00  sboag
 Global search-replace: DC requests to change the production-names of
 SchemaMode and SchemaContext to ValidationMode and ValidationContext, to more closely match the explanatory text. Editorial change only. Names of other related productions (SchemaContextLoc etc.) remain unchanged.

 Revision 1.25  2003/12/04 16:45:21  sboag
 Change FilterStep to FilterExpr as per http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Nov/0014.html

 Revision 1.24  2003/11/07 01:58:07  NormanWalsh
 Added xpath-dt-static-typing-feature link

 Revision 1.23  2003/11/04 19:23:32  NormanWalsh
 Added required class attributes; added new informative bibl entries

 Revision 1.22  2003/10/30 04:25:50  sboag
 Changed ComputedXMLComment to CompXMLComment, as per http://lists.w3.org/Archives/Public/public-qt-comments/2003Oct/0056.html (editorial discretion taken)

 Revision 1.21  2003/10/28 19:29:20  NormanWalsh
 Tweaked document order per Jeni

 Revision 1.20  2003/10/28 19:25:16  NormanWalsh
 Ran through crlf to get rid of DOS line breaks...sigh.

 Revision 1.19  2003/10/28 13:55:28  NormanWalsh
 Final edits from Don

 Revision 1.16  2003/08/27 01:52:17  sboag
 Fed through dos2unix, to clean up extra CRs.

 Revision 1.15  2003/08/13 18:31:47  NormanWalsh
 Updates from Don on 7 Aug

 Revision 1.13  2003/07/31 18:09:48  sboag
 Don's latest edits, along with the module namespace changed originally outlined in http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0218.html, and approved by XQuery July 30.

 Revision 1.12  2003/07/22 17:59:09  sboag
 Reduce production names to max 20:
 Original Name	Len	New Name	Len
 MustUnderstandExtension	23	MUExtension	11
 QuoteAttributeContentChar	25	QuotAttrContentChar	18
 AposAttributeContentChar	24	AposAttrContentChar	18
 AbbreviatedForwardStep	22	AbbrevForwardStep	17
 AbbreviatedReverseStep	22	AbbrevReverseStep	17
 ComputedDocumentConstructor	27	CompDocConstructor	18
 ComputedElementConstructor	26	CompElemConstructor	19
 ComputedAttributeConstructor	28	CompAttrConstructor	19
 ComputedNamespaceConstructor	28	LocalNamespaceDecl	17
 ComputedXmlProcessingInstruction	32	CompPIConstructor	9
 ComputedTextConstructor	23	CompTextConstructor	19
 XmlProcessingInstruction	24	DirPIConstructor	5
 QuoteAttributeValueContent	26	QuotAttrValueContent	20
 AposAttributeValueContent	25	AposAttrValueContent	20
 ProcessingInstructionTest	25	PITest	6
 SchemaContextLocation	21	SchemaContextLoc	16
 
 Revision 1.11  2003/07/22 14:26:31  sboag
 Latest edits from Don.  Pre production name reduction.

 Revision 1.10  2003/07/08 15:59:35  sboag
 Fixed 2 obvious expression bugs.

 Revision 1.9  2003/07/01 15:21:19  sboag
 Fixed validation, which includes fixing LF problems, termref/termdef attribute mess, and nt fixes.  (stylesheet fix needs to come with this).

 Revision 1.8  2003/06/30 16:18:23  sboag
 Fix double-dash problems inside comments that Mary entered.

 Revision 1.7  2003/06/26 02:37:00  mfernand

 June 25, 2003 - Mary

 Changes to documents:
 =========================
   Modified files:
     lang/XPathXQuery.xml
     lang/expressions.xml
     lang/introduction.xml
     lang/query-prolog.xml
     lang/shared.html
     lang/xquery.html
     lang/xpath.html

   Added file:
     lang/errors.xml

   o Added markup for error definitions and references in all sections.

     - Error definitions are in new file: lang/errors.xml.

   o Added term definitions and references.

     - Additions required some minor editing to sentences/paragraphs so
       that term definitions were self-contained in Glossary.

     - All term definitions in Secs 1 & 2 should be complete.

       Exceptions: definitions of "Optional Features" are not pithy, thus
       not amenable to definition in a glossary.

     - All references in Secs 1 - 4 to terms defined in Secs 1 and 2
       are marked-up.

     - A smattering of term definitions in Secs 3 & 4 are done.
       Whomever continues with term markup should begin here.

     NB: I did not add any new term definitions - - I simply converted as
     many <term> elements as possible to <termdef>s or <termref>s.
     I did not change any term definitions other than to make them
     self-contained.

 Known styling problems (need help from Norm):
 =============================
   o Need to add "spec" attribute to <termdef> to scope term
     definitions within a particular document (e.g., "XP" or "XQ")

     - Current bug: terms that should only be defined in XQuery book
       also appear in XPath book.

   o Glossary should probably be emitted in alphabetic order.

   o Not sure what to do about errors of this kind:

     "style/issues-spec.xsl:248:20: Warning! Cannot point to resolved
     issue: #xquery-abstract-syntax"

 Issues/Questions:
 =============================
   o Should Glossary be labeled as normative?

   o Should Summary of Error Codes be labeled as normative?

 Revision 1.6  2003/06/12 22:31:50  jrobie

 Made the documents consistent with the following grammar changes:

 (a) Use "declare" consistently in prolog (replacing "define") and get
 rid of all uses of "=" except between prefix and URI. See Issue
 547. Changed terminology accordingly - "function definitions" are now
 "function declarations", "user-defined functions" are now
 "user-declared functions", etc.


 (b) Limit comments, pragmas, and extensions to places inside XQuery
 expressions where insignificant whitespace is allowed. See Issue 550.

 (c) Change if-expr so both then-clause and else-clause take ExprSingle,
 not Expr. See Query/May/0006.

 (d) New clause in Prolog: "declare" "base-uri" StringLiteral
 Scope is the module in which it is declared. Proposed by M. Rys in
 Query/Apr/0001 and adopted by Query WG telcon, 5/7/03.


 (h) Change "." to be a primary expr rather than an abbreviated step.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0200.html.

 (i) Change to PITest so it allows an NCName as well as a
 StringLiteral, as proposed by JR.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0256.html.

 (16) Change to Prolog syntax: function declarations can now be mixed
 with variable and other declarations. Approved, Query WG F2F, 5/16/03.

 Revision 1.5  2003/06/10 20:53:47  jrobie
 Processing model diagrams.

 Revision 1.4  2003/06/10 20:48:09  jrobie
 *** empty log message ***

 Revision 1.3  2003/04/18 22:01:52  NormanWalsh
 Editorial nits for pubrules

 Revision 1.2  2003/04/18 19:22:04  sboag
 Don's latest revisions, responding to comments from the working groups.

 Revision 1.1  2003/04/07 22:18:05  sboag
 Initial checkin of language build and parser build.

 Revision 1.29  2002/11/07 21:45:36  sboag
 Integrated new XSL from http://www.w3.org/2002/xmlspec/html/1.4/xmlspec.xsl,
 Fixed a couple minor bugs that this helpful stylesheet flagged.

 Revision 1.28  2002/11/07 19:30:56  sboag
 changed to 2.2 xmlspec, and deleted all xmlspec-v21.xxx.  Fixed BNF
 problem with OcurrenceIndicator.  Fixed prevdoc problem.

 Revision 1.27  2002/11/07 00:27:14  sboag
 Minor changes specified by today's editorial meeting, dictated by Don to me over the phone.

 Revision 1.24  2002/11/05 16:18:45  sboag
 Minor parse test fixes.

 Revision 1.23  2002/11/05 16:13:01  sboag
 Don's final Nov. 15 drafts.

 Revision 1.20  2002/08/14 16:06:35  sboag
 Fixed up example URLs to use example.org.

 Revision 1.18  2002/08/12 03:02:22  sboag
 Fixed problems with comments from previous check-in.

 Revision 1.17  2002/08/12 02:40:48  sboag
 Check for role="parse-test" for all legitimate expression examples.  ***status: Did the best I could with <code> and <eg> examples.
 -> fixed discovered bug in grammar where document {...} constructor did not work.
 -> fixed bug with processing instruction content... I had to add a PROCESSING_INSTRUCTION_CONTENT state.
 -> fixed minor bug with end tag not being closed in expressions.xml (ugh, took me 30 minutes to track down).
 -> in section on "Other Constructors", broke samples into separate <eg>s, so they will parse (otherwise they expect an operator between them).
 -> fixed problem with CDataSection outside of element content.  (...if PI, XMLComments work, so should CDataSection, I guess).
 -> broke some/every examples in section on "Quantified Expressions" into two <eg> tags, since they can process sequentially.
      -> Also had to conditionalize these examples for XPath, so that the TypeDeclaration wasn't
           used (actually, it seems useless here).
 -> Fixed many problems with "validate".  However, see note on '"validate" seems to be reserved'.  Two of the fragments currently won't parse.

 Revision 1.15  2002/08/10 22:01:47  sboag
 Changed "default collation at" to "default collation ="

 Revision 1.14  2002/08/04 21:06:21  sboag
 The following changes from the last F2F:

 (1) Delete "precedes" and "follows" operators from OrderComp.

 (2) Change name of TypeAssertion production to TypeDeclaration.

 (3) Add the following new production:

 DefaultCollationDecl ::= "default" "collation" StringLiteral

 (A collation is identified by a URI, so you can use a more specific symbol in place of StringLiteral that indicates that a URI is expected, if you want to.)

 (4) Delete the production for ResultTypeDecl.

 (5) QueryProlog should now include DefaultCollationDecl but not ResultTypeDecl, as follows:

 QueryProlog ::= (NamespaceDecl | DefaultNamespaceDecl | SchemaImport | XMLSpaceDecl
    | DefaultCollationDecl)* FunctionDefn*

 Revision 1.13  2002/07/28 19:53:05  sboag
 Don's new documents.

 Revision 1.12  2002/07/04 18:29:22  sboag
 Simply made prerecap ref refer to itself.  This was a regression, because at one
 point I had deleted this production.

 Revision 1.11  2002/06/28 09:02:07  sboag
 Merged Don's latest work with new grammar proposal.  Changes too numerous
 to detail.

 Revision 1.10  2002/04/24 22:48:30  sboag
 Fixed minor problem with lists-within-lists-within-paragraphs.

 Revision 1.9  2002/04/24 22:21:18  sboag
 Don's changes assigned to him by this morning's telcon.

 Revision 1.8  2002/04/24 02:48:08  sboag
 CSS, HTML, Link validation passes.  Parser tests pass.  Updated to target
 pub date of April 30.

 Revision 1.6  2002/04/23 17:20:33  sboag
 Removed DocumentElement from production 61, as per WG decision.
 Fixed Dana's company and email address.
 Added section on reserved words (list is mechanically generated).
 Addressed the following issues in the lexical section from
 (http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Jan/0002.html),
 lengthy Michael Dyck.  Not all issues have been addressed yet.
 <item priority="2" status="done"> <description>para 1: "Whitespace may be
 		  freely added within patterns" What do you mean by "patterns"? Presumably,
 		  you're either talking about adding the symbol 'Whitespace' to grammar
 		  productions, or adding whitespace (i.e., sequences of characters) to queries.
 		  Don't confuse the two.</description></item>
 <item priority="2" status="done"> <description>"before or after any
 		  token" But you never actually define what a token is. It's not even clear what
 		  the set of token-types is. (Is it the set of left-hand-sides of producbtions 75
 		  through 216? Is it the set of symbols that appear in the "tokens" column of the
 		  TRANITION STATES table? The two are different, and both contain symbols that
 		  probably shouldn't be considered token-types.)</description></item>
 <item status="done"> <description>para 1 and bullets 1 and 2: Note that
 		  the Whitespace symbol derives the empty string, but phrases like "must always
 		  be followed by whitespace" and "whitespace may not occur" obviously mean
 		  "whitespace" in the sense of "a non-empty string of whitespace-characters". I
 		  think this shows correct usage, and there's no reason for Whitespace to be
 		  nullable. (That is, it should be the same as S.)</description></item>
 <item status="done"> <description>bullet 3: "A space" We're interested in
 		  whitespace, not just a space.</description></item>
 <item status="done"> <description>"may be significant" Don't tell us that
 		  it *may* be significant. Tell us exactly when it *is*
 		  significant.</description></item>
 <item status="done"> <description>para 2: "Tokens may be often only
 		  recognized" "may be often only" is clunky.</description></item>
 <item status="done"> <description>"in a specific state" You haven't
 		  defined states yet.</description></item>
 <item status="done"> <description>"within the evaluation": Does
 		  evaluation of a query include its parsing/lexing?</description></item>
 <item status="done"> <description>"may cause the grammar to transition to
 		  a different state" Grammars don't have states or transitions. Automata
 		  do.</description></item>
 <item status="done"> <description>"following the enumeration of tokens"
 		  Change "tokens" to "token-types".</description></item>
 <item status="done"> <description>para 3: "When tokenizing, the longest
 		  possible token is always returned" Issue 109 says this means "the longest
 		  sequence that would form a token in the token-space of the grammar, not the
 		  longest that would be valid in the current syntactic context." Does
 		  it?</description></item>
 <item status="done"> <description>"If there is an ambiguity between two
 		  tokens, ..." Presumably, you mean an ambiguity that isn't resolved by the
 		  longest-match rule.</description></item>
 <item status="done"> <description>"the token that an lower grammar
 		  number" Change "an" to "a".</description></item>
 <item status="done"> <description>is more specific than" Why do we care
 		  which is "more specific"? We want to know which is the right one. I'll assume
 		  that's what you mean.</description></item>

 Revision 1.5  2002/04/22 15:23:24  sboag
 Don says: I believe that these drafts contain all the substantive comments
 that were raised at the Cambridge task force meetings and subsequent
 telcons. These are the drafts that will be reviewed for publication. Additional
 minor editorial changes may be made before the documents are actually
 submitted to w3c.

 Revision 1.1  2002/04/01 20:10:30  sboag
 Jonathan Robie changes, including removal of fragment.xml and inclusion of
 expressions.xml, etc.
 Merge of his grammar with latest.


 Revision 1.42  2001/12/17 20:27:29  sboag
 Fixes for every-header-has-to-have-an-id.

 Revision 1.41  2001/12/16 06:31:59  sboag
 Minor fix to the comment ednote.

 Revision 1.37  2001/12/14 20:47:43  sboag
 Fixed some bad links.

 Revision 1.36  2001/12/14 17:21:26  sboag
 Fixed link.

 Revision 1.28  2001/12/11 17:09:44  sboag
 Don's suggested modifications to the grammar.  Also temporarily commented
 out the pathx1 build, 'till I get it fixed.

 Revision 1.27  2001/12/10 02:45:49  sboag
 Fixed some of the code examples that read <p><code>some example</code></p>.

 Revision 1.25  2001/12/09 22:07:16  sboag
 Fixed problem with comments from previous checkin.

 Revision 1.24  2001/12/09 21:39:37  sboag
 [batch checkin] Added {- - comment - -} type comments.  Added ";" list 
 query processing.  Added some stuff for ^char handling in reg 
 expressions, in order to support CharData better, but backed 
 out of this (but left some of the support in.  Removed old type def 
 and group stuff (can look to previous versions if we want to add this 
 back in).  Changed to case sensitivity in grammar, and updated 
 fragment.xml.  Added optional (AT schemaLocation)? to SchemaImport.  
 Other minor changes in support of WG decisions.

 Revision 1.23  2001/12/08 15:15:25  sboag
 Jonathan and Scott tweaked paragraph about QName escape.

 Revision 1.22  2001/12/07 23:34:28  sboag
 Add note about escaping QNames in the Basics section, pending resolution
 of the issue about what to do about possible EQName token.  Don needs to review.
 Removed paragraph again about enclosed expressions in element constructors. 

 Revision 1.20  2001/12/07 08:55:45  sboag
 Made rule about space before "<" be xquery spec only.

 Revision 1.19  2001/12/07 08:29:26  sboag
 Added ednote about space before "<" rule.

 Revision 1.18  2001/12/07 08:19:17  sboag
 Add <{foo}/> syntax, as per direction of XQuery WG.  Need to check about the
 enclosed expression syntax for attribute names, which I also added.

 Revision 1.17  2001/12/07 07:36:15  sboag
 Fix data-type section for XPath (remove Typeswitch, CaseClause).

 Revision 1.16  2001/12/07 07:06:38  sboag
 Changed BuiltInType to SimpleType in grammar and text.
 Removed Remove *:*.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral.
 Took a shot at fixing the "-" lexical rule in arithmatic section.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral. 

==================================================================== 
-->
<!-- 

float*date

send a value to a function that is expecting a node

"make a list of the errors that can be determined statically"

-->
<div1 id="id-basics">
  <head>基本事項</head> 
	 <p>XPathの基本的な構成ブロックは<term>式</term>である。これは<bibref ref="Unicode"/>文字(使用されるUnicodeの版は<termref def="dt-implementation-defined">実装定義</termref>である。)の列である。この言語には、キーワード、記号、演算数などから構成される様々な種類の式が用意されている。一般的に、式の演算数は別の式である。XPathでは、式は完全に一般的な入れ子であってもよい。</p>
	 <note><p>この仕様書では、<bibref ref="Unicode"/>文字の文字列の文字符号化方式に関して、何も仮定しないし、何も要求しない。</p></note><p>XMLと同様に、XPathは大文字小文字を区別する言語である。XPathのキーワードは小文字を用い、かつ予約されていない。すなわち、XPath式に出現する名前はXPath言語のキーワードと同じであってもよい。ただし<specref ref="id-reserved-fn-names"/>に挙げられている接頭語なし関数名を除く。</p> 
	  
	 <p><termdef term="value" id="dt-value"><termref def="dt-datamodel">データモデル</termref>では、<term>値</term>は常に<termref def="dt-sequence">列</termref>である。</termdef> <termdef id="dt-sequence" term="sequence">
<term>列</term>は0個以上の<termref def="dt-item">項目</termref>の順序付きコレクションである。</termdef>
<termdef id="dt-item" term="item">
	 <term>項目</term>は<termref def="dt-atomic-value">原子値</termref>か<termref def="dt-node">節点</termref>である。</termdef>
<termdef id="dt-atomic-value" term="atomic value"><term>原子値</term>は<bibref ref="XMLSchema"/>で定義される<term>原子型</term>の値空間に含まれる値である。</termdef>
<termdef id="dt-node" term="node"><term>節点</term>は<bibref ref="datamodel"/>で定義されている<term>節点の種類</term>のいずれかのインスタンスである。</termdef>
各節点は唯一の<term>節点識別性</term>、1つの<term>型付けされた値</term>、そして1つの<term>文字列値</term>を持つ。これに加え、いくつかの節点は<term>名前</term>を持つ。節点の<term>型付けされた値</term>は0個以上の原子値からなる列である。節点の<term>文字列値</term>は<code>xs:string</code>型の値である。節点の<term>名前</term>は<code>xs:QName</code>型の値である。</p> 
	 <p><termdef id="dt-singleton" term="singleton">ただ一つの項目しか含まない列を<term>単一値列</term>という。</termdef>項目は、その項目を含む単一値列と同一である。列が入れ子になることは決してない。例えば1, (2, 3), () という値を一つの列に結合した結果は (1, 2, 3)になる。<termdef id="dt-empty-sequence" term="empty sequence">0個の項目を含む列を<term>空列</term>という。</termdef></p>
	  <p><termdef id="dt-data-model-instance" term="XDM instance"><term>XDMインスタンス</term>という用語は<term>値</term>という用語と同義であり、<termref def="dt-datamodel">データモデル</termref>中の<termref def="dt-node">節点</termref>や<termref def="dt-atomic-value">原子値</termref>からなる制約なしの列を表す。</termdef> </p>
	  <p>XPathにおける名前は<term>QName</term>と呼ばれ、<bibref ref="XMLNAMES"/>中の文法に従う。<termdef id="dt-qname" term="QName">字句としては、<term>QName</term>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。</termdef> 字句としてのQNameは、<termref def="dt-static-namespaces">静的既知名前空間</termref><errorref code="0081" class="ST"/>を用いて名前空間接頭辞を名前空間URIに解決することにより、<term>展開済QName</term>に変換することができる。 <termdef id="dt-expanded-qname" term="expanded QName"><term>展開済QName</term>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。</termdef>名前空間URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>のためのルールに従って、空白に関して正規化される。2つの展開済QNameが等しいとは、それらの名前空間URIが等しく、かつそれらの局所名が等しいときである(それらの名前空間接頭辞が等しくなくてもよい)。名前空間URIと局所名はコード位置に基づいて比較され、それ以上の正規化は行われない。</p>

	  <p><phrase role="xpath">この文書では、以下の名前空間接頭辞を、以下に列挙する名前空間URIを表すものとして用いる。この文書でのこれらの名前空間接頭辞の束縛は参考である。</phrase></p>
	  <ulist>

<item><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></item>

<item><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></item>
<item role="xpath"><p><code>err = http://www.w3.org/2005/xqt-errors</code> (<specref ref="id-identifying-errors"/>を見よ)</p></item>

</ulist>

	 <p>要素節点は<term>有効範囲内名前空間</term>と呼ばれる性質を持つ。<termdef term="in-scope namespaces" id="dt-in-scope-namespaces">要素節点の<term>有効範囲内名前空間</term>性質は、<term>名前空間束縛</term>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。</termdef></p>

	 <p role="xpath"><bibref ref="XPath"/>では、要素節点の有効範囲内名前空間は、<term>名前空間軸</term>上に配置される<term>名前空間節点</term>のコレクションとして表される。XPathバージョン2.0では、名前空間軸は推奨されず、ホスト言語によって支援される必要もない。名前空間軸を支援しないホスト言語では、名前空間束縛を節点の形で表現する必要はない。</p>
<p><termdef term="URI" id="dt-URI">この仕様書では、<term>URI</term>という用語は、<bibref ref="RFC3986"/>で定義され<bibref ref="RFC3987"/>で新しい名前<term>IRI</term>として拡張されたUniversal Resource Identifierを表す。</termdef> ただし、IRIよりもURIという用語を好んで残している。"Base URI"のように、すべてのXML関連の仕様書で定義され、また参照されてきた概念に新しい名前を与えることを避けるためである。</p>
	 <div2 id="context"> 
	   <head>式文脈</head>
	   <p>
	     <termdef id="dt-expression-context" term="expression context">ある式に対する<term>式文脈</term>は、その式の結果に影響を与えうるすべての情報からなる。</termdef> この情報は<termref def="dt-static-context">静的文脈</termref>と<termref def="dt-dynamic-context">動的文脈</termref>という2種類に分けられる。</p>
		 
		<div3 id="static_context"> 
		  <head>静的文脈</head> 
		  <p><termdef id="dt-static-context" term="static context">式の<term>静的文脈</term>は、その式の評価よりも静的解析において有効である情報である。</termdef> この情報は、式が<termref def="dt-static-error">静的エラー</termref>を含むかどうか決定するのに用いることができる。もし式の解析が、<termref def="dt-static-context">静的文脈</termref>中の値を割り当てられていない構成要素に依存するならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref code="0001" class="ST"/>。</p> 
		  <p><termref def="dt-static-context">静的文脈</termref>の構成要素を以下にまとめる。<phrase role="xpath">各構成要素のデフォルト初期値はホスト言語で指定されていてもよい。各構成要素の有効範囲は<specref ref="id-xp-static-context-components" role="xpath"/>で指定されている。</phrase> </p>
		   
		  <ulist> 
		    <item><p><termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode"><term>XPath 1.0互換モード</term>。<phrase role="xpath">この値が<code>true</code>であるのは、XPathバージョン1.0への後方互換性のためのルールが有効である場合である。そうでない場合は<code>false</code>になる。</phrase></termdef></p></item> 
			 <item> 
				<p><termdef id="dt-static-namespaces" term="statically known namespaces"><term>静的既知名前空間</term>。これは、組(接頭辞, URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。</termdef> URIの値は<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>と<termref def="dt-static-namespaces">静的既知名前空間</termref>の違いに注意せよ。前者は要素節点の動的性質であり、後者は式の静的性質である。</p>

			 </item> 
			 <item> 
				<p><termdef id="dt-def-elemtype-ns" term="default element/type namespace"><term>デフォルト要素/型名前空間</term>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。</termdef> URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			 </item> 
			 <item> 
				<p><termdef id="dt-def-fn-ns" term="default function namespace"><term>デフォルト関数名前空間</term>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。</termdef> URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			  </item> 
			 <item> 
				<p><termdef id="dt-issd" term="in-scope schema definitions"><term>有効範囲内スキーマ定義</term>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。</termdef> 次の3つの部分を含む。</p><ulist><item><p>

			        <termdef id="dt-is-types" term="in-scope schema type"><term>有効範囲内スキーマ型</term>。各スキーマ型定義は、 <termref def="dt-expanded-qname">展開済QName</termref> (<term>名前付けされた型</term>に対して) か<termref def="dt-implementation-dependent">実装依存</termref>の型識別子 (<term>無名型</term>に対して)のいずれかで識別される。有効範囲内スキーマ型は<specref ref="id-predefined-types"/>で述べられる既定義スキーマ型を含む。



                         </termdef></p>

</item>


<item><p><termdef id="dt-is-elems" term="in-scope element declarations"><term>有効範囲内要素定義</term>。各要素定義は、<termref def="dt-expanded-qname">展開済QName</termref> (最上位要素定義に対して)か<termref def="dt-implementation-dependent">実装依存</termref>の要素識別子 (局所要素定義に対して)のいずれかで識別される。</termdef> 要素定義は、その要素の<termref def="dt-substitution-group">置換グループ</termref>の加入に関する情報を含む。</p>
<p><termdef term="substitution group" id="dt-substitution-group"><term>置換グループ</term>は<bibref ref="XMLSchema"/>第1部, 2.2.2.2節で定義されている。直観的には、与えられた要素(<term>先導要素</term>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。</termdef></p></item>

<item><p><termdef id="dt-is-attrs" term="in-scope attribute declarations"><term>有効範囲内属性定義</term> 各属性定義は<termref def="dt-expanded-qname">展開済QName</termref> (最上位属性定義に対して) か<termref def="dt-implementation-dependent">実装依存</termref>の属性識別子 (局所属性定義に対して)のいずれかで識別される。</termdef></p></item></ulist></item>
<item> <p> <termdef id="dt-in-scope-variables" term="in-scope variables"><term>有効範囲内変数</term>。これは組 (展開済QName, 型) の集合であり、式中で参照可能な変数の集合を定義する。<termref def="dt-expanded-qname">展開済QName</termref>は変数名、型はその変数の<termref def="dt-static-type">静的型</termref>である。</termdef></p>
<p> 変数を束縛する式 (<code>for</code>式, <code>some</code>式, <code>every</code>式など)は、その式の部分式の<termref def="dt-in-scope-variables">有効範囲内変数</termref>を新しく束縛された変数とその型によって拡張する。</p>

			 </item><item><p><termdef term="context item static type" id="dt-context-item-static-type"><term>文脈項目の静的型</term>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<termref def="dt-static-type">静的型</termref>を定義する。</termdef></p></item> 
			 <item> 
				<p><termdef id="dt-function-signature" term="function signature"><term>関数のシグネチャ</term>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<termref def="dt-expanded-qname">展開済QName</termref>と次数 (引数の数) によって一意に識別される。</termdef> 名前と次数に加え、関数のシグネチャはそれぞれ、その関数の引数と結果の<termref def="dt-static-type">静的型</termref>を指定する。</p>

                         <p><termref def="dt-function-signature">関数のシグネチャ</termref>は、<termref def="dt-constructor-function">構成子関数</termref>のシグネチャを含む。これについては<specref ref="id-constructor-functions"/>で議論する。</p>

			 </item> 
			 <item> 
				<p> <termdef id="dt-static-collations" term="statically known collations"><term>静的既知照合順序</term>。これは組 (URI, 照合順序)の<termref def="dt-implementation-defined">実装定義</termref>の集合である。式の処理に用いることのできる照合順序の名前を定義する。</termdef> <termdef term="collation" id="dt-collation"><term>照合順序</term>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<bibref ref="FunctionsAndOperators"/>を見よ。</termdef></p> 
			 </item> 
			 <item> 

				<p> <termdef id="dt-def-collation" term="default collation"><term>デフォルト照合順序</term>。これは、明示的に照合順序が指定されていないときに、<termref def="dt-static-collations">静的既知照合順序</termref>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型 (およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。</termdef></p>

			 </item> 





			 <item> 
		<p><termdef id="dt-base-uri" term="base URI"><term>基底URI</term>。 これは絶対URIであり、 (例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。</termdef> URIの値は<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			 </item>
<item><p> <termdef id="dt-known-docs" term="statically known documents"><term>静的既知文書</term>。 これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<termref def="dt-static-type">静的型</termref>である。</termdef> 
<code>fn:doc</code>の引数が<term>静的既知文書</term>にはない文字列リテラルであるとき、<code>fn:doc</code>の<termref def="dt-static-type">静的型</termref>は<code>document-node()?</code>である。</p>
<note><p><term>静的既知文書</term>の目的は静的型情報を提供することであり、どの文書が利用可能かを決定することではない。URIが<term>静的既知文書</term>中になくても、<code>fn:doc</code>を用いてアクセスできる。</p></note>
</item>

<item><p><termdef id="dt-known-collections" term="statically known  collections"><term>静的既知コレクション</term>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。</termdef> <code>fn:collection</code>の引数が<term>静的既知コレクション</term>にない文字列リテラルであるとき、<code>fn:collection</code>の<termref def="dt-static-type">静的型</termref>は<code>node()*</code>である。</p>
<note><p><term>静的既知コレクション</term>の目的は静的型情報を提供することで、どのコレクションが利用可能かを決定することではない。URIが<term>静的既知コレクション</term>になくても、<code>fn:collection</code>を用いてアクセスできる。</p></note></item>

<item><p><termdef id="dt-known-default-collection" term="statically known default collection type"><term>静的既知デフォルトコレクション型</term>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。</termdef> 実装によって他の値に初期化されない限り、<term>静的既知デフォルトコレクション型</term>の値は<code>node()*</code>である。</p></item>
</ulist> 


</div3>
<div3 id="eval_context"> <head>動的文脈</head> <p><termdef id="dt-dynamic-context" term="dynamic context">式の<term>動的文脈</term>は、その式が評価されているときに利用可能な情報として定義される。</termdef> 式の評価が<termref def="dt-dynamic-context">動的文脈</termref>のうち値が割り当てられていない部分に依存するとき、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0002"/>。</p>
<p><termref def="dt-dynamic-context">動的文脈</termref>の個々の構成要素を以下にまとめる。これらの構成要素の意味を支配する詳細なルールは<specref ref="id-xp-evaluation-context-components" role="xpath"/>にある。</p>
<p><termref def="dt-dynamic-context">動的文脈</termref>は<termref def="dt-static-context">静的文脈</termref>の部分要素すべて、および以下に列挙する追加構成要素を含む。</p>
<p><termdef id="dt-focus" term="focus"><termref def="dt-dynamic-context">動的文脈</termref>の最初の3つの構成要素 (文脈項目、文脈位置、文脈サイズ)を、式の<term>焦点</term>という。</termdef> 焦点を用いると、処理器はどの項目が式によって処理されているかを追跡することができる。</p>
<p>ある種の言語の構成要素、すなわち<termref def="dt-path-expression">経路式</termref> <code role="parse-test">E1/E2</code>と<termref def="dt-predicate">述語</termref> <code role="parse-test">E1[E2]</code>は、部分式の評価の際に新しい焦点を作成する。これらの構成要素では、<code role="parse-test">E1</code>を評価した結果の列中の項目それぞれに対し、<code role="parse-test">E2</code>が1回評価される。 <code role="parse-test">E2</code>が評価されるたびに、異なる焦点で評価が行われる。<code role="parse-test">E2</code>を評価する焦点を<term>内部焦点</term>、<code role="parse-test">E1</code>を評価する焦点を<term>外部焦点</term>という。内部焦点は、<code role="parse-test">E2</code>が評価されている間のみ存在する。この評価が終了するとき、含むほうの式の評価が元の焦点のまま行われる。</p>
<ulist>
  <item> <p><termdef id="dt-context-item" term="context item"><term>文脈項目</term>は現在処理している項目である。項目は原子値か節点である。</termdef><termdef id="dt-context-node" term="context node">文脈項目が節点であるとき、<term>文脈節点</term>と呼ぶこともできる。</termdef> 文脈項目は1つのドット(<code role="parse-test">.</code>)からなる式によって得られる。式<code role="parse-test">E1/E2</code>または<code role="parse-test">E1[E2]</code>が評価されるとき、<code role="parse-test">E1</code>を評価して得られる列中の項目それぞれが、<code role="parse-test">E2</code>の評価に対する内部焦点の文脈項目となる。</p> </item>
 <item> <p><termdef id="dt-context-position" term="context position"><term>文脈位置</term>は、現在処理されている項目列中での文脈項目の位置である。</termdef>文脈項目が変化するたび、文脈位置も変化する。焦点が定義されているとき、文脈位置の値は0より大きい整数である。式<code>fn:position()</code>によって文脈位置が返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点での文脈位置は、<code>E1</code>を評価して得られる列中の文脈項目の位置である。列の最初の項目の位置は常に1である。文脈位置は常に、文脈サイズより小さいか等しい。</p> </item>

<item><p><termdef id="dt-context-size" term="context size"><term>文脈サイズ</term>は、現在処理されている項目列に含まれる項目数である。</termdef> 文脈サイズの値は常に0より大きい整数である。式<code>fn:last()</code>によって文脈サイズが返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点の文脈サイズは、<code>E1</code>の評価で得られる列に含まれる項目数である。</p>
 </item>
			  
<item> 
<p> <termdef id="dt-variable-values" term="variable values"><term>変数の値</term>。これは、組 (展開済QName, 値)の集合である。式の<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-in-scope-variables">有効範囲内変数</termref>と同じ<termref def="dt-expanded-qname">展開済QName</termref>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<termref def="dt-dynamic-type">動的型</termref>が含まれる。</termdef></p>
</item>
<item><p><termdef term="function implementation" id="dt-function-implementation"><term>関数の実装</term>。<termref def="dt-function-signature">関数のシグネチャ</termref>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。</termdef></p></item>
<item> 
<p> <termdef id="dt-date-time" term="current dateTime"><term>現在のdateTime</term>。この情報は<phrase role="xpath">式</phrase>の処理の間のある<termref def="dt-implementation-dependent">実装依存</termref>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<phrase role="xpath">式</phrase>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。</termdef></p>
</item>
<item><p><termdef id="dt-timezone" term="implicit timezone"><term>暗黙タイムゾーン</term>。これは、タイムゾーンを持たない data, time, dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<termref def="dt-implementation-defined">実装定義</termref>の値である。タイムゾーンの正しい値の範囲については<bibref ref="XMLSchema"/>を見よ。</termdef></p></item>
<item><p><termdef id="dt-available-docs" term="available documents"><term>利用可能文書</term>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<termref def="dt-datamodel">データモデル</termref>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。</termdef> 利用可能文書の集合は<termref def="dt-known-docs">静的既知文書</termref>の集合に限定されず、また空集合でもよい。</p></item>
<item><p><termdef id="dt-available-collections" term="available collections"><term>利用可能コレクション</term>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。</termdef> 利用可能コレクションの集合は<termref def="dt-known-collections">静的既知コレクション</termref>の集合に限定されず、また空集合でもよい。</p></item>
<item><p><termdef id="dt-default-collection" term="default collection"><term>デフォルトコレクション</term>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。</termdef> <term>デフォルトコレクション</term>の値は実装によって初期化されてもよい。</p></item>
</ulist> </div3> </div2>
<div2 id="id-processing-model">
<head>処理モデル</head>
<p>XPathは<termref def="dt-datamodel">データモデル</termref>と<termref def="dt-expression-context">式文脈</termref>に基づいて定義される。</p>

<graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XPath.gif" alt="Processing                          Model Overview" role="xpath" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
<p>図1: 処理モデルの概要</p>

<p>図1は、この後詳細を述べる処理段階の概要を図で示したものである。このうちいくつかの段階は完全にXPathの範疇外である。図1では、これらの段階は言語の境界を表す実線の外側、<term>外部処理</term>とラベル付けされた領域に描かれている。外部処理域には、問合せが行われるデータを表現する<termref def="dt-data-model-instance">XDMインスタンス</termref>の生成(<specref ref="id-data-model-generation"/>を見よ)、スキーマの輸入処理(<specref ref="id-schema-import-processing"/>を見よ)、直列化(<specref ref="id-serialization"/>を見よ)などが含まれる。言語の境界の内側は<phrase role="xpath">XPath処理域</phrase>と呼ばれ、静的解析段階と動的評価段階(<specref ref="id-expression-processing"/>を見よ)が含まれる。
<phrase role="xpath">XPath</phrase>処理域上の無矛盾性制約は<specref ref="id-consistency-constraints"/>で定義される。</p>


<div3 id="id-data-model-generation"><head>データモデルの生成</head>

<p><phrase role="xpath">式</phrase>が処理できるようになる前に、式の入力データが<termref def="dt-data-model-instance">XDMインスタンス</termref>として表現されなければならない。この処理はXPathの範囲外で発生し、そのため図1ではこの処理を外部処理域に置いている。以下にXML文書を<termref def="dt-data-model-instance">XDMインスタンス</termref>に変換する段階を示す。</p>

<olist><item><p>文書が、<term>XML情報集合</term>(<bibref ref="XINFO"/>を見よ)を生成するXMLパーザによって解析される。解析された文書は1つ以上のスキーマに対して妥当性検証されてもよい。この処理は<bibref ref="XMLSchema"/>に記述されているが、この結果、<term>検証後情報集合</term>(Post-Schema Validation Infoset, PSVI)と呼ばれる抽象情報構造が得られる。もし文書に関連するスキーマがなければ、文書の情報集合が保存される。(図1のDM1を見よ。)</p>
</item>
<item><p>情報集合もしくはPSVIが、<bibref ref="datamodel"/>に書かれている処理によって<termref def="dt-data-model-instance">XDMインスタンス</termref>に変換される。(図1のDM2を見よ。)</p>
</item></olist>
<p>上に述べた段階は<termref def="dt-data-model-instance">XDMインスタンス</termref>がどのように構築されるかという一例を提供している。XDMインスタンスは関係データベースから直接合成されるかもしれないし、他の方法(図1のDM3を見よ)で構築されるかもしれない。XPathは<termref def="dt-datamodel">データモデル</termref>に基づいて定義されるが、XDMインスタンスがどのように構築されるかについては、制約を何も置かない。</p>

<p><termdef term="type annotation" id="dt-type-annotation"> <termref def="dt-data-model-instance">XDMインスタンス</termref>中の要素節点や属性節点はそれぞれ<term>型注釈</term>(<bibref ref="datamodel"/>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<termref def="dt-schema-type">スキーマ型</termref>であり、節点の<termref def="dt-string-value">文字列値</termref>と<termref def="dt-typed-value">型付けされた値</termref>の関連を記述する。</termdef> <termref def="dt-data-model-instance">XDMインスタンス</termref>が<xspecref spec="DM" ref="const-psvi"/>に述べられているように妥当なXML文書から導出されたならば、要素節点や属性節点の型注釈はスキーマ妥当性検証から導出される。
  XPathは要素節点や属性節点の型注釈に直接アクセスする方法は用意しない。</p>
<p>属性の値は属性節点によって直接表される。型が不明な属性節点(スキーマのない文書に出現する場合など)には<termref def="dt-type-annotation">型注釈</termref> <code>xs:untypedAtomic</code>が与えられる。</p>

<p>要素の値はその要素の子たちによって表される。子にはテキスト節点やほかの要素節点が含まれてもよい。要素節点の<termref def="dt-type-annotation">型注釈</termref>は、その子テキスト節点の値がどのように解釈されるかを示す。妥当性検証されていない要素(スキーマのない文書中に出現する場合など)には、<code>xs:untyped</code>というスキーマ型が注釈付けされる。妥当性検証されて部分的に妥当だとされた要素には<code>xs:anyType</code>というスキーマ型が注釈付けされる。もし要素が<code>xs:untyped</code>と注釈付けされているなら、そのすべての子孫要素節点もまた<code>xs:untyped</code>と注釈付けされる。しかし、もし要素が<code>xs:anyType</code>と注釈付けされているなら、その子孫要素節点のいくつかには、より詳細な<termref def="dt-type-annotation">型注釈</termref>が付けられるかもしれない。</p>


</div3><div3 id="id-schema-import-processing"><head>スキーマの輸入処理</head>

<p role="xpath"><termref def="dt-static-context">静的文脈</termref>内での<termref def="dt-issd">有効範囲内スキーマ定義</termref>はホスト言語によって用意され(図1の段階SI1を見よ)、<specref ref="id-consistency-constraints"/>で定義される無矛盾性制約を満たさなければならない。</p>

</div3><div3 id="id-expression-processing"><head>式の処理</head>
<p>XPathは、<termref def="dt-static-analysis">静的解析相</termref>と<termref def="dt-dynamic-evaluation">動的評価相</termref>という2つの処理相を定義する(図1を参照)。静的解析相では、<termref def="dt-static-error">静的エラー</termref>、<termref def="dt-dynamic-error">動的エラー</termref>、または<termref def="dt-type-error">型エラー</termref>が発生することがある。動的評価相では、<termref def="dt-dynamic-error">動的エラー</termref>と<termref def="dt-type-error">型エラー</termref>のみ発生することがある。これらの種類のエラーは<specref ref="id-kinds-of-errors"/>で定義される。</p>
<p>それぞれの相について、実装はこの文書の仕様に従う結果を得る戦略やアルゴリズムを自由に使ってよい。</p>

<div4 id="id-static-analysis"><head>静的解析相</head>
<p><termdef id="dt-static-analysis" term="static analysis phase"><term>静的解析相</term>は式自身と<termref def="dt-static-context">静的文脈</termref>に依存する。<term>静的解析相</term>は入力データ(スキーマを除く)には依存しない。</termdef></p>
<p>静的解析相では、<phrase role="xpath">XPath式</phrase>は構文解析され、<term>演算木</term>と呼ばれる内部表現となる(図1の段階SQ1)。構文解析エラーは<termref def="dt-static-error">静的エラー</termref>として発生する <errorref class="ST" code="0003"/>。次に<termref def="dt-static-context">静的文脈</termref>が実装によって初期化される(段階SQ2)。<termref def="dt-static-context">静的文脈</termref>はスキーマ型名、関数名、名前空間接頭辞、変数名などを解決するのに用いられる(段階SQ4)。もし、<term>演算木</term>中のこれらの種類のいずれかの名前が<termref def="dt-static-context">静的文脈</termref>になければ、<termref def="dt-static-error">静的エラー</termref>(<errorref class="ST" code="0008"/>もしくは<errorref class="ST" code="0017"/>)が発生する(ただし、<specref ref="id-element-test"/>および<specref ref="id-attribute-test"/>にあるこのルールの例外を見よ)。</p>

<p>次に、<term>演算木</term>は、<termref def="dt-atomization">原子化</termref>、あるいは<termref def="dt-ebv">有効ブール値</termref>の展開といった暗黙的演算を明示化することで、<term>正規化</term>される。正規化処理については<bibref ref="XQueryFormalSemantics"/>で記述されている。</p>

<p>次に、各式に<termref def="dt-static-type">静的型</termref>が付与される(段階SQ6)。<termdef id="dt-static-type" term="static type">式の<term>静的型</term>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。</termdef> もし<termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が支援されているなら、<bibref ref="XQueryFormalSemantics"/>に書かれているルールに従って、さまざまな式の<termref def="dt-static-type">静的型</termref>が推論される。もし<termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が支援されていないなら、割り当てられる静的型は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p><termref def="dt-static-analysis">静的解析相</termref>では、もし<termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が機能しており、かつ式の演算数が、その演算数に適切でない<termref def="dt-static-type">静的型</termref>を持つと分かったならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。静的型検査でエラーが発生せず<termref def="dt-static-type">静的型</termref>Tが式に割り当てられたならば、正当な入力データに対しその式を実行すると、型Tの値が生成されるか<termref def="dt-dynamic-error">動的エラー</termref>となることが保証される。</p>
<p><termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>の目的は、<termref def="dt-type-error">型エラー</termref>の早期検出を提供し、式評価の最適化に役立つ型情報を推論することである。</p>
</div4>
<div4 id="id-dynamic-evaluation"><head>動的評価相</head>
<p><termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase"><term>動的評価相</term>は式の値を計算する相である。</termdef> 動的評価相は<termref def="dt-static-analysis">静的解析相</termref>が完了した後に行われる。</p>
<p>動的評価相は、<termref def="dt-static-analysis">静的解析相</termref>でエラーが検出されなかった場合に限り行うことができる。もし<termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が機能しているなら、静的解析の間にすべての<termref def="dt-type-error">型エラー</termref>が検出され、動的評価相の実行を妨げるのに役立つ。</p>
<p>動的評価相は、評価している式の<term>演算木</term>(段階DQ1)、入力データ(段階DQ4)、<termref def="dt-dynamic-context">動的文脈</termref>(段階DQ5)に依存し、さらに外部環境(段階DQ3)や<termref def="dt-dynamic-context">静的文脈</termref>(段階DQ2)から情報を引き出す。動的評価相は新しいデータモデル値を生成したり(段階DQ4)、値を変数に束縛するなどによりそれを<termref def="dt-dynamic-context">動的文脈</termref>に展開してもよい(段階DQ5)。</p>

<p><termdef term="dynamic type" id="dt-dynamic-type"><term>動的型</term>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<termref def="dt-static-type">静的型</termref>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。</termdef></p>
<p>もし式の演算数が、その演算数に適切でない<termref def="dt-dynamic-type">動的型</termref>を持っていると分かったならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p>式が評価される前に静的型付けで多くの<termref def="dt-type-error">型エラー</termref>がとらえられるとしても、静的解析では検出されなかったエラーが評価時に発生することはあり得る。例えば、式に文字列から整数への型変換が含まれているかもしれない。これは静的には正しい。しかし、もし実行時の実際の文字列の値が整数に変換できないならば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。同様に、式中で<termref def="dt-static-type">静的型</termref>が<code>xs:untypedAtomic</code>であるような値に算術演算子を適用しているかもしれない。これは<termref def="dt-static-error">静的エラー</termref>ではない。しかし実行時では、もしその値が<termref def="dt-numeric">数</termref>型にうまく変換できなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。</p>
<p><termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が有効であるとき、式の静的解析において<termref def="dt-type-error">型エラー</termref>を発生させることは、たとえある入力に対してその式が正常に実行されるとしても、可能である。例えば、引数として要素を要求する関数が式に含まれており、静的解析相でその関数の引数の<termref def="dt-static-type">静的型</termref>が省略可能な要素であると推論されたとする。この場合は、たとえ省略可能な要素が存在するような入力データに対してこの関数呼び出しが正常に行われるとしても、<termref def="dt-type-error">型エラー</termref>として扱われ、評価が妨げられる。</p>
</div4></div3>
<div3 id="id-serialization"><head>直列化</head>
<p><termdef id="dt-serialization" term="serialization"><term>直列化</term>は<termref def="dt-data-model-instance">XDMインスタンス</termref>をオクテット列に変換する処理である(図1の段階DM4)。</termdef> 直列化の一般的な枠組は<bibref ref="serialization"/>に記述されている。</p>



<p role="xpath">ホスト言語が直列化のオプションを用意していてもよい。</p>
</div3>
<div3 id="id-consistency-constraints">

<head>無矛盾性制約</head>
<p>XPathが明確に定義されるためには、入力となる<termref def="dt-data-model-instance">XDMインスタンス</termref>、<termref def="dt-static-context">静的文脈</termref>、<termref def="dt-dynamic-context">動的文脈</termref>が互いに無矛盾でなければならない。以下に列挙する無矛盾性制約はXPathの実装が正しく動作するための前提条件である。これらの無矛盾性制約をどのように強制させるかはこの仕様書の範囲外である。この仕様書は、これらの制約が1つ以上満たされない条件の下での<phrase role="xpath">式</phrase>の結果を定義しない。</p>
<p>無矛盾性制約のいくつかでは<term>データモデルスキーマ</term>という用語を用いる。<termdef id="dt-data-model-schema" term="data model schema"><termref def="dt-data-model-instance">XDMインスタンス</termref>中のある節点に対して、<term>データモデルスキーマ</term>は、その節点の<termref def="dt-type-annotation">型注釈</termref>が導出されたスキーマとして定義される。</termdef> スキーマ妥当性検証以外の処理によって構成された節点に対しては、<term>データモデルスキーマ</term>は、単に、その節点の<termref def="dt-type-annotation">型注釈</termref>によって表現されるスキーマ型定義から成る。</p>
<ulist>



<item><p>型注釈を持つ各節点について、その型注釈が<termref def="dt-issd">有効範囲内スキーマ定義</termref>(ISSD)中にあるなら、ISSD中の定義は<termref def="dt-data-model-schema">データモデルスキーマ</termref>中の定義と等価でなければならない。さらに、<termref def="dt-data-model-schema">データモデルスキーマ</termref>中のある型から拡張によって導出されるすべての型は、それと等価な定義がISSD中にもなければならない。</p>
</item>
<item><p><termref def="dt-data-model-instance">XDMインスタンス</termref>中と<termref def="dt-issd">有効範囲内スキーマ定義</termref>(ISSD)中の両方にある要素名<emph>EN</emph>のそれぞれについて、<emph>EN</emph>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあると分かっている<termref def="dt-data-model-schema">データモデルスキーマ</termref>中のすべての要素は、また<emph>EN</emph>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあると分かっているISSD中の要素でなければならない。</p>
</item>
<item><p>要素名、属性名、<termref def="dt-in-scope-variables">有効範囲内変数</termref>や<termref def="dt-function-signature">関数のシグネチャ</termref>から参照されているスキーマ型名は、いずれも<termref def="dt-issd">有効範囲内スキーマ定義</termref>中になければならない。ただし、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>の部分から参照されている要素名、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>の部分から参照されている属性名は除く。</p>
</item>
<item><p><termref def="dt-issd">有効範囲内スキーマ定義</termref>中に、大域的要素、属性、型名に対する参照がある場合は、対応する要素、属性、型の定義を<termref def="dt-issd">有効範囲内スキーマ定義</termref>中に持っていなければならない。</p>
</item>

<item><p>文字列から<termref def="dt-available-docs">利用可能な文書</termref>中の文書節点への写像それぞれについて、もし同じ文字列から<termref def="dt-known-docs">静的既知文書</termref>中の文書型への写像が存在するなら、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、文書節点はその文書型に照合されなければならない。</p>
</item>
<item><p>文字列から<termref def="dt-available-collections">利用可能コレクション</termref>中の節点列への写像それぞれについて、もし同じ文字列から<termref def="dt-known-collections">静的既知コレクション</termref>中の型への写像が存在するなら、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、節点列はその型に照合されなければならない。</p>
</item>
<item><p><termref def="dt-default-collection">デフォルトコレクション</termref>中の節点列は、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、<termref def="dt-known-default-collection">静的既知デフォルトコレクション</termref>に照合されなければならない。</p>
</item>
<item><p><termref def="dt-context-item">文脈項目</termref>の値は、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、<termref def="dt-context-item-static-type">文脈項目静的型</termref>に照合されなければならない。</p>
</item>
<item><p><termref def="dt-in-scope-variables">有効範囲内変数</termref>中の2つ組 (変数, 型)のそれぞれと、<termref def="dt-variable-values">変数の値</termref>中で対応する2つ組 (変数, 値)のうち変数名が等しいものについて、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、値と型が照合されなければならない。</p>
</item>



<item><p><termref def="dt-static-namespaces">静的既知名前空間</termref>の中で、接頭辞<code>xml</code>は<code>http://www.w3.org/XML/1998/namespace</code>以外の名前空間URIに束縛されてはならず、またこの名前空間URIには<code>xml</code>以外の接頭辞が束縛されてはならない。</p>
</item>
</ulist>
</div3></div2>

<div2 id="errors">
<head>エラー処理</head>

<div3 id="id-kinds-of-errors"><head>エラーの種類</head>
<p><specref ref="id-expression-processing"/>で述べたように、XPathは入力データに依存しない<termref def="dt-static-analysis">静的解析相</termref>と入力データに依存する<termref def="dt-dynamic-evaluation">動的評価相</termref>を定義する。エラーはいずれの相でも発生してよい。</p>

<p><termdef id="dt-static-error" term="static error"><term>静的エラー</term>は静的解析相で検出されなければならないエラーである。構文エラーは<termref def="dt-static-error">静的エラー</termref>の例である。</termdef></p>
<p><termdef id="dt-dynamic-error" term="dynamic error"><term>動的エラー</term>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。</termdef></p>
<p><termdef id="dt-type-error" term="type error"><term>型エラー</term>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<termref def="dt-static-type">静的型</termref>とその式の出現する文脈から期待される型とが一致しないとき、<termref def="dt-type-error">型エラー</termref>が発生する。動的評価相では、値の<termref def="dt-dynamic-type">動的型</termref>とその値の出現する文脈から期待される型とが一致しないとき、<termref def="dt-type-error">型エラー</termref>が発生する。</termdef></p>

<p><termref def="dt-static-analysis">静的解析相</termref>の結果は、成功か、1つ以上の<termref def="dt-type-error">型エラー</termref>、<termref def="dt-static-error">静的エラー</termref>、静的に検出される<termref def="dt-dynamic-error">動的エラー</termref>のいずれかである。<termref def="dt-dynamic-evaluation">動的評価相</termref>の結果は、結果の値か、1つの<termref def="dt-type-error">型エラー</termref>か、1つの<termref def="dt-dynamic-error">動的エラー</termref>のいずれかである。</p>
<p>1つ以上のエラーが現れたり、エラー条件がこの仕様で定義される1つ以上のエラーの範囲内に入ったりすると、これらのエラーの空でない集合が報告されてもよい。</p>

<p><termref def="dt-static-analysis">静的解析相</termref>では、<termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が機能しており、かつ<code>()</code>もしくは<code>data(())</code>以外の式に割り当てられる<termref def="dt-static-type">静的型</termref>が<code>empty-sequence()</code>であるならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0005"/>。これにより、<termref def="dt-issd">有効範囲内スキーマ定義</termref>に存在しない要素や属性を問合せが参照している場合がとらえられる。これは綴りの誤りの可能性があるためである。</p>
<p><termref def="dt-xpath-static-typing-feature" role="xpath">静的型付け機能</termref>が機能しているかどうかに関わらず、もし<termref def="dt-static-analysis">静的解析相</termref>で、ある式が評価されると<termref def="dt-type-error">型エラー</termref>や<termref def="dt-dynamic-error">動的エラー</termref>を発生する必要がある、ということを実装が決定できるならば、実装は<termref def="dt-static-analysis">静的解析相</termref>でエラーを通知してもよい(しかし通知することを要求されるわけではない)。しかし、<code>fn:error()</code>関数は<termref def="dt-static-analysis">静的解析相</termref>では評価されてはならない。</p>
<p><termdef id="dt-warning" term="warning"><termref def="dt-static-error">静的エラー</termref>、<termref def="dt-dynamic-error">動的エラー</termref>、<termref def="dt-type-error">型エラー</termref>に加えて、XPathの実装は、<termref def="dt-static-analysis">静的解析相</termref>、<termref def="dt-dynamic-evaluation">動的評価相</termref>のいずれかで<term>警告</term>を発生してもよい。警告が発生する状況や、警告を処理する方法は<termref def="dt-implementation-defined">実装定義</termref>である。</termdef></p>
<p>この仕様書で定義されるエラーに加えて、実装は、この仕様書の範囲外の理由により<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。例えば、さまざまなオブジェクトの最大数や最大サイズに制限があってもよい。このような制限や、これらを越えることによる結果は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
</div3>
<div3 id="id-identifying-errors"><head>エラーの識別と報告</head>
<p>この仕様書で定義されるエラーは、<code role="xpath">err:XPYYnnnn</code>という形式を持つQNameで識別される。ここで:</p>
<ulist>
<item><p><code>err</code>はXPathおよびXQueryのエラーのための名前空間、<code>http://www.w3.org/2005/xqt-errors</code>を表す。この名前空間接頭辞<code>err</code>の束縛はこの文書内の便宜上用いており、参考である。</p>
</item>
<item role="xpath"><p><code>XP</code>は、そのエラーがXPathのエラーであることを識別する。</p></item>

<item><p><code>YY</code>はエラーの分類を示し、次のような符号化を用いる:</p>
<ulist>
<item><p><code>ST</code>は静的エラーを表す。</p></item>
<item><p><code>DY</code>は動的エラーを表す。</p></item>
<item><p><code>TY</code>は型エラーを表す。</p></item>
</ulist>
</item>
<item><p><code>nnnn</code>は一意に決まる数字コードである。</p></item>
</ulist>
<note><p>XPathのバージョンが変わっても、XPathとXQueryのエラーのための名前空間URIが変わることは期待されない。しかし、この名前空間の内容は、エラー定義が追加されることによって拡張されてよい。</p></note>
<p>XPath処理器がエラー情報を外部環境に報告する方法は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
<p>エラーは、エラーQNameから導出されるURI参照によって次のように表すことができる。名前空間URI<emph><code>NS</code></emph>と局所名<emph><code>LP</code></emph>を持つエラーは、URI参照<emph><code>NS</code></emph><code>#</code><emph><code>LP</code></emph>で表すことができる。例えば、QNameが<code>err:XPST0017</code>であるエラーは<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>で表せる。</p>
<note><p>エラーを識別するコードとともに、実装は、エラーの場所やエラーが検出された処理相などの付加的な情報を返してもよい。実装が付加的な情報を返すことを選択する場合は、この情報を返すのに用いられる機構は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
</note></div3>

<div3 id="id-handling-dynamic"><head>動的エラーの処理</head>
<p>この文書で示した以外に、もし式の演算数が<termref def="dt-dynamic-error">動的エラー</termref>を発生するならば、その式もまた<termref def="dt-dynamic-error">動的エラー</termref>を発生する。もし式が正常に値を返すことも動的エラーを発生することもできるのであれば、実装は、値を返すか動的エラーを発生するか選択してよい。例えば、論理式<code>expr1 and expr2</code>は、いずれかの演算数が<code>false</code>を返すならば値<code>false</code>を返してもよい。またいずれかの演算数が動的エラーを発生すれば動的エラーを発生してもよい。</p>
<p>もし式中の1つ以上の演算数がエラーを発生するならば、実装は、どのエラーがその式によって発生するかを選択してよい。例えば、次の式を考える:</p>
<eg role="parse-test" xml:space="preserve">($x div $y) + xs:decimal($z)</eg>
<p>部分式<code>($x div $y)</code>と<code>xs:decimal($z)</code>はともにエラーを発生するかもしれない。実装は式"<code>+</code>"によってどちらのエラーが発生するか選択してよい。いったん1つの演算数がエラーを発生すれば、実装が他の演算数を評価することは要求されないが、評価してもよい。</p>

<p><termdef id="dt-error-value" term="error value">識別可能なQNameに加え、動的エラーは、説明的な文字列や、<term>エラー値</term>と呼ばれる1つ以上の付加的な値を伴ってもよい。</termdef> 実装は、アプリケーションで定義されるエラー処理器がエラー値を処理し診断メッセージを生成する機構を提供してもよい。</p>

<p>動的エラーは<termref def="dt-built-in-function">組み込み関数</termref>や演算子によって発生してもよい。例えば<code>div</code>演算子は、その演算数が<code>xs:decimal</code>値でかつ第2演算数が0に等しいならば、例外を発生する。組み込み関数や演算子によって発生するエラーは<bibref ref="FunctionsAndOperators"/>で定義されている。</p>

<p>動的エラーは明示的に<code>fn:error</code>関数を呼び出すことによっても発生する。この関数はエラーを1つ発生させるだけで、値は返さない。この関数は<bibref ref="FunctionsAndOperators"/>で定義されている。例えば、次に示す関数呼び出しは動的エラーを発生する。発生する動的エラーは、エラーを識別するQName、説明的な文字列、診断値からなる(接頭辞<code>app</code>が、アプリケーションで定義されるエラーコードを含む名前空間に束縛されていると仮定している)。</p>

<eg role="parse-test" xml:space="preserve">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</eg>

</div3>
<div3 id="id-errors-and-opt"><head>エラーと最適化</head>
<p>実装が異なると、式を評価したり最適化したりする方法として異なるものを選ぶかもしれないので、この節で述べるように、<termref def="dt-dynamic-error">動的エラー</termref>の検出や報告についてのある側面は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p>実装は常に、演算子の演算数をどのような順序で評価しても自由である。</p>
<p>場合によっては、処理器は、形式的な式の意味によって内含されるすべてのデータにアクセスすることなく、式の結果を決定することができる。例えば、<termref def="dt-filter-expression">選別式</termref>の形式的記述では、<code>$s[1]</code>は列<code>$s</code>のすべての項目を検査し、述語<code>position()=1</code>を満たす項目をすべて選ぶことによって評価されるべきであると推奨している。実際は、多くの実装は、列の最初の項目を取ってきて終了してもこの式を評価することができる、と認識している。もし<code>$s</code>が<code>//book[author eq 'Berners-Lee']</code>と言った式で定義されるならば、この戦略は大きな文書全体の走査を避け、性能を大幅に改善するかもしれない。しかし、この戦略の結果として、式の評価が早く終了してしまうと、式の意味に厳密に従っていれば検出できたであろう動的エラーや型エラーが全く検出できないかもしれない。この例では、もし1個以上の<code>author</code>部分要素を持つ<code>book</code>要素が入力中にあると、このようなエラーが発生するかもしれない。</p>
<p>エラーを検出しないコストに関して、処理器がデータへのアクセスを最適化するかもしれない外延は、次のルールで定義される。</p>
<p>演算数(部分式)に<emph>E</emph>を持つ式<emph>Q</emph>を考えよう。一般には<emph>E</emph>の値は列である。列の評価の中間段階では、その項目のいくつかは分かっているが、残りは未知である。もし、評価の中間段階で、処理器が<emph>Q</emph>を評価した結果として2つの可能性しかない、すなわち値<emph>V</emph>かエラーの可能性しかないと証明できるならば、処理器は、演算数<emph>E</emph>の残りの項目を評価することなく結果<emph>V</emph>を出してもよい。この目的のために、2つの項目の節点と値がともに同一であるならば、2つの値は同じ結果を表現していると考えられる。ここで、節点が同じ識別子を持っているならば、それらの節点は同一である。また、2つの値が等値でかつ全く同じ型を持っているならば、それらの値は同一である。</p>
<p>このルールには例外がある。もし処理器が演算数 <emph>E</emph> を (その全体であれ部分的にであれ) 評価するならば、処理器は、<emph>E</emph>の演算数の実際の値が濃度に関するどんな制約にも反しないことを証明する必要がある。例えば、式<code>$e eq 0</code>は、<code>$e</code>の値が2個以上の項目を含んでいれば、型エラーという結果になる。処理器は、<code>$e</code>の値の最初の項目を評価した後、可能な結果は、値<code>true</code>か、濃度の違反による型エラーだけである、と決定することは許されない。<code>$e</code>の値が1個以下の項目しか含まないことを証明しなければならない。</p>
<p>このルールは、式の演算数として考えられるすべての組み合わせに適用される。したがって、式が2つの演算数<emph>E1</emph>と<emph>E2</emph>を持っているならば、上のルールを満たすそれぞれの列のどんな例を用いて評価されてもよい。</p>
<p>このルールは連鎖する。<emph>A</emph>が<emph>B</emph>の演算数で、<emph>B</emph>が<emph>C</emph>の演算数であるならば、処理器は<emph>C</emph>の値を決めるために充分な数の<emph>B</emph>の例だけを評価すればよく、さらに<emph>B</emph>の例を決めるために充分な数の<emph>A</emph>の例だけを評価すればよい。</p>
<p>これらのルールの効果として、処理器は、列中のあるところより先の項目が、エラーを発生させるかもしれないということ以外に結果に影響を及ぼさないと証明できれば、直ちにその先の項目の検査を止めても構わない。例えば、処理器は、2つの列から等しい値の2つ組を見つければ、直ちに<code>S1 = S2</code>の結果として<code>true</code>を返してもよい。</p>
<p>これらのルールのもう一つの結果として、列中のどの項目も式の結果に貢献しないとき、処理器はその列のどの部分も評価する義務を負わない。しかし、繰り返すが、処理器は要求される濃度の検査は、せずに済ますことができない。対象とする文脈で空列が許されなければ、処理器は、演算数が空列でないことを保証しなければならない。</p>
<p>例:</p>

<ulist>
<item><p>下の例において、実装が<code>$expr1</code>によって返される項目のうち少なくとも1つが<code>47</code>という値を持つと知ることができる(例えば索引を用いて)ならば、<code>some</code>式の結果として<code>true</code>を返すことが許される。このとき、<code>$expr1</code>によって返される他の項目に、評価するとエラーを発生させるものがあるか探す必要はない。</p>
<eg role="parse-test" xml:space="preserve">some $x in $expr1 satisfies $x = 47</eg></item>
<item><p>以下の例において、実装が、値が<code>47</code>であるような子節点<code>id</code>を持つ<code>product</code>要素節点を見つけられれば(例えば索引を用いて)、<termref def="dt-path-expression">経路式</termref>の結果としてこれらの節点を返すことが許される。このとき、他の<code>product</code>節点に、整数を値としない<code>id</code>子節点があるためにエラーを発生させるものがあるか探す必要はない。</p>
<eg role="parse-test" xml:space="preserve">//product[id = 47]</eg>
</item>
</ulist>
<p>最適化など、さまざまな理由により、実装は式を等価な式に書き換えることは自由である。エラーを発生させるか発生させないかという点を除いて、等価な式を評価した結果は、元の式を評価した結果と等しくなければならない。式の書換えを以下の例で説明する。</p>

<ulist><item><p>式<code>//part[color eq "Red"]</code>を考えよう。実装はこの式を<code>//part[color = "Red"][color eq "Red"]</code>と書き換えることを選択するかもしれない。この実装では、この式を次のように処理するかもしれない。まず part に関する索引を color によって引き、color が Red であるような part すべてを素早く見つけ、"<code>=</code>" 述語を処理する。次にこれらの part それぞれについて "<code>eq</code>" 述語を処理し、確かに一つの color しか持っていないか検査する。結果は以下のようになる。
<ulist><item><p>Redという1つの color しか持っていない part が返される。</p></item>
<item><p>ある part が Red という color と他の color を共に持っていれば、エラーが発生する。</p></item>
<item><p>Red という color を持たず Red でない color を複数持つ part が存在してもエラーは引き起こさない。</p></item></ulist>
</p></item>
<item><p>以下の例の式は、書かれている順に(すなわち左から右へ)正確に評価されれば、型変換エラーを起こすことはできない。どちらの述語も文脈位置に依存しているので、実装は、(例えば索引を利用することで)よりよい性能を得るために、述語を並び替えることを選択するかもしれない。述語を並べ替えることで、式がエラーを引き起こすかもしれない。</p>
<eg role="parse-test" xml:space="preserve">$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</eg>
<p>式の書き換えによって引き起こされる想定外のエラーを避けるために、動的エラーを防ぐために設計されたテストを、条件式を用いて表現するべきである。条件式は、実際に選択された分岐中で発生する動的エラーのみ引き起こす。したがって、前の例とは異なり、以下の例では<code>@x</code>が<code>xs:date</code>に型変換されなくても動的エラーは起こらない。</p>
<eg role="parse-test" xml:space="preserve">$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</eg></item></ulist>






</div3></div2>
<div2 id="id-important-concepts"><head>概念</head>

<p>この節では、XPath式の処理で重要な概念をいくつか説明する。</p>

<div3 id="id-document-order"><head>文書順</head>

<p><term>文書順</term>と呼ばれる順序は、ある<phrase role="xpath">式</phrase>の処理中にアクセス可能なすべての節点の間で定義され、1つ以上の<term>木</term>(文書もしくはその一部)から構成されていてもよい。文書順は<bibref ref="datamodel"/>で定義されているが、便宜上その定義をここでも繰り返す。<termdef id="dt-reverse-document-order" term="reverse document order">文書順の逆順であるような節点の順序を<term>逆文書順</term>という。</termdef></p>

<p>文書順は全順序である。ただし、節点間の相対順序は<termref def="dt-implementation-dependent">実装依存</termref>である。<termdef id="dt-document-order" term="document order"> 直観的には、<term>文書順</term>は直列化されたXML文書中で節点が出現する順序である。</termdef> <termdef id="stable" term="stable">文書順は<term>安定</term>である。ここで安定とは、ある<phrase role="xpath">式</phrase>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<termref def="dt-implementation-dependent">実装依存</termref>であっても)ことを意味する。</termdef></p>

<p>木では、文書順は次の制約を満たす。</p>

<olist>
<item><p>根節点は最初の節点である。</p></item>

<item><p>いずれの節点も、その子および子孫のどれよりも前に出現する。</p></item>

<item role="xpath"><p>名前空間節点は、それが関連づけられている要素節点の直後に出現する。名前空間節点の相対順序は安定であるが<termref def="dt-implementation-dependent">実装依存</termref>である。</p></item>

<item><p>属性節点は、それが関連づけられている要素節点の<phrase role="xpath">名前空間節点</phrase>の直後に出現する。属性節点の相対順序は安定であるが<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
</item>

<item><p>兄弟間の相対順序は、親節点の性質<code>children</code>中で出現する順序である。</p></item>
<item><p>子および子孫は、弟よりも先に出現する。</p></item>
</olist>

<p>異なる木の節点間の相対順序は安定であるが<termref def="dt-implementation-dependent">実装依存</termref>であり、次の制約に従う。与えられた木T1中のある節点が、別の木T2中のすべての節点より前に出現するならば、木T1中のすべての節点が木T2のすべての節点より前に出現する。</p>

        </div3>

	 <div3 id="id-atomization"><head>原子化</head>
<p>いくつかのXPath演算子の意味は<termref def="dt-atomization">原子化</termref>という処理に依存している。原子化がある値に対して適用されるのは、原子値の列が必要となる文脈でその値が用いられるときである。原子化の結果は、原子値の列か<termref def="dt-type-error">型エラー</termref> [err:FOTY0012] のいずれかである。<termdef id="dt-atomization" term="atomization">列の<term>原子化</term>は、<bibref ref="FunctionsAndOperators"/>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。</termdef></p>
<p>便宜上、<code>fn:data</code>の意味を繰り返す。<code>fn:data</code>の結果は、入力列中の各項目に以下のルールを適用して生成される原子値の列である。</p>
<ulist>
 <item><p>その項目が原子値であれば、その項目を返す。</p></item>
<item><p>その項目が節点であれば、その<termref def="dt-typed-value">型付けされた値</termref>を返す。(もしその節点が型付けされた値を持たないならば、err:FOTY0012が発生する。)</p></item>
			  
</ulist>
<p>原子化は以下の式の型を処理するのに用いられる。</p>
<ulist>
<item><p>算術式</p></item>
<item><p>比較式</p></item>
<item><p>関数呼び出しと関数からの戻り</p></item>
<item><p>型変換式</p></item>


</ulist>
</div3>
<div3 id="id-ebv"><head>有効ブール値</head>
<p>ある状況の下では(以下に列挙する)、値の<termref def="dt-ebv">有効ブール値</termref>を得る必要がある。<termdef id="dt-ebv" term="effective boolean value">ある値の<term>有効ブール値</term>は、<bibref ref="FunctionsAndOperators"/>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。</termdef></p>

<p>便宜上、<code>fn:boolean</code>の動的意味を繰り返す。</p>
<olist>
<item><p>演算数が空列であれば、<code>fn:boolean</code>は<code>false</code>を返す。</p></item>
<item><p>演算数が、最初の項目が節点であるような列であれば、<code>fn:boolean</code>は<code>true</code>を返す。</p></item>
<item><p>演算数が<code>xs:boolean</code>型もしくは<code>xs:boolean</code>から導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は演算数の値を変化せずに返す。</p></item>
<item><p>演算数が<code>xs:string</code>型、<code>xs:untypedAtomic</code>型、もしくはこれらのいずれかから導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は、演算数の値の長さが0の場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p></item>
<item><p>演算数が<termref def="dt-numeric">数</termref>型、もしくは数型から導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は、演算数の値が<code>NaN</code>もしくは数として0に等しい場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</item><item><p>これ以外のすべての場合について、<code>fn:boolean</code>は型エラー [err:FORG0006]を引き起こす。</p>
</item>
</olist>
<note><p><code>fn:boolean</code>の静的意味は<xspecref spec="FS" ref="sec_fn_boolean"/>で定義されている。</p>
</note>

<p>列の<termref def="dt-ebv">有効ブール値</termref>は、以下のような式の型の処理で暗黙的に計算される。</p>
<ulist>
<item><p>論理式(<code>and</code>, <code>or</code>)</p></item>
<item><p><code>fn:not</code>関数</p></item>

<item><p>ある形式の<termref def="dt-predicate">述語</termref>。例えば<code>a[b]</code></p></item>
<item><p>条件式(<code>if</code>)</p></item>
<item><p>限量式(<code>some</code>, <code>every</code>)</p></item>
<item role="xpath"><p><termref def="dt-xpath-compat-mode">XPath 1.0 互換モード</termref>における、一般比較</p></item>
</ulist>
<note><p><termref def="dt-ebv">有効ブール値</termref>の定義は、例えば<code>cast</code>式のような<code>xs:boolean</code>型への型変換、あるいは引数として<code>xs:boolean</code>型を期待する関数に値を渡すときには、<emph>使わない</emph>。</p>
</note></div3>
<div3 id="id-input-sources"><head>入力源</head>
<p>XPathは、入力データへのアクセスを提供する関数集合を持っている。これらの関数は、式が文書や文書の集まりを参照できる方法を用意しているため、特に重要である。ここでは、入力関数について直観的に記述する。これらは<bibref ref="FunctionsAndOperators"/>で定義されている。</p>

<p>式が入力データにアクセスするには、入力関数の一つを呼び出すか、外部環境によって初期化される<termref def="dt-dynamic-context">動的文脈</termref>の一部、例えば<termref def="dt-variable-values">変数</termref>や<termref def="dt-context-item">文脈項目</termref>を参照するか、いずれかによる。</p>

<p>XPathで支援されている入力関数は以下の通りである:</p>

    <ulist><item><p><code>fn:doc</code>関数はURIを含む文字列を受け取る。そのURIが<termref def="dt-available-docs">有効文書</termref>中の文書と関連づけられていれば、<code>fn:doc</code>はその文書の<termref def="dt-datamodel">データモデル</termref>表現を内容とするような文書節点を返す。それ以外の場合、<termref def="dt-dynamic-value">動的エラー</termref>を引き起こす(詳細は<bibref ref="FunctionsAndOperators"/>を見よ)。</p></item>
<item><p>1引数の<code>fn:collection</code>関数は、URIを含む文字列を受け取る。そのURIが<termref def="dt-available-collections">有効コレクション</termref>中のコレクションと関連づけられていれば、<code>fn:collection</code>はそのコレクションのデータモデル表現を返す。それ以外の場合、<termref def="dt-dynamic-error">動的エラー</termref>を引き起こす(詳細は<bibref ref="FunctionsAndOperators"/>を見よ)。コレクションは任意の節点列であってもよい。例えば、式<code>fn:collection("http://example.org")//customer</code>は、URIが<code>http://example.org</code>であるようなコレクション中の節点の子孫である<code>customer</code>要素すべてを指し示す。</p></item>
<item><p>引数を持たない<code>fn:collection</code>関数は、<termref def="dt-default-collection">デフォルトコレクション</termref>を返す。これは<termref def="dt-implementation-dependent">実装依存</termref>の節点列である。</p>
</item></ulist>

    
</div3>

</div2>
	 <div2 id="id-types"> 
		<head>型</head> 
<p>XPathの型システムは<bibref ref="XMLSchema"/>に基づいており、<bibref ref="XQueryFormalSemantics"/>で形式的に定義されている。</p>
<p><termdef id="dt-sequence-type" term="sequence type"><term>列型</term>(sequence type)は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>の構文を用いて表現することのできる型である。列型は、XPath式で型を参照する必要があるときにはいつでも用いられる。<term>列型</term>という用語は、この構文がXPathの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。</termdef></p>
<p><termdef id="dt-schema-type" term="schema type"><term>スキーマ型</term>(schema type)は<bibref ref="XMLSchema"/>の機能(<bibref ref="XMLSchema"/>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<term>複合型</term>か<term>単純型</term>のいずれかである。単純型はさらに<term>リスト型</term>、<term>共用体型</term>、<term>原子型</term>に分けられる(これらの用語の定義と説明は<bibref ref="XMLSchema"/>を見よ)。</termdef></p>
<p>原子型は<termref def="dt-sequence-type">列型</termref>と<termref def="dt-schema-type">スキーマ型</termref>という種類の間の集合積を表現している。原子型、例えば<code>xs:integer</code>や<code>my:hatsize</code>は<termref def="dt-sequence-type">列型</termref>でもあり<termref def="dt-schema-type">スキーマ型</termref>でもある。</p>
	
		<div3 id="id-predefined-types"><head>既定義スキーマ型</head>


<p role="xpath"><termref def="dt-static-context">静的文脈</termref>内の<termref def="dt-is-types">有効範囲内スキーマ型</termref>は、ホスト言語で定義されている既定義スキーマ型の集合で初期化される。この集合には<code>http://www.w3.org/2001/XMLSchema</code>名前空間内のスキーマ型の一部またはすべてが含まれていてもよい。この文書では、この名前空間を名前空間接頭辞<code>xs</code>で表している。この名前空間のスキーマ型は <bibref ref="XMLSchema"/> で定義され、<bibref ref="datamodel"/> で定義された方を追加することで拡張されている。この名前空間内のスキーマ型は<bibref ref="datamodel"/>で定義されており、以下にその概略を示す。</p>


<olist>
<item><p><termdef term="xs:untyped" id="dt-untyped"><code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<termref def="dt-type-annotation">型注釈</termref>として用いられる。</termdef> <code>xs:untyped</code>からは既定義スキーマ型は何も導出されない。</p></item>
<item><p><termdef id="dt-untypedAtomic" term="xs:untypedAtomic"><code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。</termdef> <code>skip</code>モードで妥当性検証された属性は、<termref def="dt-datamodel">データモデル</termref>中では<code>xs:untypedAtomic</code>という<termref def="dt-type-annotation">型注釈</termref>のついた属性節点として表現される。<code>xs:untypedAtomic</code>からは、既定義スキーマ型は何も導出されない。</p></item>
<item><p><termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration"><code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。</termdef></p></item>
<item><p><termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration"><code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。</termdef></p></item>
<item><p><termdef term="xs:anyAtomicType" id="dt-anyAtomicType"><code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>, <code>xs:string</code>, <code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。</termdef></p>
<note><p><code>xs:anyAtomicType</code>は<termref def="dt-data-model-instance">XDMインスタンス</termref>中の実際の値の型には出現しない。</p></note></item>
</olist>
<p><code>xs</code>名前空間中のスキーマ型の間の関連を図2に示す。XPathの型階層のより完全な記述は<bibref ref="FunctionsAndOperators"/>にある。</p>
<graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="types.jpg" alt="Type Hierarchy Diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
<p>図2: XPathで用いられるスキーマ型の階層</p></div3>

<div3 id="id-typed-value"><head>型付けされた値と文字列値</head>

<p>すべての節点は<term>型付けされた値</term>と<term>文字列値</term>とを持っている。<termdef term="typed value" id="dt-typed-value">節点の<term>型付けされた値</term>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。</termdef> <termdef id="dt-string-value" term="string value">節点の<term>文字列値</term>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。</termdef> <code>fn:data</code>と<code>fn:string</code>の定義は<bibref ref="FunctionsAndOprators"/>にある。</p>

<p>実装は、節点の<termref def="dt-typed-value">型付けされた値</termref>と<termref def="dt-string-value">文字列値</termref>をともに格納してもよいし、これらの一方だけを格納して、必要なときにもう一方を導出してもよい。節点の文字列値は、その節点の型付けされた値の正しい字句表現でなければならないが、その節点は元のソース文書から文字列表現を保存している必要はない。例えば、ある節点の型付けされた値が<code>xs:integer</code>の値<code>30</code>であったとすると、その文字列値は "<code>30</code>" でも "<code>0030</code>" でもよい。</p>
<p role="xpath">節点の<termref def="dt-typed-value">型付けされた値</termref>、<termref def="dt-string-value">文字列値</termref>、および<termref def="dt-type-annotation">型注釈</termref>は密接に関連している。節点が情報集合またはPSVIからの写像で作られたのであれば、これらの性質の関連は<bibref ref="datamodel"/>中のルールによって定義される。</p>


<p>読者の便宜のため、さまざまな種類の節点の<termref def="dt-typed-value">型付けされた値</termref>と<termref def="dt-string-value">文字列値</termref>の関連について以下にまとめ、例を用いて説明する。</p>

<olist>
<item><p>テキスト節点と文書節点では、型付けされた値と文字列値は等しく、<code>xs:untypedAtomic</code>型のインスタンスである。文書節点の文字列値は、そのすべての子孫のテキスト節点の文字列値を<termref def="dt-document-order">文書順</termref>に連接して得られる。</p></item>
<item><p>コメント、<phrase role="xpath">名前空間</phrase>、処理命令節点について、型付けされた値は文字列値に等しい。<code>xs:string</code>型のインスタンスである。</p></item>
<item><p><termref def="dt-type-annotation">型注釈</termref><code>xs:anySimpleType</code>または<code>xs:untypedAtomic</code>のついた属性節点の型付けされた値は、文字列値に等しく、<code>xs:untypedAtomic</code>型のインスタンスである。その他の型注釈のついた属性節点の型付けされた値は、対応する型に関して<bibref ref="XMLSchema"/>第2部で定義される字句から値空間への写像を用いて、文字列値や型注釈から導出される。</p>
<p>例: A1 は文字列値<code>"3.14E-2"</code>と型注釈<code>xs:double</code>を持つ属性である。A1の型付けされた値は、字句表現として<code>3.14E-2</code>を持つ<code>xs:double</code>の値である。</p>
<p>例: A2 は型注釈<code>xs:IDREFS</code>を持つ属性であり、各項目の型が原子データ型<code>xs:IDREF</code>であるようなリストデータ型である。A2の文字列値は"<code>bar baz faz</code>"である。A2の型付けされた値は、それぞれ<code>xs:IDREF</code>型である3つの原子値("<code>bar</code>", "<code>baz</code>", "<code>faz</code>")の列である。節点の型付けされた値は、名前付けされたリスト型のインスタンスとは決して扱われない。そのかわり、節点の型注釈がリスト型(<code>xs:IDREFS</code>など)であれば、型付けされた値は、それが導出される原子型(<code>xs:IDREF</code>など)の列として扱われる。</p>
</item>
<item><p>要素節点については、型付けされた値と文字列値の関連はその要素の<termref def="dt-type-annotation">型注釈</termref>に依存する。以下の通り:</p>
<olist>

<item>

<p>型注釈が<code>xs:untyped</code>、<code>xs:anySimpleType</code>、もしくは混在内容を伴う複合型(<code>xs:anyType</code>を含む)を表していれば、その節点の型付けされた値は文字列値に等しく、<code>xs:untypedAtomic</code>のインスタンスである。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列である。</p>

<p>例: E1 は型注釈<code>xs:untyped</code>と文字列値"<code>1999-05-31</code>"を持つ要素節点である。E1の型付けされた値は"<code>1999-05-31</code>"であり、<code>xs:untypedAtomic</code>のインスタンスである。</p>


<p>例: E2は、型注釈<code>formula</code>を持つ要素節点である。この型注釈は混在内容を伴う複合型である。E2の内容は文字"<code>H</code>"、<code>subscript</code>と名付けられ文字列値"<code>2</code>"を持つ子要素、文字"<code>O</code>"からなる。E2の型付けされた値は"<code>H2O</code>であり、<code>xs:untypedAtomic</code>の印寸タンスである。</p></item>

<item><p>型注釈が単純型、もしくは単純内容を伴う複合型を表していれば、その節点の型付けされた値は、スキーマ妥当性検証と同じ方法で、文字列値と型注釈から導出される。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列になる。</p>
<p>例: E3は型注釈<code>cost</code>を持つ要素節点である。この型はいろいろな属性を持ち、かつ<code>xs:decimal</code>型の単純内容を持つ複合型である。E3の文字列値は"<code>74.95</code>"である。E3の型付けされた値は<code>74.95</code>であり、<code>xs:decimal</code>のインスタンスである。</p>
<p>例: E4は型注釈<code>hatsizelist</code>を持つ要素節点である。この型は原子型<code>hatsize</code>から導出された単純型であり、<code>hatsize</code>はさらに<code>xs:integer</code>から導出されている。E4の文字列値は"<code>7 8 9</code>"である。E4の型付けされた値は3つの値(<code>7</code>, <code>8</code>, <code>9</code>)からなる列であり、3つの値はいずれも<code>hatsize</code>型である。</p>
<p>例: E5は、メンバの型が<code>xs:integer</code>と<code>xs:string</code>の共用体型<code>my:integer-or-string</code>という型注釈を持つ要素節点である。E5の文字列値は"<code>47</code>"である。E5の型付けされた値は、<code>xs:integer</code>としての<code>47</code>である。なぜならば、E5の内容を妥当性検証したメンバ型が<code>xs:integer</code>であるからである。一般的に、節点の型注釈が共用体型であるときは、その節点の型付けされた値は、共用体のいずれかのメンバ型のインスタンスである。</p>
<note><p>実装が節点の文字列値しか格納しておらず、その節点の型注釈が共用体型であるならば、実装はその節点の型付けされた値を適切なメンバ型のインスタンスとして配布しなければならない。</p></note></item>
<item><p>型注釈が空内容を伴う複合型を表していれば、その節点の型付けされた値は空列であり、文字列値は長さ0の文字列である。</p>
</item>
<item><p>型注釈が要素だけからなる内容を伴う複合型を表していれば、その節点の型付けされた値は未定義である。<code>fn:data</code>関数は、このような節点に対して適用されると<termref def="dt-type-errro">型エラー</termref> [err:FOTY0012]を引き起こす。このような節点の文字列値は、すべての子孫テキスト節点の文字列値を文書順に連接した文字列値と等しい。</p>
<p>例: E6は型注釈が<code>weather</code>である要素節点である。この型は、内容型が<code>element-only</code>と指定されている複合型である。E6は<code>temperature</code>および<code>precipitation</code>と名付けられた2つの子節点を持つ。E6の型付けされた値は未定義であり、<code>fn:data</code>関数をE6に適用するとエラーを引き起こす。</p>
</item></olist></item></olist></div3>
<div3 id="id-sequencetype-syntax"><head>SequenceTypeの文法</head>
<p>XPath式中の型を参照する必要があるときはいつでも、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>の文法が用いられる。</p>
		  <scrap headstyle="show">
			 <head/> 
			 <prod num="50" id="doc-xpath-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod> 
			  
			 <prod num="52" id="doc-xpath-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="51" id="doc-xpath-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs></prod><prod num="53" id="doc-xpath-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod> 			  
			 <prod num="54" id="doc-xpath-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod> 
			  
			 <prod num="56" id="doc-xpath-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod> 
			  
			  
			 <prod num="64" id="doc-xpath-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod> 
			  
		         <prod num="66" id="doc-xpath-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="67" id="doc-xpath-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="60" id="doc-xpath-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod>
		         

                  
                  

                  <prod num="62" id="doc-xpath-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="63" id="doc-xpath-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="65" id="doc-xpath-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod>
                  
                  <prod num="69" id="doc-xpath-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="61" id="doc-xpath-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod>
                  
                  <prod num="68" id="doc-xpath-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod>
                  

                         
			 
			 
			 		 

                             
<prod num="70" id="doc-xpath-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="59" id="doc-xpath-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod> 
 
			 <prod num="58" id="doc-xpath-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod> 
			  
			 <prod num="57" id="doc-xpath-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod>
			 
			 <prod num="55" id="doc-xpath-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod>
			 </scrap> 


<p>特別な型<code>empty-sequence()</code>を除き、<termref def="dt-sequence-type">列型</termref>は、列中の各項目の型に制約を加える<term>項目型</term>、および列の項目数に制約を加える<term>濃度</term>からなる。項目型<code>item()</code>は任意の種類の項目を許すが、これを除き、項目型は<term>節点型</term>(<code>element()</code>など)と<term>原子型</term>(<code>xs:integer</code>など)に分けられる。</p>
<p>要素節点や属性節点を表す項目型は、これらの節点の必要な<termref def="dt-type-annotation">型注釈</termref>を、<termref def="dt-schema-type">スキーマ型</termref>の形式で指定してもよい。したがって、項目型<code>element(*, us:address)</code>は、<code>us:address</code>と名付けられたスキーマ型(あるいはこの型から導出される型)を型注釈とする要素節点を表す。</p>
<p>以下に、XPath式で用いられる<termref def="dt-sequence-type">列型</termref>の例をいくつか示す。</p>
		  <ulist> 
			 <item> 
<p><code>xs:date</code>は、<code>xs:date</code>と名付けられた組み込み原子スキーマ型を参照する。</p>
			 </item> 
			 <item> 
<p><code>attribute()?</code>は省略可能な属性節点を参照する。</p>
			 </item> 
			 <item> 
<p><code>element()</code>は任意の要素節点を参照する。</p>
			 </item> 
			 <item> 
<p><code>element(po:shipto, po:address)</code>は、<code>po:shipto</code>という名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
			 </item><item> 
<p><code>element(*, po:address)</code>は、任意の名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
			 </item><item>
<p><code>element(customer)</code>は、<code>customer</code>と名付けられ、かつ任意の型注釈を持つ要素節点を参照する。</p>
</item> 
			  
			 <item><p><code>schema-element(customer)</code>は、名前が<code>customer</code>であり(もしくは<code>customer</code>を先頭とする置換グループの中にあり)、かつ型注釈が、<termref def="dt-is-elems">有効範囲内要素定義</termref>中の<code>customer</code>要素のために定義されたスキーマ型に照合するような要素節点を参照する。</p>
</item><item> 
<p><code>node()*</code>は、任意の種類の節点0個以上からなる列を参照する。</p>
			 </item> 
			 <item> 
<p><code>item()+</code>は、1個以上の節点もしくは原子値からなる列を参照する。</p>
			 </item> 
		  </ulist></div3><div3 id="id-sequencetype-matching"> 
		  <head>SequenceTypeの照合</head> 
<p><termdef id="dt-sequencetype-matching" term="SequenceType matching">式の評価の間、既知の<termref def="dt-dynamic-type">動的型</termref>が期待される<termref def="dt-sequence-type">列型</termref>に「照合」されるか決定する必要があることがある。この処理を<term>SequenceTypeの照合</term>という。</termdef> 例えば、式<code>instance of</code>は、与えられた値の<termref def="dt-dynamic-type">動的型</termref>が与えられた<termref def="dt-sequence-type">列型</termref>に照合されれば<code>true</code>を返し、照合されなければ<code>false</code>を返す。</p>





<p><termref def="dt-sequence-type">列型</termref>中に出現するQNameは、<termref def="dt-static-namespace">静的既知名前空間</termref>と(もし適用可能であれば)<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>を用いて名前空間URIに展開される接頭辞を持つ。接頭辞のない属性 QName はどの名前空間にも属さない。QName の等価性は <code>eq</code> 演算子によって定義される。</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールは、値の<termref def="dt-dynamic-type">動的型</termref>を、期待される<termref def="dt-sequence-type">列型</termref>と比較する。これらのルールは<bibref ref="XQueryFormalSemantics"/>で定義される、値と期待される型との照合を行う形式的ルールの部分集合である。なぜなら、Formal Semanticsは、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>の文法を用いて表現できない型に対して値を照合することができなければならないからである。</p>


<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールのいくつかでは、与えられたスキーマ型が期待されるスキーマ型と同じかまたは導出されるかを決定する必要がある。与えられたスキーマ型は"既知"(<termref def="dt-issd">有効範囲内スキーマ定義</termref>で定義されている)か、または"未定義"(<termref def="dt-issd">有効範囲内スキーマ定義</termref>で定義されていない)のいずれかであってもよい。未定義スキーマ型は、例えば、ソース文書が<termref def="dt-static-context">静的文脈</termref>に輸入されていないスキーマを用いて妥当性検証されている場合などに現れるかもしれない。この場合、実装は、未定義のスキーマ型が期待されるスキーマ型から導出されるか決定する<termref def="dt-implementation-dependent">実装依存</termref>の機構を用意することが許される(しかし用意しておく必要はない)。
例えば、実装は型階層に関する情報を含むデータ辞書を管理していてもよい。</p>
<p><termdef term="subtype substitution" id="dt-subtype-substitution"><termref def="dt-dynamic-type">動的型</termref>が期待される型から導出されるような値を用いることを<term>部分型置換</term>という。</termdef> 部分型置換は、値の実際の型は変更しない。例えば、<code>xs:integer</code>の値を<code>xs:decimal</code>の値が期待される場所で用いても、その値の型は<code>xs:integer</code>のまま保たれる。</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>の定義は、<code>derives-from(</code><emph>AT, ET</emph><code>)</code>という名前の擬似関数に頼っている。この関数は、実際の単純スキーマ型もしくは複合スキーマ型<emph>AT</emph>と、期待される単純スキーマ型もしくは複合スキーマ型<emph>ET</emph>をとり、ブール値を返すか、<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。
擬似関数<code>derives-from</code>は以下で定義され、また<bibref ref="XQueryFormalSemantics"/>で形式的に定義されている。</p>

		  
		  <ulist>
<item><p><emph>ET</emph>が既知の型で、以下の3つの条件のいずれかが真であるとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<code>true</code>を返す。</p>
<olist>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>中にあるスキーマ型で、<emph>ET</emph>と同じか、<emph>ET</emph>から制限もしくは拡張によって導出される。</p>
</item>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>には含まれないスキーマ型で、<termref def="dt-implementation-dependent">実装依存</termref>の機構により<emph>AT</emph>が<emph>ET</emph>から制限により導出されると決定できる。</p>
</item>
<item><p><code>derives-from(</code><emph>IT, ET</emph><code>)</code>と<code>derives-from(</code><emph>AT, IT</emph><code>)</code>が真であるようなスキーマ型<emph>IT</emph>が存在する。</p>
</item></olist></item>
<item><p><emph>ET</emph>が既知の型で、以下の条件のうち1番目と3番目、もしくは2番目と3番目が真であるとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<code>false</code>を返す。</p>
<olist><item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>中にあるスキーマ型で、<emph>ET</emph>と等しくなく、<emph>ET</emph>から制限または拡張によって導出されない。</p>
</item>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>にないスキーマ型で、<termref def="dt-implementation-dependent">実装依存</termref>の機構により<emph>AT</emph>が制限によって<emph>ET</emph>から導出されない。</p>
</item>
<item><p><code>derives-from(</code><emph>IT, ET</emph><code>)</code>と<code>derives-from(</code><emph>AT, IT</emph><code>)</code>がともに真であるようなスキーマ型<emph>IT</emph>が存在しない。</p>
</item></olist></item>
<item><p>以下のとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。</p>
<olist><item><p><emph>ET</emph>が未定義の型である。もしくは</p>
</item><item><p><emph>AT</emph>が未定義の型で、実装は、<emph>AT</emph>が制限によって<emph>ET</emph>から導出されるか決定できない。</p>
</item></olist></item></ulist>



<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールを以下に述べ、例を示す(例は説明が目的であり、可能な場合をすべて網羅しているわけではない)。</p>

		   
		   
		  <div4 id="id-matching-value"><head>SequenceTypeと値の照合</head>
<ulist><item><p><termref def="dt-sequence-type">列型</termref> <code>empty-sequence()</code>は、空列である値と照合される。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>のない<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>がただ1つの項目を含む任意の値と照合されるのは、その<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>がその項目と照合されるときである(<specref ref="id-matching-item"/>を見よ)。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>のある<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>が値と照合されるのは、その値の項目の数が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>と照合され、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>がその値の各項目と照合されるときである。</p>
</item></ulist>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>は列中の項目数を以下のように指定する。</p>

		  <ulist> 
			 <item> 
			   <p><code>?</code>は0個もしくは1個の項目と照合される</p>
			 </item> 
			 <item> 
			   <p><code>*</code>は0個以上の項目と照合される</p>
			 </item> 
			 <item> 
			   <p><code>+</code>は1個以上の項目と照合される</p>
			 </item> 
		  </ulist>

<p>これらのルールの結果として、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>が<code>*</code>もしくは<code>?</code>であるような任意の<termref def="dt-sequence-type">列型</termref>は、空列である値と照合される。</p>
</div4>
<div4 id="id-matching-item"><head>ItemTypeと項目の照合</head>
<ulist>
<item><p>QNameのみからなる<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>と解釈される。AtomicType <emph>AtomicType</emph>が実際の型が<emph>AT</emph>である原子値と照合されるのは、<code>derives-from(</code><emph>AT, AtomicType</emph><code>)</code>が<code>true</code>の場合である。もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>として用いられているQNameが<termref def="dt-is-types">有効範囲内スキーマ定義</termref>中の原子型として定義されていないならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0051"/>。</p>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt> <code>xs:decimal</code>は値<code>12.34</code> (実数リテラル)と照合される。もし<code>shoesize</code>が<code>xs:decimal</code>から制限によって導出される原子型であれば、<code>xs:decimal</code>はまた、型が<code>shoesize</code>であるような値とも照合される。</p>

<note><p><code>xs:IDREFS</code>のように原子型でない型の名前は、この文脈では認められないが、しばしば、<code>xs:IDREF+</code>のように出現標識を伴った原子型によって置き換えることができる。</p>
</note>
</item>
<item><p><code>item()</code>は任意の単一項目と照合される。</p>
<p>例: <code>item()</code>は、原子値<code>1</code>や要素<code>&lt;a/&gt;</code>と照合される。</p>
</item>
<item><p><code>node()</code>は任意の節点と照合される。</p>
</item>
<item><p><code>text()</code>は任意のテキスト節点と照合される。</p>
</item>
<item><p><code>processing-instruction()</code>は任意の処理命令節点と照合される。</p>
</item>
<item><p><code>processing-instruction(</code><emph>N</emph><code>)</code>は、処理命令節点のうち名前(XMLでは処理命令の"PITarget"という)が<emph>N</emph>に等しいものに照合される。ここで<emph>N</emph>はNCNameである。</p>
<p>例: <code>processing-instruction(xml-stylesheet)</code>は、処理命令のうちPITargetが<code>xml-stylesheet</code>であるものに照合される。</p>

<p>XPath1.0との後方互換性のため、処理命令のPITargetは文字列リテラルとしても表されてもよい。例えばこの例の通り: <code>processing-instruction("xml-stylesheet")</code></p>
</item>
<item><p><code>comment()</code>は任意のコメント節点に照合される。</p>
</item>

<item><p><code>document-node()</code>は任意の文書節点に照合される。</p>
</item>
<item><p><code>document-node(</code><emph>E</emph><code>)</code>は、文書節点のうちただ1つの要素節点を含むものに照合される。1つ以上のコメント節点や処理命令節点が含まれていてもよい。ここで<emph>E</emph>は、その要素節点に照合される<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>または<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>である(<specref ref="id-element-test"/>および<specref ref="id-schema-element-test"/>を見よ)。</p>
<p>例: <code>document-node(element(book))</code>は、文書節点のうち、ElementTest <code>element(book)</code>によって照合されるようなただ1つの文書節点を含むものに照合される。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>、または<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>であるような<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>は、以下の節で述べる要素節点または属性節点に照合される。</p>
</item></ulist></div4>

<div4 id="id-element-test"><head>要素テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>は、要素節点をその名前や<termref def="dt-type-annotation">型注釈</termref>と照合するのに用いられる。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>は以下の形式のどれをとってもよい。これらの形式では、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>は<termref def="dt-is-elems">有効範囲内要素定義</termref>中にある必要はないが、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>は<termref def="dt-is-types">有効範囲内スキーマ型</termref>中になければならない。なお、<termref def="dt-substitution-group">置換グループ</termref>は、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>の意味には影響を及ぼさない。</p>
<olist><item><p><code>element()</code>と<code>element(*)</code>は任意の単一要素節点に照合され、その名前や型注釈とは関係しない。</p>
</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>であるようなものに照合され、その型注釈や<code>nilled</code>性質とは関係しない。</p>
<p>例: <code>element(person)</code>は、要素節点のうち名前が<code>person</code>のものと照合される。</p>







</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>のものに照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。</p>
<p>例: <code>element(person, surgeon)</code>は、nilledでない要素節点のうち名前が<code>person</code>であり、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>?)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>のものに照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>が<code>true</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(person, surgeon?)</code>は、nilledもしくはnilledでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</item>



<item><p><code>element(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。</p>

<p>例: <code>element(*, surgeon)</code>は、nilledでない要素節点のうち、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item>
<item><p><code>element(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>?)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>

<p>例: <code>element(*, surgeon?)</code>は、nilledであるかnilledでない要素節点のうち、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item></olist>

</div4>



<div4 id="id-schema-element-test"><head>スキーマ要素テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>は、要素節点のうち、<termref def="dt-is-elems">有効範囲内要素定義</termref>中にある対応する要素定義に対して照合される。これは次のような形式をとる。</p>
<p><code>schema-element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>)</code></p>
<p>もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>中で指定されている<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>が<termref def="dt-is-elems">有効範囲内要素定義</termref>にないならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0008"/>。</p>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>は、以下の3つの条件がすべて満たされるとき、候補要素節点に照合される。</p>
<olist>
<item><p>候補節点の名前が、指定された<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>に照合されるか、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>と名付けられた要素を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中の要素名に照合される。</p>
</item>
<item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code>が<code>true</code>である。ここで<emph>AT</emph>はその候補節点の型注釈、<emph>ET</emph>は<termref def="dt-is-elems">有効範囲内要素定義</termref>中で要素<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>のために定義されたスキーマ型である。</p>
</item>
<item><p><termref def="dt-is-elems">有効範囲内要素定義</termref>中の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>のための要素定義が<code>nillable</code>でないならば、その候補節点の<code>nilled</code>性質は<code>false</code>である。</p>
</item>
</olist>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> <code>schema-element(customer)</code>は候補要素節点に照合される。ただし照合されるのは<code>customer</code>が<termref def="dt-is-elems">有効範囲内要素定義</termref>中の最上位要素定義であり、候補節点の名前が<code>customer</code>であるか<code>customer</code>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあり、候補節点の型注釈が<code>customer</code>要素のために定義されたスキーマ型と同じか導出されており、候補節点が<code>nilled</code>であるか<code>customer</code>が<code>nillable</code>と定義されているときである。</p>
</div4>
<div4 id="id-attribute-test"><head>属性テスト</head>




<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>は、属性節点をその名前や<termref def="dt-type-annotation">型注釈</termref>と照合するのに用いられる。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>は以下の形式のどれをとってもよい。これらの形式で、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>は<termref def="dt-is-attrs">有効範囲内属性定義</termref>中にある必要はないが、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>は<termref def="dt-is-types">有効範囲内スキーマ型</termref>中にはなければならない。</p>
<olist>

<item><p><code>attribute()</code>と<code>attribute(*)</code>は任意の単一属性節点に照合され、その名前や型注釈とは関係しない。</p>
</item>

<item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code>は、属性節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>のものに照合され、その型注釈とは関係しない。</p>
<p>例: <code>attribute(price)</code>は、名前が<code>price</code>である任意の属性節点に照合される。</p>
</item>
<item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttibuteName" xlink:type="simple">AttributeName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、属性節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Attributename" xlink:type="simple">AttributeName</nt>であり、<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であるようなものに照合される。ここで<emph>AT</emph>はその属性節点の型注釈である。</p>

<p>例: <code>attribute(price, currency)</code>は、属性節点のうち名前が<code>price</code>で型注釈が<code>currency</code>である (もしくは<code>currency</code>から導出される)ものに照合される。</p>
</item>
<item><p><code>attribute(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、名前に関係なく属性節点のうち<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>が<code>true</code>であるようなものに照合される。ここで<emph>AT</emph>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(*, currency)</code>は、属性節点のうち型注釈が<code>currency</code>である (もしくは<code>currency</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item>

</olist></div4>
<div4 id="id-schema-attribute-test"><head>スキーマ属性テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>は、属性節点のうち、<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の対応する属性定義に対する属性節点に照合される。これは次のような形式をとる。</p>
<p><code>schema-attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code></p>
<p>もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>中で指定される<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>が<termref def="dt-is-attrs">有効範囲内属性定義</termref>になければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0008"/>。</p>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>は、以下の条件が2つとも満たされるとき、候補属性に照合される。</p>
<olist><item><p>候補節点の名前が指定された<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>に照合される。</p>
</item>
<item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code>が<code>true</code>である。ここで<emph>AT</emph>は候補節点の型注釈、<emph>ET</emph>は<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の属性<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>に対して定義されるスキーマ型である。</p>
</item></olist>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> <code>schema-attribute(color)</code>は候補属性節点に照合される。ただし照合されるのは<code>color</code>が<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の最上位属性定義であり、候補節点の名前が<code>color</code>であり、候補節点の型注釈が<code>color</code>属性に対して定義されたスキーマ型と等しいか、それから導出されるときである。</p>
</div4></div3>
		 
		
		 
	 </div2> 

<div2 id="comments"><head>コメント</head>
<scrap headstyle="suppress"><head/>
<prod num="77" id="doc-xpath-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs></prod>

<prod num="82" id="doc-xpath-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod>

</scrap>

<p>コメントは<phrase role="xpath">式</phrase>のための参考的注釈を提供するのに用いてもよい。コメントは字句的な構成要素だけであり<phrase role="xpath">式</phrase>の処理には影響を与えない。</p>
<p>コメントは文字列であり、記号<code>(:</code>と<code>:)</code>によって区切られる。コメントは入れ子になってもよい。</p>
<p>コメントは<termref def="IgnorableWhitespace">無視できる空白記号</termref>が許されるところにはどこで用いてもよい(<specref ref="DefaultWhitespaceHandling"/>を見よ)。</p>
<p>以下がコメントの例である。</p>
		<eg xml:space="preserve">(: Houston, we have a problem :)</eg></div2></div1>  
  
<div1 id="id-expressions">
 <head>式</head>  
<p>この章では、基本的な式の種類について一つ一つ議論する。それぞれの式の種類は<code>PathExpr</code>のような名前を持つ。この名前は、式を定義する文法生成規則の左辺に導入される。XPathは構成可能な言語なので、それぞれの種類の式は、演算子がより高い優先度を持つような別の式を用いて定義される。このようにして、演算子の優先度は、文法中で明示的に表される。</p>
<p>この文書中で式が議論される順番は、演算子の優先度の順番を反映していない。一般に、この文書では、最も単純な種類の式を最初に導入し、続いて、より複雑な式を導入する。完全な文法については、付録を見よ [<specref ref="nt-bnf"/>]。</p>
<p><phrase role="xpath">XPathの文法の最高位にあるシンボルはXPathである。</phrase>

</p>
<scrap headstyle="show"> 
		<head/> <prod num="1" id="doc-xpath-XPath"><lhs>XPath</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="2" id="doc-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
		
	 <prod num="3" id="doc-xpath-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">ForExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod>
	 
</scrap>
<p>最も優先度の低いXPath演算子は<termref def="dt-comma-operator">コンマ演算子</termref>である。これは、2つの演算数をつないで1つの列を作るのに用いられる。文法に示す通り、一般の式(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>)は複数の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>演算数から構成することができる。このとき演算数はコンマで区切られる。名前<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>は最上位の<termref def="dt-comma-operator">コンマ演算子</termref>を含まない式を表す。(その名前に反して、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>は1つ以上の項目を含む列を評価してもよい。)</p>
<p>シンボル<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>は、文法中で式の最上位にコンマを含むことが許されないようなあちこちの場所で使われている。例えば、関数呼び出しの各引数は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>でなければならない。なぜなら、関数呼び出しの引数を区切るのにコンマが使われているからである。</p>
<p>コンマの次に低い優先度を持つ式は<phrase role="xpath"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">ForExpr</nt>,</phrase> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt>, そして<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">OrExpr</nt>である。これらの式は各々、この文書の別の節で述べる。</p>
	 <div2 id="id-primary-expressions"> 
	 <head>基本式</head> 
<p><termdef id="dt-primary-expression" term="primary expression"><term>基本式</term>(primary expression)はXPath言語の基本原式である。これにはリテラル、変数参照、文脈項目式、関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。</termdef> </p>

	 <scrap headstyle="show"> 
		<head/> <prod num="41" id="doc-xpath-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt></rhs></prod> 

	 </scrap> 
	 <div3 id="id-literals"> 
		<head>リテラル</head> 
<p><termdef id="dt-literal" term="literal"><term>リテラル</term>は原子値の直接的構文表現である。</termdef> XPathは2種類のリテラルを支援する。数リテラルと文字列リテラルである。</p>
		<scrap headstyle="show"> 
		  <head/> <prod num="42" id="doc-xpath-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod> 
		  
		  <prod num="43" id="doc-xpath-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod> 
		   
		  <prod num="71" id="doc-xpath-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		   
		  <prod num="72" id="doc-xpath-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs></prod> 
		   
		  <prod num="73" id="doc-xpath-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		   
		  <prod num="74" id="doc-xpath-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs></prod> 
		   
		<prod num="75" id="doc-xpath-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="76" id="doc-xpath-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="81" id="doc-xpath-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod>
		
</scrap> 
<p><term>数リテラル</term>の値のうち"<code>.</code>"と文字<code>e</code>, <code>E</code>を含まないものは<code>xs:integer</code>型の原子値である。数リテラルの値のうち、"<code>.</code>"を含むが文字<code>e</code>も<code>E</code>も含まないものは<code>xs:decimal</code>型の原子値である。数リテラルの値のうち、文字<code>e</code>か<code>E</code>を含むものは<code>xs:double</code>型の原子値である。これらの数リテラルの値は、<xspecref spec="FO" ref="casting-from-strings"/>で指定されているように、<code>xs:untypedAtomic</code>から数型へ型変換するためのルールにしたがって、適切な型へ変換することにより決定される。</p>
<p><term>文字列リテラル</term>の値は、 <code>xs:string</code>を型とし、区切りの一重引用符または二重引用符の間の文字によって表される文字列を値とするような原子値である。リテラルが一重引用符で区切られているとき、リテラル中で隣り合った2つの一重引用符は1つの一重引用符と解釈される。同様に、リテラルが二重引用符で区切られているとき、リテラル中で隣り合った2つの二重引用符は1つの二重引用符と解釈される。</p>



<p>リテラル式の例をいくつか示す。</p>
		<ulist> 
		  <item> 
		    <p><code>"12.5"</code>は、文字 '1', '2', '.', '5'からなる文字列を表す。</p>
		  </item> 
		  <item> 
		    <p><code>12</code>は<code>xs:integer</code>の値12を表す。</p>
		  </item> 
		  <item> 
		    <p><code>12.5</code>は<code>xs:decimal</code>の値12.5を表す。</p>
		  </item> 
		  <item> 
		    <p><code>125E2</code>は、<code>xs:double</code>の値12500を表す。</p>
		  </item>
		  <item>
<p><code>"He said, ""I don't like it."""</code>は2つの二重引用符と1つの
一重引用符を含む文字列を表す。</p>
<note role="xpath"><p>XMLの属性の中など、一重引用符が特別な意味を持つ文脈にXPath式が埋め込まれるときは、さらにエスケープ処理が必要になるかもしれない。</p>
</note></item> 


		</ulist> 
<p><code>xs:boolean</code>の値<code>true</code>と<code>false</code>は、それぞれ<termref def="dt-built-in-function">組み込み関数</termref> <code>fn:true()</code>と<code>fn:false()</code>の呼び出しによって表現することができる。</p>
<p>その他の原子型の値は、与えられた型に対する<termref def="dt-constructor-function">構成子関数</termref>を呼び出すことにより構成することができる。XML Schemaの組み込み型に対する構成子関数は<bibref ref="FunctionsAndOperators"/>で定義されている。一般的に、ある型の構成子関数の名前は、その型の名前(名前空間を含む)と等しい。例えば:</p>
		<ulist> 
		   
		  <item> 
		    <p><code>xs:integer("12")</code>は整数値12を返す。</p>
		  </item> 
		  <item> 
		    <p><code>xs:date("2001-08-25")</code>は、型が<code>xs:date</code>で、値が2001年8月25日という日付を表す項目を返す。</p>
		  </item>
		  <item><p><code>xs:dayTimeDuration("PT5H")</code>は、型が<code>xs:dayTimeDuration</code>で、値が5時間という時間を表す項目を返す。</p>
		  </item> 
		</ulist> 
<p>また構成子関数は、以下の例のように、リテラル表現を持たない特別な値を生成することもできる。
<ulist><item><p><code>xs:float("NaN")</code>は、"数でない"(Not a Number)という特別な浮動小数点数の値を返す。</p>
</item>
<item><p><code>xs:double("INF")</code>は"正の無限大"という特別な二倍長浮動小数点数の値を返す。</p>
</item></ulist></p>
<p>また、<code>cast</code>式を用いてさまざまな型の値を構成することもできる。例えば以下の通り。</p>
		<ulist> 
		  <item> 
		    <p><code>9 cast as hatsize</code>は、型が<code>hatsize</code>である原子値<code>9</code>を返す。</p>
		  </item> 
		</ulist> 
	 </div3> 
	 <div3 id="id-variables"> 
		<head>変数参照</head> 
		<scrap headstyle="show"> 
		<head/>  
	 <prod num="44" id="doc-xpath-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt></rhs></prod>

	<prod num="45" id="doc-xpath-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod>

</scrap>
<p><termdef id="dt-variable-reference" term="variable reference"><term>変数参照</term>は$記号にQNameを続けたものである。</termdef> 2つの変数参照が同値であるとは、それらの局所名が等しく、かつそれらの名前空間接頭辞が<termref def="dt-static-namespaces">静的既知名前空間</termref>中の同じ名前空間URIに束縛されていることである。接頭辞のない変数参照はどの名前空間にも属さない。</p>
<p>変数参照はそれぞれ<termref def="dt-in-scope-variables">有効範囲内変数</termref>内の名前に照合されなければならない。有効範囲内変数には以下の出所からの変数が含まれる。
<olist>

<item><p><termref def="dt-in-scope-variables">有効範囲内変数</termref>は<termref def="dt-implementation-defined">実装定義</termref>の変数によって拡大されてもよい。</p>
</item>
<item><p>変数はXPath式によって束縛されてもよい。<phrase role="xpath">変数を束縛することのできる式の種類は<code>for</code>式 (<specref ref="id-for-expressions"/>) と限量式 (<specref ref="id-quantified-expressions"/>)である。</phrase></p>
</item></olist></p> 
		 
		 
		 
		 
<p>変数束縛はそれぞれ静的有効範囲を持つ。有効範囲は、変数への参照が正しく出現できる場所を定義する。有効範囲の中にない変数を参照すると、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0008"/> である。ある式に対して、変数が<termref def="dt-static-context">静的文脈</termref>内で束縛されれば、その変数は式全体に対する有効範囲に含まれる。</p>
<p>変数参照が有効範囲内の2つ以上の変数束縛に照合されたときは、その参照は、より内側の束縛、すなわち有効範囲がより小さいほうの束縛を参照すると解釈される。評価時には、変数参照の値は、対応する変数が束縛されている式の値である。変数束縛の有効範囲は、変数を束縛することのできる式それぞれについて個別に定義される。</p>
	 </div3> 
	 <div3 id="id-paren-expressions"> 
		<head>括弧式</head> 
		<scrap headstyle="show"> 
<head/> <prod num="46" id="doc-xpath-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod> 
 
</scrap><p>括弧は、複数の演算子を含む式の評価順序をある順に強制するのに用いてもよい。例えば、式<code role="parse-test">(2 + 4)
		    * 5</code>を評価すると30になる。なぜなら括弧式<code role="parse-test">(2 + 4)</code>が最初に評価され、その結果に5が掛けられるからである。括弧をつけなければ、式<code role="parse-test">2 + 4 * 5</code>を評価すると22になる。なぜなら乗算演算子は加算演算子より優先度が高いからである。</p> 
		 
		<p>空の括弧は、<specref ref="construct_seq"/>にある通り、空列を表すのに用いられる。</p> 
	 </div3> 

         <div3 id="id-context-item-expression">
              <head>文脈項目式</head>
              <scrap headstyle="show"> <head/><prod num="47" id="doc-xpath-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod>
	      
 </scrap>

              <p><term>文脈項目式</term>を評価すると<termref def="dt-context-item">文脈項目</termref>が得られる。これは節点(式<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>中のように)か、原子値(式<code>(1 to
              100)[. mod 5 eq 0]</code>中のように)のいずれかである。</p>
<p><termref def="dt-context-item">文脈項目</termref>が未定義であれば、文脈項目式は動的エラーを引き起こす<errorref class="DY" code="0002"/>。</p>

         </div3>

	 <div3 id="id-function-calls"> 
		<head>関数呼び出し</head> 
		<p> <termdef term="built-in function" id="dt-built-in-function">XPathで支援されている<term>組み込み関数</term>は<bibref ref="FunctionsAndOperators"/>で定義されている。</termdef> <phrase role="xpath">その他の関数が<termref def="dt-static-context">静的文脈</termref>で用意されていてもよい。XPathそれ自体では関数を定義する方法は用意されていないが、ホスト言語でそのような仕組みが用意されていてもよい。</phrase>

		</p><scrap headstyle="show"> 
		  <head/> 
		  <prod num="48" id="doc-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		   
		</scrap><p><term>関数呼び出し</term>は、QNameの後ろに0個以上の式の括弧付きリストが続くような構成をしている。この括弧付きリストを<term>引数</term>という。関数呼び出しのQNameが名前空間接頭辞を持っていなければ、<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>に属するとみなす。</p>
<p>関数呼び出しの<termref def="dt-expanded-qname">展開済QName</termref>や引数の数が<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-function-signature">関数シグネチャ</termref>の名前や次数に照合されなければ、<termref def="dt-static-error">静的エラー</termref>が発生する<errorref class="ST" code="0017"/>。</p> 
		 
		 

		


		<p>関数呼び出しは次のように評価される。</p> 
		<olist> 
		  <item> 
			 <p>引数の式が評価され、引数値を生成する。引数の評価順序は<termref def="dt-implementation-dependent">実装依存</termref>であり、ある引数を評価することなく関数の本体が評価できるならば、関数はその引数を評価する必要はない。</p> 
		  </item> 
		  <item> 
			 <p>以下に挙げる関数変換ルールを適用して、引数値がそれぞれ変換される。</p> 
		  </item><item role="xpath"><p>変換された引数値を用いて関数が評価される。結果は、関数の定義済返り型のインスタンスか、動的エラーである。関数の結果の<termref def="dt-dynamic-type">動的型</termref>は定義済返り型から導出される型であってもよい。関数によって引き起こされるエラーは<bibref ref="FunctionsAndOperators"/>に定義されている。</p></item> 

		   

		</olist> 
		<p><term>関数変換ルール</term>は、引数値を、引数として期待される型に変換するのに用いられる。すなわち、関数の<phrase role="xpath">引数</phrase>の定義済型に変換するのに用いられる。期待される型は<termref def="dt-sequence-type">列型</termref>として表現される。与えられた値に対して、関数変換ルールは以下のように適用される。</p> 
		<ulist><item role="xpath"><p><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であり、かつ引数が期待される型でないならば、以下のような変換が順に引数値Vに適用される。</p>
<olist><item><p>期待される型が単一項目もしくは省略可能な単一項目 (例: <code>xs:string</code>, <code>xs:string?</code>, <code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>)を要求するならば、値VはV[1]に置き換えられる。</p></item>
<item><p>期待される型が<code>xs:string</code>または<code>xs:string?</code>であるならば、値<code>V</code>は<code>fn:string(V)</code>に置き換えられる。</p></item>
<item><p>期待される型が<code>xs:double</code>または<code>xs:double?</code>であるならば、値<code>V</code>は<code>fn:number(V)</code>に置き換えられる。</p></item></olist></item>
<item><p>期待される型が原子型の列 (出現標識<code>*</code>, <code>+</code>, <code>?</code>を伴っていてもよい)であるならば、以下の変換が適用される。</p>
<olist><item><p>与えられた値に<termref def="dt-atomization">原子化</termref>が行われ、原子値の列が結果として得られる。</p></item>
<item><p>原子列の項目のうち<code>xs:untypedAtomic</code>型のものそれぞれに対し、期待される原子型への型変換が行われる。<termref def="dt-built-in-function">組み込み関数</termref>のうち期待される型が<termref def="dt-numeric">数</termref>と指定されているものについて、<code>xs:untypedAtomic</code>型の引数が<code>xs:double</code>に型変換される。</p></item><item><p>原子列中の<termref def="dt-numeric">数</termref>項目のうち、<specref ref="promotion"/>に書かれている数昇格を用いて期待される原子型に<termref def="dt-type-promotion">昇格</termref>できるものについて、昇格が行われる。</p></item>
<item><p>原子列中の<code>xs:anyURI</code>型の項目のうち、<specref ref="promotion"/>に書かれているURI昇格を用いて期待される原子型に<termref def="dt-type-promotion">昇格</termref>できるものについて、昇格が行われる。</p></item></olist></item>
<item><p>上記の変換を行った後、結果の値が、<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールに従って期待される型に照合されないときは、<termref def="dt-type-error">型エラー</termref>が発生する<errorref class="TY" code="0004"/>。

<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールは、導出された型の値を基礎型の値として置換することを許していることに注意せよ。</p></item></ulist>

		 
<p>関数呼び出しの引数はコンマで区切られているので、最上位の<termref def="dt-comma-operator">コンマ演算子</termref>を含む引数式は、括弧で囲まなければならない。以下は、関数呼び出しの例とその説明である。</p>
		<ulist> 
		  <item> 
			 <p> <code role="parse-test">my:three-argument-function(1,
			2, 3)</code>は3つの引数を持つ関数呼び出しである。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function((1,
			2), 3)</code>は2つの引数を持つ関数呼び出しであり、1つ目の引数は2つの値の列である。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function(1,
			())</code>は2つの引数を持つ関数呼び出しであり、2つ目の引数は空列である。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:one-argument-function((1, 2,
			3))</code>は1つの引数を持つ関数呼び出しであり、その引数は3つの値の列である。</p> 
		  </item> 
		<item> 
			 <p> <code role="parse-test">my:one-argument-function(( ))</code>は1つの引数を持つ関数呼び出しであり、その引数は空列である。</p> 
		  </item><item> 
			 <p> <code role="parse-test">my:zero-argument-function( )</code>は引数のない関数呼び出しである。</p> 
		  </item></ulist> 
	 </div3> 
	  
  </div2> 
  <div2 id="id-path-expressions"> 
	 <head>経路式</head> 
	  
	 <scrap headstyle="show"> 
		<head/> <prod num="25" id="doc-xpath-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs></prod>

<prod num="26" id="doc-xpath-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod> 
		   
	 </scrap> 
	 <p><termdef id="dt-path-expression" term="path expression"><term>経路式</term>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の
<termref def="dt-step">ステップ</termref>の並びからなり、各ステップは "<code>/</code>" または 
"<code>//</code>", で区切られている。また、経路式は
	 "<code>/</code>" または "<code>//</code>"で始まる場合もある。</termdef>先頭の
	 "<code>/</code>" または "<code>//</code>" は、以下に述べるように、経路式の先頭に暗黙的に追加される1つ以上の初期ステップの省略形である。</p><p>単一のステップからなる経路式は<specref ref="id-steps"/>に述べるように評価される。</p>
<p>経路式の先頭にある "<code>/</code>" は初期ステップ<code>fn:root(self::node()) treat as
	 document-node()/</code>の省略形である (ただし、もし
	 "<code>/</code>" が経路式全体であるならば、末尾の "<code>/</code>" は展開から省かれる)。この初期ステップの効果は、その経路が文脈節点を含む木の根節点から始まる、ということである。文脈項目が節点でない場合は、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。評価時に、文脈節点より上にある根節点が文書節点でなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p>

	 <p>経路式の先頭にある "<code>//</code>" は初期ステップ<code>fn:root(self::node()) treat as
	 document-node()/descendant-or-self::node()/</code>の省略形である (ただし、"<code>//</code>" それ自身は正しい経路式ではない <errorref class="ST" code="0003"/>)。これらの初期ステップの効果は、文脈節点の存在する木の根を含み、この根の子孫にすべての節点があるような初期節点列を確立するということである。この節点列は、経路式中の次のステップの入力として用いられる。文脈項目が節点でなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。評価時に、文脈節点より上にある根節点が文書節点でなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p>
	  
	 <note><p>節点の子孫には属性節点<phrase role="xpath">や名前空間節点</phrase>は含まれない。</p></note><p>経路式中の先頭ではない場所に出現する "<code>//</code>" は<specref ref="abbrev"/>に述べるように展開され、
"<code>/</code>" で区切られるステップの列になる。次に、このステップ列が左から右へ評価される。それぞれの演算
<code role="parse-test">E1/E2</code>は次のように評価される: 
式<code role="parse-test">E1</code>が評価され、結果が(空かもしれない)節点列でなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0019"/>。
	 次に、<code>E1</code>の評価の結果得られる節点それぞれが、<specref ref="eval_context"/>にあるように、さらに<code>E2</code>の評価のための<term>内部焦点</term>を提供する。
<code>E2</code>の評価すべてから得られた列が以下のように結合される:</p>
<olist><item><p><code>E2</code>の評価それぞれが(空かもしれない)節点列を返すなら、これらの列が結合され、節点の識別性に基づき、重複する節点が除去される。<phrase role="xpath">結果の節点列は<termref def="dt-document-order">文書順</termref>で返される。</phrase></p></item>
<item><p><code>E2</code>の評価それぞれが(空かもしれない)原子値列を返すなら、これらの列が<phrase role="xpath">順に</phrase>連接され、返される。</p></item>
<item><p>複数の<code>E2</code>の評価の結果、節点と原子値が少なくとも1つずつ返ってきたならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0018"/>。</p></item></olist>
<note><p>経路の各ステップが次のステップのための文脈節点を用意するため、その結果、経路の最後のステップしか、原子値列を返すことは許されない。</p></note>
<p>経路式の例として、<code role="parse-test">child::div1/child::para</code>は、文脈節点の子要素<code>div1</code>の子要素<code>para</code>を選択する。言い換えれば、文脈節点の孫要素<code>para</code>のうち<code>div1</code>を親として持つものが選択される。 </p>
	  
	 <note><p id="Chg-slash-note">文字 "<code>/</code>" は、完全な経路式としても、"<code>/*</code>" のようなさらに長い経路式の先頭としても用いることができる。また、"<code>*</code>" は、乗算演算子であるとともに経路式のワイルドカードでもある。このことにより、"<code>/</code>" が "<code>*</code>" の左側に出現するとき、構文解析が難しくなる。これは、<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">leading-lone-slash </loc>制約を用いることにより、解決できる。例えば、"<code>/*</code>" と "<code>/ *</code>" はワイルドカードを含む正しい経路式であるが、"<code>/*5</code>" と "<code>/ * 5</code>" は構文エラーを引き起こす。<code>/</code>" を演算子の左側で用いる時は、"<code>(/) * 5</code>" のように、括弧をつけなければならない。同様に、"<code>4 + / * 5</code>" は構文エラーを引き起こすが、"<code>4 + (/) * 5</code>" は正しい式である。式 "<code>4 + /</code>" もまた正しい。なぜなら<code>/</code>が演算子の左側に出現していないからである。</p></note><div3 id="id-steps"> 
		<head>ステップ</head> 
		<scrap headstyle="show"> 
		  <head/> <prod num="27" id="doc-xpath-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod> 

			 <prod num="28" id="doc-xpath-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>

<prod num="29" id="doc-xpath-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod> 

			 <prod num="32" id="doc-xpath-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod> 
			 
		<prod num="39" id="doc-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod>
		</scrap> 
		<p><termdef term="step" id="dt-step"><term>ステップ</term>は<termref def="dt-path-expression">経路式</termref>の一部であり、項目の列を生成し、その列を0個以上の<termref def="dt-predicate">述語</termref>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<termref def="dt-axis-step">軸ステップ</termref>または<termref def="dt-filter-expression">選別式</termref>のいずれかである。</termdef> 選別式の説明は<specref ref="id-filter-expr"/>にある。</p>
<p><termdef term="axis step" id="dt-axis-step"><term>軸ステップ</term>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<term>軸</term>はステップでの "移動方向" を定義し、<termref def="dt-node-test">節点テスト</termref>は節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>により節点を選択する。</termdef> 文脈項目が節点であれば、軸ステップは0個以上の節点からなる列を返す。それ以外の場合は、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。<phrase role="xpath">得られる節点列は<termref def="dt-document-order">文書順</termref>で返される。</phrase>  軸ステップは<term>前向きステップ</term>かまたは<term>逆向きステップ</term>のいずれかであり、0個以上の<termref def="dt-predicate">述語</termref>がそれに続く。</p>
		 
		<p>ステップの<term>省略構文</term>では、軸は省略可能であり、また<specref ref="abbrev"/>にあるように、その他の短縮記法も利用できる。</p> 
		<p>軸ステップの非省略構文は軸名と節点テストからなり、これらは2つのコロンで区切られる。ステップの結果は、指定された軸を通して文脈節点から到達可能な節点のうち、節点テストで指定される節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>を持つものからなる。例えば、ステップ<code>child::para</code>は、文脈節点の子要素<code>para</code>を選択する。ここで<code>child</code>が軸の名前であり、<code>para</code>がこの軸上で選択される要素節点の名前である。利用できる軸の説明は<specref ref="axes"/>にある。利用できる節点テストの説明は<specref ref="node-tests"/>にある。ステップの例は<specref ref="unabbrev"/>や<specref ref="abbrev"/>で示されている。</p> 

		<div4 id="axes"> 
		  <head>軸</head> 
		  <scrap headstyle="show"> 
			 <head/> <prod num="30" id="doc-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod> 

				<prod num="33" id="doc-xpath-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod> 
				
		  </scrap> 





		  <p role="xpath">XPathは文書を行ったり来たりするための<term>軸</term>の完全な集合を定義しているが、<term>ホスト言語</term>がこれらの軸の部分集合を定義してもよい。以下の軸が定義されている。</p> 

		  

		  <ulist> 
		    <item> 

		      <p><code>child</code>軸は文脈節点の子を含む。これらの節点は<bibref ref="datamodel"/>にある<code>dm:children</code>アクセサにより返される。</p>
		      <note>
						     
			<p>子を持つのは文書節点と要素節点だけである。文脈節点がこれ以外の種類の節点であるか、文脈節点が空の文書節点もしくは要素節点であったならば、child軸は空列である。文書節点や要素節点の子は、要素節点、処理命令節点、コメント節点、テキスト節点のいずれかである。属性節点<phrase role="xpath">、名前空間節点</phrase>、文書節点は決して子として出現することはない。</p></note>

		    </item>
		    <item> <p><code>descendant</code>軸はchild軸の推移的閉包として定義される。この軸には文脈節点の子孫 (子、子の子、など) が含まれる。</p>

		    </item> 
		    
		    <item> 

		      <p><code>parent</code>軸は<bibref ref="datamodel"/>にある<code>dm:parent</code>アクセサにより返される列を含む。このアクセサは文脈節点の親を返す。ただし、文脈節点が親を持たない場合は空列を返す。</p>

		    <note><p>属性節点はその親として要素節点を持っていてもよい。ただしその場合も、その属性節点はその要素節点の子ではない。</p></note></item> 

		    <item> <p><code>ancestor</code>軸はparent軸の推移的閉包として定義される。この軸には文脈節点の先祖 (親、親の親、など) が含まれる。</p>

		    <note><p>ancestor軸には、文脈節点のある木の根節点が含まれる。ただし、文脈節点が根節点の場合は含まれない。</p></note>

		    </item> 


		    <item> <p><code>following-sibling</code>軸は文脈節点の後に続く兄弟を含む。すなわち文脈節点の親の子のうち、<termref def="dt-document-order">文書順</termref>で文脈節点の後ろに出現する節点を含む。もし文脈節点が属性節点<phrase role="xpath">または名前空間節点</phrase>であれば、<code>following-sibling</code>軸は空である。</p>
		    </item>

		    <item> <p><code>preceding-sibling</code>軸は文脈節点の前にある兄弟を含む。すなわち文脈節点の親の子のうち、<termref def="dt-document-order">文書順</termref>で文脈節点より前に出現する節点を含む。もし文脈節点が属性節点<phrase role="xpath">または名前空間節点</phrase>であれば、<code>preceding-sibling</code>軸は空である。</p>
		    </item>

			 <item> 

				<p><code>following</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<termref def="dt-document-order">文書順</termref>で文脈節点より後ろに出現するものすべてを含む。</p>

			 </item> 

			 <item> 

				<p><code>preceding</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<termref def="dt-document-order">文書順</termref>で文脈節点より前に出現するものすべてを含む。</p>

			 </item> 

			 <item> <p><code>attribute</code>軸は、文脈節点の属性を含む。これらは<bibref ref="datamodel"/>にある<code>dm:attributes</code>アクセサによって返される節点である。文脈節点が要素でなければ、この軸は空である。</p>

			 </item> 
			  
			 <item> 
				<p><code>self</code>軸は文脈節点自身のみを含む。</p> 
			 </item> 
			 <item> 
				<p><code>descendant-or-self</code>軸は、文脈節点と、文脈節点の子孫を含む。</p> 
			 </item> 
			 <item> 
				<p><code>ancestor-or-self</code>軸は、文脈節点と、文脈節点の先祖を含む。したがって、ancestor-or-self軸は常に根節点を含む。</p> 
			 </item> 

		  <item role="xpath"> 

				<p><code>namespace</code>軸は、文脈節点の名前空間節点を含む。これらは<bibref ref="datamodel"/>にある<code>dm:namespace-nodes</code>アクセサにより返される節点である。文脈節点が要素節点でなければ、この軸は空である。<code>namespace</code>節点はXPath 2.0 では推奨されない。もし<termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、<code>namespace</code>軸は支援されなければならない。もし<termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>false</code>であれば、<code>namespace</code>軸の支援は<termref def="dt-implementation-defined">実装定義</termref>である。<termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>false</code>であるとき<code>namespace</code>軸を支援しない実装では、この軸が使われると<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0010"/>を発生させなければならない。要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>に関する情報を必要とするアプリケーションは、<bibref ref="FunctionsAndOperators"/>で定義される<code>fn:in-scope-prefixes</code>関数や<code>fn:namespace-uri-for-prefix</code>関数を使うべきである。</p>

			 </item></ulist> 
		  <p>軸は<term>前向き軸</term>と<term>逆向き軸</term>とに分類することができる。文脈節点または<termref def="dt-document-order">文書順</termref>で文脈節点より後ろの節点のみ含む軸は、前向き軸である。文脈節点または<termref def="dt-document-order">文書順</termref>で文脈節点より前の節点のみ含む軸は、逆向き軸である。</p> 
		  <p><code>parent</code>軸, <code>ancestor</code>軸, <code>ancestor-or-self</code>軸, <code>preceding</code>軸, <code>preceding-sibling</code>軸は逆向き軸である。それ以外の軸はすべて前向き軸である。<code>ancestor</code>軸, <code>descendant</code>軸, <code>following</code>軸, <code>preceding</code>軸, <code>self</code>軸は文書を分割する (属性節点<phrase role="xpath">と名前空間節点</phrase>は無視する)。これらの軸は互いに重複がなく、すべてを合わせると文書中のすべての節点を含む。</p> 
		   
		<p><termdef id="dt-principal-node-kind" term="principal node kind">軸はそれぞれ<term>主要節点種類</term>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。</termdef> したがって:</p> 
		  <ulist> 
			 <item> 
				<p>attribute軸に対しては、主要節点種類は属性である。</p> 
			 </item> 
			 <item role="xpath"> 
				<p>namespace軸に対しては、主要節点種類は名前空間である。</p> 
			 </item> 
			 <item> 
				<p>それ以外のすべての軸に対しては、主要節点種類は要素である。</p> 
			 </item> 
		 </ulist>

		</div4> 
		<div4 id="node-tests"> 
		  <head>節点テスト</head> 
		  <p><termdef id="dt-node-test" term="node test"><term>節点テスト</term>は、<termref def="dt-step">ステップ</termref>によって選択された節点それぞれについて真にならなければならない条件である。</termdef> 
この条件は、節点の種類 (要素、属性、テキスト、文書、コメント、処理命令)、節点の名前、(要素節点、属性節点、文書節点の場合には) 節点の<termref def="dt-type-annotation">型注釈</termref>に基づいていてもよい。</p>
		  <scrap headstyle="show"> 
			 <head/> <prod num="35" id="doc-xpath-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt></rhs></prod> 

				<prod num="36" id="doc-xpath-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod> 
				
				<prod num="37" id="doc-xpath-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>)</rhs></prod> 
				 
		  </scrap> 
		   
		  <p><termdef id="dt-name-test" term="name test">QNameまたはワイルドカードのみからなる節点テストを<term>名前テスト</term>という。</termdef> 名前テストが真になるのは、節点の<term>種類</term>がそのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>であり、節点の<termref def="dt-expanded-qname">展開済QName</termref>が節点テストで指定されている<termref def="dt-expanded-qname">展開済QName</termref>と (<code>eq</code> 演算子で定義されているように) 一致するとき、かつそのときに限る。例えば、<code role="parse-test">child::para</code>は、文脈節点の<code>para</code>子要素を選択する。文脈節点の子に<code>para</code>要素がなければ、節点の空集合を選択する。<code role="parse-test">attribute::abc:href</code>は、QName<code>abc:href</code>を持つ文脈節点の属性を選択する。文脈節点がそのような属性を持たなければ、節点の空集合を選択する。</p>
		  <p>節点テスト中のQNameは、式文脈の<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて<termref def="dt-expanded-qname">展開済QName</termref>に解決される。QNameの接頭辞が静的既知名前空間のどれにも一致しなければ、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0081"/>である。接頭辞のないQNameは、<termref def="dt-principal-node-kind">主要節点種類</termref>が要素である軸上で名前テストとして用いられると、式文脈の<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>の名前空間URIを持つ。これ以外の用いられ方の場合、名前空間URIを持たない。</p>
<p>名前テストの<termref def="dt-expanded-qname">展開済QName</termref>と名前が一致しないような要素節点に対しては、その名前テストは満たされない。たとえその名前がその名付けられた節点を先頭とするような<termref def="dt-substitution-group">置換グループ</termref>中にあったとしても、その名前テストは満たされない。</p> 
		  <p>節点テスト<code>*</code>は、そのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>であるような任意の節点に対して、真である。例えば、<code role="parse-test">child::*</code>は文脈節点のすべての子要素を選択する。また<code role="parse-test">attribute::*</code>は、文脈節点のすべての属性を選択する。</p> 
		  <p>節点テストは<code>NCName:*</code>という形式を持つことができる。この場合、接頭辞はQNameと同じ方法で展開される。このとき、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いる。その接頭辞が静的既知名前空間中になければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0081"/>。このような形式の節点テストが真になるのは、ステップの軸のうち<termref def="dt-expanded-qname">展開済QName</termref>が接頭辞の束縛されている名前空間URIを持っているものについて、その軸の<termref def="dt-principal-node-kind">主要節点種類</termref>の任意の節点に対してである。その名前の局所部分には関係しない。</p>
 <p>節点テストは<code>*:NCName</code>という形式を持つこともできる。この場合、節点テストが真になるのは、そのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>の節点のうち、局所名が与えられたNCNameに一致するものに対してである。節点の名前空間や、節点の名前空間の有無には関係しない。</p>
 <p><termdef term="kind test" id="dt-kind-test">節点テストのもう一つの形式は<term>種類テスト</term>と呼ばれる。これは、節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>に基づき、節点を選択することができる。</termdef> 種類テストの構文と意味についての記述は<specref ref="id-sequencetype-syntax"/>と<specref ref="id-sequencetype-matching"/>にある。種類テストが<termref def="dt-node-test">節点テスト</termref>内で用いられるとき、指定された軸上の節点のうち、その種類テストに照合されるものだけが選択される。以下に示すのは、経路式中で用いられている種類テストの例のいくつかである。</p>
<ulist><item><p><code>node()</code>は任意の節点に照合される。</p></item>
<item><p><code>text()</code>は任意のテキスト節点に照合される。</p></item>
<item><p><code>comment()</code>は任意のコメント節点に照合される。</p></item>
<item><p><code>element()</code>は任意の要素節点に照合される。</p></item>
<item><p><code>schema-element(person)</code>は、要素節点のうち、名前が<code>person</code> (または<code>person</code>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>に含まれる)であり、型注釈が<termref def="dt-is-elems">有効範囲内要素定義</termref>中の<code>person</code>要素の定義型と同じ(もしくは導出される)であるようなものに照合される。</p></item>
<item><p><code>element(person)</code>は、要素節点のうち、名前が<code>person</code>であるようなものに照合される。その節点の型注釈には関係しない。</p></item>
<item><p><code>element(person, surgeon)</code>は、nillでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>または<code>surgeon</code>から導出されるものに照合される。</p></item>
<item><p><code>element(*, surgeon)</code>は、nillでない要素節点のうち、型注釈が<code>surgeon</code> (または<code>surgeon</code>から導出される)であるようなものに照合される。その節点の名前には関係しない。</p></item>

                  

                  <item><p><code>attribute()</code>は任意の属性節点に照合される。</p></item>

                  <item><p><code>attribute(price)</code>は、属性節点のうち名前が<code>price</code>であるものに照合される。その節点の型注釈には関係しない。</p></item>
<item><p><code>attribute(*, xs:decimal)</code>は属性節点のうち型注釈が<code>xs:decimal</code>である (または<code>xs:decimal</code>から導出される) ものに照合される。その節点の名前には関係しない。</p></item>
<item><p><code>document-node()</code>は任意の文書節点に照合される。</p></item>
<item><p><code>document-node(element(book))</code>は、文書節点のうち内容が<termref def="dt-kind-test">種類テスト</termref> <code>element(book)</code>を満たす単一要素節点と、0個以上のコメントや処理命令が交差しているようなものに照合される。</p></item></ulist>
</div4> </div3>
	  
  <div3 id="id-predicates"> 
	 <head>述語</head> 
	  
	 <scrap headstyle="show"> 
		<head/>  
	 <prod num="40" id="doc-xpath-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod>
	 
</scrap> 
	 <p><termdef term="predicate" id="dt-predicate"><term>述語</term>は式からなり、角括弧で囲まれる。この式のことを<term>述語式</term>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。</termdef> 複数の隣接する述語の場合は、述語が左から右に適用され、それぞれの述語を適用した結果が次に続く述語の入力列になる。</p>
<p>入力列のそれぞれの項目に対して、述語式は <term>内部焦点</term> を用いて以下のように評価される: 文脈項目は、その述語によって現在評価されている項目である。文脈サイズは入力列中の項目数である。文脈位置は、入力列中の文脈項目の位置である。述語中での文脈位置を評価する目的で、入力列は以下のように整列されているとみなす: 述語が前向き軸のステップ中にあるなら文書順、述語が後ろ向き軸のステップ中にあるなら逆文書順、述語がステップ内にないなら元の順である。</p>
<p>入力列の項目それぞれに対して、
述語式の結果は<code>xs:boolean</code>の値に強制される。この値を<term>述語真偽値</term>といい、以下の通りになる。述語真偽値が<code>true</code>であるような項目が残され、述語真偽値が<code>false</code>であるような項目が捨てられる。</p> 
		<p>述語真偽値は以下のルールを順に適用することで導出される。</p> 
		<olist> 
		   
		  <item> 
			 <p>述語式の値が<termref def="dt-numeric">数</termref>型または<termref def="dt-numeric">数</termref>型から導出される型の<termref def="dt-singleton">単一値列</termref>原子値であるなら、述語真偽値は次のようになる。述語式の値が(<code>eq</code>演算子によって)<term>文脈位置</term>と等しい場合は<code>true</code>、それ以外の場合は<code>false</code>になる。 <termdef term="numeric predicate" id="dt-numeric-predicate">述語式が数型を返す述語を<term>数述語</term>という。</termdef></p> 

		  </item> 
		  <item> 
			 <p>これ以外の場合は、述語真偽値は、その述語式の<termref def="dt-ebv">有効ブール値</termref>である。</p> 
		  </item> 
		   
		</olist> 


		 
		<p>以下に、述語を含む<termref def="dt-axis-step">軸ステップ</termref>の例をいくつか示す。</p> 
		<ulist> 
		  <item> 
			 <p>この例は、文脈節点の子要素のうち、2番目の<code>chapter</code>要素を選択する。</p> 
			 <eg role="parse-test" xml:space="preserve">child::chapter[2]</eg> 
		</item> 
		<item> 
		  <p>この例は、文脈節点の子孫のうち、名前が<code>"toy"</code>であり、その<code>color</code>属性の値が<code>"red"</code>であるような要素を選択する。</p>
		  <eg role="parse-test" xml:space="preserve">descendant::toy[attribute::color = "red"]</eg> 
	 </item> 
	 <item> 
		<p>この例は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>子要素と<code>assistant</code>子要素をともに持つものを選択する。</p> 
		<eg role="parse-test" xml:space="preserve">child::employee[secretary][assistant]</eg> 
  </item> 
</ulist> 




 
 
<note><p><term>逆向き軸</term>を用いて選択された節点列に<termref def="dt-predicate">述語</termref>を用いる場合、このような列の文脈位置は<termref def="dt-reverse-document-order">逆文書順</termref>に割り当てられることを覚えておくことが重要である。例えば、<code>preceding::foo[1]</code>は<termref def="dt-reverse-document-order">逆文書順</termref>に最初に限定される<code>foo</code>要素を返す。なぜなら、この述語は逆向き軸を用いた<termref def="dt-axis-step">軸ステップ</termref>の一部であるからである。一方、<code>(preceding::foo)[1]</code>は<termref def="dt-document-order">文書順</termref>に最初に限定される<code>foo</code>要素を返す。なぜなら、括弧によって<code>(preceding::foo)</code>が<termref def="dt-primary-expression">優先式</termref>と解釈され、この式の中で文脈位置が文書順に割り当てられるからである。同様に、<code>ancestor::*[1]</code>は最も近い先祖要素を返す。なぜなら<code>ancestor</code>軸は逆向き軸であるからである。一方<code>(ancestor::*)[1]</code>は根要素 (文書順で最初の先祖) を返す。</p>
<p>後ろ向き軸のステップでは述語を評価する目的で文脈位置が逆文書順で割り当てられているという事実があっても、ステップの最終結果は常に文書順であるという事実は変わらない。</p>
</note>
</div3> 
<div3 id="unabbrev"> 
<head>非省略構文</head> 
<p>この節では経路式の例をいくつか出すが、これらは、各<termref def="dt-step">ステップ</termref>で軸が明示的に指定されている。これらの例で用いられている構文は<term>非省略構文</term>と呼ばれる。多くの場合に共通して、<term>省略構文</term>を用いて経路式をより簡潔に書くことが可能である。この構文については<specref ref="abbrev"/>で説明する。</p> 
<ulist> 
<item> 
<p> <code role="parse-test">child::para</code>は文脈節点の子である<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*</code>は文脈節点の子である要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::text()</code>は文脈節点の子であるテキスト節点すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::node()</code>は、文脈節点の子すべてを選択する。属性節点は返されないことに注意すること。なぜなら属性は子ではないからである。</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::name</code>は文脈節点の<code>name</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::*</code>は、文脈節点の属性すべてを選択する。</p> 
</item><item><p><code>parent::node()</code>は、文脈節点の親を選択する。文脈節点が属性節点であれば、この式はその属性が付けられている要素節点 (もしあれば) を返す。</p></item> 
<item> 
<p> <code role="parse-test">descendant::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor-or-self::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。さらに文脈節点が<code>div</code>要素であれば、文脈節点自身も選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">descendant-or-self::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。さらに文脈節点が<code>para</code>要素であれば、文脈節点自身も選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">self::para</code>は、文脈節点が<code>para</code>要素である場合は文脈節点自身を選択する。それ以外の場合には空列を返す。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::chapter/descendant::para</code>は、文脈節点の<code>chapter</code>子要素の子孫の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*/child::para</code>は、文脈節点の孫の<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/</code>は、文脈節点の含まれる木の根を選択する。ただし、この根が文書節点でなければ動的エラーを発生する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::para</code>は、文脈節点と同じ文書中にある<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::list/child::member</code>は、<code>list</code>要素を親とする<code>member</code>要素で、文脈節点と同じ文書中にあるものすべてを選択する。</p> 
 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 1]</code>は、文脈節点の子のうち最初の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()]</code>は、文脈節点の子のうち最後の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()-1]</code>は、文脈節点の子のうち最後から2番目の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() &gt; 1]</code>は、文脈要素の子の<code>para</code>要素のうち、1番目以外のものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">following-sibling::chapter[fn:position() = 1]</code>は、文脈要素の弟の<code>chapter</code>のうち、最初に出現するものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">preceding-sibling::chapter[fn:position() = 1]</code>は、文脈要素の兄の<code>chapter</code>のうち、直前に出現するものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::figure[fn:position() = 42]</code>は、文脈要素を含む文書中で42番目に出現する<code>figure</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code>は、文脈要素を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq "warning"]</code>は、文脈要素の子の<code>para</code>のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。 </p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq 'warning'][fn:position() = 5]</code>は、文脈節点の<code>para</code>子要素で、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの5番目のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 5][attribute::type eq "warning"]</code>は、文脈節点の子のうち5番目の<code>para</code>要素を選択する。ただし、その要素が<code>type</code>属性を持ち、その値が<code>warning</code>である場合に限られる。 </p> 
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title = 'Introduction']</code>は、文脈節点の子の<code>chapter</code>のうち、<termref def="dt-typed-value">型付けされた値</termref>が文字列<code>Introduction</code>に等しいような<code>title</code>子要素を1つ以上持つようなものを選択する。</p>
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1つ以上の<code>title</code>子要素を持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or self::appendix]</code>は、文脈節点の子の<code>chapter</code>と<code>appendix</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code>は、文脈節点の子の<code>chapter</code>または<code>appendix</code>のうち、最後のものを選択する。</p> 
</item> 
</ulist> 
</div3> 
<div3 id="abbrev"> 
<head>省略構文</head> 
<scrap headstyle="show"> 
<head/> <prod num="31" id="doc-xpath-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod> 

<prod num="34" id="doc-xpath-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod>

</scrap> 
<p>省略構文では、次の省略記法が認められる。</p> 
<olist> 
<item> 
<p>attribute軸<code>attribute::</code>は<code>@</code>と略記できる。例えば、経路式<code role="parse-test">para[@type="warning"]</code>は<code role="parse-test">child::para[attribute::type="warning"]</code>の短縮形であり、<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものを選択する。</p> 
</item><item> 
<p><termref def="dt-axis-step">軸ステップ</termref>から軸名が省略されると、軸ステップが<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>または <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> を含まない限り、デフォルトの軸は<code>child</code>になる。AttributeTestを含む場合は、デフォルトの軸は<code>attribute</code>になる。例えば、経路式<code role="parse-test">section/para</code>は<code role="parse-test">child::section/child::para</code>の省略形であり、経路式<code>section/@id</code>は<code>child::section/attribute::id</code>の省略形である。同様に、<code>section/attribute(id)</code>は<code>child::section/attribute::attribute(id)</code>の省略形である。後者の式は軸指定と<termref def="dt-node-test">節点テスト</termref>をともに含んでいることに注意せよ。</p> 
</item> 
 
<item> 
<p>経路式の処理中、先頭以外に出現する<code>//</code>は<code>/descendant-or-self::node()/</code>に置き換えられる。例えば、<code role="parse-test">div1//para</code>は<code role="parse-test">child::div1/descendant-or-self::node()/child::para</code>の短縮形であり、<code>div1</code>子要素の<code>para</code>子孫要素を選択する。</p> 
<note><p>経路式<code role="parse-test">//para[1]</code>は、経路式<code role="parse-test">/descendant::para[1]</code>と同じであるということを意味<emph>しない</emph>。後者は、最初の<code>para</code>子孫要素を選択する。前者は<code>para</code>子孫要素のうち、その親の最初の<code>para</code>子要素であるものをすべて選択する。</p></note> 
</item> 
<item> 
<p><code role="parse-test">..</code>からなるステップは<code role="parse-test">parent::node()</code>の短縮形である。例えば、<code role="parse-test">../title</code>は<code role="parse-test">parent::node()/child::title</code>の短縮形であり、文脈節点の親の<code>title</code>子要素を選択する。</p> 
<note>
   <p>式<code>.</code>は、<term>文脈項目式</term>と呼ばれ、<termref def="dt-primary-expression">基本式</termref>である。これについての説明は<specref ref="id-context-item-expression"/>にある。</p>
</note></item> 
</olist>



<p>以下に示すのは、省略構文を用いた経路の例である。</p> 
<ulist> 
<item> 
<p> <code>para</code>は、文脈節点の<code>para</code>子要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">*</code>は、文脈節点の子要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">text()</code>は、文脈節点の子であるテキスト節点すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">@name</code>は、文脈節点の<code>name</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">@*</code>は、文脈節点の属性すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[1]</code>は、文脈節点の<code>para</code>子要素のうち最初のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[fn:last()]</code>は、文脈節点の<code>para</code>子要素のうち最後のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">*/para</code>は、文脈節点の<code>para</code>孫要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/book/chapter[5]/section[2]</code>は、文脈節点を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter//para</code>は、文脈節点の<code>chapter</code>子要素の子孫である<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">//para</code>は、根である文書節点の子孫の<code>para</code>をすべて選択する。すなわち、文脈節点と同じ文書内にあるすべての<code>para</code>要素を選択する。</p> 
</item><item><p><code>//@version</code>は、文脈節点と同じ文書内にあるすべての<code>version</code>属性を選択する。</p></item> 
<item> 
<p> <code role="parse-test">//list/member</code>は、文脈節点と同じ文書内にある<code>member</code>要素のうち、<code>list</code>を親に持つものをすべて選択する。</p> 
 
</item> 
 
<item> 
<p> <code role="parse-test">.//para</code>は、文脈節点の子孫の<code>para</code>要素をすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">..</code>は文脈節点の親を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">../@lang</code>は、文脈節点の親の<code>lang</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"][5]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの中から5番目を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[5][@type="warning"]</code>は、文脈節点の5番目の<code>para</code>子要素が、<code>type</code>属性を持ち、その値が<code>warning</code>であるなら、それを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title="Introduction"]</code>は、文脈節点の<code>chapter</code>子要素のうち、<termref def="dt-typed-value">型付けされた値</termref>が文字列<code>Introduction</code>であるような<code>title</code>子要素を1つ以上持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1個以上の<code>title</code>子要素を持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">employee[@secretary and @assistant]</code>は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>属性と<code>assistant</code>属性をともに持つものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">book/(chapter|appendix)/section</code>は、<code>section</code>要素のうち親が<code>chapter</code>要素か<code>appendix</code>要素のいずれかであり、さらにそれが文脈節点の子の<code>book</code>の子であるようなものを選択する。</p> 
</item> 
<item><p><code>E</code>が節点列を返す式であるとき、式<code>E/.</code>は同じ節点列を<termref def="dt-document-order">文書順</termref>で返す。ただし、節点の識別性に基づき重複が除去される。</p></item> 
</ulist> 
</div3>	
</div2>	
<div2 id="id-sequence-expressions"> 
<head>列式</head> 
<p>XPathは<termref def="dt-item">項目</termref>の<termref def="dt-sequence">列</termref>を構成したり選別したり結合したりする演算を支援している。列は決して入れ子にならない。例えば、値<code>1</code>, <code>(2, 3)</code>, <code>( )</code>を結合して1つの列にすると、結果は列<code>(1, 2, 3)</code>になる。</p> 
<div3 id="construct_seq"> 
<head>列の構成</head> 
<scrap headstyle="show"> 
<head/>  
<prod num="2" id="noid_N12B76.doc-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
 
<prod num="11" id="doc-xpath-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod> 

</scrap> 
<p><termdef term="comma operator" id="dt-comma-operator">列を構成する1つの方法は、<term>コンマ演算子</term>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。</termdef> 空の括弧は空列を表すのに用いることができる。</p>
<p>列は原子値や節点を重複して含んでいてもよいが、列が別の列の項目になることは決してない。2つ以上の入力列を連接して新たな列を生成する場合、新たな列は、入力列の項目すべてを含み、かつその長さは入力列の長さの総和になる。</p> 
<note><p>関数呼び出しの引数など、文法中で<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>が必要とされる場所では、最上位のコンマ演算子を含む式はすべて括弧で囲まなければならない。</p></note>
<p>列を構成する式の例をいくつか示す。</p>
<ulist> 
<item> 
<p>この式の結果は、5つの整数の列である。</p> 
<eg role="parse-test" xml:space="preserve">(10, 1, 2, 3, 4)</eg> 
</item> 
<item> 
<p>この式はそれぞれ長さ1, 2, 0, 2である4つの列を結合し、長さ5の1つの列にする。この式の結果は列<code>10, 1, 2, 3, 4</code>になる。</p> 
<eg role="parse-test" xml:space="preserve">(10, (1, 2), (), (3, 4))</eg> 
 
 
</item> 
<item> 
<p>この式の結果は、文脈節点のすべての<code>salary</code>子節点の後ろにすべての<code>bonus</code>子節点が続くような列である。</p> 
<eg role="parse-test" xml:space="preserve">(salary, bonus)</eg> 
</item> 
<item> 
<p><code>$price</code>が値<code>10.50</code>に束縛されているとすると、この式の結果は列<code>10.50, 10.50</code>である。</p> 
<eg role="parse-test" xml:space="preserve">($price, $price)</eg> 
 
 
</item> 
</ulist> 
<p><term>範囲式</term>は連続した整数の列を構成するのに用いることができる。<code>to</code>演算子の演算数はそれぞれ、期待される引数の型が<code>xs:integer?</code>であるような関数の引数であるかのように、変換される。いずれかの演算数が空列であるか、第1演算数から導出される整数が第2演算数から導出される整数より大きければ、範囲式の結果は空列である。2つの演算数の変換結果が同じ整数になれば、範囲式の結果はその整数である。それ以外の場合は、結果は、2つの整数演算数、および2つの演算数の間の整数すべてからなる列であり、昇順に並べられる。</p> 
<ulist> 
<item> 
<p>この例では、列を構成する演算数の1つに範囲式を用いている。これを評価すると列<code>10, 1, 2, 3, 4</code>になる。</p> 
<eg role="parse-test" xml:space="preserve">(10, 1 to 4)</eg> 
 
</item><item><p>この例では、1つの整数<code>10</code>を含む長さ1の列を構成している。</p><eg role="parse-test" xml:space="preserve">10 to 10</eg></item>
<item><p>この例の結果は長さ0の列である。</p><eg role="parse-test" xml:space="preserve">15 to 10</eg></item>
<item><p>この例では、<code>fn:reverse</code>を用いて6つの整数の降順列を構成している。これを評価すると列<code>15, 14, 13, 12, 11, 10</code>となる。</p><eg role="parse-test" xml:space="preserve">fn:reverse(10 to 15)</eg></item> 
</ulist> 
</div3> 
<div3 id="id-filter-expr"><head>選別式</head>
<scrap headstyle="show"><head/>
<prod num="38" id="doc-xpath-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>

<prod num="39" id="noid_N12C1D.doc-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod>

</scrap>
<p><termdef id="dt-filter-expression" term="filter expression"><term>選別式</term>は、単に、1つの<term>基本式</term>の後ろに0個以上の<termref def="dt-predicate">述語</termref>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。</termdef> 述語が全く指定されなければ、結果は単に基本式の結果である。選別式によって返される項目の順序は、基本式の結果の順序と同じである。項目に割り当てられる文脈位置は、結果の列中の順序位置に基づいて決められる。最初の文脈位置は1である。</p>
<p>選別式の例を以下に示す。</p>
<ulist>
<item><p>productsの列が変数で与えられているとすると、これらのproductsのうちpriceが100以上のものを返す。</p><eg role="parse-test" xml:space="preserve">$products[price gt 100]</eg></item>
<item><p>1から100までの整数のうち5で割り切れるものをすべて列挙する(<code>to</code>演算子についての説明は<specref ref="construct_seq"/>を見よ)。</p><eg role="parse-test" xml:space="preserve">(1 to 100)[. mod 5 eq 0]</eg></item>
<item><p>以下の式の結果は整数25である。</p><eg role="parse-test" xml:space="preserve">(21 to 29)[5]</eg></item>
<item><p>以下の例は、変数 <code>$orders</code> に束縛されている列の5番目から9番目までを返す。</p><eg role="parse-test" xml:space="preserve">$orders[fn:position() = (5 to 9)]</eg></item>
<item><p>次に示すのは、選別式を<termref def="dt-path-expression">経路式</termref>の<termref def="dt-step">ステップ</termref>として用いている例である。これは、変数<code>$book</code>に束縛されている本の中からchapterまたはappendixのうち最後のものを返す。</p><eg role="parse-test" xml:space="preserve">$book/(chapter | appendix)[fn:last()]</eg></item>
<item><p>次に示すのも、選別式を<termref def="dt-path-expression">経路式</termref>の<termref def="dt-step">ステップ</termref>として用いている例である。これは、指定された文書中の要素節点のうち、IDの値が<code>tiger</code>であるようなものを返す。</p><eg role="parse-test" xml:space="preserve">fn:doc("zoo.xml")/fn:id('tiger')</eg></item></ulist></div3><div3 id="combining_seq"> 
<head>節点列の結合</head> 
<scrap headstyle="show"> 
<head/> <prod num="14" id="doc-xpath-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod> 

<prod num="15" id="doc-xpath-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod> 

</scrap> 
<p>XPathでは、節点列を結合する演算として次のようなものを用意している。</p>
<ulist>
<item><p><code>union</code>演算子と<code>|</code>演算子は等価である。これらは2つの節点列を演算数として取り、いずれかの演算数中に出現するすべての節点を含む列を返す。</p></item>
<item><p><code>intersect</code>演算子は2つの節点列を演算数として取り、どちらの演算数にも出現するすべての節点を含む列を返す。</p></item>
<item><p><code>except</code>演算子は2つの節点列を演算数として取り、第1演算数には出現するが第2演算数には出現しない節点をすべて含む列を返す。</p></item></ulist>
<p>これらの演算子はすべて、節点の識別性に基づき結果の列から重複した節点を取り除く。<phrase role="xpath">結果の列は<termref def="dt-document-order">文書順</termref>で返される。</phrase></p>
<p><code>union</code>, <code>intersect</code>, <code>except</code>の演算数が節点でない項目を含んでいたならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<p>以下に、列を結合する式の例をいくつか示す。3つの要素節点が存在すると仮定しよう。これらをA, B, Cという記号名で参照する。また、変数<code>$seq1</code>,  <code>$seq2</code>, <code>$seq3</code>が、先に挙げた節点からなる以下のような列に束縛されていると仮定する。</p>
<ulist><item><p><code>$seq1</code>は (A, B) に束縛されている</p></item>
<item><p><code>$seq2</code>は (A, B) に束縛されている</p></item>
<item><p><code>$seq3</code>は (B, C)に束縛されている</p></item></ulist>
<p>このとき:</p> 
<ulist> 
<item> 
<p> <code role="parse-test">$seq1 union $seq2</code>を評価すると列 (A, B) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 union $seq3</code>を評価すると列 (A, B, C) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 intersect $seq2</code>を評価すると列 (A, B) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 intersect $seq3</code>を評価すると B のみを含む列になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 except $seq2</code>を評価すると空列になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 except $seq3</code>を評価すると A のみを含む列になる。</p> 
</item> 
</ulist> 
<p>ここで述べた列に関する演算子に加えて、<bibref ref="FunctionsAndOperators"/>には、添字を通して項目や列の部分列にアクセスするための関数、添字を通して列中から項目を削除したり列中に項目を挿入するための関数、列から重複した項目を削除するための関数がある。</p> 
</div3>	
</div2><div2 id="id-arithmetic"> 
<head>算術式</head> 
<p>XPathは、加算、減算、乗算、除算、法などの算術演算子を、通常の単項や二項の形で用意している。</p> 
<scrap headstyle="show"> 
<head/> 
<prod num="12" id="doc-xpath-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod> 

<prod num="13" id="doc-xpath-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod> 

<prod num="20" id="doc-xpath-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod> 

<prod num="21" id="doc-xpath-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">PathExpr</nt></rhs></prod>

</scrap> 
<p>減算演算子の前には空白を置かなければならない。そうしなければ、直前の字句の一部と解釈されることがある。例えば、<code role="parse-test">a-b</code>は1つの名前と解釈されるが、<code role="parse-test">a - b</code>や<code>a -b</code>は算術式と解釈される。(空白処理の詳細は<specref ref="whitespace-rules"/>を見よ。)</p>
<p>算術式の評価は、まず演算数を評価することから始まる。演算数を評価する順番は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0 互換モード</termref>が<code>true</code>であれば、各演算数は以下のステップを順に適用することで評価される。</p>
<olist role="xpath">
<item><p><termref def="dt-atomization">原子化</termref>が演算数に適用される。この操作の結果は<term>原子化済演算数</term>と呼ばれる。</p></item>
<item><p>原子化済演算数が空列であれば、算術式の結果は<code>xs:double</code>の値<code>NaN</code>であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p></item>
<item><p>原子化済演算数が長さ1以上の列であれば、その列の先頭の項目から後ろの項目は捨てられる。</p></item>
<item><p>この結果、原子化済演算数が<code>xs:boolean</code>型, <code>xs:string</code>型,
<code>xs:decimal</code>型 (<code>xs:integer</code>を含む), <code>xs:float</code>型, <code>xs:untypedAtomic</code>型のいずれかのインスタンスになれば、<code>fn:number</code>関数を適用することで<code>xs:double</code>に変換される。(<code>fn:number</code>は、演算数が数に変換できない場合は値<code>NaN</code>を返すことに注意せよ。)</p></item></olist>
<p><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0 互換モード</termref>が<code>false</code>であれば、各</phrase>演算数は以下のステップを順に適用することで評価される。</p><olist>
<item><p><termref def="dt-atomization">原子化</termref>が演算数に適用される。この操作の結果は<term>原子化済演算数</term>と呼ばれる。</p></item>
<item><p>原子化済演算数が空列であれば、算術式の結果は空列であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p></item>
<item><p>原子化済演算数が長さ1より大きい列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:double</code>に型変換される。型変換に失敗すれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。 [err:FORG0001]</p></item></olist>
<p>演算数の評価の後、演算数の型が与えられた算術演算子について正しい組み合わせであれば、演算子が演算数に適用される。結果は、原子値または<termref def="dt-dynamic-error">動的エラー</termref>となる。 (例えば、0で除算を行った結果はエラーになるかもしれない。) さまざまな算術演算子に受け入れられる原子型の組み合わせ、算術演算子の結果として期待される型については<specref ref="mapping"/>に列挙されている。ここには、それぞれの型の組み合わせに対して演算子の意味を定義する<termref def="dt-operator-function">演算子関数</termref>についても記述がある。演算子関数の定義は<bibref ref="FunctionsAndOperators"/>にある。</p>
<p>演算数の型が、評価の後、与えられた演算子について正しい組み合わせでないならば、<specref ref="mapping"/>のルールに従って、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p>XPathは<code>div</code>と<code>idiv</code>という2種類の除算演算子を支援する。これらの演算子は、2つの演算数として任意の<termref def="dt-numeric">数</termref>型の値を許す。<bibref ref="FunctionsAndOperators"/>の説明の通り、<code>$arg1 idiv $arg2</code>は<code>($arg1 div $arg2) cast as xs:integer?</code>と等しい。ただしエラーの場合は除く。</p><p>以下に、算術式の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>以下の最初の式は<code>xs:decimal</code>の値<code role="parse-test">-1.5</code>を返し、2番目の式は<code>xs:integer</code>の値<code role="parse-test">-1</code>を返す。</p> 
<eg role="parse-test" xml:space="preserve">-3 div 2
-3 idiv 2</eg> 
 </item> 
<item> 
<p>2つの日付値の差の結果は<code>xs:dayTimeDuration</code>型の値になる。</p> 
<eg role="parse-test" xml:space="preserve">$emp/hiredate - $emp/birthdate</eg> 
</item> 
 
<item> 
<p>この例は減算演算子とハイフンの違いを示している。</p> 
<eg role="parse-test" xml:space="preserve">$unit-price - $unit-discount</eg> 
</item> 
<item> 
<p>単項演算子は二項演算子より優先度が高い。もちろんこれは、括弧の利用に左右される。従って、次の2つの例は異なる意味となる。</p> 
<eg xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</eg> 
</item> 
</ulist>	
<note><p id="note-consecutive-unary-ops"><bibref ref="XPath"/>との互換性のため、XPathでは複数の単項算術演算子が連続して出現することが許される。</p></note></div2>	
<div2 id="id-comparisons"> 
<head>比較式</head> 
<p>比較式は、2つの値を比較することを許す。XPathは、3種類の比較式を用意している。それぞれ、値比較、汎用比較、節点比較という。</p> 
<scrap headstyle="show"> 
<head/> <prod num="10" id="doc-xpath-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod>

<prod num="23" id="doc-xpath-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="22" id="doc-xpath-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod> 

<prod num="24" id="doc-xpath-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod> 

</scrap> 

<note role="xpath"><p role="xpath">XPath式がXML文書中に書かれる場合は、特殊文字に関するXMLのエスケープルールに従わなければならない。従って、"<code>&lt;</code>" は "<code>&amp;lt;</code>" と書き換えられなければならない。</p> </note>


<div3 id="id-value-comparisons"> 
<head>値比較</head> 
<p>値比較演算子は<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>である。値比較は単一値を比較するのに用いられる。</p> 
<p>値比較の評価で最初に行われるのは演算数の評価である。演算数が評価される順番は<termref def="dt-implementation-dependent">実装依存</termref>である。各演算数は以下のステップを順に適用することで評価される。</p>
<olist>
<item><p><termref def="dt-atomization">原子化</termref>が演算数に対して適用される。この操作の結果は<term>原子化済演算数</term>と呼ばれる。</p></item>
<item><p>原子化済演算数が空列であれば、値比較の結果は空列であり、実装は、他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p></item>
<item><p>原子化済演算数が長さ1より大きい列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:string</code>に型変換される。</p>
<note><p>このルールの目的は、値比較を推移的にするためである。利用者は、汎用比較演算子は<code>xs:untypedAtomic</code>演算数に関する別の型変換ルールを持っていることに気づくべきである。また利用者は、型変換での正確さを犠牲にすることで、値比較の推移性が妥協されてもよいということにも気づくべきである (例えば、ほんの少し異なる2つの<code>xs:integer</code>の値は、<code>xs:float</code>が<code>xs:interger</code>よりも正確さに欠けるために、同じ<code>xs:float</code>の値だとみなされてもよい)。</p></note></item></olist>
<p>次に、可能ならば、<termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって2つの演算数がそれらの最小共通型に変換される。例えば、演算数が <code>hatsize</code> 型 (<code>xs:integer</code> から導出される) と <code>shoesize</code> 型 (<code>xs:float</code> から導出される) であれば、それらの最小共通型は <code>xs:float</code> である。</p>
<p>最後に、演算数の型が与えられた演算子について正しい組み合わせであれば、演算子が演算数に対して適用される。さまざまな値比較演算子について、認められる原子型の組み合わせや、その演算子の結果として期待される型は<specref ref="mapping"/>にある。ここではまた<termref def="dt-operator-function">演算子関数</termref>についても記述されている。これは、型の組み合わせそれぞれに対して演算子の意味を定義するものである。演算子関数の定義は<bibref ref="FunctionsAndOperators"/>にある。</p>
<p>直観的には、2つの原子化済演算数がともにまったく1つの原子値からなっているならば、比較の結果は次のようになる。もし第1演算数の値が第2演算数の値 (に等しい, に等しくない, より小さい, より小さいか等しい, より大きい, より大きいか等しい) ならば、結果は<code>true</code>である。それ以外の場合には、比較の結果は<code>false</code>である。</p>
<p>演算数を評価した後、その演算数の型が与えられた演算数について正しくない組み合わせであれば、<specref ref="mapping"/>のルールに従って、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<p>以下に、値比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>次の比較は、式<code>$book/author</code>によって返される節点を原子化する。比較が真になるのは、原子化の結果が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての値 "Kennedy" である場合だけである。原子化の結果が空列であれば、比較の結果は空列になる。原子化の結果が2個以上の値を含む列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<eg role="parse-test" xml:space="preserve">$book1/author eq "Kennedy"</eg> 
</item>
<item><p>次の<termref def="dt-path-expression">経路式</termref>は、重さが100以上の製品を選択する述語を含む。<code>weight</code>部分要素を持たない製品については、この述語の値は空列であり、その製品は選択されない。この例では、<code>weight</code> は検証された要素であり、数型であると仮定している。</p><eg role="parse-test" xml:space="preserve">//product[weight gt 100]</eg></item>

<item><p>次の比較が真になるのは、<code>my:hatsize</code>と<code>my:shoesize</code>がともに、原子型<termref def="dt-numeric">numeric</termref>から制限によって導出されるユーザ定義型である場合である。</p><eg role="parse-test" xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</eg></item> 
<item><p>以下の比較は true である。<code>eq</code> は2つの QName について、それらの名前空間 URI と局所名をコード位置により比較を行うことにより、比較する。名前空間接頭辞は無視する。</p><eg role="parse-test" xml:space="preserve">fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")</eg></item>
</ulist> 
</div3> 
<div3 id="id-general-comparisons"> 
<head>汎用比較</head> 
<p>汎用比較演算子は<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>である。汎用比較は存在限量比較であり、任意の長さの列の演算数に適用してもよい。汎用比較の結果は、エラーが発生しないときは常に<code>true</code>か<code>false</code>である。</p>
<p role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、汎用比較は以下のルールを順に適用することで評価される。</p>
<olist role="xpath">
<item><p>どちらかの演算数が単一の原子値かつ<code>xs:boolean</code>のインスタンスであれば、もう一方の演算数は、その<termref def="dt-ebv">有効ブール値</termref>を取ることにより<code>xs:boolean</code>に変換される。</p></item>
<item><p><termref def="dt-atomization">原子化</termref>がそれぞれの演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p></item>
<item><p>比較演算子が<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>であれば、両演算数の列中の各項目が、<code>fn:number</code>関数を適用することにより、<code>xs:double</code>に変換される。 (<code>fn:number</code>は、演算数が数に変換できない場合は値<code>NaN</code>を返すことに注意せよ。)</p></item>
<item><p>比較の結果は次のようになる。原子値の組で、一方が第1演算数の列、もう一方が第2演算数の列であり、要求される<term>大小関係</term>を持っているものがあれば、結果は<code>true</code>である。そうでなければ、比較の結果は<code>false</code>である。2つの原子値間の<term>大小関係</term>は以下のルールを適用することで決定される。これらのルールから呼び出した<code>cast</code>演算子が成功しなければ、動的エラーが発生する。 [err:FORG0001]</p>
<olist>
<item><p>2つの原子値のうち少なくとも一方が<termref def="dt-numeric">数</termref>型のインスタンスであれば、原子値はともに、<code>fn:number</code>関数を適用することにより、<code>xs:double</code>型に変換される。</p></item>
<item><p>2つの原子値のうち少なくとも一方が<code>xs:string</code>のインスタンスであるか、原子値がともに<code>xs:untypedAtomic</code>のインスタンスであれば、原子値はともに<code>xs:string</code>型に型変換される。</p></item>
<item><p>原子値の一方が<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>, <code>xs:untypedAtomic</code>, あるいはどの<termref def="dt-numeric">数</termref>型のいずれでもなければ、<code>xs:untypedAtomic</code>の値が、もう一方の値の<termref def="dt-dynamic-type">動的型</termref>に型変換される。</p></item>
<item><p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>のいずれか一つを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, <code>&gt;=</code>のどれであったかに依存する。値が要求された<term>大小関係</term>を持っているのは、この値比較の結果が<code>true</code>であるとき、かつそのときに限る。</p></item></olist></item></olist>
<p><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>false</code>のとき、</phrase>汎用比較は以下のルールを順に適用することで評価される。</p>
<olist><item><p><termref def="dt-atomization">原子化</termref>が各演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p></item>
<item><p>比較の結果が<code>true</code>になるのは、原子値の組が存在し、その1つは第1演算数の列、もう一方が第2演算数の列であり、それらが要求された<term>大小関係</term>を持っているとき、かつその時に限る。それ以外の場合には、比較の結果は<code>false</code>になる。2つの原子値間の<term>大小関係</term>は、以下のルールを順に適用することで決定される。これらのルールによって呼び出される<code>cast</code>演算子が成功しなければ、動的エラーが発生する。 [err:FORG0001]</p>

<olist><item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<termref def="dt-numeric">数</termref>型のインスタンスであれば、<code>xs:untypedAtomic</code>の値が<code>xs:double</code>型に型変換される。</p></item>
<item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:untypedAtomic</code>または<code>xs:string</code>のインスタんであれば、<code>xs:untypedAtomic</code>の値 (または両方) が<code>xs:string</code>型に型変換される。</p></item>
<item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>, <code>xs:untypedAtomic</code>, または任意の<termref def="dt-numeric">数</termref>型のどれでもなければ、<code>xs:untypedAtomic</code>の値がもう一方の<termref def="dt-dynamic-type">動的型</termref>に型変換される。</p></item>
<item><p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>のいずれかを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, <code>&gt;=</code>のどれであったかに依存する。値が、要求される<term>大小関係</term>を持つのは、この値比較の結果が<code>true</code>である場合、かつその時に限る。</p></item></olist></item></olist>
<p>いずれかの演算数が項目の列である汎用比較を評価するとき、実装は、第1演算数と第2演算数から、要求される<term>大小関係</term>を持つ項目を1つずつ見つけると直ちに<code>true</code>を返してもよい。同様に、汎用比較は、いずれかの演算数を評価しているときや2つの演算数から選んだ項目の組を比較するときにエラーが生じれば、直ちに<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。これらのルールの結果として、エラーが存在するときには、汎用比較の結果は決定的ではない。</p> 
 
 
<p>以下に、汎用比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>以下の比較は、<code>$book1</code>の任意の部分要素<code>author</code>について、その<termref def="dt-typed-value">型付けされた値</termref>が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての "Kennedy" であるとき、trueになる。</p>
<eg role="parse-test" xml:space="preserve">$book1/author = "Kennedy"</eg> 
</item>
<item><p>以下の例は3つの汎用比較を含む。初めの2つの比較の値は<code>true</code>であり、3つ目の比較の値は<code>false</code>である。この例は、汎用比較は推移的ではないという事実を示している。</p>
<eg xml:space="preserve">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</eg></item>
<item><p>以下の例は2つの汎用比較を含む。これらはいずれも<code>true</code>である。この例は、<code>=</code>と<code>!=</code>は互いに逆ではないという事実を示している。</p><eg xml:space="preserve">(1, 2) = (2, 3)
(1, 2) != (2, 3)</eg></item>
<item><p><code>$a</code>, <code>$b</code>, <code>$c</code>がそれぞれ、型注釈<code>xs:untypedAtomic</code>を持ち、<termref def="dt-string-value">文字列値</termref> "<code>1</code>", "<code>2</code>"、および"<code>2.0</code>" を持つ要素節点に束縛されているとする。このとき <code>($a, $b) = ($c, 3.0)</code>は<code>false</code>を返す。なぜなら<code>$b</code>と<code>$c</code>は文字列として比較されるためである。しかし<code>($a, $b) = ($c, 2.0)</code>は<code>true</code>を返す。なぜなら<code>$b</code>と<code>2.0</code>は数として比較されるためである。</p></item> 
</ulist> 
</div3> 
<div3 id="id-node-comparisons"> 
<head>節点比較</head> 
<p>節点比較は、2つの節点を識別性または<termref def="dt-document-order">文書順</termref>に基づいて比較するのに用いられる。節点比較の結果は以下のルールにより定義される。</p> 
<olist> 
<item> 
<p>節点比較の演算数が<termref def="dt-implementation-dependent">実装依存</termref>の順で評価される。</p></item>
<item><p>各演算数は単一の節点か空列でなければならない。そうでない場合は<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
</item> 
<item> 
<p>いずれかの演算数が空列であれば、比較の結果は空列であり、実装は他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p> 
</item> 
<item> 
<p><code>is</code>演算子による比較が<code>true</code>を返すのは、2つの演算数が同じ識別性を持っており、したがって同じ節点である場合である。そうでない場合は<code>false</code>を返す。節点の識別性の定義は<bibref ref="datamodel"/>を見よ。</p> 
</item> 
<item> 
<p><code>&lt;&lt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<termref def="dt-document-order">文書順</termref>で前にある場合である。そうでない場合は<code>false</code>を返す。</p> 
</item> 
<item> 
<p><code>&gt;&gt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<termref def="dt-document-order">文書順</termref>で後ろにある場合である。そうでない場合は<code>false</code>を返す。</p>
</item></olist> 
<p>以下に、節点比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>次の比較が真になるのは、左辺と右辺を評価した結果がそれぞれ完全に同じ単一節点になる場合のみである。</p> 
<eg role="parse-test" xml:space="preserve">/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</eg> 
</item> 

<item> 
<p>次の比較が真になるのは、左辺によって識別される節点が、右辺によって識別される節点よりも文書順で前に出現する場合のみである。</p>
<eg role="parse-test" xml:space="preserve">/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]</eg> 
</item></ulist> 
</div3> 
	
</div2>	
<div2 id="id-logical-expressions"> 
<head>論理式</head> 
<p><term>論理式</term>は<term>and式</term>か<term>or式</term>のいずれかである。ある論理式がエラーを発生しない場合、結果は常にブール値<code>true</code>か<code>false</code>のいずれかである。</p> 
<scrap headstyle="show"> 
<head/> <prod num="8" id="doc-xpath-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod> 

<prod num="9" id="doc-xpath-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod> 

</scrap> 
<p>論理式の評価は、まず各演算数の<termref def="dt-ebv">有効ブール値</termref>を見つけることから始まる (<specref ref="id-ebv"/>を見よ)。</p> 
 
<p>and式の値は、演算数の有効ブール値 (EBV) により、次の表のように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV"><tbody><tr><td rowspan="1" colspan="1">AND:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub>でエラー
</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">エラー</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>
= <code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、<code>false</code>。そうでない場合は<code>false</code>かエラー。</phrase></td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>でエラー
</td><td rowspan="1" colspan="1">エラー</td><td rowspan="1" colspan="1"><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、エラー。そうでない場合は<code>false</code>かエラー</phrase></td><td rowspan="1" colspan="1">エラー</td></tr></tbody></table>
<p>or式の値は、演算数の有効ブール値 (EBV) により、次の表にあるように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV"><tbody><tr><td rowspan="1" colspan="1">OR:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub>でエラー</td></tr>
<tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、<code>true</code>。そうでない場合は<code>true</code>かエラー</phrase></td></tr>
<tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>false</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">エラー</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>でエラー</td><td rowspan="1" colspan="1"><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、エラー。そうでない場合は<code>true</code>かエラー。</phrase></td><td rowspan="1" colspan="1">エラー</td><td rowspan="1" colspan="1">エラー</td></tr></tbody></table>
<p role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>true</code>であれば、論理式の演算数を評価する順番が事実上決定される。特に、結果を決定するのに第2演算数を評価する必要がないとき、第2演算数を評価した結果エラーが発生する必要はない。</p>
<p><phrase role="xpath"><termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>が<code>false</code>であれば、論理式の演算数を評価する順番は<termref def="dt-implementation-dependent">実装依存</termref>である。この場合、</phrase>or-式は、1番目の式を評価するとtrueになれば、<code>true</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。同様に、and式は、1番目の式を評価するとfalseになれば、<code>false</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。これらのルールの結果として、論理式は、エラーが存在する場合、非決定的である。その例を以下に示す。</p>
<p>以下に、論理式の例をいくつか示す。</p>
 
<ulist>
<item><p>次の式は<code>true</code>を返す。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 and 2 eq 2</eg><eg role="parse-test" xml:space="preserve">1 eq 1 or 2 eq 3</eg></item>
<item><p>次の式は<code>false</code>を返すか<termref def="dt-dynamic-error">動的エラー</termref>を発生する<phrase role="xpath"> (<termref def="dt-xpath-compat-mode">XPath 1.0 互換モード</termref>では、結果は<code>false</code>でなければならない)</phrase>。</p>
<eg role="parse-test" xml:space="preserve">1 eq 2 and 3 idiv 0 = 1</eg></item>
<item><p>次の式は<code>true</code>を返すか<termref def="dt-dynamic-error">動的エラー</termref>を発生する<phrase role="xpath"> (<termref def="dt-xpath-compat-mode">XPath 1.0互換モード</termref>では、結果は<code>true</code>でなければならない)</phrase>。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 or 3 idiv 0 = 1</eg></item>
<item><p>次の式は<termref def="dt-dynamic-error">動的エラー</termref>を発生しなければならない。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 and 3 idiv 0 = 1</eg></item></ulist>

<p>and式、or式に加え、XPathは<code>fn:not</code>という関数を用意している。これは引数として一般の列をとり、ブール値を返す。<code>fn:not</code>関数の定義は<bibref ref="FunctionsAndOperators"/>にある。<code>fn:not</code>関数は、引数を<termref def="dt-ebv">有効ブール値</termref>に縮退する。そして、引数の有効ブール値が<code>false</code>であれば<code>true</code>を返し、引数の有効ブール値が<code>true</code>であれば<code>false</code>を返す。引数の有効ブール値を求める際にエラーが起これば、<code>fn:not</code>は同じエラーを発生する。</p>

	
</div2>	
	
<div2 role="xpath" id="id-for-expressions">
<head>For式</head>
<p>XPathは<term>for式</term>と呼ばれる繰り返し機能を用意している。</p>
<scrap headstyle="show"> 
<head/> 
 
<prod num="4" id="doc-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 
<prod num="5" id="doc-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod></scrap>
<p><code>for</code>式は以下のように評価される。</p>
<olist>
<item><p><code>for</code>式が複数の変数を用いていれば、まず、入れ子の<code>for</code>式の集合に展開される。これらはそれぞれ、ただ1つの変数しか用いない。例えば、式
<code>for $x in X, $y in Y return $x + $y</code>
は
<code>for $x in X return 
    for $y in Y return $x + $y</code>と展開される。</p></item>
<item><p>1つの変数を用いる<code>for</code>式では、その変数を<term>範囲変数</term>、キーワード<code>in</code>に続く式の値を<term>束縛列</term>、キーワード<code>return</code>に続く式の値を<term>return式</term>という。<code>for</code>式の結果は、束縛列中の項目それぞれに対し<code>return</code>式を1回評価することで得られる。このとき範囲変数は束縛列中のその項目に束縛される。結果の列は、それが導出された束縛列中の項目の順に (<termref def="dt-comma-operator">コンマ演算子</termref>を用いたように) 連接される。</p></item></olist>
<p role="xpath">次に示すのは、<code>for</code>式を入力文書の再構成に用いた例である。この例では、以下の入力を基にしている。</p> 
<eg xml:space="preserve">&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</eg>



<p>以下の例では、この入力文書を、各著者の名前が1回ずつ出現し、その著者による本の題目のリストが続くようなリストに変換する。この例では、文脈項目が入力文書中の<code>bib</code>要素であると仮定している。</p>


<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $a in fn:distinct-values(book/author)
return (book/author[. = $a][1], book[author = $a]/title)</phrase></eg>
<p>上の式の結果は以下のような要素の列からなる。与えられた著者による本の題目が、その著者の名前に続いている。結果中の<code>author</code>要素の順序は<termref def="dt-implementation-dependent">実装依存</termref>であり、<code>fn:distinct-values</code>関数の意味に依存している。</p>
<eg xml:space="preserve">&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</eg>
<p>次に示すのは、1つ以上の変数を含む<code>for</code>式の例である。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</phrase></eg>
<p>上の式の結果は数の列として表現され、以下の通りである: <code>11, 12, 21, 22</code></p>
<p><code>for</code>式中で束縛された変数の有効範囲は、<code>for</code>式の部分式のうち変数の束縛より後ろに出現するものすべてから構成される。有効範囲には、その変数が束縛される式は含まれない。以下に示すのは、変数束縛が、同じ<code>for</code>式中でそれより前に束縛された別の変数を参照してもよいという例である。</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</phrase></eg>

 
<note><p><code>for</code>式の<code>return</code>節の評価のための焦点は、その<code>for</code>式の評価のための焦点そのものに等しい。次の例では、order-item の集合の合計値を求めようとしているのだが、先に述べたような理由で誤りである。</p>
<eg role="error" xml:space="preserve">fn:sum(for $i in order-item return @price * @qty)</eg><p> 

代わりに、この式は、<code>for</code>節の中で束縛される変数を用いて書かれなければならない。</p>
<eg role="parse-test" xml:space="preserve">fn:sum(for $i in order-item
    return $i/@price * $i/@qty)</eg></note>



</div2>



<div2 id="id-conditionals"> 
<head>条件式</head> 
<p>XPathはキーワード<code>if</code>, <code>then</code>, <code>else</code>に基づく条件式を支援する。</p> 
<scrap headstyle="show"> 
<head/> <prod num="7" id="doc-xpath-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 

</scrap> 
<p>キーワード<code>if</code>に続く式を<term>テスト式</term>という。またキーワード<code>then</code>や<code>else</code>に続く式をそれぞれ<term>then式</term>、<term>else式</term>という。</p> 
<p>条件式を処理する最初の段階は、テスト式の<termref def="dt-ebv">有効ブール値</termref>を求めることである。これは<specref ref="id-ebv"/>に定義されている通りである。</p> 
 
<p>条件式の値は以下のように定義される: テスト式の有効ブール値が<code>true</code>であれば、then式の値が返される。テスト式の有効ブール値が<code>false</code>であれば、else式の値が返される。</p>
<p>条件式には、<termref def="dt-dynamic-error">動的エラー</termref>の伝搬に関する特別なルールがある。テスト式の有効値が<code>true</code>であれば、条件式は、else式から起こる動的エラーをすべて無視する (発生させない)。この場合、else式は観測可能な作用を持たなくてもよいため、評価される必要はない。同様に、テスト式の有効値が<code>false</code>であれば、条件式は、then式から起こる<termref def="dt-dynamic-error">動的エラー</termref>をすべて無視し、then式は評価される必要はない。</p> 
<p>以下に、条件式の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>この例では、テスト式は比較式である。</p> 
<eg role="parse-test" xml:space="preserve">if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2</eg> 
</item> 
<item> 
<p>この例では、テスト式は<code>discounted</code>という属性の有無を調べている。その属性の値には依存しない。</p> 
<eg role="parse-test" xml:space="preserve">if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail</eg> 
</item> 
</ulist>	
</div2>	
<div2 id="id-quantified-expressions">
<head>限量式</head> 
<p>限量式は存在限量子と全称限量子を支援する。限量式の値は常に<code>true</code>か<code>false</code>である。</p>
<scrap headstyle="show">
<head/> 
<prod num="6" id="doc-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>


</scrap>
<p><term>限量式</term>は<term>限量子</term>で始まる。これはキーワード<code>some</code>か<code>every</code>である。これに1つ以上のin節が続き、変数を束縛するのに用いられる。さらにキーワード<code>satisfies</code>とテスト式が続く。各in節は、項目の列を返す式に変数を関連づける。この列のことを、その変数に対する<term>束縛列</term>という。in節は変数束縛の組を生成する。これには、それぞれの変数に対する束縛列中の項目の組み合わせ各々に対応する組が含まれる。概念的には、テスト式は、変数束縛の組それぞれについて評価される。結果はテスト式の<termref def="dt-ebv">有効ブール値</termref>に依存する。これは<specref ref="id-ebv"/>で定義されている通りである。限量式の値は以下のルールによって定義される。</p>
<olist>
<item>
<p>限量子が<code>some</code>であれば、限量式は、テスト式の評価のうち少なくとも1つが<termref def="dt-ebv">有効ブール値</termref> <code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>false</code>であることが分かる。</p>
</item>
<item>
<p>限量子が<code>every</code>であれば、限量式は、テスト式の評価がすべて<termref def="dt-ebv">有効ブール値</termref> <code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>true</code>であることが分かる。</p>
</item>
</olist>


<p>限量式中で束縛された変数の有効範囲は、その限量式の部分式のうちその変数束縛の後ろで出現したものすべてから構成される。有効範囲にはその変数が束縛される式は含まれない。</p>

<p>テスト式がさまざまな変数束縛組に対して評価される順序は<termref def="dt-implementation-dependent">実装依存</termref>である。限量子が<code>some</code>であれば、実装は、テスト式が<code>true</code>という<termref def="dt-ebv">有効ブール値</termref>を持つ束縛組を1つ見つけたら直ちに<code>true</code>を返してもよい。また、テスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。同様に、限量式が<code>every</code>であれば、実装は、テスト式が<code>false</code>という<termref def="dt-ebv">有効ブール値</termref>を持つ束縛組を1つ見つけたら直ちに<code>false</code>を返してよい。またテスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。これらのルールの結果として、以下の例で示すように、限量式の値は、エラーが存在する場合には決定的ではない。</p>
<p>以下に、限量式の例をいくつか示す。</p>
<ulist>
<item>
<p>この式は、すべての<code>part</code>要素が<code>discounted</code>属性を持つならば (これらの属性の値に関わらず)、<code>true</code>である。</p> 
<eg role="parse-test" xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</eg>
</item> 
<item>
<p>この式は、少なくとも1つの<code>employee</code>要素が与えられた比較式を満たすならば<code>true</code>である。</p> 
<eg role="parse-test" xml:space="preserve">some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)</eg>
</item>
<item>
<p>以下の例では、各限量式がテスト式を9つの変数束縛の組上で評価する。9つの変数束縛とは、列<code>(1, 2, 3)</code>と<code>(2, 3, 4)</code>の直積から構成される。<code>some</code>で始まる式を評価すると<code>true</code>であり、<code>every</code>で始まる式を評価すると<code>false</code>である。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg>
</item>
<item>
<p>この限量式は<code>true</code>を返すか、<termref def="dt-type-error">型エラー</termref>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>true</code>を返し、別の変数束縛に対して<termref def="dt-type-error">型エラー</termref>を発生するからである。</p>
<eg role="parse-test" xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>
<item>
<p>この限量式は<code>false</code>を返すか<termref def="dt-type-error">型エラー</termref>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>false</code>を返し、別の変数束縛に対して<termref def="dt-type-error">型エラー</termref>を発生するからである。</p>
<eg role="parse-test" xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item> 

</ulist>
</div2> 
<div2 id="id-expressions-on-datatypes"> 
<head>SequenceTypes上の式</head> 
<p><termref def="dt-sequence-type">列型</termref>は<code>instance of</code>式,  <code>cast</code>式, <code>castable</code>式, <code>treat</code>式で使われている。</p> 
 
 
 
 
 
 
 
<div3 id="id-instance-of"><head>Instance Of</head><scrap headstyle="show"> 
<head/> 
<prod num="16" id="doc-xpath-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>    

</scrap>
<p>ブール演算子<code>instance of</code>は、第1演算数の値が第2演算数の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>に照合されるとき、<code>true</code>を返す。これは<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>にあるルールに従う。そうでない場合は<code>false</code>を返す。例えば:</p> 
<ulist>
<item><p><code role="parse-test">5 instance of xs:integer</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が与えられた型のインスタンスであるからである。</p></item>
<item><p><code>5 instance of xs:decimal</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が整数リテラルで、<code>xs:integer</code>が制限によって<code>xs:decimal</code>から導出されるからである。</p></item>

<item><p><code>(5, 6) instance of xs:integer+</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた列は2つの整数を含んでおり、指定された型の正しいインスタンスであるからである。</p></item>
<item><p><code role="parse-test">. instance of element()</code></p>
<p>文脈項目が要素節点のとき、この例は<code>true</code>を返す。文脈項目が定義されているが要素節点ではないとき、この例は<code>false</code>を返す。文脈項目が未定義であれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0002"/>。</p></item></ulist>
</div3>

<div3 id="id-cast"><head>Cast</head><scrap headstyle="show"> 
<head/> 
   <prod num="19" id="doc-xpath-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod> 
   
<prod num="49" id="doc-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>

</scrap>
<p>場合によっては、値を指定されたデータ型に変換する必要が生じる。この目的のため、XPathは<code>cast</code>式を用意している。これは、すでにある値に基づき、指定された型の値を新たに生成する。<code>cast</code>式は2つの演算数を取る。<term>入力式</term>と<term>目的型</term>である。入力式の型を<term>入力型</term>という。目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>に含まれており、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また原子型の後ろに出現標識 "<code>?</code>" を置き、空列を許すということを示してもよい <errorref class="ST" code="0080"/>。目的型が名前空間接頭辞を持たないならば、その目的型は<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>に属するとみなされる。<code>cast</code>式の意味は以下の通りである。</p>
<olist>
<item><p><termref def="dt-atomization">原子化</termref>が入力式に対して行われる。</p></item>
<item><p>原子化の結果が長さ1より大きい原子値の列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化の結果が空列であれば:</p>
<olist>
<item><p>目的型の後ろに<code>?</code>が指定してあれば、<code>cast</code>式の結果は空列である。</p></item>
<item><p>目的型の後ろに<code>?</code>が指定してなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item></olist>
</item>
<item><p>原子化の結果が単一の原子値であれば、cast式の結果は入力型と目的型に依存する。一般的に、cast式は、入力値に基づき目的型の値を新たに生成しようと試みる。ある種の入力型と目的型の組み合わせだけが支援されている。このルールの概要を以下に列挙する。これらのルールの規範的定義は<bibref ref="FunctionsAndOperators"/>にある。これらのルールの目的のため、実装は、<termref def="dt-issd">有効範囲内スキーマ定義</termref>を検査したり、あるいはその代替としてデータ辞書のような<termref def="dt-implementation-dependent">実装依存</termref>の機構を用いて、ある型が別の型から制限によって導出されると決定してもよい。</p>

<olist><item><p><code>cast</code>は、<xspecref spec="FO" ref="casting-from-primitive-to-primitive"/>に列挙されている入力型と目的型の組み合わせに対して支援される。これらの組み合わせそれぞれについて、入力型と目的型は基本<termref def="dt-schema-type">スキーマ型</termref>である。例えば、<code>xs:string</code>型の値はスキーマ型<code>xs:decimal</code>に型変換することができる。これらの組み込みの組み合わせについては、型変換の意味が<bibref ref="FunctionsAndOperators"/>で指定されている。</p>
<p><code>cast</code>式の目的型が<code>xs:QName</code>であるか、<code>xs:QName</code>または<code>xs:NOTATION</code>から導出される型であるか、入力の基礎型が目的型の基礎型と等しくないならば、入力式は文字列リテラルでなければならない <errorref code="0004" class="TY"/>。</p>
<note><p>このルールの理由は、これらの目的型の1つのインスタンスを文字列から構成するには名前空間の束縛に関する知識が必要になる、ということである。入力式がリテラルでない文字列であれば、名前空間の束縛が<termref def="dt-static-namespaces">静的既知名前空間</termref>と異なる入力文書から導出されるかもしれない。</p></note></item>
<item><p><code>cast</code>は、入力型が基本でない原子型で、目的型から制限によって導出される場合に支援される。この場合、入力値は目的型の値空間に写像され、その型以外には変更されない。例えば、<code>shoesize</code>が制限によって<code>xs:integer</code>から導出されるならば、型<code>shoesize</code>の値はスキーマ型<code>xs:integer</code>に型変換することができる。</p></item>
<item><p><code>cast</code>は、目的型が基本でない原子型で、入力型が<code>xs:string</code>または<code>xs:untypedAtomic</code>である場合に支援される。入力値はまず、目的型に対する空白の正規化ルールを適用する（<bibref ref="XMLSchema"/>で定義されているように）ことで、目的型の字句空間中の値に変換される。結果の字句値が目的型のパターンの相 (facet) を満たさないならば、<termref def="dt-dynamic-error">動的エラー</termref> [err:FORG0001] が発生する。次に字句値は、目的型のスキーマ定義ルールを用いて、目的型の値空間に変換される。結果の値が目的型のすべての相を満たさないならば、<termref def="dt-dynamic-error">動的エラー</termref> [err:FORG0001] が発生する。</p></item>
<item><p><code>cast</code>は、目的型が基本型でない原子型であり、かつ入力型から制限によって導出されるならば、支援される。入力値は目的型のすべての相を満たさなければならない (パターンの相の場合には、これは、<code>xs:string</code>への型変換ルールを用いて、入力値の文字列表現を生成することで検査される)。結果の値は入力値と等しい。ただし<termref def="dt-dynamic-type">動的型</termref>は異なる。</p></item>
<item><p>基本型 P1 が基本型 P2 に型変換されるならば、制限によって P1 から導出される任意の型は、制限によって P2 から導出される任意の型に型変換できる。そして、目的型の相が満たされると規定される。まず、上のルール (b) を用いて、入力値が P1 に型変換される。次に、上のルール (a) を用いて、P1 型の値が P2 型に変換される。最後に、上のルール (d) を用いて、P2 型の値が目的型に変換される。</p></item>
<item><p>上に列挙されていない入力型と目的型の組み合わせに対して、<code>cast</code>式は<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。</p></item></olist>

</item></olist>
<p>入力型から目的型への型変換が支援されているが、にもかかわらず入力値を目的型の値空間に型変換することが不可能であれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。 [err:FORG0001] これは、目的型のどの相も満たされない場合を含む。例えば、式<code>"2003-02-31" cast as xs:date</code>は<termref def="dt-dynamic-error">動的エラー</termref>を発生する。</p> 
</div3><div3 id="id-castable"><head>Castable</head><scrap headstyle="show"> 
<head/> 
    
<prod num="18" id="doc-xpath-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>
<prod num="49" id="noid_N1495E.doc-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>

</scrap>
<p>XPathは、与えられた値が与えられた目的型に型変換可能かテストする式を用意している。目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>に含まれていなければならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また、空列を許すことを示すために出現標識 "<code>?</code>" を後ろに付けることができる <errorref class="ST" code="0080"/>。式<code>V castable
as T</code>が<code>true</code>を返すのは、<code>cast</code>式を用いて値<code>V</code>が目的型<code>T</code>に型変換することに成功する場合である。そうでない場合は<code>false</code>を返す。<code>castable</code>式を<termref def="dt-predicate">述語</termref>として用い、評価時のエラーを避けることも可能である。また、適切な型を選択して与えられた値を処理することにも利用できる。以下に例を示す。</p>
<eg role="parse-test" xml:space="preserve">
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string</eg></div3>
<div3 id="id-constructor-functions"><head>構成子関数</head>
<p><termref def="dt-is-types">有効範囲内スキーマ型</termref>中の原子型それぞれについて (<code>xs:NOTATION</code>および<code>xs:anyAtomicType</code>を除く。これらはインスタンスを生成できない)、<term>構成子関数</term>が暗黙的に定義される。それぞれの場合について、構成子関数の名前は目的型の名前 (名前空間を含む)と同じである。型<emph>T</emph>の構成子関数のシグネチャは以下の通りである。</p>

<eg xml:space="preserve"><emph>T</emph>($arg as xs:anyAtomicType?) as <emph>T?</emph></eg>

<p> <termdef term="constructor function" id="dt-constructor-function">与えられた型に対する<term>構成子関数</term>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数 <code>T($arg)</code>の意味は式<code>($arg cast as T?)</code>と同じであると定義される。</termdef></p>
<p><code>xs:QName</code>、あるいは<code>xs:QName</code>や<code>xs:NOTATION</code>から導出される型に対する構成子関数では、文字列リテラルの引数か、目的型の基礎型と同じ基礎型を持つ引数を要求する。そうでない場合は型エラー <errorref code="0004" class="ST"/> が発生する。このルールは、<specref ref="id-cast"/>に定義されているこれらの型に対する<code>cast</code>式の意味と一貫している。</p>
<p>構成子関数の使い方を以下の例で示す。</p>
<ulist>
<item><p>この例は<code>("2000-01-01" cast as xs:date?)</code>に等しい。</p>

<eg role="parse-test" xml:space="preserve">xs:date("2000-01-01")</eg></item>
<item><p>この例は<code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>に等しい。</p>
<eg role="parse-test" xml:space="preserve">xs:decimal($floatvalue * 0.2E-5)</eg></item>
<item><p>この例は、21日に等しい<code>xs:dayTimeDuration</code>の値を返す。これは<code>("P21D" cast as xs:dayTimeDuration?)</code>と同値である。</p>
<eg role="parse-test" xml:space="preserve">xs:dayTimeDuration("P21D")</eg></item>
<item><p><code>usa:zipcode</code>がユーザ定義の原子型であり<termref def="dt-is-types">有効範囲内スキーマ型</termref>中にあるならば、以下の式は、式<code>("12345" cast as
usa:zipcode?)</code>と同値である。</p>
<eg role="parse-test" xml:space="preserve">usa:zipcode("12345")</eg></item></ulist>

<note><p>名前空間中にない原子型のインスタンスは、以下のいずれかの方法で構成することができる。</p>
<ulist>
<item><p>もし<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>が "none" であれば、<code>cast</code>式を用いる。</p><eg role="parse-test" xml:space="preserve">17 cast as apple</eg></item>
<item><p>もし<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>が "none" であれば、構成子関数を用いる。</p>
<eg role="parse-test" xml:space="preserve">apple(17)
</eg></item>
</ulist></note></div3>
<div3 id="id-treat"><head>Treat</head><scrap headstyle="show"> <head/> <prod num="17" id="doc-xpath-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod> 

</scrap>
<p>XPathは<code>treat</code>と呼ばれる式を用意している。これは、演算数の<termref def="dt-static-type">静的型</termref>を変更するのに用いることができる。</p>
<p><code>cast</code>のように、<code>treat</code>式は2つの演算数をとる。式と<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>である。しかし、<code>cast</code>とは異なり、<code>treat</code>はその演算数の<termref def="dt-dynamic-type">動的型</termref>や値は変更しない。そのかわり、<code>treat</code>の目的は、式が評価時に期待される動的型を持つことを保証することである。</p>
<p><emph><code>expr1</code></emph><code> treat as </code><emph><code>type1</code></emph>の意味は以下の通りである。</p>
<ulist>
<item><p>静的解析時:</p>
<p><code>treat</code>式の<termref def="dt-static-type">静的型</termref>は<emph><code>type1</code></emph>である。これにより、<emph><code>type1</code></emph>の引数を必要とする関数の引数として、その式を用いることが可能となる。</p></item>
<item><p>式の評価時:</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のルールを用いて<emph><code>expr1</code></emph>が<emph><code>type1</code></emph>と照合されるならば、<code>treat</code>式は<emph><code>expr1</code></emph>の値を返す。そうでない場合は<termref def="dt-dynamic-error">動的エラー</termref> <errorref class="DY" code="0050"/>が発生する。<emph><code>expr1</code></emph>の値が返るならば、その識別性は保存される。<code>treat</code>式は、その式の演算数の値が実行時に期待される型にしたがうことを保証する。</p></item>
<item><p>例:</p>
<eg role="parse-test" xml:space="preserve">$myaddress treat as element(*, USAddress)</eg>
<p><code>$myaddress</code>の<termref def="dt-static-type">静的型</termref>は<code>element(*, Address)</code>であってもよい。これは<code>element(*, USAddress)</code>より詳しくない型である。しかし実行時には、<code>$myaddress</code>の値は、<termref def="dt-dynamic-error">SequenceTypeの照合</termref>のルールを用いて、型<code>element(*, USAddress)</code>に照合されなければならない。そうでない場合は<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p></item></ulist></div3></div2> 


</div1>




</body>
<back id="id-appendices">

<div1 id="nt-bnf"><head>XPathの文法</head>
<div2 id="id-grammar">
<head>EBNF</head>


<p>XPathの文法は、単純な拡張バッカス記法 (EBNF) を用いる。これは<bibref ref="XML"/>と同じものであるが、以下に述べるように、若干の違いがある。</p>
<ulist>
<item><p>名前づけられた記号はすべて、大文字で始まる名前を持つ。</p></item>
<item><p>外部の仕様の生成規則を参照するための記法を加える。</p></item>
<item><p>コメントや、文法の生成規則に関する特別な文法的制限を '/*' と '*/' という記号の間に置く。</p>
<ulist><item><p>'xgc:' 接頭辞は特別な文法的制限であり、その詳細は<specref ref="extra-grammatical-constraints"/>に説明がある。</p></item>
<item><p>'ws:' 接頭辞は生成規則に対する空白のルールであり、その詳細は<specref ref="whitespace-rules"/>に説明がある。</p></item>
<item><p>'gn:' 接頭辞は '文法上の備考' (Grammar Note)の意味であり、ルール解釈を明確にすることを意味する。これについては<specref ref="notes-on-parsing"/>に説明されている。これらの備考は参考である。</p></item></ulist></item></ulist>
<p>この文法の終端記号には、既出の生成規則で用いられた引用符付き文字列や、<specref ref="terminal-symbols"/>で定義された終端記号が含まれる。</p>
<p>EBNF記法についてのより詳しい説明は<specref ref="EBNFNotation"/>にある。</p>
<p>可読性を上げるため、この文書の本体のEBNFでは記法上の特徴をいくつか省略している。この附録はEBNFの参考バージョンである。</p>
<scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head/>
<prod num="1" id="prod-xpath-XPath"><lhs>XPath</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="2" id="prod-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="3" id="prod-xpath-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForExpr" xlink:type="simple">ForExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod><prod num="4" id="prod-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="5" id="prod-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="6" id="prod-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="7" id="prod-xpath-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="8" id="prod-xpath-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="9" id="prod-xpath-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="10" id="prod-xpath-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod><prod num="11" id="prod-xpath-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="12" id="prod-xpath-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="13" id="prod-xpath-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="14" id="prod-xpath-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="15" id="prod-xpath-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="16" id="prod-xpath-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="17" id="prod-xpath-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="18" id="prod-xpath-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="19" id="prod-xpath-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="20" id="prod-xpath-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod><prod num="21" id="prod-xpath-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PathExpr" xlink:type="simple">PathExpr</nt></rhs></prod><prod num="22" id="prod-xpath-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="23" id="prod-xpath-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="24" id="prod-xpath-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="25" id="prod-xpath-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: leading-lone-slash</loc></com></prod><prod num="26" id="prod-xpath-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="27" id="prod-xpath-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod><prod num="28" id="prod-xpath-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="29" id="prod-xpath-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod><prod num="30" id="prod-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="31" id="prod-xpath-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod><prod num="32" id="prod-xpath-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod><prod num="33" id="prod-xpath-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="34" id="prod-xpath-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="35" id="prod-xpath-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NameTest" xlink:type="simple">NameTest</nt></rhs></prod><prod num="36" id="prod-xpath-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod><prod num="37" id="prod-xpath-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="38" id="prod-xpath-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="39" id="prod-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="40" id="prod-xpath-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="41" id="prod-xpath-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt></rhs></prod><prod num="42" id="prod-xpath-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="43" id="prod-xpath-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod><prod num="44" id="prod-xpath-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="45" id="prod-xpath-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="46" id="prod-xpath-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="47" id="prod-xpath-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="48" id="prod-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: reserved-function-names</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc></com></prod><prod num="49" id="prod-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="50" id="prod-xpath-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="51" id="prod-xpath-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: occurrence-indicators</loc></com></prod><prod num="52" id="prod-xpath-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="53" id="prod-xpath-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="54" id="prod-xpath-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod><prod num="55" id="prod-xpath-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="56" id="prod-xpath-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="57" id="prod-xpath-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="58" id="prod-xpath-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="59" id="prod-xpath-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="60" id="prod-xpath-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="61" id="prod-xpath-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="62" id="prod-xpath-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="63" id="prod-xpath-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="64" id="prod-xpath-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="65" id="prod-xpath-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="66" id="prod-xpath-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="67" id="prod-xpath-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="68" id="prod-xpath-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="69" id="prod-xpath-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="70" id="prod-xpath-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod>

</scrap>

<div3 id="EBNFNotation"><head>記法</head>
<p>以下の定義は、この解説を正確に定義するのに役立つ。</p>
<p><termdef id="symbol" term="symbol">文法中の各規則は1つの<term>記号</term>を定義する。ここで用いられる形式は以下の通りである。<eg xml:space="preserve">symbol ::= expression</eg></termdef></p>
<p><termdef term="terminal" id="terminal"><term>終端記号</term>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。</termdef> 以下の構成要素が、長さ1以上の文字からなる文字列で終端記号中にあるものと照合されて用いられる。</p>
<glist><gitem><label>[a-zA-Z]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>で、示された範囲(すべての)中の値であるようなものと照合される。</p></def></gitem>
<gitem><label>[abc]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>で、列挙された文字のどれかの値であるようなものと照合される。<phrase diff="del">列挙と範囲を1つの角括弧の中で混ぜることもできる。</phrase></p></def></gitem>
<gitem><label>[^abc]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>で、与えられた文字のどれでもない値と照合される。<phrase diff="del">禁止される値の列挙と範囲を1つの角括弧のなかで混ぜることもできる。</phrase></p></def></gitem>
<gitem><label>"string"</label><def><p>二重引用符の中に出現する文字の列と照合される。</p></def></gitem>
<gitem><label>'string'</label><def><p>一重引用符の中に出現する文字の列と照合される。</p></def></gitem>
<gitem><label>	[http://www.w3.org/TR/REC-example/#NT-Example]</label><def><p>用意された参照の通りの外部仕様で定義される生成規則によって照合される文字列と照合される。</p></def></gitem></glist>
<p>パターン (上記の構成要素を含む) を文法構成子で組み合わせ、より複雑なパターンを形成することができる。このようなパターンは文字列の複雑な集合に照合される。以下の例では、AとBは(部分)パターンを表す。</p>
<glist><gitem><label>(A)</label><def><p><code>A</code>は1つの単位として扱われ、このリスト中に記述されているように組み合わせても構わない。</p></def></gitem>
<gitem><label>A?</label><def><p><code>A</code>に照合されるか、何とも照合されない。すなわち省略可能な<code>A</code>と照合される。</p></def></gitem>
<gitem><label>A B</label><def><p><code>A</code>の後ろに<code>B</code>が続くものと照合される。この演算子は代替よりも優先度が高い。従って<code>A B | C D</code>は<code>(A B) | (C D)</code>と同じである。</p></def></gitem>
<gitem><label>A | B</label><def><p><code>A</code>または<code>B</code>に照合される。ただし両方同時には照合されない。</p></def></gitem>
<gitem><label>A - B</label><def><p><code>A</code>に照合されるが、<code>B</code>には照合されないすべての文字列に照合される。</p></def></gitem>
<gitem><label>A+</label><def><p><code>A</code>の1回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A+ | B+</code>は<code>(A+) | (B+)</code>と同じである。</p></def></gitem></glist>
<glist><gitem><label>A*</label><def><p><code>A</code>の0回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A* | B*</code>は<code>(A*) | (B*)</code>と同じである。</p></def></gitem></glist></div3>
<div3 id="extra-grammatical-constraints"><head>特別な文法上の制約</head>
<p>この節はEBNFの生成規則の制約を含む。これらは正当な文を解釈するのに必要となる。以下の備考は、次のような記法で、生成規則の右辺から参照される: <emph>/* xgc: &lt;id&gt; */</emph>。</p>
<constraintnote id="parse-note-leading-lone-slash" type="xgc">
<head>leading-lone-slash</head>
<p>単一のスラッシュは、完全経路式として出現するか、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>の後に続く経路式の最初の部分として出現するかのいずれかである。後者の場合、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt> ("*" または QName)の形式を取る。"*", "union" などの演算子が出現しうる文脈では、構文解析器は演算子とNameTestを区別するのが困難であってもよい。例えば、先読みをしなければ、式 "/ * 5" の最初の部分は例えば容易に "/ *" という完全経路式だととられる。これは全く異なる解釈を持つ ("/"の子節点)。</p>
<p>そこで、先読みの必要を削減するため、スラッシュの直後に続くトークンが "*" またはキーワードである場合は、スラッシュは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">PathExpr</nt>の先頭でなければならないが、その全体であってはならない (そして、それに続くトークンは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt>でなければならず、演算子であってはならない)。</p>
<p>単一のスラッシュは、括弧で囲むことにより、演算子の左側の引数として用いてもよい: <code>(/) * 5</code>。一方、式<code>5 * /</code>は括弧なしでも正しい式である。</p></constraintnote>
<constraintnote id="parse-note-xml-version" type="xgc"><head>xml-version</head>
<p>実装が<bibref ref="XML"/>と<bibref ref="XMLNAMES"/>の字句定義、あるいは<bibref ref="XML1.1"/>と<bibref ref="XMLNAMES11"/>の字句定義のいずれを支援することを選択するかによって、この生成規則の定義を得る外部文書が決定される。EBNFではバージョン1.0への参照しか持たせていない。ある場合には、XML 1.0とXML 1.1の定義は全く同じであるかもしれない。また、これらの外部定義は、その仕様の空白のルールに従い、この仕様のルール、特に<specref ref="DefaultWhitespaceHandling"/>には従わないことに注意すること。したがって<code>prefix : localname</code>は、XML文書中では許されないのと同様に、この仕様では正しくないQNameである。またコメントはコロンのどちら側にも許されない。また整形式制約のような特別な文法的制約を考慮しなければならない。</p></constraintnote>
<constraintnote id="parse-note-reserved-function-names" type="xgc">
<head>reserved-function-names</head>
<p>言語のキーワードと同じように綴られた接頭辞なしの関数名は、言語の認識を困難にするかもしれない。例えば<code>if(foo)</code>は、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt>とも、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt>の先頭ともとれる。そのため、<specref ref="id-reserved-fn-names"/>中の名前のいずれかと一致する接頭辞なし名前の関数を呼び出すことは、文法的に誤りである。</p>
<p>"if"という名前の関数は、その名前空間をある接頭辞に束縛し、接頭辞付きの形式を用いれば、呼び出すことができる: "if(foo)" の代わりに "library:if(foo)" というようにである。</p></constraintnote>
<constraintnote id="parse-note-occurrence-indicators" type="xgc"><head>occurrence-indicators</head>
<p>すでに書いたように、<specref ref="nt-bnf"/>の文法は '+' と '*' の Kleene 演算子を用いたある種の形式について、曖昧である。この曖昧性は以下のようにして解消される。これらの演算子は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>式と強く結合しており、これらの記号を他の用途で用いた場合より高い優先度を持つ。列型に続いて '?' ばかりでなく '+' や '*' が出現しても、出現標識であると仮定される。すなわち、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>の直後に出現する "+", "*", "?" は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>でなければならない。したがって、<code>4 treat as
       item() + - 5</code>は<code>(4 treat as item()+) - 5</code>と解釈されなければならない。つまり '+' は OccurrenceIndicator として、'-' は減算演算子として解釈されなければならない。"+" を強制的に加算演算子と解釈するには (その結果として "-" は単項のマイナスと解釈される)、括弧を用いてもよい: <code>(4 treat as item()) + -5</code>という形で、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>式を括弧で囲むと、期待される解釈を導く。</p>
<p>このルールの結果として、このルールを用いなければ正しくかつ曖昧性のないある種の形式は、認識されない。"4 treat as item() + 5" では、"+" は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>ととられ、演算子とは見なされない。そのため、この式は正しい式ではないと解釈される。</p></constraintnote>
</div3>
<div3 id="notes-on-parsing"><head>文法に関する備考</head>
<p>この節は、EBNFの生成規則についての一般的な備考を含む。これらはEBNFをどのように解釈し、またどのように実装するかを理解する助けとなるかもしれない。これらの備考は規範的である。以下の備考は、<emph>/* gn: &lt;id&gt; */</emph>という形式で、生成規則の右辺から参照される。</p>
<note><glist><gitem id="parse-note-parens"><label>grammar-note: parens</label>
<def><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt>を、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt>の続くQNameやキーワードと区別するには、先読みが必要である。例えば: <code>address (: this may be empty :)</code>は、先読みを用いないと、"address"という名前の関数の呼び出しと間違われるかもしれない。 別の例は<code>for (: whom the bell :) $tolls in 3 return $tolls</code>である。これはキーワード "for" を関数名と間違ってはならない。</p>  </def></gitem>
<gitem id="parse-note-comments"><label>grammar-note: comments</label>
<def><p>コメントは<termref def="IgnorableWhitespace">無視可能な空白</termref>が許される場所にならどこでも許される。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt>記号は生成規則の右辺に明示的に出現はしない (それ自身の生成規則を除く)。<specref ref="DefaultWhitespaceHandling"/>を見よ。</p>
<p>コメントはコメントを入れ子で含むことができる。ただし、すべての "(:" と ":)" パターンの対応が取れている限りにおいてである。さらに外側のコメントの中で発生するかには関係しない。</p>
<note><p>字句解析では概して、入れ子のコメントを扱うのに各 "(:" パターンでカウンタを1増やし、各 ":)" パターンでカウンタを1減らすという方法を用いるかもしれない。そのコメントは、カウンタが0に戻るまでずっと終了しない。</p></note>
<p>いくつか例で説明する。</p>
<ulist>
<item><p><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code>は正しいコメントである。なぜなら対応の取れたコメントの入れ子は許されるからである。</p></item>
<item><p><code>"this is just a string :)"</code>は正しい式である。しかし、<code>(: "this is just a string :)" :)</code>は構文エラーを引き起こす。同様に<code>"this is another string (:"</code>は正しい式だが、<code>(: "this is another string (:" :)</code>は構文エラーを引き起こす。入れ子のコメントの限界として、リテラル内容により対応の取れない入れ子コメントが生じる。</p></item>
<item><p><code>for (: set up loop :) $i in $x return $i</code>は、コメントを無視すると、構文的には正しい。</p></item>
<item><p><code>5 instance (: strange place for a comment :) of xs:integer</code>もまた構文的に正しい。</p></item>


</ulist></def></gitem></glist></note>
</div3></div2><div2 id="lexical-structure">
<head>字句構造</head>
<p>上の文法で仮定されている終端記号を、この節で述べる。</p>
<p>生成規則中に出現する引用符つき文字列は終端記号である。</p>
<p>その他の終端記号は<specref ref="terminal-symbols"/>で定義されている。</p>
<p role="xpath"><term>ホスト言語</term>は、<bibref ref="XML"/>や<bibref ref="XMLNAMES"/>の字句規則に従うか、あるいは<bibref ref="XML1.1"/>や<bibref ref="XMLNAMES11"/>の字句規則に従うか、選択してよい。</p>

<p>トークンを切り出すときには、現在の文脈で正しい照合のうち、最長のものが使われる。</p>
<p>すべてのキーワードは大文字小文字を区別する。キーワードは予約されない。すなわち、任意のQNameはキーワードと重複してよい。ただし、<specref ref="id-reserved-fn-names"/>に述べるものを除く。</p>

<div3 id="terminal-symbols"><head>終端記号</head><scrap headstyle="show">
		    
		  <head/><prod num="71" id="prod-xpath-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod><prod num="72" id="prod-xpath-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="73" id="prod-xpath-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="74" id="prod-xpath-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="75" id="prod-xpath-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="76" id="prod-xpath-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="77" id="prod-xpath-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: comments</loc></com></prod><prod num="78" id="prod-xpath-QName"><lhs>QName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="79" id="prod-xpath-NCName"><lhs>NCName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="80" id="prod-xpath-Char"><lhs>Char</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod> 
		   
		</scrap>
<p>以下の記号は、終端記号の定義中でのみ用いられる。これらは<specref ref="id-grammar"/>の文法の終端記号ではない。</p><scrap headstyle="show">
		    
		  <head/><prod num="81" id="prod-xpath-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="82" id="prod-xpath-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod> 
		   
		</scrap></div3>
<div3 id="id-terminal-delimitation"><head>終端記号の区切り</head>
<p role="xpath">XPath 2.0の式は<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#terminal-symbols" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">終端記号</loc>と<termref def="symbolseparators">記号区切り</termref>からなる。</p>

<p>終端記号には2種類ある。区切り終端記号と非区切り終端記号である。</p>
<p role="xpath"><termdef id="delimiting-token" term="delimiting terminal symbol"><term>区切り終端記号</term>は: ",", "$", "(", ")", "=", "!=", "&lt;=", "&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?", "-", "+", "&lt;", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Comment" xlink:type="simple">Comment</nt>, "/", "//", ":"</termdef>  </p>

<p role="xpath"><termdef id="non-delimiting-token" term="non-delimiting terminal symbol"><term>非区切り終端記号</term>は:  "return", "for", "in", "some", "every", "satisfies", "if", "then", "else", "eq", "ne", "lt", "le", "gt", "ge", "is", "child", "descendant", "attribute", "self", "descendant-or-self", "following-sibling", "following", "namespace", "parent", "ancestor", "preceding-sibling", "preceding", "ancestor-or-self", "empty-sequence", "item", "node", "document-node", "text", "comment", "processing-instruction", "schema-attribute", "element", "schema-element", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>, "external", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt></termdef>  </p>

<p><termdef id="symbolseparators" term="symbol separators"><term>記号区切り</term>としての<termref def="Whitespace">空白</termref>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc>という備考や、<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* xgs: xml-version */</loc>という備考で禁止されている場所を除く。</termdef></p>
<p>通例として、連続した終端記号は<termref def="Whitespace">空白</termref>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>で区切る。しかし、このことが要求されるのは、そうしなければ2つの非区切り終端記号が互いに隣接してしまう場合のみである。この例外が2つある。"." と "-" がQNameやNCNameに続くならば、その間に<termref def="symbolseparators">記号区切り</termref>が必要である。</p></div3>
<div3 id="id-eol-handling"><head>行末処理</head>
<p>XPath処理器は、入力中にあるすべての行末を、構文解析前に正規化するように振る舞わなければならない。正規化は、<bibref ref="XML"/>か<bibref ref="XML1.1"/>かいずれの字句処理を支援すると選択するかに従って行われるべきである。</p>
<div4 id="id-xml10-eol-handling"><head>XML 1.0の行末処理</head>
<p><bibref ref="XML"/>の処理では、以下のすべてが単一の文字 #xA に変換されなければならない。</p>
<olist>
<item><p>2文字の列 #xD #xA</p></item>
<item><p>#xA の直後に続かない #xD 文字</p></item>
</olist></div4>
<div4 id="id-xml11-eol-handling"><head>XML 1.1の行末処理</head>
<p><bibref ref="XML1.1"/>の処理では、以下のすべてが単一の文字 #xA に変換されなければならない。</p>
<olist>
<item><p>2文字の列 #xD #xA</p></item>
<item><p>2文字の列 #xD #x85</p></item>
<item><p>単一の文字 #x85</p></item>
<item><p>単一の文字 #x2028</p></item>
<item><p>#xA または #x85 の直後に続かない #xD 文字</p></item>
</olist>

</div4></div3>
<div3 id="whitespace-rules"><head>空白規則</head>
<div4 id="DefaultWhitespaceHandling"><head>デフォルト空白処理</head>
<p><termdef id="Whitespace" term="whitespace"><term>空白</term>文字は、<xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml#NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>で定義される任意の文字である。</termdef></p>
<p>  <termdef term="ignorable whitespace" id="IgnorableWhitespace"><term>無視可能な空白</term>は、<termref def="Whitespace">空白</termref>文字のうち<termref def="terminal">終端記号</termref>の間に出現してもよいものである。ただし、これらの文字が<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ExplicitWhitespaceHandling" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws:explicit</loc>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない (<specref ref="ExplicitWhitespaceHandling"/>を見よ)。</termdef>  無視可能な空白文字は、式の意味には影響しない。空白は、モジュールの最初の終端記号の前や、最後の終端記号の後ろにも許される。空白は、任意の2つの<termref def="terminal">終端記号</termref>の間に許される。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>もまた "空白" として振舞い、2つの隣接した終端記号を1つだと認識されることを防いでもよい。いくつか例で説明する。</p>
<ulist>
<item><p><code>foo- foo</code>は構文エラーになる。"foo-" が QName として認識される。</p></item>
<item><p><code>foo -foo</code>は構文的には<code>foo - foo</code>、すなわち減算演算子によって区切られた2つのQNameと同値である。</p></item>
<item><p><code>foo(: This is a comment :)- foo</code>は構文的には<code>foo - foo</code>と等価である。これは、コメントによって、2つの隣接した終端記号が1つのものとして認識されるのが防がれているからである。</p></item>
<item><p><code>foo-foo</code>は構文的には1つのQNameと等価である。これは、"-" がQName中の正しい文字だからである。名前の文字の後ろで演算子として使うときには、"-" は、例えば空白や括弧によって、名前から区切らなければならない。</p></item>
<item><p><code>10div 3</code>は構文エラーになる。</p></item>
<item><p><code>10 div3</code>もまた構文エラーになる。</p></item>
<item><p><code>10div3</code>もまた構文エラーになる。</p></item></ulist></div4>
<div4 id="ExplicitWhitespaceHandling"><head>明示的空白処理</head>
<p>EBNFの生成規則では、空白処理がデフォルトルールと異なる場合、以下に示す記述で明示的空白処理を指定する。この記述は継承されない。言い換えると、EBNFルールが /* ws: explicit */ と目印付けされているならば、この記述は、そのルールの '子' の EBNF 生成規則いずれにも自動的には適用されない。</p>
<glist><gitem id="ws-explicit"><label>ws: explicit</label><def><p>/* ws: explicit */ は、EBNF記述で、<code>S</code>もしくは他の方法により、<termref def="Whitespace">空白文字</termref>の許される場所が明示的に記述されていることを意味している。備考 /* ws: explicit */ を持つ生成規則では、<specref ref="DefaultWhitespaceHandling"/>は適用されない。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>もまたこれらの生成規則中では許されない。</p></def></gitem>

</glist>

</div4></div3></div2>

<div2 id="id-reserved-fn-names"><head>予約済関数名</head>
<p>以下の名前は、接頭辞のない形式の関数名としては許されない。なぜなら、式の構文のほうが優先するからである。</p>
<ulist>
<item><p><code>attribute</code></p></item>
<item><p><code>comment</code></p></item>
<item><p><code>document-node</code></p></item>
<item><p><code>element</code></p></item>


<item><p><code>empty-sequence</code></p></item><item><p><code>if</code></p></item>
<item><p><code>item</code></p></item>

<item><p><code>node</code></p></item>
<item><p><code>processing-instruction</code></p></item>
<item><p><code>schema-attribute</code></p></item><item><p><code>schema-element</code></p></item><item><p><code>text</code></p></item>
<item><p><code>typeswitch</code></p>
<note role="xpath"><p>キーワード<code>typeswitch</code>は XPath では用いられないが、XQueryとの互換性のため予約済関数とみなされる。</p></note></item>
</ulist>
</div2>
<div2 id="id-precedence-order"><head>優先順位</head>
<p><specref ref="id-grammar"/>中の文法では、XPathの演算子の間の組み込み優先順位を規定として定義している。これらの演算子をここでまとめ、優先度を低い順から高い順に明らかにする。より低い優先度順位を持つ演算子を、より高い優先度順位を持つ演算子が含むことはできない。結合性の欄は、式中で同じ優先度を持つ演算子が適用される順番を表している。</p>
  <table border="1">
  <tbody>
  
  <tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">演算子</th><th rowspan="1" colspan="1"> 	

結合性</th></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">, (comma)</td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1"><phrase role="xpath"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">for</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">some, every</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">if</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">or</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">and</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  
  
  
  
  <tr><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueComp" xlink:type="simple">eq, ne, lt, le, gt, ge</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-GeneralComp" xlink:type="simple">=, !=, &lt;, &lt;=, &gt;, &gt;=</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">is</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">&lt;&lt;, &gt;&gt;</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">to</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">+, -</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">*, div, idiv, mod</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  
  <tr><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">union, |</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">intersect, except</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">instance of</nt> </td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">13</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TreatExpr" xlink:type="simple">treat</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastableExpr" xlink:type="simple">castable</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastExpr" xlink:type="simple">cast</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnaryExpr" xlink:type="simple"> -(unary),  +(unary)</nt></td><td rowspan="1" colspan="1">右から左</td></tr><tr><td rowspan="1" colspan="1">17</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">?, *(OccurrenceIndicator), +(OccurrenceIndicator)</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">/, //</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">19</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">[ ]</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ParenthesizedExpr" xlink:type="simple">( )</nt>, {}</td><td rowspan="1" colspan="1">左から右</td></tr>
  </tbody>
  </table>
  </div2>
			

</div1>


<div1 id="id-type-promotion-and-operator-mapping">
<head>型の昇格と演算子の写像</head>
<div2 id="promotion">
<head>型の昇格</head>

<p><termdef term="type promotion" id="dt-type-promotion">ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<specref ref="id-function-calls"/>を見よ)や演算子の評価 (<specref ref="mapping"/>を見よ)のときに、<term>型の昇格</term>が用いられる。</termdef> 以下のような型の昇格が許されている。</p>

<olist><item><p>数型の昇格:</p>
<olist><item><p><code>xs:float</code>型 (もしくは<code>xs:float</code>型から制限によって導出される任意の型) の値は<code>xs:double</code>型に昇格させることができる。結果は、元の値と等しい<code>xs:double</code>の値である。</p></item>

<item><p><code>xs:decimal</code>型 (もしくは<code>xs:decimal</code>から制限によって導出される任意の型) の値は、<code>xs:float</code>型、もしくは<code>xs:double</code>型のいずれかに昇格させることができる。この昇格の結果は、元の値を要求された型に型変換することで生成される。この種の昇格は、正確さを損なうことを引き起こすかもしれない。</p></item></olist></item>
<item><p>URI型の昇格: <code>xs:anyURI</code>型 (もしくは<code>xs:anyURI</code>から制限によって導出される任意の型) の値は、<code>xs:string</code>型に昇格させることができる。この昇格の結果は、元の値を<code>xs:string</code>型に型変換することで生成される。</p>
<note><p><code>xs:anyURI</code>の値は<code>xs:string</code>に昇格させることができるので、<termref def="dt-def-collation">デフォルト照合順序</termref>を用いて文字列を比較する関数や演算子は、<termref def="dt-def-collation">デフォルト照合順序</termref>を用いて<code>xs:anyURI</code>の値も比較する。このことにより、文字列や<code>xs:anyURI</code>の値、またはこれら2つの型の組み合わせを含む順序は、一定でかつはっきり定義されることが保証される。</p></note></item>


</olist>
<p><termref def="dt-type-promotion">型の昇格</termref>は<termref def="dt-subtype-substitution">部分型置換</termref>とは異なることに注意すること。例えば:</p>
<ulist><item><p><code>xs:float</code>型の引数<code>$p</code>を期待する関数は、<code>xs:decimal</code>型の値を与えて呼び出すことができる。これは<termref def="dt-type-promotion">型の昇格</termref>の例である。この値は期待される型に実際に変換される。関数の本体の内部では、<code>$p instance of xs:decimal</code>は<code>false</code>を返す。</p></item>
<item><p><code>xs:decimal</code>型の引数<code>$p</code>を期待する関数は、<code>xs:integer</code>型の値を与えて呼び出すことができる。これは<termref def="dt-subtype-substitution">部分型置換</termref>の例である。この値は元の型のまま残されている。関数の本体の内部では、<code>$p instance of xs:integer</code>は<code>true</code>を返す。</p></item></ulist></div2>

<div2 id="mapping">
<head>演算子の写像</head>
<p>この節の演算子の写像表は、さまざまなXPathの演算子に対して定義される方の組み合わせを列挙する。<termdef term="operator function" id="dt-operator-function">各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<term>演算子関数</term>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。</termdef> 演算子関数の定義は<bibref ref="FunctionsAndOperators"/>で与えられている。演算子の結果、その演算子関数によってエラーが発生してもよい。これに関する定義は<bibref ref="FunctionsAndOperators"/>にある。ある場合には、演算子関数は与えられた演算子の完全な意味を実装しない。各演算子の定義 (空列や長さが1より大きい列に対する振舞いを含む) については、この文書の主部分中の記述を見よ。</p>
<p><code>and</code>や<code>or</code>演算子は、この文書の主部分に直接定義されており、演算子の写像表には出現していない。</p>
<p>演算子の写像表中の演算子が型 <emph>ET</emph> の演算数を要求するとき、<termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって型 <emph>AT</emph> が型 <emph>ET</emph> に変換されるならば、その演算子は型 <emph>AT</emph> の演算数に適用することができる。
例えば、表のエントリに<code>gt</code>演算子を2つの<code>xs:date</code>演算数に適用してよく、そのとき<code>xs:boolean</code>を返すと示しているものがある。したがって、<code>gt</code>演算子は2つの<code>xs:date</code>の部分型 (これらは異なることもある) に適用してもよく、この場合も<code>xs:boolean</code>を返す。</p>
<p><termdef id="dt-numeric" term="numeric">型を参照するとき、<term>数</term>という用語は<code>xs:integer</code>型, <code>xs:decimal</code>型,
<code>xs:float</code>型, <code>xs:double</code>型を表す。</termdef> 演算数と結果が<termref def="dt-numeric">数</termref>と指定されている演算子は、4つの演算子、すなわち数型それぞれに対し1つの演算子を表していると考えられる。例えば、数型の<code>+</code>演算子は、以下の4つの演算子を表していると考えられる:</p>

<table width="80%" border="1" summary="Operators"><tbody><tr><td align="center" rowspan="1" colspan="1">演算子</td><td align="center" rowspan="1" colspan="1">第1演算数の型</td><td align="center" rowspan="1" colspan="1">第2演算数の型</td><td align="center" rowspan="1" colspan="1">結果の型</td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td></tr></tbody></table>
<p><termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって型 <emph>AT</emph> が4つの数型のいずれかに変換可能であれば、
数演算子は型<emph>AT</emph>の演算数に正しく適用してよい。演算子の結果の型が数と列挙されていれば、その意味は "順序リスト <code>(xs:integer, xs:decimal, xs:float, xs:double)</code>のうち、すべての演算数が<termref def="dt-subtype-substitution">部分型置換</termref>や<termref def="dt-type-promotion">型の昇格</termref>により変換することのできる型の最初のもの" である。例として、型<code>hatsize</code>が<code>xs:integer</code>から導出されており、型<code>shoesize</code>が<code>xs:float</code>から導出されているとしよう。このとき、<code>+</code>演算子が、型<code>hatsize</code>と<code>shoesize</code>の演算数を伴って実行されるならば, 型<code>xs:float</code>の結果を返す。同様に、<code>+</code>が型<code>hatsize</code>の2つの演算数を伴って実行されるならば、型<code>xs:integer</code>の結果を返す。</p>
<p><termdef id="dt-gregorian" term="Gregorian">演算子の写像表で、<term>Gregorian</term>という用語は、<code>xs:gYearMonth</code>型, <code>xs:gYear</code>型,
<code>xs:gMonthDay</code>型, <code>xs:gDay</code>型, 
<code>xs:gMonth</code>型を表す。</termdef>  2つのGregorian型の演算数を取ることのできる2項演算子について、演算数はともに同じ型でなければならない。 (例えば、1つの演算数が<code>xs:gDay</code>型であれば、もう一方の演算数も<code>xs:gDay</code>でなければならない。)</p>

<table border="1" summary="Binary operators" role="small">
<caption>2項演算子</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">演算子</th>
<th rowspan="1" colspan="1">型(A)</th>
<th rowspan="1" colspan="1">型(B)</th>
<th rowspan="1" colspan="1">関数</th>
<th rowspan="1" colspan="1">結果の型</th>
</tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-add(A, B)</td><td rowspan="1" colspan="1">数</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td><td rowspan="1" colspan="1">数</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:subtract-dates(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:subtract-times(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:subtract-dateTimes(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td><td rowspan="1" colspan="1">数</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A idiv B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-integer-divide(A, B)</td><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-divide(A, B)</td><td rowspan="1" colspan="1">数; ただし、演算数がともに xs:integer であれば xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr>
<tr><td rowspan="1" colspan="1">A mod B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-mod(A, B)</td><td rowspan="1" colspan="1">数</td></tr>

<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">op:duration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hex-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">op:QName-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">fn:not(op:duration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hex-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A is B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:is-same-node(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>


<tr><td rowspan="1" colspan="1">A &lt;&lt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-before(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A &gt;&gt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-after(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>



<tr><td rowspan="1" colspan="1">A union B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A | B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A intersect B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:intersect(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A except B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:except(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>

<tr><td rowspan="1" colspan="1">A to B</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">op:to(A, B)</td><td rowspan="1" colspan="1">xs:integer*</td></tr>
<tr><td rowspan="1" colspan="1">A , B</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">op:concatenate(A, B)</td><td rowspan="1" colspan="1">item()*</td></tr>

</tbody>
</table>

<table border="1" summary="Unary operators" role="small">
<caption>単項演算子</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">演算子</th>
<th rowspan="1" colspan="1">演算数の型</th>
<th rowspan="1" colspan="1">関数</th>
<th rowspan="1" colspan="1">結果の型</th>
</tr>
<tr><td rowspan="1" colspan="1">+ A</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td><td rowspan="1" colspan="1">数</td></tr>
<tr><td rowspan="1" colspan="1">- A</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td><td rowspan="1" colspan="1">数</td></tr>
</tbody>
</table>


</div2>
</div1>

<div1 id="id-xp-context-components" role="xpath"><head>文脈の構成要素</head>
<p>この節の表は、静的文脈や動的文脈のさまざまな構成要素の有効範囲 (適用可能な範囲) を記述する。</p>

<div2 id="id-xp-static-context-components"><head>静的文脈の構成要素</head>
<p>以下の表では、<term>静的文脈</term>の構成要素について記述する。構成要素それぞれについて、"大域" とは、構成要素の値が XPath 式の全体を通して適用するということを表し、一方 "字句" とは、構成要素の値が、それが定義されている部分式の中でしか適用しないことを表している。</p>

<table width="60%" border="1" summary="Static Context" role="small">

<caption>静的文脈の構成要素</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">構成要素</th>



<th rowspan="1" colspan="1">有効範囲</th>

</tr>
<tr>
<td rowspan="1" colspan="1">XPath 1.0 互換モード</td>



<td rowspan="1" colspan="1">大域</td>

</tr><tr>
<td rowspan="1" colspan="1">静的既知名前空間</td>



<td rowspan="1" colspan="1">大域</td>

</tr><tr><td rowspan="1" colspan="1">デフォルト要素/型名前空間</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">デフォルト関数名前空間</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">有効範囲内スキーマ型</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">有効範囲内要素定義</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">有効範囲内属性定義</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">有効範囲内変数</td><td rowspan="1" colspan="1">字句; for式と限量式では新しい変数を束縛することができる</td></tr><tr><td rowspan="1" colspan="1">文脈項目静的型</td><td rowspan="1" colspan="1">字句</td></tr><tr><td rowspan="1" colspan="1">関数のシグネチャ</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">静的既知照合</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">デフォルト照合</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">基底URI</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">静的既知文書</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">静的既知コレクション</td><td rowspan="1" colspan="1">大域</td></tr><tr><td rowspan="1" colspan="1">静的既知デフォルトコレクション型</td><td rowspan="1" colspan="1">大域</td></tr>
</tbody>
</table></div2>

<div2 id="id-xp-evaluation-context-components"><head>動的文脈の構成要素</head>
<p>以下の表では、<term>動的文脈</term>のさまざまな構成要素に値がいかに割り当てられるかを記述している。これらの構成要素はホスト言語で定義される機構で初期化される。構成要素それぞれについて、"大域" とは、構成要素の値が、XPath式の評価の間ずっと変化しないことを表す。一方 "動的" とは、構成要素の値が、部分式の評価によって変更可能であることを表す。</p>
<table width="60%" border="1" summary="Static Context" role="small">
<caption>動的文脈の構成要素</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">構成要素</th>



<th rowspan="1" colspan="1">有効範囲</th>

</tr>
<tr>
<td rowspan="1" colspan="1">文脈項目</td>



<td rowspan="1" colspan="1">動的; 経路式や述語の評価の間変化する</td>

</tr><tr>
<td rowspan="1" colspan="1">文脈位置</td>



<td rowspan="1" colspan="1">動的; 経路式や述語の評価の間変化する</td>

</tr><tr><td rowspan="1" colspan="1">文脈サイズ</td><td rowspan="1" colspan="1">動的; 経路式や述語の評価の間変化する</td></tr><tr><td rowspan="1" colspan="1">変数の値</td><td rowspan="1" colspan="1">動的; for式と限量式では新しい変数を束縛することができる</td></tr><tr><td rowspan="1" colspan="1">現在の日付と時間</td><td rowspan="1" colspan="1">大域; 実装によって初期化されなければならない</td></tr><tr><td rowspan="1" colspan="1">暗黙的タイムゾーン</td><td rowspan="1" colspan="1">大域; 実装によって初期化されなければならない</td></tr><tr><td rowspan="1" colspan="1">利用可能文書</td><td rowspan="1" colspan="1">大域; 実装によって初期化されなければならない</td></tr><tr><td rowspan="1" colspan="1">利用可能コレクション</td><td rowspan="1" colspan="1">大域; 実装によって初期化されなければならない</td></tr><tr><td rowspan="1" colspan="1">デフォルトコレクション</td><td rowspan="1" colspan="1">大域; 実装によって上書き可能</td></tr>
</tbody>
</table></div2></div1>

<div1 id="id-impl-defined-items"><head>実装定義の項目</head>
<p>この仕様中の以下の項目は<termref def="dt-implementation-defined">実装定義</termref>である:</p>
<olist>
<item><p>式を構成するUnicodeの版</p></item>
<item><p><termref def="dt-static-collations">静的既知照合順序</termref></p></item>
<item><p><termref def="dt-timezone">暗黙的タイムゾーン</termref></p></item>
<item><p><termref def="dt-warning">警告</termref>が発生する状況、および警告が処理される方法</p></item>
<item><p>エラーが外部処理環境に通知される方法</p></item>
<item><p>実装が<bibref ref="XML"/>や<bibref ref="XMLNAMES"/>のルール、<bibref ref="XML1.1"/>や<bibref ref="XMLNAMES11"/>のルールのいずれに基づいているか。これらのルール集合のうち1つが、実装のすべての局面で常に適用されなければならない。</p></item>
<item role="xpath"><p>実装が名前空間軸を支援するかどうか。</p></item>

<item role="xpath"><p>実装によって支援される任意の<termref def="dt-xpath-static-typing-extension">静的型付け拡張</termref>。ただし、<termref def="dt-xpath-static-typing-feature">静的型付け機能</termref>が支援される場合のみ。</p></item>










</olist><note><p>追加の<termref def="dt-implementation-defined">実装定義</termref>の項目が<bibref ref="datamodel"/>や<bibref ref="FunctionsAndOperators"/>に列挙されている。</p></note></div1>
<div1 id="id-references">
<head>参考文献</head>
<div2 id="id-normative-references">
<head>規格</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. See <loc href="http://rfc.net/rfc2119.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2396" key="RFC2396" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 2396. See <loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2396.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 3986. See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst and M. Suignard.  <emph>Internationalized Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization). <emph>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</emph>, ただし, 日々修正されたり、新しい版に置き換えられたり、新しい部の追加によって拡張されたりする。 [Geneva]: International Organization for Standardization. (最新版については<loc href="http://www.iso.ch" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.ch</loc>を見よ。)</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">The Unicode Consortium. <emph>The Unicode Standard</emph>  Reading, Mass.: Addison-Wesley, 2003, ただし、日々新たな版が公表されることにより更新される。最新版、およびこの標準の版や Unicode Character Databaseに関する追加情報については、<loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/standard/versions</loc>を見よ。使用される Unicode の版は<termref def="dt-implementation-defined">実装定義</termref>である。ただし、実装は最新の Unicode の版を使用することが推奨される。</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.0. (Third Edition)</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML1.1" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.1.</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES" key="XML Names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml-names/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLID" key="XML ID" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph> W3C Proposed Recommendation. See <loc href="http://www.w3.org/TR/xml-id/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-id/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October
2004. See <loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</loc>, <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</loc>, and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery/XPath Data Model (XDM)" id="datamodel" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath
2.0 Data Model (XDM)</emph>. W3C Candidate Recommendation, 03 Nov. 2005. See <loc href="http://www.w3.org/TR/xpath-datamodel/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XQueryFormalSemantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Formal Semantics</emph>.  W3C Candidate Recommendation,
03 Nov. 2005. See <loc href="http://www.w3.org/TR/xquery-semantics/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-semantics/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="FunctionsAndOperators" key="XQuery 1.0 and XPath 2.0 Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Functions and
     Operators</emph> W3C Candidate Recommendation, 03 Nov. 2005. See <loc href="http://www.w3.org/TR/xquery-operators/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-functions/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XSLT 2.0 and XQuery 1.0 Serialization" id="serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium.
<emph>XSLT 2.0 and XQuery 1.0 Serialization</emph>.
W3C Candidate Recommendation, 03 Nov.  2005.
See <loc href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt-xquery-serialization/</loc>.</bibl>

</blist>
</div2>
<div2 id="id-non-normative-references">
<head>参考</head>

<blist>



<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPath-Requirements" key="XPath 2.0 Requirements" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>XPath Requirements
Version 2.0</emph>. W3C Working Draft 22 August 2003. See <loc href="http://www.w3.org/TR/xpath20req" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20req</loc>.
</bibl>





<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery" role="xpath" id="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0: An XML Query Language</emph>. W3C Candidate Recommendation, 03 Nov. 2005. See
<loc href="http://www.w3.org/TR/xquery/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</loc>.</bibl>
					

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT" key="XSLT 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.  <emph>XSL
Transformations (XSLT) 2.0.</emph> W3C Candidate Recommendation, 03 Nov. 2005.  See <loc href="http://www.w3.org/TR/xslt20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt20/</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM" key="Document Object Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XINFO" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Information Set.</emph> W3C Recommendation 24 October 2001. See
<loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XPath 1.0" id="XPath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>XML Path
Language (XPath) Version 1.0</emph>. W3C Recommendation, Nov. 16, 1999. See
<loc href="http://www.w3.org/TR/xpath.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath.html</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPTR" key="XPointer" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001. See <loc href="http://www.w3.org/TR/WD-xptr" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/WD-xptr</loc></bibl>











 





</blist>
</div2>

<div2 id="id-background-material"><head>背景資料</head><blist>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CHARMOD" key="Character Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT1" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XSL
Transformations (XSLT) 1.0.</emph> W3C Recommendation. See <loc href="http://www.w3.org/TR/xslt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</loc></bibl>


			


</blist>
</div2>
</div1>

<div1 role="xpath" id="id-xpath-conformance"><head>適合性</head>
<p>XPathは主に他の仕様で用いることができる構成要素を意図している。そのため、XPathはそれが用いられる仕様 (<bibref ref="XPTR"/>や<bibref ref="XSLT"/>など) に依存して、それぞれの環境に対してXPathの適合性規範が指定される。XPathの用い方に対して適合性規範を指定している仕様は、XPathの構文や意味の定義をこの仕様で与えられたものから変更してはならない。ただし、一部だけを使用したり、互換性のある拡張を行うことは許される。</p>
<div2 id="id-xpath-static-typing"><head>静的型付け機能</head><p>
                <termdef id="dt-xpath-static-typing-feature" term="static typing feature" role="xpath"><term>静的型付け機能</term>はXPathの選択可能な機能であり、<bibref ref="XQueryFormalSemantics"/>に定義されている静的型の支援を提供し、実装が<termref def="dt-static-analysis">静的解析相</termref>における<termref def="dt-type-error">型エラー</termref>を検出し通知するのに必要である。</termdef> XPathを用いる仕様は、静的型付け機能を用いるための適合性を指定してもよい。</p>
            <p>実装が<termref def="dt-xpath-static-typing-feature">静的型付け機能</termref>を支援していないが、それにもかかわらず静的解析相において、ある式を実行時に評価すると型エラーが必然的に発生する、ということが決定できるならば、実装は、静的解析相においてエラーを発生させてもよい。このようなエラーを発生させるかどうかの選択は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
            <div3 id="id-xpath-static-extensions"><head>静的型付け拡張</head>
<p>ある場合には、<bibref ref="XQueryFormalSemantics"/>で定義されている静的型付けルールはあまり詳細ではない (例えば、parent, ancestor, ancestor-or-self など先祖に関する軸や<code>fn:root</code>関数に関する型推論ルールを見よ)。実装によっては、より詳細な静的型付けルールの支援を期待してもよい。</p>
                <p><termref def="dt-xpath-static-typing-feature">静的型付け機能</termref>を実装する適合性実装は、1つ以上の<term>静的型付け拡張</term>も用意してもよい。<termdef term="static typing extension" id="dt-xpath-static-typing-extension"><term>静的型付け拡張</term>は<termref def="dt-implementation-defined">実装定義</termref>の型推論ルールであり、<bibref ref="XQueryFormalSemantics"/>の型推論ルールによる推論よりもより詳細な静的型を推論する。</termdef>静的型付け拡張に関する制約の形式的定義については、<xspecref spec="FS" ref="id-static-extensions"/>を見よ。</p></div3></div2></div1>
<div1 id="id-errors">	
  <head>エラー条件</head>	
<error-list>
<error spec="XP" code="0001" class="ST" type="static">
<p>
<termref def="dt-static-error">静的エラー</termref>であり、式の解析が、値の割り当てられていない<termref def="dt-static-context">静的文脈</termref>の構成要素に依存している。</p></error>

<error spec="XP" code="0002" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、式の評価が、値の割り当てられていない<termref def="dt-dynamic-context">動的文脈</termref>の部分に依存している。</p></error>

<error spec="XP" code="0003" class="ST" type="static">
<p>
<termref def="dt-static-error">静的エラー</termref>であり、式が<specref ref="id-grammar"/>で定義されている文法の正しいインスタンスではない。</p></error>

<error spec="XP" code="0004" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、<termref def="dt-static-analysis">静的解析相</termref>において、式が、その式の出現する文脈に適さない<termref def="dt-static-type">静的型</termref>を持っていると分かったり、<termref def="dt-dynamic-evaluation">動的評価相</termref>において、値の<termref def="dt-dynamic-type">動的型</termref>が<specref ref="id-sequencetype-matching"/>の照合ルールで指定された要求型と照合されない。</p></error>

<error spec="XP" code="0005" class="ST" type="static">
<p>静的解析における<termref def="dt-static-error">型エラー</termref>であり、<code>()</code>または<code>data(())</code>以外の式に割り当てられた<termref def="dt-static-type">静的型</termref>が<code>empty-sequence()</code>である。</p></error>

<error spec="XP" code="0006" class="TY" type="type">
<p>(現在は使われていない。)</p></error>

<error spec="XP" code="0007" class="TY" type="type">
<p>(現在は使われていない。)</p>
</error>

<error spec="XP" code="0008" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、式が<termref def="dt-static-context">静的文脈</termref>で定義されていない要素名、属性名、スキーマ型名、名前空間接頭辞、変数名を参照している。ただし、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>の中での参照を除く。</p>
</error>







<error spec="XP" code="0010" class="ST" type="static">
<p>実装は、その実装が支援しない軸の参照に出会うと、<termref def="dt-static-error">静的エラー</termref>を発生しなければならない。</p>
</error>











<error spec="XP" code="0017" class="ST" type="static">
<p><phrase role="xpath">エラー (ホスト言語環境はこのエラーを<termref def="dt-static-error">静的エラー</termref>と定義しても<termref def="dt-dynamic-error">動的エラー</termref>と定義してもよい)</phrase>であり、関数呼び出し中の引数の展開済QNameや引数の数が、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-function-signature">関数シグネチャ</termref>の名前や次数と一致しない。</p>
</error>

<error spec="XP" code="0018" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、経路式の最後のステップの結果が節点も原子値も含んでいない。</p>
</error>

<error spec="XP" code="0019" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、経路式のステップ (最後のステップ以外) の結果が原子値を含んでいる。</p>
</error>

<error spec="XP" code="0020" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、軸ステップで文脈項目が節点ではない。</p>
</error>

<error spec="XP" code="0021" class="DY" type="dynamic">
<p>(現在は使われていない。)</p>
</error>









































<error spec="XP" code="0050" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、<code>treat</code>式の演算数の<termref def="dt-dynamic-type">動的型</termref>が<code>treat</code>式で指定された<termref def="dt-sequence-type">静的型</termref>と一致しない。このエラーは、"<code>/</code>" や "<code>//</code>" で始まる経路式のうち、その文脈節点が文書節点を根とする木の中にないときも発生する。これは、経路式の先頭の "<code>/</code>" や "<code>//</code>" が、節<code>treat as document-node()</code>を含む初期ステップの省略形だからである。</p></error>
<error spec="XP" code="0051" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>中の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>として用いられるQNameが、<termref def="dt-is-types">有効範囲内スキーマ型</termref>中で原子型として定義されていない。</p></error>



<error spec="XP" code="0080" class="ST" type="static">
<p><code>cast</code>式や<code>castable</code>式の目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>中になくてはならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。後ろに出現標識 "<code>?</code>" が続いてもよい。そうでない場合は<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XP" code="0081" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<phrase role="xpath">式</phrase>で用いられているQNameが、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いても名前空間URIに展開できない名前空間接頭辞を含む。</p>
</error>



<error spec="XP" code="0083" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error>



</error-list>
</div1>



<inform-div1 id="id-glossary"><head>用語集</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>



<inform-div1 role="xpath" id="id-backwards-compatibility"><head>XPath 1.0 との後方互換性</head>

<p>この附録では、XPath 2.0 と<bibref ref="XPath"/>との非互換性の範囲についてのまとめを提供する。</p>

<p>3つの個別の場合が考えられる:</p>

<olist>
<item><p>ソース文書がスキーマを持ち、XPath 1.0互換モードが true として走らせるときに存在する非互換性。この仕様では、このような状況での非互換性の数を極力削って完全に最小になるよう設計されているが、しかしいくつかの違いは残っている。これらをそれぞれ列挙する。</p></item>

<item><p>XPath 1.0 互換モードが false に設定されているときに生じる非互換性。この場合、互換性の失われる式の数はより多くなる。</p></item>

<item><p>ソース文書がスキーマを用いて処理されるときに生じる非互換性 (XPath 1.0互換モードが true に設定されているかどうかに関わらず)。スキーマを用いて文書を処理すると、節点の値を解釈する方法が変化する。これにより XPath 式が異なる結果を返す。</p></item>
</olist>

<div2 id="id-incompat-in-true-mode"><head>互換モードが true のときの非互換性</head>

<p>以下のリストには、この仕様の範囲内で、互換モードが true で動作する XPath 2.0 処理器が、XPath 1.0 処理器により同じ式を処理したときと異なる結果を生成するような既知の場合がすべて含まれている。ただし、その式は XPath 1.0 で妥当であり、ソース文書の節点は <code>xs:untyped</code>と<code>xs:untypedAtomic</code>以外の型注釈を持たないと仮定する。</p>

<p>個々の関数の振舞いに関する非互換性はここには列挙していない。<bibref ref="FunctionsAndOperators"/>の附録に含まれている。</p>

<p>XPath 1.0 も XPath 2.0 も、仕様のある面を実装定義として残しているため、特定の実装の振舞いについての非互換性で、この仕様の範囲外のものがあってもよい。それらの振舞いの面の一部はホスト言語で定義されている。</p>


<olist>
<item><p><code>A &lt; B &lt; C</code>のように連続した比較演算子は XPath 1.0 では支援されるが、XPath 2.0 の文法では許されない。多くの場合、XPath 1.0 のこのような比較は直観的に明らかな意味を持たなかった。そのため、このような比較が現実に広く用いられているということは考えられない。このような構成要素が見つかれば、XPath 2.0 処理器は構文エラーを通知し、また構成要素を<code>(A &lt; B) &lt; C</code>と書き換えることができる。</p></item>

<item><p>文字列を数に変換するとき (明示的に<code>number</code>関数を使うときも、暗黙的に関数呼び出しを行うときも)、XPath 1.0 において特別な値 <code>NaN</code>に変換される文字列は、XPath 2.0 では<code>NaN</code>以外の値に変換される。これには<code>+</code>が先頭に書かれた数、指数による浮動小数点記法 (<code>1.0e+9</code>など)、文字列<code>INF</code>や<code>-INF</code>などが含まれる。</p></item>

<item><p>XPath 2.0 は、空白の出現なしに、数リテラルの直後に文字から始まるトークンが置かれることを許さない。例えば、<code>10div 3</code>は XPath 1.0 では許されたが、XPath 2.0 では<code>10 div 3</code>というように書かれなければならない。</p></item>

<item><p>XPath 2.0 では名前空間軸は推奨されない。実装は、XPath 1.0 との後方互換性のため名前空間軸を支援してもよいが、支援する必要はない。(XSLT 2.0 は、XPath 後方互換性モードが支援されていれば、名前空間軸もまた支援されなければならない。しかし他のホスト言語では異なる適合性ルールを定義してもよい。)</p></item>


</olist>



</div2>

<div2 id="id-incompat-in-false-mode"><head>互換性モードが false のときの非互換性</head>

<p>XPath 1.0 互換モードが false に設定されていても、多くの XPath 式は XPath 1.0 の下でも XPath 2.0 の下でもやはり同じ結果を生成する。例外をこの節で述べる。</p>

<p>どの場合でも、質問中の式は XPath 1.0 の下で正しいと仮定する。また、XPath 1.0 互換モードが false であり、すべての要素と属性はそれぞれ<code>xs:untyped</code>または<code>xs:untypedAtomic</code>と注釈付けされていると仮定する。</p>

<p>以下の記述では、<emph>節点集合</emph>と<emph>数</emph>という用語を XPath 1.0 の意味で用いる。すなわち、XPath 1.0 のルールに従ってそれぞれ節点集合と数を生成する式を記述するのに用いる。</p>

<olist>


<item><p>単一の節点や値を引数として期待する関数や演算子に、1個より多い節点を含む節点集合が引数として渡されたとき、XPath 1.0 のルールでは、1番目より後ろのすべての節点は捨てられる。XPath 2.0 では、1個より多い節点からなるときには型エラーが発生する。XPath 1.0 の振舞いは、述語<code>[1]</code>を用いて節点集合の最初の節点を明示的に選択することで、常に復元することが可能である。</p></item>

<item><p>XPath 1.0 では、<code>&lt;</code>演算子や<code>&gt;</code>演算子は、2つの文字列に対して適用されるときは、文字列をともに数に変換し、結果の間で算術比較を行っていた。XPath 2.0 では、これらの演算子はデフォルト照合順序列を用いて文字列比較を行う。(ただし、どちらかの値が数であれば、結果は XPath 1.0 と互換である)</p></item>

<item><p>数を引数として期待する関数や演算子に空の節点集合が引数として渡されると、値が暗黙的にNaNに変換される、ということはなくなった。XPath 1.0 の振舞いは、<code>number</code>関数を用いて明示的に変換を行うことにより、常に復元することが可能である。</p></item>

<item><p>より一般的には、関数や演算子の引数が要求型に暗黙的に変換されるということはなくなった。ただし、渡された引数が<code>xs:untypedAtomic</code>の場合を除く (これはスキーマを持たない文書中の節点が引数として渡されたときの共通の場合である)。例えば、関数呼び出し<code>substring-before(10 div 3, ".")</code>は、XPath 2.0 では型エラーを発生する。XPath 1.0 の振舞いは、構成子関数や型変換を用いて要求型に明示的に変換を行うことにより、復元することが可能である。</p></item>

<item><p>節点集合とブール値を比較するルールが変更されている。XPath 1.0 では、<code>$node-set = true()</code>のような式は、節点集合をブール値に変換した後ブール値の比較を行うことで評価していた。したがってこの式は、<code>$node-set</code>が空でなければ<code>true</code>を返す。XPath 2.0 では、列と単一値列の間の他の比較と同様の方法で処理される。この式は、原子化および型変換ルールを用いたブール値への変換の後、値が<code>true</code>であるような節点が1つ以上<code>$node-set</code>に含まれていれば<code>true</code>である。</p>

<p>このことは、<code>$node-set</code>が空であれば、XPath 2.0 の下での結果はブール型の演算数の値に関わらず、そしてどの演算子が用いられたかに関わらず、<code>false</code>である、ということを意味している。<code>$node-set</code>が空でなければ、多くの場合、ブール値と比較した結果は失敗し、動的エラーを返すことが普通である。しかし、節点が値 "0", "1", "true", "false" を持っている場合は、式の評価は成功するかもしれない。</p></item>

<item><p>数とブール値の比較、数と文字列の比較、文字列とブール値の比較は XPath 2.0 では許されない。これらは型エラーになる。XPath 1.0 では、これらの比較は許されており、一方の演算数をもう一方の演算数の型に変換することで処理されていた。したがって、例えば XPath 1.0 では<code>4 = true()</code>は true であり、<code>4 = "+4"</code>は false (なぜなら、文字列<code>+4</code>は<code>NaN</code>に変換されるから), <code>false = "false"</code>は false であった (なぜなら文字列<code>"false"</code>はブール値<code>true</code>に変換されるから)。XPath 2.0 ではこれらの比較はいずれも型エラーである。</p></item>


<item><p>新たな数型が追加された。その結果、算術演算は integer, decimal, 単倍長浮動小数点、二倍長浮動小数点として計算してもよい。以前は、算術演算は常に二倍長浮動小数点として計算されていた。<code>div</code>演算子で2つの整数を除算した結果は、double 型ではなく decimal 型の値である。式<code>10 div 0</code>は、正の無限大を返すのではなく、エラーを発生する。</p></item>

<item><p>数を文字列に変換するルールが変更されている。これにより、数をスタイルシート外部に表示する方法が影響を受けるかもしれない。絶対値が1E-6から1E+6の範囲内である数に対しては、結果は全く同じであるべきである。しかしこの範囲外では、整数でない<code>xs:float</code>や<code>xs:double</code>の値に対して科学的形式が用いられる。</p>
</item>

<item><p>文字列を数に変換するルールが変更されている。XPath 1.0 互換モードが true の時に適用される変更に加えて、互換モードが false のとき、文字列 <code>Infinity</code>と<code>-Infinity</code>が正の無限大、負の無限大の表現として認識されることはなくなった。<code>number</code>関数は、すべての認識できない文字列を<code>NaN</code>に変換するという動作を続けるが、文字列を数に型変換する操作は、このような文字列に対して動的エラーを起こす。</p></item>

<item><p>XPath 2.0 の多くの演算では、1つ以上の演算数が空列であるとき、その結果として空列を生成する。演算が文字列を期待するとき、空列は通常長さ0の文字列と等価であるとみなされる。これは XPath 1.0 の振舞いと互換である。しかし、演算が数を期待するとき、結果は等しくない。例えば、<code>@width</code>が空列を返すならば、XPath 1.0 では<code>@width+1</code>の結果は<code>NaN</code>であった。しかし XPath 2.0 では、この結果は<code>()</code>である。この影響として、<code>item[@width+1 != 2]</code>のような選別式は、XPath 1.0 では属性<code>width</code>を持たない項目が選択されるが、XPath 2.0 ではそのような項目は選択されない。</p></item>

<item><p>XPath 2.0 におけるコメント節点、処理命令節点、名前空間節点の型付き値は<code>xs:string</code>型であり、<code>xs:untypedAtomic</code>ではない。このことは、数を期待される文脈で値が用いられても暗黙的な変換は行われない、ということを意味している。例えば、もし処理命令節点が算術演算子の演算数として用いられるならば、XPath 1.0 では節点の文字列値を数に変換しようと試みていた (そして成功すれば<code>NaN</code>を生成していた)。しかし XPath 2.0 では型エラーを通知する。</p></item>

<item><p>XPath 1.0 では、<code>A and B</code>の形の式では、Aが false であれば B は評価されないと定義されていた。同様に、<code>A or B</code>の場合には、A が true であれば B は評価されなかった。XPath 2.0 では、これは保証されなくなった。実装は、2つの演算数をその順に評価しても並列に評価しても自由である。この変更により、索引により支援されるような巨大なデータコレクションに対して XPath 式が評価されるような状況において、最適化の可能性がより大きくなる。実装は、この部分において後方互換性を保つことを選択してもよいが、そうすることは義務ではない。</p></item>




</olist>



</div2>

<div2 id="id-incompat-when-using-schema"><head>スキーマを用いた場合の非互換性</head>

<p>スキーマに基づいて処理された文書にXPath式を適用すると、スキーマのない同じ文書に対して同じ式を適用した場合と常に同じ結果になるとは限らない。スキーマ処理はXPath 1.0 の式の結果に影響を与えないので、このことにより更なる非互換性が起こるかもしれない。この節では、起こりうる違いについて、いくつかの例を挙げる。</p>

<p>文脈節点が要素節点であり、以下のマークアップから導出されているとする: <code>&lt;background color="red green blue"/&gt;</code>。XPath 1.0 では、述語<code>[@color="blue"]</code>は<code>false</code>を返す。XPath 2.0 では、属性<code>color</code>がスキーマで<code>xs:NMTOKENS</code>型であると定義されていれば、同じ述語が<code>true</code>を返す。</p>

<p>同様に、式<code>@birth &lt; @death</code>を要素<code>&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</code>に適用することを考える。XPath 1.0 では、この式は false を返す。なぜなら、2つの属性がともに数に変換され、どちらの場合も<code>NaN</code>を返すからである。XPath 2.0 では、スキーマ中にこれらの属性が日付であると注釈付けされていた場合、この式は<code>true</code>を返す。</p>

<p>いったんスキーマ検証が適用されると、要素や属性は、異なるデータ型を期待する式の演算数や引数として用いることはできない。例えば、日付に対して<code>substring</code>関数を適用して年を取得したり、数に<code>substring</code>関数を適用して整数部分を取得したりすることはできなくなった。同様に、属性がブール型と注釈付けされていると、それを文字列<code>"true"</code>や<code>"false"</code>と比較することはできない。これらの演算はすべて型エラーになる。このようなエラーが起こるときの救済策は、明示的な変換を導入するか、同じ計算を別の方法で行うかである。例えば、<code>substring-after(@temperature, "-")</code>は<code>abs(@temperature)</code>と書き換えられるかもしれない。</p>

<p>静的型付け機能を提供している XPath 2.0 の実装では、XPath 1.0 の下では動作していた式についてさらに多くの型エラーが通知される。例えば、<code>round(../@price)</code>のような式は静的型エラーになるかもしれない。なぜなら処理器は、<code>../@price</code>が数であるという保証を静的に推論することができないからである。</p>

<p>スキーマ検証は多くの場合、要素の内容に空白の正規化を行う (要素の型に依存する)。これにより、<code>string-length</code>関数のような演算の結果が変化する。</p>

<p>スキーマ検証は、省略された属性や空の要素に対してデフォルト値を追加することによりデータモデルを拡張する。</p>

</div2>

</inform-div1>





<inform-div1 id="id-revisions-log" role="xpath"><head>Revision
Log</head>

<p>This log records the substantive and significant editorial changes that have been made to this document since the Candidate Recommendation Draft of 03 November 2005. Minor editorial changes are not included in this log.</p><div2 id="id-log-050707"><head>10 May 2006</head><olist><item><p>Deleted all references to the namespace <code>http://www.w3.org/2005/xpath-datatypes</code>, formerly known by the prefix <code>xdt:</code>, and moved all the schema types defined in this namespace to the namespace <code>http://www.w3.org/2001/XMLSchema</code>, known in this document by the prefix <code>xs:</code>. All built-in schema types used by XPath and XQuery are now consolidated in the <code>xs:</code> namespace.</p><p>This change closes Bugzilla entry 2548. It affects many sections throughout this document and other XPath and XQuery specifications.</p></item><item><p>Deleted a paragraph requiring the functions <code>fn:doc</code> and <code>fn:collection</code> to be stable (returning the same results when called repeatedly.) Stability of these functions is now covered in the Functions and Operators specification. The functions are stable by default but an implementation may provide a user option to relax this requirement.</p><p>This change closes Bugzilla entry 2553. Section affected: <specref ref="id-input-sources"/></p></item><item><p>A cast expression or constructor function whose target type is <code>xs:QName</code> or is derived from <code>xs:QName</code> or <code>xs:NOTATION</code> formerly required its operand to be a literal string. Now it accepts either a literal string or an expression whose base type is the same as the base type of the target type. For example, it is now possible to cast a value of type <code>xs:QName</code> to <code>my:BigQName</code> which is derived from <code>xs:QName</code>.</p><p>This change closes Bugzilla entry 2678. Sections affected:</p><olist><item><p><specref ref="id-cast"/></p></item><item><p><specref ref="id-constructor-functions"/></p></item><item><p>Error code XPST0083 is eliminated (all casts and calls to constructor functions with invalid operands raise XPTY0004.)</p></item></olist></item><item><p>Modified the definition of Effective Boolean Value to specify that a value of type <code>xs:anyURI</code> is treated the same as a value of type <code>xs:string</code> (a consequence of placing <code>xs:anyURI</code> and <code>xs:string</code> in the same promotion hierarchy).</p><p>This change closes Bugzilla entry 2545. Section affected: <specref ref="id-ebv"/></p></item><item><p>When a namespace prefix cannot be resolved, error code XPST0081 is raised rather than the more generic error XPST0008.</p><p>This change closes Bugzilla entry 2447. Sections affected: </p><olist><item><p><specref ref="node-tests"/></p></item></olist></item><item><p>When the axis name is omitted from an axis step containing a SchemaAttributeTest, the default axis is <code>attribute</code>. Example: <code>part/schema-attribute(color)</code>.</p><p>This change closes Bugzilla entry 2527. Section affected: <specref ref="abbrev"/></p></item><item><p>Equality of QNames is defined by the <code>eq</code> operator, which performs codepoint-comparisons of the namespace URIs and the local names, ignoring the namespace prefixes. This is not a change, but some editorial clarifications have been made in the XPath, XQuery, and Functions and Operators documents. For example, phrases such as "QNames are the same" have been replaced by "QNames are equal as defined by the <code>eq</code> operator", and a new example has been added to the section on Value Comparisons.</p><p>This change closes Bugzilla entry 2634. Sections affected: Minor editorial changes to various sections and to the definitions of error codes  XQST0034 and XQST0049.</p></item><item><p>An implementation is not required to enforce cardinality constraints on operands that are not evaluated.</p><p>This change closes Bugzilla entry 2708. Section affected: <specref ref="id-errors-and-opt"/></p></item><item><p>Entries for the <code>eq</code> and <code>ne</code> operators on the types <code>xs:yearMonthDuration</code> and <code>xs:dateTimeDuration</code> have been removed from the operator mapping table. These operators are now handled by promotion to <code>xs:duration</code>.</p><p>This change closes Bugzilla entry 2789. Section affected: <specref ref="mapping"/></p></item><item><p>Editorial changes have been made to clarify that type promotions and subtype substitutions may be performed on the operands of all operators, including value comparisons. This is not a substantive change.</p><p>This change closes Bugzilla entries 2324 and 2631. Sections affected: <specref ref="id-value-comparisons"/> and <specref ref="mapping"/>.</p></item><item><p>Editorial changes have been made to clarify that a sequence of adjacent predicates is processed from left to right, and to clarify the assignment of context positions on reverse axes. This is not a substantive change.</p><p>This change closes Bugzilla entry 2500. Sections affected: <specref ref="id-steps"/>, <specref ref="axes"/>, <specref ref="id-predicates"/>, and <specref ref="id-filter-expr"/>.</p></item><item><p>If multiple errors are detected, an implementation may report any non-empty subset of the detected errors.</p><p>This change closes Bugzilla entry 3122. Section affected: <specref ref="id-kinds-of-errors"/>.</p></item></olist></div2></inform-div1>


</back>

</spec>