<?xml version="1.0" encoding="utf-8"?>
<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" w3c-doctype="cr">
<?translation-notice?>
  <!-- W3C header, disclaimers and abstracts -->
       <header>
  <title>XQuery 1.0 および XPath 2.0 の形式的意味</title>
  <w3c-designation>CR-xquery-semantics-20060608</w3c-designation>
  <w3c-doctype>W3C Candidate Recommendation</w3c-doctype>

  <pubdate>
   <day>8</day>
   <month>June</month>
   <year>2006</year>
  </pubdate>

  <publoc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xquery-semantics-20060608/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2006/CR-xquery-semantics-20060608/</loc>
  </publoc>

  <altlocs>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xquery-semantics-20060608/xquery-semantics.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="diff-from-20051103.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recent revisions</loc>
  </altlocs>

  <latestloc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery-semantics/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-semantics/</loc>
  </latestloc>

  <prevlocs>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-semantics-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050915/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050603/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
<!--
    <loc
    href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050404/"/>
    <loc
    href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050211/">http://www.w3.org/TR/2005/WD-xquery-semantics-20050211/</loc>
    <loc
    href="http://www.w3.org/TR/2004/WD-xquery-semantics-20040220/">http://www.w3.org/TR/2004/WD-xquery-semantics-20040220/</loc>
    <loc
    href="http://www.w3.org/TR/2003/WD-xquery-semantics-20031112/">http://www.w3.org/TR/2003/WD-xquery-semantics-20031112/</loc>
    <loc
    href="http://www.w3.org/TR/2003/WD-xquery-semantics-20030822/">http://www.w3.org/TR/2003/WD-xquery-semantics-20030822/</loc>
    <loc
    href="http://www.w3.org/TR/2003/WD-xquery-semantics-20030502/">http://www.w3.org/TR/2003/WD-xquery-semantics-20030502/</loc>
    <loc
    href="http://www.w3.org/TR/2002/WD-query-semantics-20021115/">http://www.w3.org/TR/2002/WD-query-semantics-20021115/</loc>
    <loc
    href="http://www.w3.org/TR/2002/WD-query-semantics-20020816/">http://www.w3.org/TR/2002/WD-query-semantics-20020816/</loc>
    <loc
    href="http://www.w3.org/TR/2002/WD-query-semantics-20020326/">http://www.w3.org/TR/2002/WD-query-semantics-20020326/</loc>
    <loc
    href="http://www.w3.org/TR/2001/WD-query-semantics-20010607/">http://www.w3.org/TR/2001/WD-query-semantics-20010607/</loc>
    <loc
    href="http://www.w3.org/TR/2001/WD-query-algebra-20010215/">http://www.w3.org/TR/2001/WD-query-algebra-20010215/</loc>
    <loc
    href="http://www.w3.org/TR/2000/WD-query-algebra-20001204/">http://www.w3.org/TR/2000/WD-query-algebra-20001204/</loc>
-->
  </prevlocs>

  <authlist>
    <author>
      <name>Denise Draper</name>
      <affiliation>Microsoft</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:denised@microsoft.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">denised@microsoft.com</email>
    </author>
    <author>
      <name>Peter Fankhauser (XML Query WG)</name>
      <affiliation>Infonyte GmbH</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:fankhaus@infonyte.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">fankhaus@infonyte.com</email>
    </author>
    <author>
      <name>Mary Fernández (XML Query WG)</name>
      <affiliation>AT&amp;T Labs - Research</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mff@research.att.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mff@research.att.com</email>
    </author>
    <author>
      <name>Ashok Malhotra (XML Query and XSL WGs)</name>
      <affiliation>Oracle Corporation</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:ashok.malhotra@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">ashok.malhotra@oracle.com</email>
    </author>
    <author>
      <name>Kristoffer Rose (XSL WG)</name>
      <affiliation>IBM T.J. Watson Research Center</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:krisrose@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">krisrose@us.ibm.com</email>
    </author>
    <author>
      <name>Michael Rys (XML Query WG)</name>
      <affiliation>Microsoft</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mrys@microsoft.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mrys@microsoft.com</email>
    </author>
    <author>
      <name>Jérôme Siméon (XML Query WG)</name>
      <affiliation>IBM T.J. Watson Research Center</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:simeon@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">simeon@us.ibm.com</email>
    </author>
    <author>
      <name>Philip Wadler (XML Query WG)</name>
      <affiliation>University of Edinburgh</affiliation>
      <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:wadler@inf.ed.ac.uk" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">wadler@inf.ed.ac.uk</email>
    </author>
  </authlist>

  <abstract>
    <p>この文書は<phrase role="xquery">XQuery 1.0 <bibref ref="xquery"/></phrase> <phrase role="shared">および</phrase> <phrase role="xpath">XPath 2.0
    <bibref ref="xpath20"/></phrase>の意味を形式的に定義する。</p>
  </abstract>

  <status>
<p><emph>This section describes the status of this document at the time of 
its publication. Other documents may supersede this document. A list of 
current W3C publications and the latest revision of this technical report 
can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports 
index</loc> at http://www.w3.org/TR/.</emph></p>

<p>On 3 November 2005, this specification <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-semantics-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">was
published</loc> as a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc>, and a Call
for Implementations was announced. This revision is published in order
to give visibility to the technical decisions that have been made so
far during this phase of the process. The maturity level of the
specification remains unchanged, and the work is on track to move
forward to the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed Recommendation</loc> stage when the
exit criteria for the current phase have been met.  Publication as a
Candidate Recommendation does not imply endorsement by the W3C
Membership.  This is a draft document and may be updated, replaced or
obsoleted by other documents at any time.  It is inappropriate to cite
this document as other than work in progress.  This specification will
remain a Candidate Recommendation until at least 28 February 2006.
</p>

<p>This document was produced jointly by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc>, both of which are part 
of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</p>

<p>This draft includes corrections and changes based on <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=Formal+Semantics&amp;version=Candidate+Recommendation&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED&amp;bug_status=CLOSED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public 
comments</loc> recorded in the W3C public Bugzilla repository (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Bugs/Public/</loc>) used for 
Last Call issues tracking. A list of substantive changes since the 
publication of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-semantics-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc> of 03 November 
2005 can be found in <specref ref="id-fs-revisions-log"/>.</p>

<p>Comments on this document are invited and should be made in W3C's
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla
system</loc> (instructions can be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
If access to that system is not feasible, you may send your comments
to the W3C XSLT/XPath/XQuery mailing list, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. It
will be very helpful if you include the string [FS] in the subject
line of your comment, whether made in Bugzilla or in email. Each
Bugzilla entry and email message should contain only one comment.
Archives of the comments and responses are available at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/
</loc>.</p>

<p>The <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML 
Query and XPath Test Suite</loc> is under development. Implementors are 
encouraged to run this test suite and report their results.
A <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/XQTSReport.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">preliminary XQuery Test 
Suite Result Summary</loc>
has been prepared that contains information submitted for several 
implementations.
</p>

<p>This document was produced by groups operating under the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 
February 2004 W3C Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2002/08/xmlquery-IPR-statements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public 
list of any patent disclosures</loc> made in connection with the 
deliverables of the XML Query Working Group and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/Disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
disclosures</loc> made in connection with the deliverables of the XSL 
Working Group; those pages also include instructions for disclosing a 
patent.  An individual who has actual knowledge of a patent which the 
individual believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc> with respect to this 
specification should disclose the information in accordance with <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 
6 of the W3C Patent Policy</loc>. </p>

  </status>

  <langusage>
    <language id="EN">English</language>
    <language id="ebnf">EBNF</language>
  </langusage>

  <revisiondesc>
    <p>JS January 2005. Major revision, aligning the Formal Semantics
    with decisions taken up to October 2004.</p>

    <p>JS April 22/2003: Revised version implementing decisions from
    the December 2002 and March 2003 f2f meetings.</p>

    <p>JS November 4/2002: Revised version implementing decisions from
    the September 2002 f2f meeting in North Carolina.</p>

    <p>JS July 26/2002: Revised version which implements most of the
    recent decisions of the XML Query and XSLT working groups. Notably
    implements semantics of element constructors.</p>

    <p>JS June 15/2002: Revised version which fixes many problems
    pointed out by reviewers. Revised version of Sections 4.3 and
    4.13.</p>

    <p>JS May 05/2002: New major revision which integrates named
    typing, mapping from XML Schema and the semantics of XPath
    2.0.</p>

    <p>JS March 22/2002: Most of the document is new. This is the
    basis for the new Formal Semantics of XPath 2.0 and XQuery
    1.0. The current version is up to date and aligned with the
    December 2002 XQuery 1.0 and XPath 2.0 working drafts.</p>
  
    <p>JS January 2002: Comprehensive editorial rewrite. Update to
    align the formal semantics with the new [XPath/XQuery] language
    document. Update to align the formal semantics with the new
    <bibref ref="xpath-functions"/> document. Update to align the formal semantics with
    XML Schema.</p>

    <p>DD August 2001: Comprehensive editorial rewrite.  Introduced
    new section <specref ref="sec_preliminaries"/> with new text and
    amalgamated material that was previously spread over the entire
    document.  Merged previously separate static, dynamic, and core
    rewrite sections into a single section.  Switched to the type
    system and syntax as defined Jérôme's presentation
    from the last face-to-face. Text is marked according to various
    properties:</p>
    <slist>
      <sitem role="newtext">Substantially new text.</sitem>
      <sitem role="iffy">Text that seems likely to be somewhat controversial.</sitem>
      <sitem role="missing">Areas where there is known to be missing text.</sitem>
      <sitem role="notdone">Old text, dropped into position, but not yet incorporated.</sitem>
    </slist>
  
    <p>MF June 06/2001: Added FS-Issue-0099</p>
  
    <p>PF, MF May 31/2001: Added FS-Issue-0094, FS-Issue-0095, FS
     Issue-0096, FS-Issue-0097, FS-Issue-0098.
    </p>
  
    <p>PF, MF May 28/2001: Large number of syntax errors and editorial
    fixes.</p>
  
    <p>JS, May 11/2001: Large number of syntax errors and editorial
    fixes. Added FS-Issue-0092.</p>
  
    <p>MF, Apr 30/2001: Resolved FS-Issue-0076.  Added FS-Issue-0089,
    FS-Issue-0090, FS-Issue-0091.</p>
  
    <p>JS, Apr 21/2001: Populated Section 6: [XPath/XQuery] Mapping to the
    Core</p>
  
    <p>PF, Apr 18/2001: (Re)introduced example on joins on unordered
    sequences in Section 2, a section on typing descendant-or-self in
    Section 4, and some new optimization rules for unordered().</p>
  
    <p>MF, Apr 04/2001: Syntax overhaul through Sec 4.8 : changed all
    examples to [XPath/XQuery] syntax.</p>
  
    <p>PF, Jan 30/2001: Simplified design for dealing with unordered
    collections along the lines presented at the F2F in Nov 2000.</p>
  
    <p>MF, Jan 15/2000: Addressed many issues raised by Micheal
    Brundage.Added FS-Issue-0081, FS-Issue-0082, FSIssue-0083, FS
    Issue-0084, FS-Issue-0085, FS-Issue-0086 and FS-Issue-0087.
    Resolved FS-Issue-0038, FS-Issue-0062, FS-Issue-0066, and FS
    Issue-0071.
    </p>
  
    <p>MF, Jan 5/2000: Added introductory paragraph on static and
    dynamic semantics and a section on dynamic/operational semantics.
    WARNING: This material has not been reviewed by Algebra editors
    yet.  Commented out unnecessary references.</p>
  
    <p>MF, Dec 19/2000: Addendum to FS-Issue-0011.  Added FS
    Issue-0081.</p>
  
    <p>MF, Dec 11/2000: Added sections on parent and dynamic and
    static casts, and on references and node identity.  Separated
    built-in functions and operators from core syntax and moved into
    own section.  Improved correspondence with data model (See
    accompanying release of data model document.)  Added Jerome's text
    on querying order.  Clarified that semantics of operators will be
    defined by joint task force.  Closed FS-Issue-0003; added FS
    Issue-0079.  Pending approval of group, can also close FS
    Issue-0062, FS-Issue-0071.</p>
  
    <p>PF, Dec 11/2000: Introduced unordered forests, implying changes
    to Section 2 (example), Section 3 (expressions and amended type
    system), and Section 4 (amended type equivalences and type
    inference rules). Resolved related issues, and raised new issue
    "unordered types".</p>
  
    <p>MF, Dec 9/2000: Added sections on PIs/comments and mixed
    content.  Added <code>nodes</code> and <code>string</code>
    built-in functions.  Changed <code>bag</code> operator to a
    built-in function.  Substituted ^ for &amp; for consistency.</p>
  
    <p>PF, Dec 4/2000: Minor editorial corrections for W3C pubrules,
    some clean-up of associated stylesheets</p>
  
    <p>PF, Nov 20/2000: Added abstract, status section from Paul, and
    Issue-0075 "Overloading user defined functions". Integrated Phil's
    motivation for the type system into the introduction.  Slightly
    edited (anonymized) some issues, and corrected some XML-stuff to
    generate valid HTML.</p>
  
    <p>MF, Nov 16/2000: Corrected many typos.  Added Issue-0074
    "Operational semantics for expressions".</p>
  
    <p>MF, Oct 23/2000: Major changes: Added support for attributes,
    namespaces, all-groups. Changed syntax (and semantics) of case,
    for, sort. Introduced new built-in and derived operators
    (children, data). Refined approach for wildcards. Introduced
    concrete syntax for special kinds of types (ContentType,
    ElementGroup, etc.). Adapted type inference rules to these
    changes, and introduced more specific type system for iteration by
    for. For more details see the resolutions around Sep/Oct 2000 in
    Issue list in Appendix B.</p>
  
    <p>PF, Oct 22/2000: Discarded obsolete issue clustering.  Resolved
    some issues, amended some issue descriptions, and added some
    issues, see Issues List in Appendix B for details.</p>
  
    <p>PF, MF: Oct 16/2000. WARNING. This document has not been
    thoroughly reviewed by the editorial team, and may thus contain a
    number of editorial inconsistencies.  The editorial team plans to
    correct them by about October 24. During this time the body of the
    document may undergo some changes. Nevertheless, the editorial
    team welcomes comments.</p>
  
    <p>PF, Oct 15/2000: Major changes: substantial update of the
    issues list. Resolved some, added some, see Issues list in
    Appendix B for details.</p>
  
    <p>PF, Aug 23/2000. Added Issue-0061 from Group 3 F2F in Redmond,
     added reference to I18N character doc.</p>
  
    <p>MF, Aug 11/2000: Proofread, typographical and editorial
    corrections</p>
  
    <p>PF, Aug 09/2000: Added more issues by LA-Team and I18N, added
    links to dtd, xml, and stylesheets.</p>
      
    <p>PF, Aug 05/2000: Major changes: Added Appendix on Issues, moved
    issues list in Discussion to Appendix on Issues.</p>
   
    <p>PF, July 21/2000: First version by Fernández,
    Siméon, Wadler. All copy-editing mistakes resulting from
    the transformation to the XML spec.dtd are due to me.</p>
  
    <p>Fernández, Siméon, Wadler: June/July 2000:
    Original Version</p>
  
    <p>Fankhauser, July 21 2000. Transformed original version to
    conform to XML spec.dtd</p>
  
    <p>Fankhauser, August 05 2000. Made various editorial corrections
    (in particular whitespace-magic for mixed content...). Compiled
    list of issues for appendix. Merged Discussion Section with list
    of issues.</p>
  
    <p>Fernandez, August 11 2000. Made various typographical
    corrections.</p>
  </revisiondesc>

</header>


  <body>
     <!-- *********************************************************************
      Section 1. Introduction
     ********************************************************************* -->

<div1 id="introduction">
  <head>はじめに</head>

  <p>この文書は XQuery 1.0 および XPath 2.0 の形式的意味を定義する。現在の文書は、XQuery 1.0 および XPath 2.0 言語をともに定義する一連の文書の一部である:</p>

  <ulist>
    <item>
      <p><bibref ref="xquery"/> は XQuery 1.0 言語を紹介し、その能力をユーザ中心の視点から定義している。また言語の構文を定義している。</p>
    </item>
    <item>
      <p><bibref ref="xpath20"/> は XPath 2.0 言語を紹介し、その能力をユーザ中心の視点から定義している。また言語の構文を定義している。</p>
    </item>
    <item>
      <p><bibref ref="xpath-functions"/> は [XPath/XQuery] 言語のために定義された関数や演算子を列挙し、それらの引数や返り値に要求される型を指定している。</p>
    </item>
    <item>
      <p><bibref ref="xpath-datamodel"/> は、[XPath/XQuery] で XML 文書の内容を表現するのに用いられるデータモデルを定義している。[XPath/XQuery] 言語は、このデータモデル上の演算によって形式的に定義される。</p>
    </item>
    <item>
      <p><bibref ref="xslt-xquery-serialization"/> は、[XPath/XQuery] データモデルの値がどのように XML に直列化されるかを指定する。</p>
    </item>
  </ulist>

  <p>[XPath/XQuery] で想定される範囲と目標は、W3C [XSL/XML Query] 作業部会の憲章や [XPath/XQuery] の要件 <bibref ref="xquery-requirements"/> で議論されている。</p>

  <p>この文書は、[XPath/XQuery] 仕様のそれぞれの式について、[XPath/XQuery] データモデルに基づいてその形式的意味を正確に与えることにより、[XPath/XQuery] の意味を定義している。この文書では、読者はすでに [XPath/XQuery] 言語についてよく知っていることを仮定している。この文書で定義する XPath 2.0 の形式的意味は、XPath 1.0 後方互換性ルールが有効でない場合のみである。</p>

  <p>[XPath/XQuery] の設計上の2つの重要な側面は、<emph>関数型</emph>であるということと、<emph>型付き</emph>であるということである。これらの2つの側面は、[XPath/XQuery] の形式的意味において重要な役割を果たしている。</p>

  <p><term>[XPath/XQuery] は関数型言語である</term>。[XPath/XQuery] は文ではなく式から構築されている。言語の各構成要素は (XQuery 問合せの前書きを除き) 1つの式であり、式は任意に構成することができる。1つの式の結果は別の式の入力として用いることができる。ただし、これができるのは、前者の式の結果の型が、それと組み合わせされる後者の式の入力型と互換である場合に限る。関数型言語のもう一つの特徴は、変数が常に値渡しされ、変数の値を副作用を通して変更することはできない、ということである。</p>

  <p><term>[XPath/XQuery] は型付き言語である</term>。型は、入力文書や出力文書を表現する1つ以上の XML Schema から輸入することができる。また [XPath/XQuery] 言語は、これらの型を基に演算を行うことができる。さらに、[XPath/XQuery] では<emph>静的型解析</emph>を支援する。静的型解析は、入力式の型に基づいて式の出力型を推論する。ユーザのために式の型を推論することに加え、静的型付けによって型エラーを早期に発見することが可能となり、またある種のクラスの最適化の基礎として用いることができる。[XPath/XQuery] の型システムは<bibref ref="xmlschema-1"/>のほとんどの機能をそのまま持っている。これには大域的・局所的な要素や属性の宣言、複合型や単純型の定義、名前付き・無名型、制限による導出、拡張、リストや共用体、置換グループ、ワイルドカード型などが含まれる。ただし、単純型に対する一意性制約や相 (facet) 制約は模倣しない。</p>

  <p>この文書の構成は以下の通りである。<specref ref="sec_preliminaries"/> では [XPath/XQuery] の形式的意味を定義するのに用いられる記法を紹介する。これらには [XPath/XQuery] データモデルでの値や XML Schema の型のための形式的記法が含まれる。次の3つの節、<specref ref="id-basics"/>, <specref ref="id-expressions"/>, および <specref ref="id-query-prolog"/> は、文書 <bibref ref="xquery"/> や <bibref ref="xpath20"/> の対応する節と同じ構造を持つ。これにより、読者は、個々の言語構成要素の形式的定義を素早く見つけることが可能となる。<specref ref="id-basics"/> では、[XPath/XQuery] の基本的概念に対する意味を定義する。<specref ref="id-expressions"/> では、[XPath/XQuery] のそれぞれの式の動的意味と静的意味を定義する。<specref ref="id-query-prolog"/> では、[XPath/XQuery] の前書きの意味を定義する。

<specref ref="sec_special_functions"/> では、<bibref ref="xpath-functions"/> にある様々な関数の静的意味を定義し、この文書で用いられるさまざまなサポート関数の動的意味や静的意味を与える。残りの節、<specref ref="sec_auxiliary_judgments"/> と <specref ref="sec_importing_schema"/>には、[XPath/XQuery] の形式的意味を支援する道具が含まれる。<specref ref="sec_auxiliary_judgments"/> では、データモデルと関連する形式的判断を定義する。これは型と型を関連づけ、妥当性検証の形式的意味を支援する。これらの判断は、<specref ref="id-expressions"/> で式の定義に用いられる。

最後に、<specref ref="sec_importing_schema"/> では、XML Schema 文書を [XPath/XQuery] 型システムに輸入する方法や XML Schema の型を [XPath/XQuery] 型システムに関連づける方法について指定する。</p>

  <div2 id="id-normativity"><head>規範と参考に関する節</head>

  <p>この文書では、言語処理のある面を<term>実装定義</term>あるいは<term>実装依存</term>と表現することがある。</p>

  <ulist>
    <item>
      <p><termdef id="dt-implementation-defined" term="implementation       defined"><term>実装定義</term>は、実装によって異なるかもしれないが、個々の実装について、実装者が指定をしなければならない面を示す。</termdef></p>
    </item>
    <item>
      <p><termdef id="dt-implementation-dependent" term="implementation       dependent"><term>実装依存</term>は、実装によって異なるかもしれず、この仕様または W3C のどの仕様でも指定されず、個々の実装について実装者が指定をする必要のない面を示す。</termdef></p>
    </item>
  </ulist>

  <p role="xpath">この仕様で<term>実装定義</term>あるいは<term>実装依存</term>と表されている言語の面は、XPath や XQuery が埋め込まれているホスト言語の仕様によってさらに制限がかけられてもよい。</p>

  <p>この文書には、[XPath/XQuery] の規範的な静的意味が含まれる。<specref ref="id-basics"/>, <specref ref="id-expressions"/>, <specref ref="id-query-prolog"/>, および <specref ref="sec_special_functions"/> にある静的意味ルールは規範的である。<specref ref="static_context"/> は規範的である。なぜならこれにより静的型付けルールで用いられる静的文脈が定義されるからである。<specref ref="sec_auxiliary_judgments"/> は規範的である。なぜなら、SequenceType の照合を定義するために必要な判断がすべて含まれているからである。</p>

  <p>[XPath/XQuery] の動的意味は <bibref ref="xquery"/> および <bibref ref="xpath20"/> で規範的に定義されている。この文書では、<specref ref="id-basics"/>, <specref ref="id-expressions"/>, および <specref ref="id-query-prolog"/> 中の動的意味ルール、例、"Note" とラベル付けされた項目は説明の目的で用意されており、参考である。</p>

  <p><specref ref="sec_importing_schema"/> で与えられる XML Schema から XQuery 型システムへの対応ルール、および <specref ref="sec_validation_judgments"/> にある XML Schema 検証の形式的意味は参考であり、XML Schema のどの機能も制御しない。</p>
</div2>

</div1>


     <!-- ===================================================================== -->
<!--  Section 2. Preliminaries                                             -->
<!-- ===================================================================== -->

<div1 id="sec_preliminaries">
  <head>準備</head>

  <p>この節では、形式的意味を理解するのに必要な背景知識を用意し、用いられる記法を紹介する。また、他の文書との関連についても説明する。</p>

  <div2 id="sec_intro">
    <head>形式的意味への導入</head>

    <p><term>なぜ形式的意味が必要なのか?</term> 形式的意味の目的は、[XPath/XQuery] の仕様 (<bibref ref="xquery"/> および <bibref ref="xpath20"/>)を補完することである。これは [XPath/XQuery] 式の意味を数学的に厳密な方法で定義することで行われる。</p>

    <p>厳密な形式的意味により、英語で書かれた仕様で意図された意味が明確になり、重箱の隅のような場合が残っていないことが保証され、実装のための参照が提供される。</p>

    <p><term>なぜ形式的な記法を用いるのか?</term> 厳密さを得るために、式、XML の値、XML Schema の型といった [XPath/XQuery] のオブジェクトを表現するのに形式的な記法を用い、これらのオブジェクトの間の関連を、言語の意味を反映するように体系的に定義する。特に、動的意味は [XPath/XQuery] 式を、それを評価して得られる XML の値に関連づける。また静的意味は [XPath/XQuery] 式を、その式に対して推論される XML Schema の型に関連づける。</p>

    <p>形式的意味では、[XPath/XQuery] 式、XML の値、XML Schema の型の間の関連を定義するのに、さまざまな種類の形式的な記法を用いる。この節では、判断、推論ルール、照合ルールの記法を紹介する。また、環境の記法も紹介する。これは動的文脈や静的文脈を実装する。これらの記法をすでに知っている読者は、この節を飛ばし、<specref ref="sec_values"/> から続けることができる。</p>

    <!-- ***************** Grammar productions    ****** -->

    <div3 id="sec_grammar_notations">
      <head>文法規則からの記法</head>

      <p>文法規則は、形式的意味で操作される<quote>object</quote> (値、型、[XPath/XQuery] 式など) を記述するのに用いる。形式的意味では、いくつかの種類の文法規則を用いる: [XPath/XQuery] の文法そのものに由来する規則、この文書を通して用いられる XQuery Core と呼ばれる [XPath/XQuery] 言語の部分集合のための規則、その他 XQuery の型システムのような形式的仕様のためにのみ用いられる規則である。</p>

      <p>XQuery の文法規則は XQuery 言語と式を記述する。XQuery の規則は番号によって識別されている。この番号は <bibref ref="xquery"/> 中での番号と一致しており、<quote>(XQuery)</quote> という目印が付けられている。例えば、以下の規則は XQuery の FLWOR 式を記述している。</p>
        
      <scrap headstyle="show">
        <head>[For/FLWOR] 式</head>
        <prod num="33 (XQuery)" id="noid_N10426.doc-xquery-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LetClause" xlink:type="simple">LetClause</nt>)+  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-WhereClause" xlink:type="simple">WhereClause</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt>?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
      
      <p>この文書の目的では、XQuery 1.0 と XPath 2.0 の文法の違いは概ね問題にならない。デフォルトでは、この文書は XQuery 1.0 の文法規則を用いる。XPath 2.0 の文法と XQuery 1.0 の文法と異なるときはいつでも、対応する XPath 2.0 の規則も与える。XPath の規則は番号によって識別される。この番号は <bibref ref="xpath20"/> の番号と等しく、<quote>(XPath)</quote> という目印が付けられている。例えば、以下の規則は XPath の式を記述している。</p>

      <scrap headstyle="show">
        <head>[For/FLWOR] 式</head>
        <prod num="4 (XPath)" id="noid_N1043D.doc-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
      
      <p>XQuery Core 文法規則は XQuery Core を記述する。Core の文法は<specref ref="sec_core"/>で与えられる。Core の生成規則は番号によって識別される。この番号は <specref ref="sec_core"/> の番号と等しく、<quote>(Core)</quote> という目印が付けられている。例えば、以下の規則は XQuery Core でのより単純な <quote>FLWOR</quote> 式の形式を記述している。</p>

      <scrap headstyle="show">
        <head>核 FLWOR 式</head>
        <prod num="24 (Core)" id="noid_N10458.doc-core-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-LetClause" xlink:type="simple">LetClause</nt>)  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
      
      <p>形式的意味では <quote>objects</quote> (値、型、式など) のうち、<bibref ref="xquery"/> 文書中に文法規則が存在しないものを扱う。これらの場合では、詳細な文法規則が示される。特に、<bibref ref="xpath-datamodel"/> での値を記述するため、および [XPath/XQuery] 型システムを記述するために、新たな規則が追加されて用いられる。形式的意味に関する規則は番号で識別され、<quote>(Formal)</quote> という目印が付けられる。例えば、以下の規則は [XPath/XQuery] 型システムでの大域型定義を記述している。</p>
      
      <scrap headstyle="show">
        <head>型定義</head>
      
        <prod num="39 (Formal)" id="noid_N10479.doc-fs-Definition"><lhs>Definition</lhs><rhs>("define"  "element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementName" xlink:type="simple">ElementName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptSubstitution" xlink:type="simple">OptSubstitution</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptNillable" xlink:type="simple">OptNillable</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeName" xlink:type="simple">AttributeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeDerivation" xlink:type="simple">TypeDerivation</nt>)</rhs></prod>
      </scrap>

      <p>注意として、形式的意味に固有の規則 (すなわち <quote>(Formal)</quote> と目印の付けられた規則) は [XPath/XQuery] の一部ではない。これらはユーザからは利用できず、言語の意味を定義する過程でのみ用いられる。</p>

      <p>この文書の広範囲に渡って、文法の非終端記号を用いて、判断中のオブジェクトを表現する (次節を見よ)。便宜上、判断に用いられる非終端記号には、適切な文法規則へのリンクが張られている。</p>
    </div3>

    <!-- ***************** Judgments              ****** -->

    <div3 id="sec_judgments">
      <head>判断に対する記法</head>

      <p>形式的仕様を構成する基本ブロックは<emph>判断</emph>と呼ばれる。判断は、ある性質が成立するかどうかを表している。</p>

      <p>例えば:</p>

      <smnotation>
        <p>判断</p>

        <display>
          <clause>
          <expression><emph>Object</emph> <term>は正の整数である</term></expression>
          </clause>
        </display>

        <p>は、オブジェクト <emph>Object</emph> が正の整数であるとき、成立する。</p>
      </smnotation>

      <p>判断は成立する (真の場合) か成立しない (偽の場合) かのいずれかである。例えば、'1 <term>は正の整数である</term>' は成立する。一方 '-1 <term>は正の整数である</term>' は成立しない。</p>

      <smnotation>
        <p>別の判断の例を2つ示す。</p>

        <p>判断</p>

        <display>
          <clause>
          <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
          </clause>
        </display>

        <p>は、式 <emph>Expr</emph> が値 <a href="#doc-fs-Value"><emph>Value</emph></a> を産出する (または、評価の結果その値になる)とき、成立する。</p>

        <p>判断</p>

        <display>
        <clause>
          <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
        </clause>
        </display>

        <p>は、式 <emph>Expr</emph> が型 <a href="#doc-fs-Type"><emph>Type</emph></a> を持つとき、成立する。</p>

        <p>この文書で用いられる他の判断の多くは、その意味を反映するように意図された英語の短文である。例えば、判断</p>

        <display>
        <clause>
          <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term> は主要 </term></a> <emph>PrincipalNodeKind</emph> <term>を持つ</term></expression>
        </clause>
        </display>

        <p>は、<emph>PrincipalNodeKind</emph> が軸 <emph>Axis</emph> の主要節点種類であるときに成立する。</p>
      </smnotation>

      <p>判断は <emph>記号</emph> と <emph>パターン</emph> を含むことができる。</p>

      <p>記号は純粋に構文的であり、その判断自身を書くのに用いられる。記号は判断の意味を反映するように選択され、太字のフォントで書かれる。例えば、'<term>は正の整数</term>'、'<term>=&gt;</term>'、'<term>:</term>' は記号である。このうち、2つ目と3つ目はそれぞれ<quote>を産出する</quote>、<quote>は型〜を持つ</quote>と読むべきである。</p>

      <p>パターンはオブジェクトを表現するのに用いられる。このオブジェクトは与えられた文法規則から構成される。パターンでは、通常、斜字体の語が文法の非終端記号に対応する。これら非終端記号の名前は意味を持ち、<quote>object</quote> (値、型、式など) のうち正当にその非終端記号に代入できるものにのみ実体化してもよい。例えば、'<emph>Expr</emph>' は [XPath/XQuery] 式を意味するパターン、'<emph>Expr</emph><subscript>1</subscript> + <emph>Expr</emph><subscript>2</subscript>' は加算式を表すパターン、'element a {
      <a href="#doc-fs-Value"><emph>Value</emph></a> }' は [XPath/XQuery] データモデルの値のうち 'a' 要素であるものを表すパターンである。</p>

      <p>パターン中の非終端記号は、同じ種類のパターンの別のインスタンスと区別するために添字を付けてもよい (例えば <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>)。場合によっては、パターン中の非終端記号は、正確にその非終端記号の名前ではなく、それに基づいたような名前を持っていてもよい。例えば、<a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> は型名を意味するパターンであり、<a href="#doc-fs-TypeName"><emph>TypeName</emph></a> あるいは <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> と同じである。この使い方には制限があり、ある種の推論ルールの可読性を改善する目的のみで出現する。</p>

      <p>判断を<emph>実体化</emph>するとき、それぞれの判断は適切な種類の<quote>object</quote> (値、型、式など) に実体化されなければならない。例えば、'3 <term>=&gt;</term> 3' と '$x+0 <term>=&gt;</term>' はいずれも判断 '<emph>Expr</emph>
      <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>' のインスタンスである。注意点として、1つ目の判断では '3' は式 '3' (記号 <term>=&gt;</term> の左辺) と値 '3' (記号 <term>=&gt;</term> の右辺) のいずれにも一致している。</p>

      <p id="jd_not">場合によっては、ある判断が満たされ<emph>ない</emph>という事実を推論ルールで用いる必要がある。<expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Judgment</emph>)</expression>が満たされるのは <emph>Judgment</emph> が満たされない場合、かつそのときに限る。</p>

      <p id="jd_isin">場合によっては、あらかじめ決定された値の有限集合中の値でパターンを実体化するかもしれない。取りうる値の集合を判断 <a href="#jd_isin" class="judgment"><term>in</term></a> を用いて書いてもよい。例えば、判断</p>

        <display>
          <clause>
          <expression><emph>Color</emph> <a href="#jd_isin" class="judgment"><term>in</term></a> {
          <term>blue</term>, <term>green</term> }
          </expression>
          </clause>
        </display>

      <p>は、パターン <emph>Color</emph> が値 <emph>blue</emph> か値 <emph>green</emph> のいずれかを持つとき、満たされる。</p>

      <p>場合によっては、判断は、記号 <quote>=</quote> を用いて、ある値が別の値に等しいことを表したり、パターンがある値に等しいことを表したりするかもしれない。例えば、判断</p>

        <display>
          <clause>
          <expression><emph>Color</emph> = <term>blue</term>
          </expression>
          </clause>
        </display>

      <p>は、パターン <emph>Color</emph> が値 <emph>blue</emph> を持つとき、満たされる。</p>

      <p>この仕様で用いられるすべての判断への索引は <specref ref="sec_indexes"/> で用意されている。</p>
    </div3>

    <!-- ***************** Environments              ****** -->

    <div3 id="sec_environments">
      <head>環境に対する記法</head>

      <p id="xq_environment">環境構成要素は、記号 (例えば、関数名や変数名) を <quote>object</quote> (例えば、関数の本体、型、値) に対応づける辞書である。環境構成要素中の情報は、アクセスすることも更新することもできる。</p>

      <p><quote>envComp</quote> が環境構成要素であるとき、<quote>envComp(<emph>symbol</emph>)</quote> は <emph>symbol</emph> が対応づけられる <quote>object</quote> を表す。この記法は、意図的に、関数の適用と似た形になっている。というのは、環境構成要素は、引数 <emph>symbol</emph> から、<emph>symbol</emph> が対応づけられる <quote>object</quote> への関数とみなすことができるからである。</p>

      <p>この文書では、関連する環境構成要素をグループ化した<emph>環境</emph>を用いる。環境 <quote>env</quote> に環境構成要素 <quote>envComp</quote> が含まれるとき、この環境構成要素を <quote>env.envComp</quote> と表す。この環境構成要素中で <emph>symbol</emph> が対応づけられる値を <quote><expression>env.envComp(<emph>symbol</emph>)</expression></quote> と表す。</p>

      <p>形式的意味では主に2つの環境が用いられる: 動的環境 (<a href="#xq_dyn_env_def" class="env">dynEnv</a>) と静的環境 (<a href="#xq_stat_env_def" class="env">statEnv</a>) である。前者は [XPath/XQuery] の動的文脈をモデル化している。後者は [XPath/XQuery] の静的文脈をモデル化している。これらはいずれも <specref ref="sec_context"/> で定義される。</p>

      <p>例えば、<a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> は変数を値に対応づける動的環境構成要素を表す。また、<a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) は動的文脈中での変数 <emph>Variable</emph> の値を表す。</p>

      <p>判断の中では、その判断が計算される文脈のある部分を取り出すのに環境が用いられる。また、多くの判断の計算では、ある種の環境が与えられるものと仮定されている。この <emph>仮定</emph> を、判断の前に <quote><expression>env</expression> |-</quote> を付けることで表す。記号 <quote>|-</quote> は <quote>turnstile</quote> と呼ばれ、ほとんどすべての推論ルールで用いられる。</p>

      <p>例えば、判断</p>

      <display>
        <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression>
      	    <emph>Expr</emph> <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
        </clause>
      </display>

      <p>は次のように読む: 動的環境 <a href="#xq_dyn_env_def" class="env">dynEnv</a> を仮定するとき、式 <emph>Expr</emph> は値 <a href="#doc-fs-Value"><emph>Value</emph></a> を産出する。</p>

      <p>環境は<emph>更新</emph>することができる。これには次の記法を用いる:</p>

      <ulist>
        <item>
          <p>
            <quote><expression><update><environment>env.envComp</environment>
            <expression><emph>symbol</emph> =&gt;
            <emph>object</emph></expression></update></expression></quote>
            これは、<emph>env</emph> と等しい新たな環境を表す。ただし、環境構成要素 <emph>envComp</emph> のみ、<emph>symbol</emph> が <emph>object</emph> と対応づけられるように更新されている。記法 <expression><emph>symbol</emph> =&gt;
            <emph>object</emph></expression> は、新しい環境中で <emph>symbol</emph> が <emph>object</emph> に対応づけられることを示す。</p>
        </item>
        <item>
          <p>環境構成要素が定数値1つしか含まない場合 (例えば順序付けモード。これは ordered か unordered のいずれかの可能性しかない)、その値を設定するのに以下の記法を用いる。
            <quote><expression><update>
                  <environment>env.envComp</environment>
                  <expression>
                    <emph>object</emph>
                  </expression>
                </update></expression></quote>.</p>
        </item>
        <item>
          <p>以下の略記も認められる:
             <quote><expression><update>
                  <environment>env.envComp</environment>
                  <expression>
                    <emph>symbol</emph><subscript>1</subscript>
                    =&gt;
                    <emph>object</emph><subscript>1</subscript>
                    ; ... ;
                    <emph>symbol</emph><subscript>n</subscript>
                    =&gt;
                    <emph>object</emph><subscript>n</subscript>
                  </expression>
                </update></expression></quote> このとき、新しい環境中で各記号は対応するオブジェクトに対応づけられる。</p>

            <p>この記法は次のような入れ子の更新と等価である:
            <quote>
              <expression>
                (env + envComp(
                <emph>symbol</emph><subscript>1</subscript>
                =&gt;
                <emph>object</emph><subscript>1</subscript>)
                + 
                ...
                ) + env(<emph>symbol</emph><subscript>n</subscript>
                =&gt;
                <emph>object</emph><subscript>n</subscript>)</expression></quote>.
          </p>
        </item>
      </ulist>

      <p>ある環境を更新すると、元の環境の複製が生成され、その環境中にすでに存在する束縛のうち同じ名前や同じ構成要素に対するものが上書きされる。環境の更新は、記号 (変数、名前空間接頭辞など) の<emph>有効範囲</emph>を獲得するのに用いられる。例えば、式</p>

<eg xml:space="preserve">
  let $x := 1 return
  let $x := $x + 2 return
  $x - 3
</eg>

      <p>では、各 let 式で新しい変数が新しい値に束縛され、動的文脈が変更される。別の文脈はそれぞれ別の環境によって表現される。元の環境では、式 <code>1</code> が評価されるが、変数 <code>$x</code> に対する束縛は何も含まれない。この環境は、最初に変数 <code>$x</code> が値 <code>1</code> に束縛されるときに更新され、この環境が式 <code>$x + 2</code> の評価に用いられる。次に、変数 <code>$x</code> が値 <code>3</code> に束縛されるときに、2度目の更新が起こり、この環境が式 <code>$x - 3</code> の評価に用いられる。</p>

      <p>また注意すべき点として、環境からエントリを削除する方法はない。これは決して必要とはならない。なぜなら、環境を更新すると、事実上、元の環境の複製が新たに生成されて拡張され、更新された複製の有効範囲に入っている場所であっても元の環境にアクセスすることは引き続き可能であるからである。</p>

    </div3>

    <!-- ***************** Inference rules ****** -->

    <div3 id="sec_inference">
      <head>推論規則に対する記法</head>

      <p>推論規則は、ある判断が満たされるかどうかをどのように推論するかを指定するのに用いられる。推論規則は、判断の間の論理的関係を表現し、複雑な判断をどのようにしてより簡単な前提判断から結論づけることができるのかを述べる。</p>

      <p>論理推論ルールは<emph>前提</emph>と<emph>結論</emph>の集まりとして記述される。前提と推論は、以下のように、それぞれ区切り線の上と下に書かれる:</p>

      <infergr>
    	<infer>
    	 <prejudge>
    	  <clause>
    	   <expression>
    	       <emph>前提</emph><subscript>1</subscript>
    	       ...
    	       <emph>前提</emph><subscript>n</subscript>
    	   </expression>
    	  </clause>
    	 </prejudge>
    	 <postjudge>
    	  <clause>
    	   <expression>
    	       <emph>結論</emph>
    	   </expression>
    	  </clause>
    	 </postjudge>
    	</infer>
      </infergr>

      <p>前提と結論はすべて判断である。論理的な視点からは、推論ルールは演繹であり、前提が満たさされれば結論も満たされる。この意味で、上の推論ルールは以下のような論理文と同じような意味を持っている。</p>

      <p>IF <emph>前提</emph><subscript>1</subscript></p>
      <p>AND ...</p>
      <p>AND <emph>前提</emph><subscript>n</subscript></p>
      <p>THEN <emph>結論</emph></p>

      <p>以下に、推論ルールの簡単な例を示す。ここでは、先に判断の例として挙げた '<emph>Expr</emph>
      <term>=&gt;</term> <a href="#doc-fs-Value"><emph>Value</emph></a>' のインスタンスを用いている:</p>

      <infergr>
    	<infer>
    	 <prejudge>
    	  <clause>
    	   <expression>
    	       $x <term>=&gt;</term> 0
    	   </expression>
    	  </clause>
    	  <clause>
    	   <expression>
    	       3 <term>=&gt;</term> 3
    	   </expression>
    	  </clause>
    	 </prejudge>
    	 <postjudge>
    	  <clause>
    	    <expression>
    	       $x + 3 <term>=&gt;</term> 3
    	    </expression>
    	  </clause>
    	 </postjudge>
    	</infer>
      </infergr>

      <p>この推論ルールは以下の性質を表現している: <emph>もし</emph>変数式 '$x' が値 '0' を産出し、<emph>かつ</emph>リテラル式 '3' が値 '3' を産出するならば、<emph>then</emph> 式 '$x + 3' は値 '3' を産出する。</p>

      <p>推論ルールは線の上の前提を持たなくてもよい。この場合、線の下の式は常に満たされることを意味する。例えば:</p>

      <infergr>
    	<infer>
    	 <postjudge>
    	  <clause>
    	    <expression>
    	       3 <term>=&gt;</term> 3 
    	    </expression>
    	  </clause>
    	 </postjudge>
    	</infer>
      </infergr>

      <p>この推論ルールは次の性質を表現している: リテラル式 '3' を評価すると、常に値 '3' が産出される。</p>

      <p>上の2つのルールは特定の式や値について表現していたが、通常、ルールはより抽象的である。すなわち、判断は完全には実体化されない。以下に示すルールは、整数値 <emph>Integer</emph> を産出する任意の変数 $<emph>VarName</emph> について、'0' を加えても同じ整数値が産出されると言っている:</p>

      <infergr>
        <infer>
         <prejudge>
           <clause>
             <expression>
                $<emph>VarName</emph> <term>=&gt;</term> <emph>Integer</emph>
             </expression>
           </clause>
         </prejudge>
         <postjudge>
          <clause>
            <expression>
              $<emph>VarName</emph> + 0 <term>=&gt;</term> <emph>Integer</emph>
            </expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>推論ルール中のあるパターンの出現はそれぞれ、ルール全体で同じ <quote>object</quote> によって実体化されなければならない。この意味するところは、ルールの特定の実体化の文脈では、$<emph>VarName</emph> の最初 (2番目など) の出現に束縛される値という代わりに、<quote>$<emph>VarName</emph> の値</quote> と言っても構わない、ということである。</p>

      <p>以下はルールの例であり、この文書中、後で出現する。</p>

      <infergr>
       <infer>
        <prejudge>
         <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>Expr</emph><subscript>1</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
         </clause>
         <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
         </clause>
        </prejudge>
        <postjudge>
         <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
         </clause>
        </postjudge>
       </infer>
      </infergr>

      <p>このルールは次のように読む: 2つの式 <emph>Expr</emph><subscript>1</subscript> と <emph>Expr</emph><subscript>2</subscript> が静的型 <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> と <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> を持つと分かっているならば (線の上の2つの前提)、列式 <quote><emph>Expr</emph><subscript>1</subscript> ,
      <emph>Expr</emph><subscript>2</subscript></quote> は静的型 <quote><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></quote> を持つ。これは型 <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> と <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> の列である。注意すべき点として、この推論ルールは静的環境を変更しない。</p>

      <p>以下のルールは <quote>let</quote> 式の静的意味を定義している。元の静的環境の varType 構成要素が更新されることで、新しい変数の束縛が獲得されている。</p>

      <infergr>
       <infer>
    	<prejudge>
         <multiclause>
    	 <clause>
    	  <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
    	  <expression>
    		  <term>var の </term><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>が</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><term>に展開される</term>
    	   </expression>
    	 </clause>
         </multiclause>
         <multiclause>
    	 <clause>
    	  <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
    	  <expression>
    		  <emph>Expr</emph><subscript>1</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
    	   </expression>
    	 </clause>
    	 <clause>
    		<environment>
    		  <update>
    		    <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
    		    <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
    		  </update>
    		</environment>
    		<expression>
    		    <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
    	  </expression>
    	 </clause>
         </multiclause>
    	</prejudge>
    	<postjudge>
    	 <clause>
    	  <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
    	  <expression>
    		  <code>let</code>
    		  <code>$</code><emph>VarName</emph> := <emph>Expr</emph><subscript>1</subscript>
    		  <code>return</code>
    		  <emph>Expr</emph><subscript>2</subscript> <term>:</term> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
    	  </expression>
    	 </clause>
    	</postjudge>
       </infer>
      </infergr>

      <p>このルールは以下のように読む: まず、変数は QName であるので、最初に展開済 QName に展開される。次に、<quote>let</quote> の入力式 <emph>Expr</emph><subscript>1</subscript> の型 <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> が計算される。次いで <quote>let</quote> の変数、すなわち展開済 QName が <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>、型が <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> である変数が静的環境 <a href="#xq_stat_env_def" class="env">statEnv</a> の varType 構成要素に追加される。最後に、<emph>Expr</emph><subscript>2</subscript> の型 <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> が新しい環境で計算される。</p>

      <p>場合によっては、省略記号を推論ルール中で用いて、任意個の判断を表してもよい。このような場合、パターンのいくつかは添字の形でインデックスを持っていてもよい。同じルール中で同じインデックスが何度も用いられると、それぞれの場合で判断の番号は同じ出なければならない。例えば、以下のルールは任意個の式 <emph>Expr</emph><subscript>1</subscript> から <emph>Expr</emph><subscript>n</subscript> について成立する。このとき、型は <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> から      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> であり、個数は同じである。</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <term>func の</term><expression><emph>QName</emph>
                  <term>が</term> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression><a href="#jd_func_qname_expands_to" class="judgment"><term>に展開される</term></a>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,...,<emph>Expr</emph><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>この推論ルールは、1番目のルールが1つの判断を持つ、2番目が2つの判断、というような無限個のルールと等価である。例えば、上のルールは、以下のルールのいずれか1つが満たされるとき、かつそのときに限り満たされる。</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <term>func の</term><expression><emph>QName</emph>
                  <term>が</term> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression><a href="#jd_func_qname_expands_to" class="judgment"><term>に展開される</term></a>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>または</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <term>func の</term><expression><emph>QName</emph>
                  <term>が</term> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression><a href="#jd_func_qname_expands_to" class="judgment"><term>に展開される</term></a>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>など。</p>

        <p>省略記号が使われるとき、インデックスの値は常に 1 から任意の数 n までの範囲内である。</p>
    </div3>

    <div3 id="sec_together">
      <head>一緒に置く</head>

      <p>各々の推論ルールは、単独ではある判断に対する意味の部分を記述している。推論ルールは、一緒に用いることで、特定の判断が満たされるかどうかを記述するのに用いることのできる推論を表す。</p>

      <p>ある判断に対して、すでに真と分かっている前提に基づいた推論の列を適用することで、その判断が真であると推論できるならば、その推論は成功である。多くの場合、推論は、中間的な判断を証明し、すでに成功した推論ルールを適用することである判断から次の判断への結果を続けて行くことで、継続していく。</p>

      <p>このような推論は、静的型解析を記述する場合にも動的評価を記述する場合にも用いることのできる機構である。特に、静的型付けを行うということは、ある式 <emph>Expr</emph> に対して以下の判断が満たされるかどうかを証明することである。</p>

      <display>
      <clause>
        <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
      </clause>
      </display>

      <p>この判断がある型 <a href="#doc-fs-Type"><emph>Type</emph></a> に対して満たされるならば、この型が、その式に対する可能な静的型である。この判断を満たす型が存在しないならば、静的型付けは失敗し、ユーザに対して静的型エラーが返される。</p>

      <p>以下の式を考えてみよう。</p>

<eg xml:space="preserve">
  fn:count((1,2,3))
</eg>

      <p>この文書の以下の部分にある、式のための静的型付けルールを用いると、以下の推論を経て、この式の型は <code>xs:integer</code> であると演繹することができる。</p>

<eg xml:space="preserve">
  statEnv |- 1 : xs:integer  (from typing of literals)
  statEnv |- 2 : xs:integer  (from typing of literals)
  --------------------------------------------------- (sequence)
    statEnv |- 1,2 : xs:integer, xs:integer
    statEnv |- 3 : xs:integer
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer

    declare function fn:count($x as item()*) as xs:integer
    statEnv |- xs:integer,xs:integer,xs:integer &lt;: item*
    ---------------------------------------------------------- (function call)
    statEnv |- fn:count((1,2,3)) : xs:integer
</eg>

   <p>一方、つぎの式を考えてみよう。</p>

<eg xml:space="preserve">
  fn:nilled((1,2,3))
</eg>

   <p>この文書の以下の部分にある、式のための静的型付けルールを用いると、以下の場所までは推論ルールを適用することができる。</p>

<eg xml:space="preserve">
    ....
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer
</eg>

      <p>しかし、<code>fn:nilled((1,2,3))</code> の型を推論することのできるルールはない。なぜなら関数呼び出しの静的型付けルールは、関数の引数の型が期待された型の部分型である場合にのみ満たされるからである。しかし、ここで <code>(xs:integer,xs:integer,xs:integer)</code> は節点型ではない。節点型が関数 <code>fn:nilled</code> に対して期待される型である。</p>

      <p>注意すべき点として、場合によっては、環境を適切に変更することによってのみ推論を進めることができる。例えば、以下の式を考える。</p>

<eg xml:space="preserve">
  let $x := 1 return ($x,$x)
</eg>

      <p>この文書の以下の部分にある、式のための静的型付けルールを用いると、以下の推論により、この式は <code>(xs:integer,xs:integer)</code> 型であると演繹できる。</p>

<eg xml:space="preserve">
statEnv0.varType = ()

  -------------------------- (literal)
  statEnv0 |- 1 : xs:integer

statEnv1 = statEnv0 + varType($x =&gt; xs:integer)

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     ------------------------------------------- (sequence)
     statEnv1 |- ($x,$x) : xs:integer,xs:integer

  -------------------------------------------------------------- (let)
  statEnv0 |- let $x := 1 return ($x,$x) : xs:integer,xs:integer
</eg>

      <p>この例は、個々の部分式に対してそれぞれのルールがどのように適用されるか、また対応する文脈情報を管理するのに環境がどのように用いられるか、を示している。</p>
    </div3>

  </div2>

  <div2 id="sec_namespaces">
    <head>URI, 名前空間, 接頭辞</head>

    <p>形式的意味では、基礎 URI に基づく相対 URI の補正については形式的に指定しない。この文書中で用いられるすべての URI は絶対 URI であると仮定している。</p>

    <p>形式的意味では以下の名前空間接頭辞を用いる。</p>

    <ulist>
      <item><p><code>fn:</code>。文書<bibref ref="xpath-functions"/>に由来する関数や演算子に対して。</p></item>
      <item><p><code>xs:</code>。XML Schema の構成要素や組込み型に対して。</p></item>
    </ulist>

    <p>これらの接頭辞は適切な URI に束縛されていると仮定する。</p>

    <p>これに加え、形式的意味では、仕様の目的で、以下の特別な接頭辞を用いる。</p>

    <ulist>
      <item><p><emph>dm:</emph>。<bibref ref="xpath-datamodel"/>のアクセサに対して。</p></item>
      <item><p><emph>op:</emph>。<bibref ref="xpath-functions"/>の演算子に対して。</p></item>
      <item><p><emph>fs:</emph>。形式的意味で定義されている関数や型に対して。</p></item>
    </ulist>

    <p>これらの接頭辞は、対応する関数や変数や型が抽象的であることを強調するために、常に斜字体で表される: これらの関数や変数や型は [XPath/XQuery] からはアクセスされないし、アクセスすることはできない。これらの特別な接頭辞にはいずれも明示的な URI は与えられないが、名前空間の解決のために URI を持っているかのように振る舞う。</p>
  </div2>

  <div2 id="sec_values">
    <head>XML の値</head>

    <p>[XPath/XQuery] 言語は [XPath/XQuery] データモデルの値上で定義される。[XPath/XQuery] データモデルは <bibref ref="xpath-datamodel"/> で規範的に定義されている。ここでは、推論ルール中で値を記述したり操作したりするために、この文書で用いられる形式的記法を定義する。形式的な値は仕様の目的でのみ用いられ、[XPath/XQuery] のユーザが目にすることはない。</p>

    <p>この節では、形式的な値の文法を与え、対応するデータモデルの性質の概要を添える。この文書の文脈では、<bibref ref="xpath-datamodel"/> 中で指定される値に関する制約はすべて満たされていると仮定する。</p>

    <div3 id="sec_data_model_overview">
      <head>形式的値</head>

      <p>値は0個以上の項目の列である。項目は原子値または節点のいずれかである。</p>

      <p>原子値は、ある原子型の値空間中の値であり、その原子型の名前でラベル付けされている。原子型は XML Schema <bibref ref="xmlschema-2"/> に基づく基本原子型または導出原子型のいずれかであり、<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> または <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> である。</p>

      <p>節点は要素節点、属性節点、文書節点、テキスト節点、コメント節点、処理命令節点のいずれかである。</p>

      <p>要素節点は<xtermref spec="XQ" ref="dt-type-annotation"/>を持ち、複合値もしくは単純値を含む。属性節点は<xtermref spec="XQ" ref="dt-type-annotation"/>を持ち、単純値を含む。テキスト節点は常に型<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>の文字列値1つを含む。したがって、テキスト節点の形式的記法では、対応する型注釈は省略される。文書節点は型注釈を持たず、要素節点、テキスト節点、コメント節点、処理命令節点からなる列を含む。</p>

      <p>単純値は原子値の列である。</p>

      <p>複合値は、属性節点の列に続いて、要素節点、テキスト節点、コメント節点、処理命令節点からなる列がくるようなものである。</p>

      <p><xtermref spec="XQ" ref="dt-type-annotation"/>は宣言された型の <emph>QName</emph> か、無名型である。無名型は XML Schema の型のうちスキーマの作者が名前を用意しなかったものに対応する。無名型はユーザには見えないが、スキーマ妥当性検証で生成され、データモデル中の節点を注釈付けするのに用いられる。利便性のため、形式的意味の接頭辞 <emph>fs:</emph> を用いて無名型の名前を表す: <emph>fs:</emph>anon<subscript>0</subscript>,
      <emph>fs:</emph>anon<subscript>1</subscript> といった具合である。</p>

      <p>形式的値は以下の文法で定義される。</p>

      <scrap headstyle="show">
        <head>値</head>

        <prod num="7 (Formal)" id="doc-fs-Value"><lhs>Value</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Item" xlink:type="simple">Item</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Value" xlink:type="simple">Value</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Value" xlink:type="simple">Value</nt>)<br/>|  ("("  ")")</rhs></prod>
        <prod num="21 (Formal)" id="doc-fs-Item"><lhs>Item</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-NodeValue" xlink:type="simple">NodeValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicValue" xlink:type="simple">AtomicValue</nt></rhs></prod>
        <prod num="22 (Formal)" id="doc-fs-AtomicValue"><lhs>AtomicValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicValueContent" xlink:type="simple">AtomicValueContent</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?</rhs></prod>
        <prod num="1 (Formal)" id="doc-fs-AtomicValueContent"><lhs>AtomicValueContent</lhs><rhs>String<br/>|  Boolean<br/>|  Decimal<br/>|  Float<br/>|  Double<br/>|  Duration<br/>|  DateTime<br/>|  Time<br/>|  Date<br/>|  GYearMonth<br/>|  GYear<br/>|  GMonthDay<br/>|  GDay<br/>|  GMonth<br/>|  HexBinary<br/>|  Base64Binary<br/>|  AnyURI<br/>|  expanded-QName<br/>|  NOTATION</rhs></prod>
        <prod num="2 (Formal)" id="doc-fs-TypeAnnotation"><lhs>TypeAnnotation</lhs><rhs>"of"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod>
        <prod num="9 (Formal)" id="doc-fs-ElementValue"><lhs>ElementValue</lhs><rhs>"element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementName" xlink:type="simple">ElementName</nt>  "nilled"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Value" xlink:type="simple">Value</nt>  "}"  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-NamespaceBindings" xlink:type="simple">NamespaceBindings</nt>  "}")?</rhs></prod>
        <prod num="10 (Formal)" id="doc-fs-AttributeValue"><lhs>AttributeValue</lhs><rhs>"attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeName" xlink:type="simple">AttributeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>  "}"</rhs></prod>
        <prod num="8 (Formal)" id="doc-fs-SimpleValue"><lhs>SimpleValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicValue" xlink:type="simple">AtomicValue</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>)<br/>|  ("("  ")")</rhs></prod>
        <prod num="11 (Formal)" id="doc-fs-DocumentValue"><lhs>DocumentValue</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Value" xlink:type="simple">Value</nt>  "}"</rhs></prod>
        <prod num="13 (Formal)" id="doc-fs-CommentValue"><lhs>CommentValue</lhs><rhs>"comment"  "{"  String  "}"</rhs></prod>
        <prod num="14 (Formal)" id="doc-fs-ProcessingInstructionValue"><lhs>ProcessingInstructionValue</lhs><rhs>"processing-instruction"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  String  "}"</rhs></prod>
        <prod num="12 (Formal)" id="doc-fs-TextValue"><lhs>TextValue</lhs><rhs>"text"  "{"  String  "}"</rhs></prod>
        <prod num="20 (Formal)" id="doc-fs-NodeValue"><lhs>NodeValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementValue" xlink:type="simple">ElementValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeValue" xlink:type="simple">AttributeValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-DocumentValue" xlink:type="simple">DocumentValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TextValue" xlink:type="simple">TextValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-CommentValue" xlink:type="simple">CommentValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ProcessingInstructionValue" xlink:type="simple">ProcessingInstructionValue</nt></rhs></prod>
        <prod num="3 (Formal)" id="doc-fs-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
        <prod num="6 (Formal)" id="doc-fs-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
        <prod num="23 (Formal)" id="doc-fs-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
        <prod num="15 (Formal)" id="doc-fs-NamespaceBindings"><lhs>NamespaceBindings</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>)*</rhs></prod>
        <prod num="17 (Formal)" id="doc-fs-NamespaceBinding"><lhs>NamespaceBinding</lhs><rhs>"namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  AnyURI  "}"</rhs></prod>
      </scrap>

      <smnotation>
        <p><a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a> の生成規則において、右辺の各記号は原子型1つに対応している。例えば、<emph>String</emph> は <code>xs:string</code> に対応し、<emph>Boolean</emph> は <code>xs:boolean</code> に対応している。(対応は明らかである。ただし、"expanded-QName" は <code>xs:QName</code> に対応する) これらの記号に対する明示的な規則はないが、これらはそれぞれ構文的オブジェクトの集合を導出する非終端記号で、オブジェクトはそれぞれ対応するデータ型の値空間中の値に対応する、と仮定する。例えば、非終端記号 <emph>String</emph> は、例えば <code>""</code>, <code>"a"</code>,
        <code>"John"</code> といった構文的オブジェクトの集合を導出する。このオブジェクトはそれぞれ <code>xs:string</code> 値空間中の文字列に対応する。分かりやすくするため、これらのオブジェクトには XQuery や Core の文法での <emph>StringLiteral</emph> と同じ外観を持たせている。しかし、これらは形式的オブジェクトであり、FS 中では異なる役割を持つ。</p>
      </smnotation>

      <p>型注釈を持たない要素 (属性) は型注釈 <code>xs:anyType</code> (<code>xs:anySimpleType</code>) を持つと仮定する。型注釈を持たない原子値は、対応する値に対する基本型の型注釈を持つと仮定する。例えば、<code>"Hello, World!"</code> は <code>"Hello,
      World!" of type xs:string</code> と等価である。</p>

      <p>型付けされていない要素 (例えば整形式文書中の要素) は<xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untyped"><code>xs:untyped</code></a>を持つ。型付けされていない属性は<xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>を持つ。型付けされていない原子値は<xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>を持つ。</p>

      <p>要素は省略可能な目印 <quote>nilled</quote> を持つ。この目印は、その要素が検証の結果、スキーマ中で <quote>nillable</quote> である要素型であるとされた場合に限り出現し、その要素は内容を持たず、属性 <code>xsi:nil</code> が <code>"true"</code> に設定される。</p>

      <p>また要素は名前空間束縛の列を持つ。これはその要素に対する有効範囲内名前空間の集合である。各名前空間束縛は、接頭辞と URI の2つ組である。名前空間束縛を持たない要素は、有効範囲内名前空間が空集合であると仮定する。</p>

      <note role="xquery"><p><bibref ref="XPath"/>では、要素節点の有効範囲内名前空間は<term>名前空間軸</term>上に配置される<term>名前空間節点</term>の集まりとして表現される。この軸は、<bibref ref="xpath20"/> では省略可能であり、推奨されない。XQuery は名前空間軸を支援せず、名前空間束縛を節点の形式では表現しない。</p></note>

    </div3>

    <div3 id="sec_example_values">
      <head>値の例</head>

      <p><term>整形式文書</term></p>

<eg xml:space="preserve">
  &lt;fact&gt;The cat weighs &lt;weight units="lbs"&gt;12&lt;/weight&gt; pounds.&lt;/fact&gt;
</eg>

      <p>スキーマがなければ、この文書は次のように表現される:</p>

<eg xml:space="preserve">
  element fact of type xs:untyped {
    text { "The cat weighs " },
    element weight of type xs:untyped {
      attribute units of type xs:untypedAtomic {
        "lbs" of type xs:untypedAtomic
      }
      text { "12" }
    },
    text { " pounds." }
  }
</eg>

      <p><term>妥当性検証の前の文書と後の文書</term></p>

<eg xml:space="preserve">
  &lt;weight xsi:type="xs:integer"&gt;42&lt;/weight&gt;
</eg>

      <p>値に対する形式的モデルは妥当性検証前の値と検証後の値を表現できる。検証前は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element weight of type xs:untyped {
    attribute xsi:type of type xs:untypedAtomic {
      "xs:integer" of type xs:untypedAtomic
    },
    text { "42" }
  }
</eg>

      <p>検証後は、この文書は次のように表現される:</p>

<eg xml:space="preserve">
  element weight of type xs:integer {
    attribute xsi:type of type xs:QName {
      "xs:integer" of type xs:QName
    },
    42 of type xs:integer
  }
</eg>

      <p><term>リスト型を持つ要素</term></p>

<eg xml:space="preserve">
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</eg>

      <p>検証前は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</eg>

      <p>次のスキーマを仮定する。</p>

<eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
</eg>

      <p>このスキーマによる検証後では、先の要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type sizesType {
    1 of type sizeType,
    2 of type sizeType,
    3 of type sizeType
  }
</eg>

      <p><term>無名型を持つ要素</term></p>

<eg xml:space="preserve">
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</eg>

      <p>検証前は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 2 3" }
  }
</eg>

      <p>次のスキーマを仮定する。</p>

<eg xml:space="preserve">
  &lt;xs:element name="sizes"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:integer"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:element&gt;
</eg>

      <p>検証後は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type fs:anon1 {
    1 of type xs:integer,
    2 of type xs:integer,
    3 of type xs:integer
  }
</eg>

      <p>ここで <emph>fs:</emph>anon<subscript>1</subscript> は内部無名型を表す。これは <code>sizes</code> 要素に対してシステムで生成される。</p>

      <p><term>nillable であり、</term><code>xsi:type</code> <term>が true であるような要素</term></p>

<eg xml:space="preserve">
  &lt;sizes xsi:nil="true"/&gt;
</eg>

      <p>検証前は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type xs:untyped {
    attribute xsi:nil of type xs:untypedAtomic { "true" of type xs:untypedAtomic }
  }
</eg>

      <p>次のスキーマを仮定する。</p>

<eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType" nillable="true"/&gt;
</eg>

      <p>このスキーマによる検証後は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes nilled of type sizesType {
    attribute xsi:nil of type xs:boolean { true of type xs:boolean }
  }
</eg>

      <p><term>共用体型を持つ要素</term></p>

<eg xml:space="preserve">
  &lt;sizes&gt;1 two 3 four&lt;/sizes&gt;
</eg>

      <p>検証前は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type xs:untyped {
    text { "1 two 3 four" }
  }
</eg>

      <p>次のスキーマを仮定する。</p>

<eg xml:space="preserve">
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:union memberType="xs:integer xs:string"/&gt;
  &lt;/xs:simpleType&gt;
</eg>

      <p>このスキーマによる検証後は、この要素は次のように表現される:</p>

<eg xml:space="preserve">
  element sizes of type sizesType {
    1 of type xs:integer,
    "two" of type xs:string,
    3 of type xs:integer,
    "four" of type xs:string
  }
</eg>

    </div3>

  </div2>

  <div2 id="sec_types">
    <head>[XPath/XQuery] 型システム</head>

    <p>[XPath/XQuery] 型システムは、[XPath/XQuery] の動的意味および静的意味の仕様で用いられる。この節では、型を記述する形式的記法を導入する。</p>

    <div3 id="sec_schema">
      <head>XML Schema と [XPath/XQuery] 型システム</head>

      <p>[XPath/XQuery] 型システムは<bibref ref="xmlschema-1"/>と<bibref ref="xmlschema-2"/>に基づいている。<bibref ref="xmlschema-1"/>と<bibref ref="xmlschema-2"/>は [XPath/XQuery] で利用可能な型情報を規範的に指定している。ここでは、推論ルール中で型を記述したり操作したりするためにこの文書中で用いられる形式的記述を定義する。形式的型は仕様の目的でのみ用いられ、[XPath/XQuery] のユーザが目にすることはない。</p>

      <p><term>内容モデルの表現。</term> 静的型付けの目的で、[XPath/XQuery] 型システムでは、リスト型の minOccurs, maxOccurs, and minLength, maxLength のうち、DTD の演算子 <code>+</code>, <code>*</code>, および <code>?</code> に対応する出現のみ記述する。選択は DTD の演算子 <code>|</code> で表現する。<term>All groups</term>は interleave 演算子 (<code>&amp;</code>) を用いて表す。</p>

      <p><term>無名型の表現。</term> 意味を明確にするため、[XPath/XQuery] 型システムでは無名型をすべて明示する。</p>

      <p><term>XML Schema の単純型 facet および識別性制約。</term> 簡単のため、XML Schema の単純型 facet と識別性制約は [XPath/XQuery] 型システムでは形式的には表現されない。しかし、XML Schema の輸入や検証を支援する [XPath/XQuery] の実装では、単純型 facet や識別性制約を考慮に入れなければならない。</p>

      <p>この文書では、[XPath/XQuery] 型システムでの型について記述する。これ以外に、これらの型上での演算子や性質についても記述する。これらは [XPath/XQuery] の静的型付け機能を定義するのに用いられる。最も重要な2つの性質は、データインスタンスが型に照合されるかどうか、そして型が別の型の部分型であるかどうかである。これらの性質は<specref ref="sec_type_matching"/>で記述される。この文書では、これらの型上での他の性質についてはすべて記述しない。</p>

      <p>XML Schema から [XPath/XQuery] 型システムへの対応は <specref ref="sec_importing_schema"/> で与えられる。この節の以下の部分は次のように構成されている。<specref ref="sec_item_types"/>では項目型について述べる。<specref ref="sec_content_models"/>では内容モデルについて述べる。<specref ref="sec_top_level_definitions"/>では最上位型宣言について述べる。</p>

    </div3>

    <div3 id="sec_item_types">
      <head>項目型</head>

      <p>項目型は、原子型、要素型、属性型、文書節点型、テキスト節点型、コメント節点型、処理命令型のいずれかである。文書節点、属性節点、および要素の内容に出現し得る節点 (要素節点、コメント節点、処理命令節点、テキスト節点) は互いに区別される。というのは、後で、形式的意味の中で要素内容型を参照する必要が生じるからである。</p>

  <scrap headstyle="show">
  <head>項目型</head>
  <prod num="25 (Formal)" id="doc-fs-FormalItemType"><lhs>FormalItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-NodeType" xlink:type="simple">NodeType</nt></rhs></prod>
  <prod num="28 (Formal)" id="doc-fs-AtomicTypeName"><lhs>AtomicTypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod>
  <prod num="26 (Formal)" id="doc-fs-NodeType"><lhs>NodeType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-DocumentType" xlink:type="simple">DocumentType</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeType" xlink:type="simple">AttributeType</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementContentType" xlink:type="simple">ElementContentType</nt></rhs></prod>
  <prod num="27 (Formal)" id="doc-fs-ElementContentType"><lhs>ElementContentType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementType" xlink:type="simple">ElementType</nt><br/>|  "comment"<br/>|  "processing-instruction"<br/>|  "text"</rhs></prod>
  <prod num="29 (Formal)" id="doc-fs-ElementType"><lhs>ElementType</lhs><rhs>"element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptTypeSpecifier" xlink:type="simple">OptTypeSpecifier</nt></rhs></prod>
  <prod num="4 (Formal)" id="doc-fs-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  "*"</rhs></prod>
  <prod num="5 (Formal)" id="doc-fs-AttributeNameOrWildcard"><lhs>AttributeNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  "*"</rhs></prod>
  <prod num="77 (Formal)" id="doc-fs-OptTypeSpecifier"><lhs>OptTypeSpecifier</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeSpecifier" xlink:type="simple">TypeSpecifier</nt>?</rhs></prod>
  <prod num="30 (Formal)" id="doc-fs-TypeSpecifier"><lhs>TypeSpecifier</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptNillable" xlink:type="simple">OptNillable</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt></rhs></prod>
  <prod num="31 (Formal)" id="doc-fs-AttributeType"><lhs>AttributeType</lhs><rhs>"attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeNameOrWildcard" xlink:type="simple">AttributeNameOrWildcard</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptTypeReference" xlink:type="simple">OptTypeReference</nt></rhs></prod>
  <prod num="75 (Formal)" id="doc-fs-OptNillable"><lhs>OptNillable</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Nillable" xlink:type="simple">Nillable</nt>?</rhs></prod>
  <prod num="32 (Formal)" id="doc-fs-Nillable"><lhs>Nillable</lhs><rhs>"nillable"</rhs></prod>
  <prod num="78 (Formal)" id="doc-fs-OptTypeReference"><lhs>OptTypeReference</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt>?</rhs></prod>
  <prod num="36 (Formal)" id="doc-fs-TypeReference"><lhs>TypeReference</lhs><rhs>"of"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod>
  <prod num="45 (Formal)" id="doc-fs-DocumentType"><lhs>DocumentType</lhs><rhs>"document"  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  "}")?</rhs></prod>
  </scrap>

      <p>要素型や属性型は名前もしくはワイルドカードを持ち、また省略可能な型参照を持つ。単独で用いられる名前は大域要素宣言や大域属性制限への参照に対応する。型参照を持つ名前は、局所要素宣言や局所属性宣言に対応する。単独で用いられる "element *" や "attribute *" は任意の要素や任意の属性に対するワイルドカード型を参照する。加えて、要素型は、その要素が nilled であってもよいかどうかを示す nillable の省略可能なフラグを持つ。</p>

      <p>文書型は省略可能な内容型を持つ。内容型が与えられなければ、その型は文書に対するワイルドカード型、すなわち、テキスト節点と要素節点の列であると扱われる。要素節点との一貫性のために、PI とコメントは、このワイルドカード型には示されないが、インスタンス中に出現してもよい。</p>

      <smnote>
        <p>SequenceType の生成規則中で用いられる汎化節点型 (<code>node()</code> など) は、型システムでは、対応する節点型 (要素節点、属性節点、テキスト節点、コメント節点、処理命令節点など) の集合和として解釈され、文法中には現れない。列型の意味は<specref ref="id-sequencetype-matching"/>で述べる。</p>
      </smnote>
      
      <smexamples>

        <p>次に示すのはテキスト節点型</p>

<eg xml:space="preserve">
  text
</eg>

        <p>次に示すのはすべての要素に対する型</p>

<eg xml:space="preserve">
  element * of type xs:anyType
</eg>

        <p>次に示すのは文字列型の要素すべてに対する型</p>

<eg xml:space="preserve">
  element * of type xs:string
</eg>

        <p>次に示すのは、型が文字列で名前が <code>size</code> であるような nillable な要素の型</p>

<eg xml:space="preserve">
  element size nillable of type xs:string
</eg>

        <p>次に示すのは大域属性宣言への参照</p>

<eg xml:space="preserve">
  attribute sizes
</eg>

        <p>次に示すのは無名型 <emph>fs:</emph>anon<subscript>1</subscript> の要素の型:</p>

<eg xml:space="preserve">
  element sizes of type fs:anon1
</eg>

      </smexamples>

    </div3>

    <div3 id="sec_content_models">
      <head>内容モデル</head>

      <p>XML Schema にならい、[XPath/XQuery] の型は項目型から、省略可能、1個以上、0個以上、<term>all
      group</term>, <term>sequence</term>, <term>choice</term>、空列 (<code>empty</code> と書かれる)、空の選択 (<code>none</code> と書かれる) などによって構成される。</p>

      <p>The type <code>empty</code> matches the empty sequence. The type
      <code>none</code> matches no values. <code>none</code> is the identity for
      choice, that is <expression>(<a href="#doc-fs-Type"><emph>Type</emph></a> | <code>none</code>) =
      <a href="#doc-fs-Type"><emph>Type</emph></a></expression>. The type <code>none</code> is the static type
      for <specref ref="sec_fnerror"/>.</p>

      <scrap headstyle="show">
        <head>型</head>
      
        <prod num="24 (Formal)" id="doc-fs-Type"><lhs>Type</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalItemType" xlink:type="simple">FormalItemType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  "|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>)<br/>|  "empty"<br/>|  "none"<br/>|  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>  ")")</rhs></prod>
      </scrap>

      <p>The [XPath/XQuery] type system includes three binary operators on
      types: ",", "|" and "&amp;", corresponding respectively to
      sequence, choice and <term>all groups</term> in Schema. The
      [XPath/XQuery] type system includes three unary operators on types:
      "*", "+", and "?", corresponding respectively to zero or more
      instances of the type, one or more instances of the type, or an
      optional instance of the type.</p>

      <p>The "&amp;" operator builds the <quote>interleaved
      product</quote> of two types. The type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> matches any sequence that is an interleaving of two
      sequences of items, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, with
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> matching <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> matching
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>. The interleaving of two sequences of items
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is any sequence <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> such
      that there is an ordered partition of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> into the two
      sub-sequences <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>. The interleaved
      product captures the semantics of <term>all groups</term> in XML
      Schema, but is more general as it applies to arbitrary
      types. <term>All groups</term> in XML Schema are restricted to
      apply only on global or local element declarations with
      minOccurs 0 or 1, and maxOccurs 1.</p>

      <p>For example, consider the types <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> =
      <code>xs:integer</code>,<code>xs:integer</code>,<code>xs:integer</code> and <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
      <code>xs:string</code>,<code>xs:string</code>. <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <code>= (1,2,3)</code>
      matches the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <code>=
      ("a","b")</code> matches the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>. Any of the
      following <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> are interleavings of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, and therefore match the type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>):</p>

<eg xml:space="preserve">
Value0 = (1,2,3,"a","b")
Value0 = (1,2,"a",3,"b")
Value0 = (1,2,"a","b",3)
Value0 = (1,"a",2,3,"b")
Value0 = (1,"a",2,"b",3)
Value0 = (1,"a","b",2,3)
Value0 = ("a",1,2,3,"b")
Value0 = ("a",1,2,"b",3)
Value0 = ("a",1,"b",2,3)
Value0 = ("a","b",1,2,3)
</eg>

      <p><term>Types precedence order</term>. To improve readability
      when writing types, we assume the following precedence order
      between operators on types.</p>

      <table border="1">
      <tbody>
  
      <tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">Operator</th></tr>
      <tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">| (choice)</td></tr>
      <tr><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">&amp; (interleaving)</td></tr>
      <tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">, (sequence)</td></tr>
      <tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1">*, +, ? (occurrence)</td></tr>
      </tbody>
      </table>

      <p>Parenthesis can be used to enforce precedence. For
      instance</p>

<eg xml:space="preserve">
  xs:string | xs:integer, xs:float*
</eg>

      <p>is equivalent to</p>

<eg xml:space="preserve">
  xs:string | (xs:integer, (xs:float*))
</eg>

      <p>and a different precedence can be obtained by writing</p>

<eg xml:space="preserve">
  ((xs:string | xs:integer), xs:float)*
</eg>

      <smexamples>
        <p><term>A sequence of elements</term></p>

        <p>The "," operator builds the <quote>sequence</quote> of two
        types. For example,</p>

<eg xml:space="preserve">
  element title of type xs:string, element year of type xs:integer
</eg>

        <p>is a sequence of an element title of type string followed
        by an element year of type integer.</p>

        <p><term>The union of two element types</term></p>

        <p>The "|" operator builds the <quote>union</quote> of two
        types. For example,</p>

<eg xml:space="preserve">
  element editor of type xs:string | element bib:author
</eg>

        <p>means either an element editor of type string, or a
        reference to the global element <code>bib:author</code>.</p>

        <p><term>An all group of two elements</term></p>

        <p>The "&amp;" operator builds the <quote>interleaved
        product</quote> of two types. For example,</p>

<eg xml:space="preserve">
  (element a &amp; element b) =
    element a, element b
  | element b, element a
</eg>

        <p>which specifies that the <code>a</code> and <code>b</code>
        elements can occur in any order.</p>

        <p><term>An empty type</term></p>

        <p>The following type matches the empty sequence.</p>

<eg xml:space="preserve">
  empty
</eg>

        <p><term>A sequence of zero or more elements</term></p>

        <p>The following type matches zero or more elements each of
        which can be a <code>surgeon</code> or a
        <code>plumber</code>.</p>

<eg xml:space="preserve">
  (element surgeon | element plumber)*
</eg>

      </smexamples>      

      <smnotation>
        <p>The grammar for <a href="#doc-fs-Type"><emph>Type</emph></a> describe above is general enough
        to capture type infered for arbitrary expression, as well as
        to represent the content of an in <bibref ref="xmlschema-1"/>. In a few
        cases, inference rules rely on the fact that a given type is a
        type validly describing the content of an element. To capture
        those cases, we introduce the following auxiliary grammar
        productions to describe more precisely the attribute
        declarations and the content model for an element.</p>

      <scrap headstyle="show">
        <head/>
        <prod num="42 (Formal)" id="doc-fs-AttributeModel"><lhs>AttributeModel</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeType" xlink:type="simple">AttributeType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeType" xlink:type="simple">AttributeType</nt>  "?")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeModel" xlink:type="simple">AttributeModel</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeModel" xlink:type="simple">AttributeModel</nt>)<br/>|  ("("  ")")</rhs></prod>
        <prod num="43 (Formal)" id="doc-fs-ElementModel"><lhs>ElementModel</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementType" xlink:type="simple">ElementType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementType" xlink:type="simple">ElementType</nt>  "?")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementModel" xlink:type="simple">ElementModel</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementModel" xlink:type="simple">ElementModel</nt>)<br/>|  ("("  ")")<br/>|  "none"</rhs></prod>
      </scrap>
      </smnotation>

    </div3>

    <div3 id="sec_top_level_definitions">
      <head>トップレベル定義</head>

      <p>Top level definitions correspond to global element
      declarations, global attribute declarations and type definitions
      in XML Schema.</p>

      <scrap headstyle="show">
      <head>型定義</head>
      
      <prod num="40 (Formal)" id="doc-fs-Definitions"><lhs>Definitions</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Definition" xlink:type="simple">Definition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Definitions" xlink:type="simple">Definitions</nt>)?</rhs></prod>
      <prod num="39 (Formal)" id="doc-fs-Definition"><lhs>Definition</lhs><rhs>("define"  "element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementName" xlink:type="simple">ElementName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptSubstitution" xlink:type="simple">OptSubstitution</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptNillable" xlink:type="simple">OptNillable</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeName" xlink:type="simple">AttributeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeDerivation" xlink:type="simple">TypeDerivation</nt>)</rhs></prod>
      <prod num="76 (Formal)" id="doc-fs-OptSubstitution"><lhs>OptSubstitution</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Substitution" xlink:type="simple">Substitution</nt>?</rhs></prod>
      <prod num="41 (Formal)" id="doc-fs-Substitution"><lhs>Substitution</lhs><rhs>"substitutes"  "for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ElementName" xlink:type="simple">ElementName</nt></rhs></prod>
      <prod num="33 (Formal)" id="doc-fs-TypeDerivation"><lhs>TypeDerivation</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ComplexTypeDerivation" xlink:type="simple">ComplexTypeDerivation</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicTypeDerivation" xlink:type="simple">AtomicTypeDerivation</nt></rhs></prod>
      <prod num="34 (Formal)" id="doc-fs-ComplexTypeDerivation"><lhs>ComplexTypeDerivation</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Derivation" xlink:type="simple">Derivation</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-OptMixed" xlink:type="simple">OptMixed</nt>  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>?  "}"</rhs></prod>
      <prod num="35 (Formal)" id="doc-fs-AtomicTypeDerivation"><lhs>AtomicTypeDerivation</lhs><rhs>"restricts"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt></rhs></prod>
      <prod num="37 (Formal)" id="doc-fs-Derivation"><lhs>Derivation</lhs><rhs>("restricts"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt>)<br/>|  ("extends"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeName" xlink:type="simple">TypeName</nt>)</rhs></prod>
      <prod num="74 (Formal)" id="doc-fs-OptMixed"><lhs>OptMixed</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Mixed" xlink:type="simple">Mixed</nt>?</rhs></prod>
      <prod num="38 (Formal)" id="doc-fs-Mixed"><lhs>Mixed</lhs><rhs>"mixed"</rhs></prod>
      </scrap>

       <p>A type definition has a name (possibly anonymous) and a type
       derivation. In the case of a complex type, the derivation
       indicates whether it is derived by extension or restriction, its
       base type, and its content model, with an optional flag
       indicating if it has mixed content.</p>

       <p>Note the type system allows recursive types, following the
       rules defined in <bibref ref="xmlschema-1"/>.</p>

       <smexample>

       <p>For instance, the following complex type</p>

<eg xml:space="preserve">
 &lt;complexType name="UKAddress"&gt;
   &lt;complexContent&gt;
     &lt;extension base="ipo:Address"&gt;
       &lt;sequence&gt;
         &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
       &lt;/sequence&gt;
       &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
     &lt;/extension&gt;
   &lt;/complexContent&gt;
 &lt;/complexType&gt;
</eg>

       <p>is represented as follows</p>

<eg xml:space="preserve">
  define type UKAddress extends ipo:Address {
    attribute exportCode of type ipo:UKPostcode,
    element postcode of type positiveInteger
  };
</eg>

       </smexample>
       <smexample>

       <p>In the case of simple types derived by union or list, the
       derivation is always a restriction from the base type
       <code>xs:anySimpleType</code>, and has a content which is a union of the
       member types, or a repetition of the item type. For instance,
       the two following simple type declarations</p>

<eg xml:space="preserve">
&lt;xsd:simpleType name="listOfMyIntType"&gt;
  &lt;xsd:list itemType="myInteger"/&gt;
&lt;/xsd:simpleType&gt;

&lt;xsd:simpleType name="zipUnion"&gt;
  &lt;xsd:union memberTypes="USState FrenchRegion"/&gt;
&lt;/xsd:simpleType&gt;
</eg>

       <p>are represented as follows</p>

<eg xml:space="preserve">
define type listOfMyIntType restricts xs:anySimpleType {
  myInteger*
}

define type zipUnion restricts xs:anySimpleType {
  USState | FrenchRegion
}
</eg>

       </smexample>
       <smexample>

       <p>In the case of an atomic type, it just indicates its base
       type. For instance, the following type definition</p>

<eg xml:space="preserve">
&lt;xsd:simpleType name="SKU"&gt;
 &lt;xsd:restriction base="xsd:string"&gt;
  &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
 &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg>

       <p>is represented as follow</p>

<eg xml:space="preserve">
  define type SKU restrict xsd:string;
</eg>

       </smexample>
       <smexample>

       <p>When the type derivation is omitted, the type derives by
       restriction from <code>xs:anyType</code>. For instance:</p>

<eg xml:space="preserve">
  define type Bib { element book* } =
  define type Bib restricts xs:anyType { element book* }
</eg>

       </smexample>
       <smexample>

       <p>Empty content can be indicated with the explicit empty
       sequence, or omitted, as in:</p>

<eg xml:space="preserve">
  define type Bib { } =
  define type Bib { empty }
</eg>

       </smexample>

       <p>Global element and attribute declarations always have a name
       and a reference to a (possibly anonymous) type.  A global
       element declaration also may declare a substitution group for
       the element and whether the element is nillable.</p>

       <smexample>
         <p>A type declaration with one element name of type
         <code>xs:string</code> follows by one or more elements street of type
         <code>xs:string</code>.</p>

<eg xml:space="preserve">
  define type Address {
    element name of type xs:string,
    element street of type xs:string*
  }
</eg>

       </smexample>
       <smexample>

         <p>A type declaration with complex content derived by
         extension</p>

<eg xml:space="preserve">
  define type USAddress extends Address {
    element zip name of type xs:integer
  }
</eg>

       </smexample>
       <smexample>

         <p>A type declaration with mixed content</p>

<eg xml:space="preserve">
  define type Section mixed {
    (element h1 of type xs:string |
     element p of type xs:string |
     element div of type Section)*
  }
</eg>

       </smexample>
       <smexample>

         <p>A type declaration with simple content derived by
         restriction</p>

<eg xml:space="preserve">
  define type SKU restricts xs:string
</eg>

       </smexample>
       <smexample>

         <p>An element declaration</p>

<eg xml:space="preserve">
  define element address of type Address
</eg>

       </smexample>
       <smexample>

         <p>An element declaration with a substitution
         group</p>

<eg xml:space="preserve">
  define element usaddress substitutes for address of type USAddress
</eg>

       </smexample>
       <smexample>

         <p>An element declaration which is nillable</p>

<eg xml:space="preserve">
  define element zip nillable of type xs:integer
</eg>

       </smexample>

     </div3>

     <div3 id="sec_types_example">
       <head>完全スキーマの例</head>

       <p>Here is a schema describing purchase orders from
       <bibref ref="xmlschema-0"/>.</p>

<eg xml:space="preserve">
  &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  
   &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
   &lt;/xsd:annotation&gt;
  
   &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;
  
   &lt;xsd:element name="comment" type="xsd:string"/&gt;
  
   &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="shipTo" type="USAddress"/&gt;
     &lt;xsd:element name="billTo" type="USAddress"/&gt;
     &lt;xsd:element ref="comment" minOccurs="0"/&gt;
     &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="name"   type="xsd:string"/&gt;
     &lt;xsd:element name="street" type="xsd:string"/&gt;
     &lt;xsd:element name="city"   type="xsd:string"/&gt;
     &lt;xsd:element name="state"  type="xsd:string"/&gt;
     &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN" fixed="US"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:complexType&gt;
  	&lt;xsd:sequence&gt;
  	 &lt;xsd:element name="productName" type="xsd:string"/&gt;
  	 &lt;xsd:element name="quantity"&gt;
  	  &lt;xsd:simpleType&gt;
  	   &lt;xsd:restriction base="xsd:positiveInteger"&gt;
  	    &lt;xsd:maxExclusive value="100"/&gt;
  	   &lt;/xsd:restriction&gt;
  	  &lt;/xsd:simpleType&gt;
  	 &lt;/xsd:element&gt;
  	 &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
  	 &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
  	 &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
  	&lt;/xsd:sequence&gt;
  	&lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
   &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
     &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
  
  &lt;/xsd:schema&gt;
</eg>

<p>Here is the mapping of the above schema into the [XPath/XQuery] type
system.</p>

<eg xml:space="preserve">
  declare namespace xsd = "http://www.w3.org/2001/XMLSchema";

  define element purchaseOrder of type PurchaseOrderType;
 
  define element comment of type xsd:string;
  
  define type PurchaseOrderType {
    attribute orderDate of type xsd:date?,
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element comment?,
    element items of type Items
  };

  define type USAddress {
    attribute country of type xsd:NMTOKEN,
    element name of type xsd:string,
    element street of type xsd:string,
    element city of type xsd:string,
    element state of type xsd:string,
    element zip of type xsd:decimal
  };

  define type Items {
    attribute partNum of type SKU,
    element item of type fs:anon1*
  };

  define type fs:anon1 {
    element productName of type xsd:string,
    element quantity of type fs:anon2,
    element USPrice of type xsd:decimal,
    element comment?,
    element shipDate of type xsd:date?
  };

  define type fs:anon2 restricts xsd:positiveInteger;

  define type SKU restrict xsd:string;
</eg>

      <p>Note that the two anonymous types in the <code>item</code>
      element declarations are mapping to types with names <emph>fs:</emph>anon<subscript>1</subscript>
      and <emph>fs:</emph>anon<subscript>2</subscript>.</p>

      <p>The following additional definitions illustrate how more
      advanced XML Schema features (a complex type derived by
      extension, an anonymous simple type derived by restriction, and
      substitution groups) are represented in the [XPath/XQuery] type
      system.</p>

<eg xml:space="preserve">
  &lt;complexType name="NYCAddress"&gt;
    &lt;complexContent&gt;
     &lt;extension base="USAddress"&gt;
      &lt;sequence&gt;
       &lt;element ref="apt"/&gt;
      &lt;/sequence&gt;
     &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;element name="apt"&gt;
    &lt;xsd:simpleType&gt;
     &lt;xsd:restriction base="xsd:positiveInteger"&gt;
      &lt;xsd:maxExclusive value="10000"/&gt;
     &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/element&gt;

  &lt;element name="usaddress" substitutionGroup="address" type="USAddress"/&gt;
  &lt;element name="nycaddress" substitutionGroup="usaddress" type="NYCAddress"/&gt;
</eg>

<p>The above definitions are mapped into the [XPath/XQuery] type system as
follows:</p>

<eg xml:space="preserve">
  define type NYCAddress extends USAddress {
    element apt
  }

  define element apt of type fs:anon3

  define type fs:anon3 restricts xsd:positiveInteger

  define element usaddress  substitutes for address of type USAddress
  define element nycaddress substitutes for usaddress of type NYCAddress
</eg>

    </div3>

  </div2>

  <div2 id="sec_fando">
    <head>関数と演算子</head>

    <p>The <bibref ref="xpath-functions"/> document defines built-in functions
    available in [XPath/XQuery]. A number of these functions are used to
    define the [XPath/XQuery] semantics; those functions are listed in
    <specref ref="sec_used_functions"/>.</p>

    <p>Many functions in the <bibref ref="xpath-functions"/> document are
    <emph>generic</emph>: they perform operations on arbitrary
    components of the data model, e.g., any kind of node, or any
    sequence of items. For instance, the <code>fn:unordered</code>
    returns its input sequence in an implementation-dependent
    order. The signature of the <code>fn:unordered</code> function
    takes arbitrary items as input and output:</p>

<eg xml:space="preserve">
  fn:unordered($sourceSeq as item()*) as item()*
</eg>

    <p>As defined, this signature provides little useful type
    information. For such functions, better type information can often
    be obtained by having the output type depend on the type of input
    parameters. For instance, if the function
    <code>fn:unordered</code> is applied on a sequence of
    <code>a</code> elements, the result is also a sequence of
    <code>a</code> elements.</p>

    <p>In order to provide better static typing for those functions,
    specific static typing rules are given in <specref ref="sec_special_functions"/>.</p>
  </div2>

</div1>

<!-- Keep this comment at the end of the file for Emacs' XML mode to work.
 Local variables:
 mode: xml
 sgml-indent-step:2
 indent-tabs-mode:nil
 sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
 End:
-->

     <!-- *************************** &language; Semantics            **************** -->

<div1 id="id-basics">
  <head>基礎</head>

  <p>The organization of this section parallels the organization of
  <xspecref spec="XQ" ref="id-basics"/>.</p>

  <div2 id="sec_context">
    <head>式文脈</head>

    <smintro>
      <p>The expression context for a given expression consists of all
      the information that can affect the result of the
      expression. This information is organized into the <emph>static
      context</emph> and the <emph>dynamic context</emph>.  This
      section specifies the environments that represent the context
      information used by [XPath/XQuery] expressions.</p>
    </smintro>

    <div3 id="static_context">
      <head>静的文脈</head>

      <smnotation>
        <p>We introduce the following auxiliary grammar production to
        describe function signatures.</p>

      <scrap headstyle="show">
        <head/>
        <prod num="85 (Formal)" id="doc-fs-FunctionSig"><lhs>FunctionSig</lhs><rhs>"declare"  "function"  expanded-QName  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-TypeList" xlink:type="simple">TypeList</nt>?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod>
        <prod num="86 (Formal)" id="doc-fs-TypeList"><lhs>TypeList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-Type" xlink:type="simple">Type</nt>)*</rhs></prod>
      </scrap>
      </smnotation>

      <p id="xq_stat_env"><a href="#xq_stat_env_def" class="env">statEnv</a> denotes the environment
      available during static analysis.  Static analysis may extend
      parts of the static environment. The static environment is also
      available during dynamic evaluation.</p>

      <p>If analysis of an expression relies on some component of the
      static context that has not been assigned a value, a static
      error is raised.</p>

      <p id="xq_stat_env_def">The following environment components are
      part of the static environment:</p>
  
      <table summary="" role="figure" cellpadding="5">
      <col width="10%" span="1"/><!-- empty column forces left indentation -->
      <col width="15%" span="1"/>
      <col width="65%" align="justify" span="1"/>
      <col width="10%" span="1"/><!-- empty column forces right indentation -->
      <tbody>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_xpath_compat_flag" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a></td>
          <td rowspan="1" colspan="1">
             <table summary="">
             <tbody>
               <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a> environment
               component designates the <term>XPath 1.0 compatibility
               flag</term> in the [XPath/XQuery] static context. It
               specifies whether the semantic rules for backward
               compatibility with XPath 1.0 are in effect. This
               document defines the formal semantics for XPath 2.0
               only when the XPath 1.0 backward compatibility rules
               are not in effect.</td></tr>
             </tbody>
             </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></td>
          <td rowspan="1" colspan="1">
            <table summary="" id="term_active">
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component
                designates the <term>statically known
                namespaces</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component maps a
                namespace prefix (<emph>NCName</emph>) onto a <term>namespace
                kind</term> and a namespace URI (<emph>AnyURI</emph>), the null
                namespace (#NULL-NAMESPACE), or (#UNDECLARED). The
                namespace kind is either <term>passive</term> or
                <term>active</term>.  The namespace kind determines
                whether a namespace node is created for an element
                during element construction. The (#UNDECLARED) value
                may be used to indicate that the prefix has been
                undeclared, and may occur only if the implementation
                supports <bibref ref="XMLNAMES11"/>.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_default_elem_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component designates the <term>default element/type
                namespace</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component contains a namespace URI (a <emph>AnyURI</emph>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing in a position where an
                element or type name is expected.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_default_fn_ns_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component designates the <term>default function
                namespace</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component contains a namespace URI (a <emph>AnyURI</emph>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing as the function name in a
                function call.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_type_defn" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component
                designates the <term>in-scope schema types</term> in
                the [XPath/XQuery] static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component maps
                expanded type names (expanded <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>s) onto
                their type definition (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).  A type name
                may be globally declared or anonymous.</td></tr>
             </tbody>
           </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_elem_decl" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component
                designates the <term>in-scope element
                declarations</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component maps
                expanded element names (expanded <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>s)
                onto their declaration (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_attr_decl" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component
                designates the <term>in-scope attribute
                declarations</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component maps
                expanded attribute names (expanded
                <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>s) onto their declaration
                (<a href="#sec_top_level_definitions"><emph>Definition</emph></a>).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component
                designates the <term>in-scope variables</term> in
                the [XPath/XQuery] static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component maps
                expanded variable names (expanded <emph>VarName</emph>) to
                their static type (<a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr>

                <tr><td rowspan="1" colspan="1">The <term>context item static type</term> in
                the [XPath/XQuery] static context is represented by the
                binding of the variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> to its corresponding
                type in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_functy_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                designates the <term>function signatures</term> in the
                [XPath/XQuery] static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                stores the static type signatures of
                functions. Because [XPath/XQuery] allows multiple
                functions with the same name differing in the number
                of parameters, this environment component maps an
                expanded <emph>QName</emph> and an arity to a function
                signatures <emph>FunctionSig</emph>.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_collations_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> environment component
                designates the <term>statically known
                collations</term> in the [XPath/XQuery] static
                context.</td></tr> <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a>
                environment component maps a unique namespace URI (a
                <emph>AnyURI</emph>) to a pair of functions: the first function
                takes a set of strings and returns a sequence
                containing those strings in sorted order; and the
                second function takes two strings, returns true if
                they are considered equal, and false if not.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
         <td id="xq_default_collation_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component designates the <term>default
                collation</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component is a pair of functions as described in
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> above.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_construction_mode_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component designates the <term>construction
                mode</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component is one of <term>preserve</term> or
                <term>strip</term>.  </td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_ordering_mode_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component designates the <term>ordering mode</term> in
                the [XPath/XQuery] static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component is one of <term>ordered</term> or
                <term>unordered</term>.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_default_empty_order" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component designates the <term>default order for empty
                sequences</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1"> The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component controls whether an empty sequence is
                interpreted as the greatest value or as the least
                value during processing of an <code>order by</code>
                clause in a FLWOR expression. Its value may be
                <code>greatest</code> or <code>least</code>.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_boundary_space" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                designates the <term>boundary-space policy</term>
                in the [XPath/XQuery] static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                controls the processing of boundary whitespace by
                element constructors. Its value may be
                <code>preserve</code> or <code>strip</code>.</td></tr>
            </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_copy_namespaces_mode" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component designates the <term>copy-namespaces
                mode</term> in the [XPath/XQuery] static
                context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component controls the namespace bindings that are
                assigned when an existing element node is copied by an
                element constructor. Its value consists of two parts:
                <code>preserve</code> or <code>no-preserve</code>, and
                <code>inherit</code> or
                <code>no-inherit</code>.</td></tr>
            </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_base_uri_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                designates the <term>base URI</term> in the [XPath/XQuery]
                static context.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                contains a unique namespace URI (a
                <emph>AnyURI</emph>).</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_doc_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                designates the <term>statically known documents</term>
                in the [XPath/XQuery] static context.  It contains the
                static type for the input documents, and is used to
                provide the static type to the <code>fn:doc</code>
                function.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                contains bindings from input URIs (a <emph>AnyURI</emph>) to
                types (a <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_collection_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component designates the <term>statically known
                collections</term> in the [XPath/XQuery] static context.
                It contains the static type for the input collections,
                and is used to provide the static type to the
                <code>fn:collection</code> function.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component contains bindings from input URIs (a
                <emph>AnyURI</emph>) to types (a <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_default_collection_type_env" valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component designates the <term>statically
                known default collection type</term> in the [XPath/XQuery]
                static context. It contains the static type for the
                default collection, and is used to provide the static
                type to the <code>fn:collection</code> function when called with
                no arguments.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component contains type (a
                <a href="#doc-fs-Type"><emph>Type</emph></a>).</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      </tbody>
      </table>

      <p>Note that the boundary-space behavior is not formally
      specified in this document.</p>

      <p id="xq_default_stat_env">An initial environment is set up
      when [expression/query] processing begins, containing, for example,
      the function signatures of all built-in functions.  The initial
      values for the static context are defined in <xspecref spec="XQ" ref="id-xq-context-components"/> and <xspecref spec="XP" ref="id-xp-context-components"/> and is denoted by
      <a href="#xq_default_stat_env" class="env">statEnvDefault</a> in the Formal Semantics.</p>

      <p>Here is an example that shows how the static environment is
      modified in response to a namespace definition.</p>

      <infergr>
        <infer>
         <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
          <clause>
            <environment>
              <update>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                <expression><emph>NCName</emph> =&gt; (passive, <emph>AnyURI</emph>)</expression>
              </update>
            </environment>
            <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><code>declare namespace</code> <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
  
      <p>This rule reads as follows: <quote>the phrase on the bottom
      (a namespace declaration in the query prolog followed by a
      sequence of expressions) is well-typed (accepted by the static
      typing rules) within an environment <a href="#xq_stat_env_def" class="env">statEnv</a>
      <emph>if</emph> the sequence of expressions above the line is
      well-typed in the environment obtained from <a href="#xq_stat_env_def" class="env">statEnv</a> by
      adding the namespace declaration</quote>.</p>

      <p id="fs_activeNS">The helper function
      <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>) returns all the active in-scope
      namespaces in the given static environment.</p>

      <p id="fs_ns_from_items">For each attribute and element node in
      <a href="#doc-fs-Value"><emph>Value</emph></a>, such that the node has name <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> in the
      namespace <emph>AnyURI</emph>, the helper function
      <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><emph>Value</emph></a>) returns the
      in-scope namespace that corresponds to <emph>AnyURI</emph>.  This is a
      reverse-lookup on <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> by <emph>AnyURI</emph>.</p>

    <div4 id="id-expanded-qnames">
      <head>QName から展開済 QName への解決</head>

      <p>A common use of the static environment is to expand a
      <emph>QName</emph> by looking up the URI that corresponds to the QName's
      namespace prefix in the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component and by
      constructing an <xtermref spec="DM" ref="dt-expanded-qname"/>,
      which contains the URI and the QName's local part. Element and
      type names may be in the null namespace, that is, there is no
      URI associated with their namespace prefix.  The null namespace
      is denoted by the special value
      <code>#NULL-NAMESPACE</code>.</p>

      <p>The auxiliary judgments below expand an element, type,
      attribute, variable, or function <emph>QName</emph> by looking up the
      namespace prefix in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> or, if the QName is unqualified,
      by using the appropriate default namespace. </p>
  
      <smnotation>
        <p id="jd_elem_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>QName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
          </clause>
        </display>
        <p>holds when the element or type QName expands to the 
        given expanded QName.</p>
        <p id="jd_attr_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>QName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
          </clause>
        </display>
        <p>holds when the attribute QName expands to the 
        given expanded QName.</p>

        <p>We use <emph>Variable</emph> to denote the expanded QNames of
        variables.</p>

        <p id="jd_var_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>QName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression>
          </clause>
        </display>
        <p>holds when the variable QName expands to the 
        given expanded QName.</p>

        <p id="jd_func_qname_expands_to">The judgment</p>
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
          </clause>
        </display>
        <p>holds when the function QName expands to the 
        given expanded QName.</p>
    </smnotation>

    <smrules>
      <p>Note that none of the inference rules can infer a resolved
      name in the case a given namespace prefix is bound to the
      (#UNDECLARED) value. As a result, namespace resolution will fail
      if the implementation supports <bibref ref="XMLNAMES11"/> and a
      given namespace prefix has been undeclared.</p>

      <p>An element or type QName consisting of a prefix NCName and a
      local part NCName expands to the URI (or the null namespace)
      corresponding to that prefix and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI-or-#NULL-NAMESPACE</emph>)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a>
           (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An element or type QName consisting only of a local part
      NCName expands to the default element/type namespace and the
      local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> = <emph>AnyURI-or-#NULL-NAMESPACE</emph></expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a>
           (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An attribute QName consisting of a prefix NCName and a local
      part NCName expands to the URI (or the null namespace)
      corresponding to the prefix and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI-or-#NULL-NAMESPACE</emph>)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> (<emph>AnyURI-or-#NULL-NAMESPACE</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>An attribute QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <infergr>
        <infer>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a>
           (#NULL-NAMESPACE, <emph>NCName</emph>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A variable QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> (<emph>AnyURI</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A variable QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <infergr>
        <infer>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
           (#NULL-NAMESPACE, <emph>NCName</emph>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A function QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>NCName</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph><subscript>1</subscript>:<emph>NCName</emph><subscript>2</subscript>
           <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<emph>AnyURI</emph>, <emph>NCName</emph><subscript>2</subscript>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>A function QName consisting only of a local part NCName
      expands to the default function namespace URI and the local
      part.</p>

      <infergr>
        <infer>
         <prejudge>
         <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> = <emph>AnyURI</emph></expression>
         </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><emph>NCName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a>
           (<emph>AnyURI</emph>, <emph>NCName</emph>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    </smrules>
    </div4>  

    </div3>
   
    <div3 id="eval_context">
      <head>動的文脈</head>

      <p id="xq_dyn_env_def"><a href="#xq_dyn_env_def" class="env">dynEnv</a> denotes the environment
      available during dynamic evaluation. Dynamic evaluation may
      extend parts of the dynamic environment.</p>

      <p>If evaluation of an expression relies on some component of
      the dynamic context that has not been assigned a value, a
      dynamic error is raised.</p>

      <p>The following environment components are part of the dynamic
      environment:</p>
  
      <table summary="" role="figure" cellpadding="5">
      <col width="10%" span="1"/><!-- empty column forces left indentation -->
      <col width="15%" span="1"/>
      <col width="65%" align="justify" span="1"/>
      <col width="10%" span="1"/><!-- empty column forces right indentation -->
      <tbody>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_val_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></td>
          <td rowspan="1" colspan="1">
           <table><tbody>
            <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> environment component corresponds to the
            <term>variable values</term>, the <term>context
            item</term>, the <term>context position</term> and the
            <term>context size</term> in the [XPath/XQuery] evaluation
            context.</td></tr>

            <tr><td rowspan="1" colspan="1">The dynamic value environment component maps an
            expanded variable name (expanded <emph>VarName</emph>) to the
            variable's value (<a href="#doc-fs-Value"><emph>Value</emph></a>) or to the value
            <code>#IMPORTED</code>(<emph>AnyURI</emph>), if the variable is
            defined in the imported module with namespace
            <emph>AnyURI</emph>.</td></tr> </tbody></table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_func_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
               <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component corresponds to
               the <term>function implementations</term> (or
               definition) part of the [XPath/XQuery] dynamic
               context.</td></tr>

               <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component maps an
               expanded function name and parameter signature of the
               form <quote><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ...,
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)</quote> to the remainder of the
               corresponding function definition. If the function is
               defined in <bibref ref="xpath-functions"/>, the function definition is
               the value <code>#BUILT-IN</code>. If the function is
               externally defined, the function definition is the
               value <code>#EXTERNAL</code>. If the function is
               defined in the imported module with namespace <emph>AnyURI</emph>,
               the function definition is the value
               <code>#IMPORTED</code>(<emph>AnyURI</emph>). If the function is
               locally declared, the function definition is of the
               form <quote>(<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>,...,
               <emph>Variable</emph><subscript>n</subscript>)</quote>, where <emph>Expr</emph> is the
               function body and <emph>Variable</emph><subscript>1</subscript>, ..., <emph>Variable</emph><subscript>n</subscript>
               are the function parameters.</td></tr>

               <tr><td rowspan="1" colspan="1"> The initial function environment component
               (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>.funcDefn) maps the signatures of
               the internal functions defined in <specref ref="sec_operators"/> and the signatures of the
               functions defined in <bibref ref="xpath-functions"/> to
               <code>#BUILT-IN</code>.</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_date_time_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a></td>
          <td rowspan="1" colspan="1">
           <table><tbody>
            <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a> environment component corresponds to
            the <term>current dateTime</term> in the [XPath/XQuery]
            dynamic context.</td></tr> </tbody></table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_timezone_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a></td>
          <td rowspan="1" colspan="1">
           <table><tbody>

            <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a> environment component corresponds to
            the <term>implicit timezone</term> in the [XPath/XQuery]
            dynamic context and is used by the timezone related
            functions in <bibref ref="xpath-functions"/>.</td></tr> </tbody></table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>

      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_doc_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component corresponds
                to the <term>available documents</term> in the
                [XPath/XQuery] dynamic context.  It contains the document
                nodes corresponding to input documents, and is used to
                provide the dynamic value of the <code>fn:doc</code>
                function.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component contains
                bindings from input URIs (a <emph>AnyURI</emph>) to documents (a
                <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a>).</td></tr>
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_collection_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                corresponds to the <term>available collections</term>
                in the [XPath/XQuery] dynamic context.  It contains the
                root nodes corresponding to the input collections, and
                is used to provide the dynamic value of the
                <code>fn:collection</code> function.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                contains bindings from input URIs (a <emph>AnyURI</emph>) to
                a sequence of nodes.</td></tr>
                </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      <tr><td rowspan="1" colspan="1"/>
          <td id="xq_default_collection_value_env" valign="top" rowspan="1" colspan="1"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a></td>
          <td rowspan="1" colspan="1">
            <table>
              <tbody>
                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component corresponds to the <term>default
                collection</term> in the [XPath/XQuery] dynamic context.
                It contains the sequence of nodes corresponding to the
                default collection, and is used to provide the dynamic
                value of the <code>fn:collection</code> function when called with
                no arguments.</td></tr>

                <tr><td rowspan="1" colspan="1">The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component contains a sequence of nodes.</td></tr>
  
              </tbody>
            </table>
          </td>
          <td rowspan="1" colspan="1"/>
      </tr>
      </tbody>
      </table>

      <p id="xq_default_dyn_env">The initial values for the dynamic
      context are defined in <xspecref spec="XQ" ref="id-xq-context-components"/> and <xspecref spec="XP" ref="id-xp-context-components"/>. The corresponding initial
      dynamic environment is denoted by <a href="#xq_default_dyn_env" class="env">dynEnvDefault</a> in the
      Formal Semantics.</p>

      <p id="fs_builtin_vars">The following Formal Semantics variables
      represent the <term>context item</term>, <term>context
      position</term>, and <term>context size</term> properties of the
      dynamic context:</p>
  
      <table summary="" border="1">
       <tbody>
        <tr><td rowspan="1" colspan="1">Built-in Variable  </td><td rowspan="1" colspan="1">Represents:</td></tr>
        <tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a></td><td rowspan="1" colspan="1">context item</td></tr>
        <tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a></td><td rowspan="1" colspan="1">context position </td></tr>
        <tr><td rowspan="1" colspan="1"><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a></td><td rowspan="1" colspan="1">context size</td></tr>
       </tbody>
      </table>
  
      <p>Within this document, variables with the "fs" prefix are
      reserved for use in the formal specification. Values of
      <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> and <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> can be obtained by invoking the
      <code>fn:position</code> and <code>fn:last</code> functions, respectively. Note that
      the type for those variables is obtained as for any other
      variables. As expected the type of <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> and <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>
      is always <code>xs:integer</code> while the type of <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> depends on the
      context in which it is being used.</p>
    </div3>
  </div2>

  <div2 id="id-processing-model">
    <head>処理モデル</head>

    <p>This section reviews the processing model for [XPath/XQuery]. The
    [XPath/XQuery] processing model is defined normatively in <xspecref spec="XQ" ref="id-processing-model"/>.  This section also explains
    how the main notations (normalization rules, static typing rules,
    and dynamic evaluation rules) relate to the phases in that
    processing model.</p>

    <div3 id="id-fs-processing-model">
      <head>処理モデル</head>

      <p>The following figure depicts the [XPath/XQuery] processing
      model</p>

<graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XQuery.gif" alt="Processing Model Overview" role="xquery" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>

      <p>Figure 1: Processing Model Overview</p>

      <p>This processing model is not intended to describe an actual
      implementation, although a naive implementation might be based
      upon it. It does not prescribe an implementation technique, but
      any implementation should produce the same results as obtained
      by following this processing model and applying the rest of the
      Formal Semantics specification.</p>

      <p>Query processing consists of two phases: a static analysis
      phase and a dynamic evaluation phase.  Static analysis is further
      divided into four sub-phases.   Typically, each phase consumes the result of
      the previous phase and generates output for the next phase. When
      processing query prologs, these phases may be mutually dependent
      (See <specref ref="id-query-prolog"/>).
      For       each processing phase, we point to the relevant notations
      introduced later in the document.</p>

      <p><termdef id="dt-static-analysis" term="static analysis       phase">The <term>static analysis phase</term> depends on the
      expression itself and on the static context. The <term>static
      analysis phase</term> does not depend on input data (other than
      schemas).</termdef></p>

      <p>The purpose of the static analysis phase is to detect errors,
      e.g., syntax errors or type errors, at compile time rather than
      at run-time. If no error occurs, the result of static analysis
      could be some compiled form of [expression/query], suitable for
      execution by a compiled-[expression/query] processor. Static analysis
      consists of the following sub-phases:</p>

      <olist>
        <item>
          <p id="processing_parsing"><term>Parsing.</term> (Step SQ1
          in Figure 1). The grammar for the [XPath/XQuery] syntax is
          defined in <bibref ref="xquery"/>.  Parsing may generate syntax
          errors.  If no error occurs, an internal operation tree of
          the parsed query is created.</p>
        </item>

        <item>
          <p id="processing_context"><term>Static Context
          Processing.</term> (Steps SQ2, SQ3, and SQ4 in Figure
          1). The static semantics of [expression/query] depends on the
          input static context. The input static context needs to be
          generated before the [expression/query] can be analysed. In
          XQuery, the input static context may be defined by the
          processing environment and by declarations in the Query
          Prolog (See <specref ref="id-query-prolog"/>). In XPath, the
          input static context is defined by the processing
          environment. The static context is denoted by
          <a href="#xq_stat_env_def" class="env">statEnv</a>. </p>
        </item>

        <item>
          <p id="processing_normalization"><term>Normalization.</term>
          (Step SQ5 in Figure 1). To simplify the semantics
          specification, some normalization is performed on the
          [expression/query]. The [XPath/XQuery] language provides many powerful
          features that make [expression/query]s simpler to write and use,
          but are also redundant. For instance, a complex
          <code>for</code> expression might be rewritten as a
          composition of several simple <code>for</code>
          expressions. The language composed of these simpler
          [expression/query] is called the [XPath/XQuery] <emph>Core
          language</emph> and is described by a grammar which is a
          subset of the XQuery grammar. The grammar of the [XPath/XQuery]
          Core language is given in <specref ref="sec_core"/>.</p>

          <p>During the normalization phase, each [XPath/XQuery]
          [expression/query] is mapped into its equivalent [expression/query] in
          the Core. (Note that this has nothing to do with Unicode
          Normalization, which works on character strings.)
          Normalization works by recursive application of the
          normalization rules over a given expression.</p>

          <p>Specifically the normalization phase is defined in terms
          of the static part of the context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a
          [expression/query] (<emph>Expr</emph>) abstract syntax tree. Formal
          notations for the normalization phase are introduced in
          <specref ref="sec_normalization"/>.</p>

          <p>After normalization, the full semantics is obtained by
          giving a semantics to the normalized Core [expression/query]. This
          is done during the last two phases.</p>
        </item>
        <item>
          <p id="processing_static"><term>Static type analysis.</term>
          (Step SQ6 in Figure 1).  Static type analysis is optional.
          If this phase is not supported, then normalization is
          followed directly by dynamic evaluation.  </p> <p>Static
          type analysis checks whether each [expression/query] is
          well-typed, and if so, determines its static type. Static
          type analysis is defined only for Core [expression/query]. Static
          type analysis works by recursive application of the static
          typing rules over a given expression.</p>

          <p>If the [expression/query] is not well-typed, static type
          analysis yields a <emph>type error</emph>. For instance, a
          comparison between an integer value and a string value might
          be detected as an type error during the static type
          analysis. If static type analysis succeeds, it yields an
          abstract syntax tree where each sub-expression is associated
          with its static type.</p>

          <p>More precisely, the static analysis phase is defined in
          terms of the static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a Core
          [expression/query] (<emph>CoreExpr</emph>).  Formal notations for
          the static analysis phase are introduced in <specref ref="sec_static"/>.</p>

          <p>Static typing does not imply that the content of XML
          documents must be rigidly fixed or even known in advance.
          The [XPath/XQuery] type system accommodates
          <quote>flexible</quote> types, such as elements that can
          contain any content.  Schema-less documents are handled in
          [XPath/XQuery] by associating a standard type with the document,
          such that it may include any legal XML content.</p>
        </item>
      </olist>

      <p>If the static analysis phase succeeds, the dynamic evaluation
      phase (sometimes also called <quote>execution</quote>) evaluates
      a query on input document(s).</p>

      <olist>
        <item>
          <p id="dyn_processing_context"><term>Dynamic Context
          Processing.</term> (Steps DQ2 and DQ3 in Figure 1).The
          dynamic semantics of [expression/query] depends on the dynamic
          input context. The dynamic input context needs to be
          generated before the [expression/query] can be evaluated. The
          dynamic input context may be defined by the processing
          environment and by statements in the Query Prolog (See
          <specref ref="id-query-prolog"/>). In XPath, the dynamic
          input context is defined by the processing environment. The
          static input context is denoted by <a href="#xq_dyn_env_def" class="env">dynEnv</a>.</p>
        </item>
        <item>
          <p id="processing_dynamic"><term>Dynamic Evaluation.</term>
          (Steps DQ4 and DQ5 in Figure 1). This phase computes the
          value of an [expression/query].  The semantics of evaluation is
          defined only for Core [expression/query] terms. The formal
          description of evaluation works by recursive application of
          the dynamic evaluation rules over a given expression. (Note
          that in practice some implementations may prefer top-down
          evaluation strategies.)  Evaluation may result in a value OR
          a dynamic error, which may be a non-type error or a type
          error.  If static typing of an expression does not raise a
          type error, then dynamic evaluation of the same expression
          will not raise a type error (and thus dynamic type checking
          can be avoided when static typing is enabled). Dynamic
          evaluation may still raise a non-type error.</p>

          <p>The dynamic evaluation phase is defined in terms of the
          static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and evaluation context
          (<a href="#xq_dyn_env_def" class="env">dynEnv</a>), and a Core [expression/query]
          (<emph>CoreExpr</emph>). Formal notations for the dynamic
          evaluation phase are introduced in <specref ref="sec_evaluation"/>.</p>
        </item>
      </olist>

      <p>Static type analysis catches only certain classes of
      errors. For instance, it can detect a comparison operation
      applied between incompatible types (e.g., <code>xs:int</code>
      and <code>xs:date</code>). Some other classes of errors cannot
      be detected by the static analysis and are only detected at
      evaluation time. For instance, whether an arithmetic expression
      on 32 bit integers (<code>xs:int</code>) yields an out-of-bound
      value can only be detected at run-time by looking at the
      data.</p>

      <p>While implementations are free to implement different
      processing models, the [XPath/XQuery] static semantics relies on the
      existence of a static type analysis phase that precedes any
      access to the input data.</p>

      <p>The above processing phases are all internal to the
      [XPath/XQuery] processor. They do not deal with how the [XPath/XQuery]
      processor interacts with the outside world, notably how it
      accesses actual documents and types. A typical [expression/query]
      engine would support at least three other important processing
      phases:</p>

      <olist>
        <item>
          <p><term>Schema Import Processing.</term> The [XPath/XQuery]
          type system is based on XML Schema. In order to perform
          dynamic or static typing, the [XPath/XQuery] processor needs to
          build type descriptions that correspond to the schema(s) of
          the input documents. This phase is achieved by mapping all
          schemas required by the [expression/query] into the [XPath/XQuery]
          type system. The XML Schema import phase is described in
          <specref ref="sec_importing_schema"/>.</p>
        </item>
        <item>
          <p><term>Data Model Generation.</term> Expressions are
          evaluated on values in the <bibref ref="xpath-datamodel"/>. XML documents
          must be loaded into the <bibref ref="xpath-datamodel"/> before the evaluation
          phase. This is described in the <bibref ref="xpath-datamodel"/> and is not
          discussed further here.</p>
        </item>
        <item>
          <p><term>Serialization.</term> Once the [expression/query] is
          evaluated, processors might want to serialize the result of
          the [expression/query] as actual XML documents. Serialization of
          data model instances is described in
          <bibref ref="xslt-xquery-serialization"/> and is not discussed further
          here.</p>
        </item>
      </olist>

      <p>The parsing phase is not specified formally; the formal
      semantics does not define a formal model for the syntax trees,
      but uses the [XPath/XQuery] concrete syntax directly.  More details
      about parsing for XQuery 1.0 can be found in the <bibref ref="xquery"/>
      document and more details about parsing for XPath 2.0 can be
      found in the <bibref ref="xpath20"/> document. No further discussion of
      parsing is included here.</p>

    </div3>

    <div3 id="sec_normalization">
      <head>正規化写像ルール</head>

      <p>Normalization is specified using <emph>mapping</emph> rules,
      which describe how a [XPath/XQuery] expression is rewritten into an
      expression in the [XPath/XQuery] Core. Mapping rules are also used
      in <specref ref="sec_importing_schema"/> to specify how XML
      Schemas are imported into the [XPath/XQuery] type system.</p>

      <smnotation>
        <p>Mapping rules are written using a square bracket notation,
          as follows:</p>

        <mapping>
          <xquery>
            <expression> 
              <map><expression>Object</expression></map><subscript>Subscript</subscript>,
              <emph>premises</emph>
            </expression>
          </xquery>
          <core>
            <expression>
              <emph>Mapped Object</emph>
            </expression>
          </core>
        </mapping>
        
        <p>The original <quote>object</quote>, and an optional list of
        premises, is written above the <term>=</term> sign. The
        rewritten <quote>object</quote> is written beneath the
        <term>=</term> sign. The subscript is used to indicate what
        kind of <quote>object</quote> is mapped, and sometimes to pass
        some information between mapping rules. For instance, the
        mapping rule <map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a> is
        used in the normalization of <specref ref="id-function-calls"/> and passes a sequence type as a
        parameter during normalization.</p>

        <p>Since normalization is always applied in the presence of a 
        static context, the above rule is a shorthand for:</p>

        <display>
         <infergr>
          <infer><prejudge><clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>premises</expression></clause></prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
              <map><expression>Object</expression></map>
              <subscript>Subscript</subscript>
              =
              Mapped Object
            </expression>
          </clause>
          </postjudge>
         </infer>
         </infergr>
        </display>

        <p>Most normalization rules have no premises, so they are
        omitted.  The static environment is used in certain
        normalization rules (e.g. for normalization of function
        calls).  To keep the notation simpler, the static environment
        is not written in the normalization rules, but it is assumed
        to be available.</p>

        <p id="jd_map_expr">The normalization rule that is used to map
        <quote>top-level</quote> expressions in the [XPath/XQuery] syntax
        into expressions in the [XPath/XQuery] Core is:</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>
      	      <emph>CoreExpr</emph>
      	    </expression>
      	  </core>
      	</mapping>

        <p>which indicates that the expression <emph>Expr</emph> is normalized
        to the expression <emph>CoreExpr</emph> in the [XPath/XQuery] Core
        (with the implied <a href="#xq_stat_env_def" class="env">statEnv</a>). Note that <emph>Expr</emph> within
        the square brackets are the expression being normalized, while
        the <emph>Expr</emph> in the subscript indicate that this is the main
        normalization rule that applies to expressions. For instance,
        here is the normalization rule applied to the literal integer
        <code>1</code>.</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>1</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>1</expression>
      	  </core>
      	</mapping>

        <p>To simplify the specification in some cases, some further
        normalization may be used on the right-hand side of a
        normalization rule. For instance, the following normalization
        rules for the <code>/</code> operator applies normalization to
        the expanded expression on the right-hand side.</p>

      <mapping>
       <xquery>
         <expression><map>/</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><map>(<code>fn:root</code>(self::node()) treat as document-node())</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </core>
      </mapping>
      </smnotation>

      <smexample>
        <p>For instance, the following [expression/query]</p>

<eg xml:space="preserve">
    for $i in (1, 2),
        $j in (3, 4)
    return
      element pair { ($i,$j) }
</eg>

        <p>is normalized to the Core expression</p>

<eg xml:space="preserve">
    for $i in (1, 2) return
      for $j in (3, 4) return
          element pair { ($i,$j) }
</eg>

        <p>in which the <quote>FWLR</quote> expression is
        mapped into a composition of two simpler "for" expressions.</p>
      </smexample>

    </div3>

    <div3 id="sec_static">
      <head>静的型の判断</head>

      <p>The static semantics is specified using <term>static typing
      rules</term>, which relate [XPath/XQuery] expressions to types and
      specify under what conditions an expression is well typed.</p>

      <smnotation>
        <p id="jd_has_type">The judgment</p>

        <display>
        <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
        </clause>
        </display>

        <p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the
        expression <emph>Expr</emph> has type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p>
      </smnotation>

      <smexample>
        <p>The result of static type inference is to associate a
        static type with every [expression/query], such that any evaluation
        of that [expression/query] is guaranteed to yield a value that
        belongs to that type.</p>

        <p>For instance, the following expression.</p>

<eg xml:space="preserve">
   let $v := 3 return $v+5
</eg>

        <p>has type <code>xs:integer</code>. This can be inferred as follows: the
        literal '3' has type integer, so the variable
        $v also has type integer. Since the sum of two integers is an
        integer, the complete expression has type integer.</p>
      </smexample>

      <smnote>
        <p>The type of an expression is computed by inference. Static
        typing rules define for each kind of expression how to compute
        the type of the expression given the types of its
        sub-expressions.  Here is a simple example:</p>

      	<infergr>
      	  <infer>
      	   <prejudge>
      	    <clause>
      	     <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	     <expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
      	    </clause>
      	    <clause>
      	     <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	     <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>   </expression>
      	    </clause>
      	    <clause>
      	     <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	     <expression> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>    </expression>
      	    </clause>
      	   </prejudge>
      	   <postjudge>
      	    <clause>
      	     <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	     <expression>
      	  <code>if</code> (<emph>Expr</emph><subscript>1</subscript>)
      	  <code>then</code> <emph>Expr</emph><subscript>2</subscript>
      	  <code>else</code> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> ( <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> )
      	    </expression>
      	    </clause>
      	   </postjudge>
      	  </infer>
      	</infergr>
  
      	<p>This rule states that if the conditional expression of an
      	<quote>if</quote> expression has type boolean, then the type
      	of the entire expression is one of the two types of its
      	<quote>then</quote> and <quote>else</quote> clauses.  Note
      	that the resulting type is represented as a union:
      	'(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)'.</p>

        <p>The the part after the <term>:</term> and before
        <term>|-</term> in the judgment <emph>below</emph> the
        line corresponds to some [expression/query], for which a type is
        computed. If the [expression/query] has been parsed into an internal
        abstract syntax tree, this usually corresponds to some node in
        that tree. The judgment usually has patterns in it (here
        <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>, and <emph>Expr</emph><subscript>3</subscript>) that need to be
        matched against the children of the node in the abstract
        syntax tree. The judgments <emph>above</emph> the line
        indicate things that need to be computed to use this rule; in
        this case, the types of the condition expression and the two
        branches of the if-then-else expression.  Once those types are
        computed (by further applying static typing rules recursively
        to those sub-expressions), then the type of the expression
        below the line can be computed.  This example illustrates a
        general feature of the [XPath/XQuery] type system: the type of an
        expression depends only on the type of its sub-expressions.
        Static type inference is recursive, following the abstract
        syntax of the [expression/query].  At each point in the recursion,
        an inference rule whose conclusion has a structure that
        matches that of the premise in question is sought.  If all the
        premises of a rule cannot be satisfied, then the static type
        inference has failed for the given expression, and the
        [expression/query] is not well-typed.</p>

     </smnote>

    </div3>

    <!-- ***************** Evaluation **************** -->

    <div3 id="sec_evaluation">
      <head>動的評価の判断</head>

      <p>The dynamic, or operational, semantics is specified using
      <term>dynamic evaluation rules</term>, which relate [XPath/XQuery]
      expressions to values, and in some cases specify the order in
      which an [XPath/XQuery] expression is evaluated.</p>

      <smnotation>
        <p id="jd_yields">The judgment</p>

        <display>
        <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
        </clause>
        </display>

        <p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a> and
        dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the expression <emph>Expr</emph>
        yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p>

      </smnotation>

      <p>The static environment is used in certain cases (e.g. for
      type matching) during evaluation. To keep the notation simpler,
      the static environment is not written in the dynamic evaluation
      rules, but it is assumed to be available.</p>

      <p>The inference rules used for dynamic evaluation, like those
      for static typing, follow a recursive structure, computing the
      value of expressions from the values of their
      sub-expressions.</p>

    </div3>

  </div2>

  <div2 id="sec_errors">
    <head>エラー処理</head>

    <p>Expressions can raise errors during static analysis or dynamic
    evaluation.  The <bibref ref="xpath-functions"/> <bibref ref="xquery"/>, and <bibref ref="xpath20"/>
    specify the conditions under which an expression or operator
    raises an error.  The user may raise an error explicitly by
    calling the <code>fn:error</code> function, which takes an optional item as
    an argument.</p>

    <p>This document does not describe formally the conditions under
    which dynamic errors are raised. Notably, it does not specify the
    error codes or the rules about errors and optimization, as
    described in <bibref ref="xquery"/>. Instead, this document
    describe the rules necessary to statically detect the subset of
    the [XPath/XQuery] dynamic errors known as <xtermref spec="XQ" ref="dt-type-error"/>.</p>

  </div2>

  <div2 id="id-important-concepts">
    <head>概念</head>

    <p>[XPath/XQuery] is most generally used to process
    <term>documents</term>. The representation of a document is
    normatively defined in <bibref ref="xpath-datamodel"/>. The functions used to
    access documents and collections are normatively defined in
    <bibref ref="xpath-functions"/>. </p>

    <div3 id="id-doc-order">
      <head>文書順</head>

      <p>Document order is defined in <bibref ref="xpath-datamodel"/>.</p>
    </div3>


      <div3 id="id-atomization">
        <head>原子化</head>

        <p>Atomization converts an item sequence into a sequence of
        atomic values and is implemented by the <code>fn:data</code> function.
        Atomization is applied to a value when the value is used in a
        context in which a sequence of atomic values is required.</p>
      </div3>
  
    <div3 id="id-ebv">
      <head>有効ブール値</head>

      <p>If a sequence of items is encountered where a boolean value
      is expected, the item sequence's effective boolean value is
      used. The <code>fn:boolean</code> function returns the effective boolean
      value of an item sequence.</p>
    </div3>
  
    <div3 id="id-input-sources"><head>入力源</head>
      <p>[XPath/XQuery] has several functions that provide access to input
      data, described in <xspecref spec="XQ" ref="id-input-sources"/>. These functions are of particular
      importance because they provide a way in which an expression can
      reference a document or a collection of documents. The dynamic
      semantics of these input functions are described in more detail
      in <bibref ref="xpath-functions"/>.</p>
    </div3>

    <div3 id="id-uri-literals" role="xquery">
      <head>URI リテラル</head>

      <p>In certain places in the XQuery grammar, a statically known
      valid absolute URI is required. These places are denoted by the
      grammatical symbol <emph>URILiteral</emph>, and are treated as described
      in <bibref ref="xquery"/>.</p>

    </div3>
  </div2>

  <div2 id="id-type-conversion">
    <head>型</head>

    <div3 id="id-predefined-types">
      <head>既定義スキーマ型</head>

      <p>All the built-in types of XML Schema are recognized by
      [XPath/XQuery]. In addition, [XPath/XQuery] recognizes the predefined
      types <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
      and the duration subtypes <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and
      <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      . The definition of those types in the
      [XPath/XQuery] type system is given below.</p>

      <p><termdef id="dt-xs_anyType" term="xs:anyType"> The following
      type definition of <term><phrase><code>xs:anyType</code></phrase></term>
      reflects the semantics of the Ur type from Schema in the
      [XPath/XQuery] type system.</termdef></p>

<eg xml:space="preserve">
  define type xs:anyType restricts xs:anyType {
    attribute * of type xs:anySimpleType*,
    ( xs:anyAtomicType* | ( element * of type xs:anyType | text | comment | processing-instruction )* )
  }
</eg>

      <p><termdef id="dt-xs_anySimpleType" term="xs:anySimpleType">
      The following type definition of
      <term><phrase><code>xs:anySimpleType</code></phrase></term> reflects the
      semantics of the Ur simple type from Schema in the [XPath/XQuery]
      type system.</termdef></p>

<eg xml:space="preserve">
  define type xs:anySimpleType restricts xs:anyType {
    xs:anyAtomicType*
  }
</eg>

      <p>The name of the Ur simple type is <code>xs:anySimpleType</code>. It is
      derived by restriction from <code>xs:anyType</code>, its content is a
      sequence any atomic types.</p>

      <p><termdef id="dt-xs_anyAtomicType" term="xs:anyAtomicType"><phrase>The following type definition
      of <term><phrase><a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></phrase></term> reflects
      the semantics of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> in the [XPath/XQuery] type
      system.</phrase></termdef></p>

<eg xml:space="preserve">
  define type xs:anyAtomicType restricts xs:anySimpleType {
    ( xs:string
    | xs:boolean
    | xs:decimal
    | xs:float
    | xs:double
    | xs:duration
    | xs:dateTime
    | xs:time
    | xs:date
    | xs:gYearMonth
    | xs:gYear
    | xs:gMonthDay
    | xs:gDay
    | xs:gMonth
    | xs:hexBinary
    | xs:base64Binary
    | xs:anyURI
    | xs:QName
    | xs:NOTATION
    | xs:untypedAtomic )
  }
</eg>

      <p><termdef id="dt-primitive-types" term="primitive types"> The
      following type definitions of <term> the XML Schema primitive
      types</term> reflect the semantics of the primitive types from
      Schema in the [XPath/XQuery] type system.</termdef></p>

<eg xml:space="preserve">
  define type xs:string       restricts xs:anyAtomicType
  define type xs:boolean      restricts xs:anyAtomicType
  define type xs:decimal      restricts xs:anyAtomicType
  define type xs:float        restricts xs:anyAtomicType
  define type xs:double       restricts xs:anyAtomicType
  define type xs:duration     restricts xs:anyAtomicType
  define type xs:dateTime     restricts xs:anyAtomicType
  define type xs:time         restricts xs:anyAtomicType
  define type xs:date         restricts xs:anyAtomicType
  define type xs:gYearMonth   restricts xs:anyAtomicType
  define type xs:gYear        restricts xs:anyAtomicType
  define type xs:gMonthDay    restricts xs:anyAtomicType
  define type xs:gDay         restricts xs:anyAtomicType
  define type xs:gMonth       restricts xs:anyAtomicType
  define type xs:hexBinary    restricts xs:anyAtomicType
  define type xs:base64Binary restricts xs:anyAtomicType
  define type xs:anyURI       restricts xs:anyAtomicType
  define type xs:QName        restricts xs:anyAtomicType
  define type xs:NOTATION     restricts xs:anyAtomicType
</eg>

      <p>All of those primitive types derive from
      <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>. Note that the value space of each atomic
      type (such as <code>xs:string</code>) does not appear. The value space for
      each type is built-in and is as defined in <bibref ref="xmlschema-2"/>.</p>

      <p><termdef id="dt-xs_untypedAtomic" term="xs:untypedAtomic">The type
      <term><phrase><a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></phrase></term> is defined as
      follows.</termdef></p>

<eg xml:space="preserve">
  define type xs:untypedAtomic restricts xs:anyAtomicType
</eg>

      <p>Note that this rule does not indicate the value space of
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>. By definition, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> has the
      same value space as <code>xs:string</code>.</p>

      <p>The following example shows two atomic values. The first one
      is a value of type string containing "Database". The second one
      is an untyped atomic value containing "Database".</p>

<eg xml:space="preserve">
  "Databases" of type xs:string
  "Databases" of type xs:untypedAtomic
</eg>

      <p><termdef id="dt-xs_untyped" term="xs:untyped">The type
      <term><phrase><a href="#dt-xs_untyped"><code>xs:untyped</code></a></phrase></term> is defined as
      follows.</termdef></p>

<eg xml:space="preserve">
  define type xs:untyped restricts xs:anyType {
    attribute * of type xs:untypedAtomic*,
    ( element * of type xs:untyped | text | comment | processing-instruction )*
  }
</eg>

      <p><termdef id="dt-derived-types" term="derived types">The
      following type definitions of the <term>XML Schema derived
      types</term> reflect the semantics of the XML Schema types
      derived by restriction from another atomic type.</termdef></p>

<eg xml:space="preserve">
  define type xs:normalizedString   restricts xs:string
  define type xs:token              restricts xs:normalizedString
  define type xs:language           restricts xs:token
  define type xs:NMTOKEN            restricts xs:token
  define type xs:Name               restricts xs:token
  define type xs:NCName             restricts xs:Name
  define type xs:ID                 restricts xs:NCName
  define type xs:IDREF              restricts xs:NCName
  define type xs:ENTITY             restricts xs:NCName
  define type xs:integer            restricts xs:decimal
  define type xs:nonPositiveInteger restricts xs:integer
  define type xs:negativeInteger    restricts xs:nonPositiveInteger
  define type xs:long               restricts xs:integer
  define type xs:int                restricts xs:long
  define type xs:short              restricts xs:int
  define type xs:byte               restricts xs:short
  define type xs:nonNegativeInteger restricts xs:integer
  define type xs:unsignedLong       restricts xs:nonNegativeInteger
  define type xs:unsignedInt        restricts xs:unsignedLong
  define type xs:unsignedShort      restricts xs:unsignedInt
  define type xs:unsignedByte       restricts xs:unsignedShort
  define type xs:positiveInteger    restricts xs:nonNegativeInteger
</eg>

      <p>Three XML Schema built-in derived types are derived by list,
      as follows. Note that those derive directly from
      <code>xs:anySimpleType</code>, since they are derived by list, and that
      their value space is defined using a <quote>one or more</quote>
      occurrence indicator.</p>

<eg xml:space="preserve">
  define type xs:NMTOKENS restricts xs:anySimpleType { xs:NMTOKEN+ }
  define type xs:IDREFS   restricts xs:anySimpleType { xs:IDREF+ }
  define type xs:ENTITIES restricts xs:anySimpleType { xs:ENTITY+ }
</eg>

     <p>For example, here is an element whose content is of type
     <code>xs:IDREFS</code>.</p>

<eg xml:space="preserve">
  element a of type xs:IDREFS {
    "id1" of type xs:IDREF,
    "id2" of type xs:IDREF,
    "id3" of type xs:IDREF
  }
</eg>

      <p>Note that the type name <code>xs:IDREFS</code> derives from
      <code>xs:anySimpleType</code>, but not from <code>xs:IDREF</code>. As a consequence,
      calling the following three XQuery functions with the element
      <code>a</code> as a parameter succeeds for <code>f1</code> and
      <code>f2</code>, but raises a type error for
      <code>f3</code>.</p>

<eg xml:space="preserve">
  declare function f1($x as element(*,xs:anySimpleType)) { $x }
  declare function f2($x as element(*,xs:IDREFS)) { $x }
  declare function f3($x as element(*,xs:IDREF)) { $x }
</eg>

      <p><termdef id="dt-xs_durations" term="Totally ordered duration       types"><phrase>The <term>totally ordered duration types</term>,
      <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> and <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      , are derived
      by restriction from <code>xs:duration</code>.</phrase></termdef></p>

<eg xml:space="preserve">
  define type xs:yearMonthDuration restricts xs:duration
  define type xs:dayTimeDuration   restricts xs:duration
</eg>

      <p><termdef id="dt-fs_numeric" term="fs:numeric">In addition,
      the Formal Semantics uses the additional type <emph>fs:</emph><code>numeric</code>. This
      type is necessary for the specification of some of XPath type
      conversion rules.  It is defined as follows.</termdef></p>

<eg xml:space="preserve">
  define type fs:numeric restricts xs:anyAtomicType { xs:decimal | xs:float | xs:double }
</eg>

    </div3>

    <div3 id="id-typed-value">
      <head>型付けられた値と文字列値</head>
      <p>The typed value of a node is computed by the <code>fn:data</code>
      function, and the string value of a node is computed by the
      <code>fn:string</code> function, defined in <bibref ref="xpath-functions"/>.
The normative definitions of typed value and string value are defined in <bibref ref="xpath-datamodel"/>.
</p>
    </div3>

    <div3 id="id-sequencetype"> 
      <head>SequenceType の構文</head> 

      <smintro>
        <p>Sequence types can be used in [XPath/XQuery] to refer to an XML
        Schema type. Sequence types are used to declare the types of
        function parameters and in several [XPath/XQuery] expressions.</p>
  
        <p>The syntax of sequence types is described by the following
        grammar productions.</p>

    <scrap headstyle="show"> 
      <head>SequenceType</head> 
      <prod num="119 (XQuery)" id="doc-xquery-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod>
      <prod num="121 (XQuery)" id="doc-xquery-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod>
      <prod num="120 (XQuery)" id="doc-xquery-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs></prod>
      <prod num="122 (XQuery)" id="doc-xquery-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
      <prod num="123 (XQuery)" id="doc-xquery-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod>
      <prod num="125 (XQuery)" id="doc-xquery-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod>
      <prod num="133 (XQuery)" id="doc-xquery-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod>
      <prod num="135 (XQuery)" id="doc-xquery-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod>
      <prod num="136 (XQuery)" id="doc-xquery-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt></rhs></prod>
      <prod num="129 (XQuery)" id="doc-xquery-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod>
      <prod num="131 (XQuery)" id="doc-xquery-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod>
      <prod num="132 (XQuery)" id="doc-xquery-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod>
      <prod num="134 (XQuery)" id="doc-xquery-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod>
      <prod num="138 (XQuery)" id="doc-xquery-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
      <prod num="130 (XQuery)" id="doc-xquery-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod>
      <prod num="137 (XQuery)" id="doc-xquery-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
      <prod num="139 (XQuery)" id="doc-xquery-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
      <prod num="128 (XQuery)" id="doc-xquery-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod>
      <prod num="127 (XQuery)" id="doc-xquery-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod>
      <prod num="126 (XQuery)" id="doc-xquery-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod>
      <prod num="124 (XQuery)" id="doc-xquery-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod>
    </scrap> 

        <smcore>
          <p>The Core grammar productions for sequence types are:</p>
      
  <scrap headstyle="show">
   <head/>
   <prod num="76 (Core)" id="doc-core-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod>
   <prod num="78 (Core)" id="doc-core-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod>
   <prod num="77 (Core)" id="doc-core-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs></prod>
   <prod num="79 (Core)" id="doc-core-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
   <prod num="80 (Core)" id="doc-core-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod>
   <prod num="82 (Core)" id="doc-core-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod>
   <prod num="90 (Core)" id="doc-core-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod>
   <prod num="92 (Core)" id="doc-core-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod>
   <prod num="93 (Core)" id="doc-core-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementName" xlink:type="simple">ElementName</nt></rhs></prod>
   <prod num="86 (Core)" id="doc-core-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod>
   <prod num="88 (Core)" id="doc-core-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod>
   <prod num="89 (Core)" id="doc-core-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod>
   <prod num="91 (Core)" id="doc-core-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod>
   <prod num="95 (Core)" id="doc-core-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
   <prod num="87 (Core)" id="doc-core-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod>
   <prod num="94 (Core)" id="doc-core-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
   <prod num="96 (Core)" id="doc-core-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
   <prod num="85 (Core)" id="doc-core-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod>
   <prod num="84 (Core)" id="doc-core-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod>
   <prod num="83 (Core)" id="doc-core-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod>
   <prod num="81 (Core)" id="doc-core-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod>
  </scrap>
        </smcore>

        <p>The semantics of SequenceTypes is defined by means of
        normalization rules from SequenceTypes into types in the
        [XPath/XQuery] type system (See <specref ref="sec_types"/>).</p>

        <p>However, the [XPath/XQuery] type system not being part of the
        [XPath/XQuery] syntax, the SequenceType syntax is still part of
        the [XPath/XQuery] Core. Normalization from SequenceTypes to types
        is not applied during the normalization phase but whenever a
        dynamic evaluation or static typing rule requires it.</p>

      </smintro>
  
    </div3>
      <div3 id="id-sequencetype-matching">
        <head>SequenceType の照合</head>
    
        <smintro>
          <p>During processing of a query, it is sometimes necessary
          to determine whether a given value matches a type that was
          declared using the SequenceType syntax. This process is
          known as SequenceType matching, and is formally specified in
          <specref ref="sec_type_matching"/>.</p>
        </smintro>

        <smnotation>
          <p id="jd_map_sequencetype">To define normalization of
          SequenceTypes to the [XPath/XQuery] type system, the following
          auxiliary mapping rule is used.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression>
             </core>
            </mapping>
        
          <p>specifies that <emph>SequenceType</emph> is mapped to a <a href="#doc-fs-Type"><emph>Type</emph></a>,
          in the [XPath/XQuery] type system.</p>
        </smnotation>
        
        <smnorm>
          <p>OccurenceIndicators are left unchanged when normalizing
          SequenceTypes into [XPath/XQuery] types. Each kind of
          SequenceType component is normalized separately into the
          [XPath/XQuery] type system.</p>

            <mapping>
             <xquery>
              <expression>
               <map><a href="#doc-core-ItemType"><emph>ItemType</emph></a> <emph>OccurrenceIndicator</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               <map><a href="#doc-core-ItemType"><emph>ItemType</emph></a></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> <emph>OccurrenceIndicator</emph>
              </expression>
             </core>
            </mapping>
        
            <p>The <quote>empty-sequence()</quote> sequence type is
            mapped to the empty type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>empty-sequence()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               empty
              </expression>
             </core>
            </mapping>

            <p>An atomic type is normalized to itself in the
            [XPath/XQuery] type system.</p>

            <mapping>
             <xquery>
              <expression>
               <map><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType without content
            or with a wildcard and no type name is normalized into a
            wildcard element type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type <code>xs:anyType</code>
              </expression>
             </core>
            </mapping>
        
            <mapping>
             <xquery>
              <expression>
               <map>element(*)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type <code>xs:anyType</code>
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with a wildcard
            and a type name is normalized into a wildcard element type
            with a corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element * of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>element(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>?)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element * nillable of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with a name and
            a type name is normalized into an element type with a
            corresponding type name. The presence of a
            <quote>?</quote> after the type name indicates a nillable
            element.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>?)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> nillable of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <p>An <quote>element</quote> SequenceType with only a name
            is normalized into a <emph>nillable</emph> element type
            with a corresponding name. The reason for the
            normalization to allow nillable elements is because the
            semantics of SequenceTypes in that case allows it to match
            every possible element with that names, regardless of its
            type or nilled property.</p>

            <mapping>
             <xquery>
              <expression>
               <map>element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> nillable of type <code>xs:anyType</code>
              </expression>
             </core>
            </mapping>
       
            <p>A <quote>schema-element</quote> SequenceType with an
            element declaration is normalized into a reference to the
            corresponding global element declaration.</p>

            <mapping>
             <xquery>
              <expression>
               <map>schema-element(<a href="#doc-fs-ElementName"><emph>ElementName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
              </expression>
             </core>
            </mapping>
        
            <p>An <quote>attribute</quote> SequenceType without
            content or with a wildcard and no type name is normalized
            into a wildcard attribute type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type <code>xs:anySimpleType</code> 
              </expression>
             </core>
            </mapping>
        
            <mapping>
             <xquery>
              <expression>
               <map>attribute(*)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type <code>xs:anySimpleType</code> 
              </expression>
             </core>
            </mapping>

            <p>An <quote>attribute</quote> SequenceType with a
            wildcard and a type name is normalized into a wildcard
            attribute type with a corresponding type name.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute(*,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                attribute * of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <p>An <quote>attribute</quote> SequenceType with a name
            and a type name is normalized into an attribute type with
            a corresponding type name.</p>

            <mapping>
             <xquery>
              <expression>
               <map>attribute(<a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>,<a href="#doc-fs-TypeName"><emph>TypeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              </expression>
             </core>
            </mapping>

            <p>A <quote>schema-attribute</quote> SequenceType with an
            attribute declaration is normalized into a reference to
            the corresponding global attribute declaration.</p>

            <mapping>
             <xquery>
              <expression>
               <map>schema-attribute(<a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
              </expression>
             </core>
            </mapping>

            <p>A <quote>document-node()</quote> sequence types is
            normalized into the corresponding document type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>document-node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                document { (element * of type <code>xs:anyType</code> | text | comment | processing-instruction)* }
              </expression>
             </core>
            </mapping>

            <p>A <quote>document-node</quote> sequence type with an
            element test (resp. a schema element test) is normalized
            into the corresponding document type, whose content is the
            normalization of the element test (resp. schema element
            test), interleaved with an arbitrary sequence of
            processing instruction, comment, and text nodes.</p>

            <mapping>
             <xquery>
              <expression>
               <map>document-node(<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                document {
                <map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> &amp;
                ( processing-instruction | comment ) *}
              </expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>document-node(<emph>SchemaElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                document {
                <map><emph>SchemaElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> &amp;
                ( processing-instruction | comment ) *}
              </expression>
             </core>
            </mapping>

            <p>A <quote>processing-instruction()</quote> SequenceType
            is normalized into the corresponding
            processing-instruction type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>processing-instruction()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>processing-instruction</expression>
             </core>
            </mapping>

            <p>The [XPath/XQuery] type system does not model the target of
            a processing-instruction, which is treated as a dynamic
            property. Therefore a
            <quote>processing-instruction</quote> SequenceType with a
            string or NCName parameter is normalized into an optional
            processing-instruction type.</p>

            <mapping>
             <xquery>
              <expression>
               <map>processing-instruction(<emph>StringLiteral</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>processing-instruction?</expression>
             </core>
            </mapping>

            <mapping>
             <xquery>
              <expression>
               <map>processing-instruction(<emph>NCName</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>processing-instruction?</expression>
             </core>
            </mapping>

            <p>A <quote>comment()</quote> SequenceType is normalized
            into the corresponding comment type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>comment()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>comment</expression>
             </core>
            </mapping>

            <p>A <quote>text()</quote> SequenceType is normalized into
            the corresponding text type.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map>text()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                text
              </expression>
             </core>
            </mapping>

            <p>The <quote>node()</quote> SequenceType denotes any
            node. It is normalized into a choice between the
            corresponding wildcard types for each kind of node.</p>

            <mapping>
             <xquery>
              <expression>
               <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                (element * of type <code>xs:anyType</code> | attribute * of type
                <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction)* } | comment | processing-instruction)
              </expression>
             </core>
            </mapping>

            <p>The <quote>item()</quote> SequenceType denotes any node
            or atomic value. It is normalized into a choice between
            the corresponding wildcard types for each kind of nodes or
            atomic values.</p>

            <mapping>
             <xquery>
              <expression>
               <map>item()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
                (element * of type <code>xs:anyType</code> | attribute * of type <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction)* } | comment |
                processing-instruction | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> )
              </expression>
             </core>
            </mapping>

        </smnorm>
      </div3>
  
  
  </div2>

  <div2 id="comments">
    <head>コメント</head>
  
    <scrap headstyle="show">
      <head/>
      <prod num="151 (XQuery)" id="doc-xquery-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs></prod>
      <prod num="159 (XQuery)" id="doc-xquery-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod>
    </scrap>

    <p>Comments are lexical constructs only, and have no effect on the
    meaning of the query, and therefore do not have any formal
    semantics.</p>
  
  </div2>

  <div2 id="xml-terminals">
    <head>XML で定義された終端記号</head>

    <p>The following terminals are defined by XML.</p>
	
	<scrap headstyle="show">  
		<head/>
		<prod num="152 (XQuery)" id="prod-xquery-PITarget"><lhs>PITarget</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-PITarget" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-PITarget]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="153 (XQuery)" id="prod-xquery-CharRef"><lhs>CharRef</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-CharRef" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-CharRef]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="154 (XQuery)" id="prod-xquery-QName"><lhs>QName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="155 (XQuery)" id="prod-xquery-NCName"><lhs>NCName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="156 (XQuery)" id="prod-xquery-S"><lhs>S</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="157 (XQuery)" id="prod-xquery-Char"><lhs>Char</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod> 	   
	</scrap>

  </div2>

</div1>

<div1 id="id-expressions">
  <head>式</head>

  <p>This section gives the semantics of all the [XPath/XQuery]
  expressions. The organization of this section parallels the
  organization of <xspecref spec="XQ" ref="id-expressions"/>.</p>

  <scrap headstyle="show"><head/>
    <prod num="31 (XQuery)" id="doc-xquery-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
    <prod num="32 (XQuery)" id="doc-xquery-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FLWORExpr" xlink:type="simple">FLWORExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod>
    <prod num="1 (XPath)" id="doc-xpath-XPath"><lhs>XPath</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt></rhs></prod>
  </scrap>

  <p>For each expression, a short description and the relevant grammar
  productions are given. The semantics of an expression includes the
  normalization, static analysis, and dynamic evaluation
  phases. Recall that normalization rules translate [XPath/XQuery] syntax
  into Core syntax. In the sections that contain normalization rules,
  the Core grammar productions into which the expression is normalized
  are also provided. After normalization, sections on static type
  inference and dynamic evaluation define the static type and dynamic
  value for the Core expression.</p>

  <smcore>
    <p>The Core grammar productions for expressions are:</p>

    <scrap headstyle="show"><head/>
      <prod num="22 (Core)" id="doc-core-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
      <prod num="23 (Core)" id="doc-core-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-FLWORExpr" xlink:type="simple">FLWORExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod>
    </scrap>
  </smcore>

  <smtype>
    <p>During static analysis, it is a type error for an expression to have the empty
    type, except for the following expressions and function calls:

    <ulist>
      <item><p>Empty parentheses <code>()</code>, which denote the
      empty sequence.</p></item>
      <item><p>The <code>fn:data</code> function and all functions in the
      <emph>fs</emph> namespace applied to empty
      parentheses <code>()</code>.</p></item>
      <item><p>Any function which returns the empty type.</p></item>
    </ulist>

    The reason for these exceptions is that they are typically part of
    the result of normalizing a larger user-level expression and are
    used to capture the semantics of the user-level expression when
    applied to the empty sequence.</p>

    <p>The rule below enforces the above constraints. It is a static
    type error, if the following conditions hold for a given
    expression <emph>Expr</emph>.</p>

      <infergr>
    	<infer>
          <prejudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		      <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		      <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code></expression></clause>
 	    </multiclause>
 	    <multiclause>
              <clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Expr</emph> is the empty
              parentheses () or <code>fn:data</code> or any <emph>fs</emph>
              function applied to empty parentheses ())</expression></clause>
 	    </multiclause>
          </prejudge>
 	  <postjudge>
 	    <multiclause>
              <clause>
               <expression>A static type error is raised for expression <emph>Expr</emph></expression>
              </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>In general, static type errors are raised whenever there is
      no static typing rules which can compute the type of a given
      expression. This is the reason for the absence of a formal
      post-condition in this rules. There is indeed a rule that infers
      the type for expression <emph>Expr</emph>, however the inferred type is
      empty and still a static type error must be raised.</p>

      <smexample>
        <p>The above rule is useful in catching common mistakes, such
        as the misspelling of an element or attribute name or
        referencing of an element or attribute that does not
        exist. For instance, the following path expression</p>
<eg xml:space="preserve">  $x/title
</eg>
    <p>raises a static type error if the type of variable
    <code>$x</code> does not include any
    <code>title</code> children elements.</p>
  </smexample>
  </smtype>

  <!-- ***************** Primary expressions              ****** -->

  <div2 id="id-primary-expressions">
    <head>基本式</head>
  
    <p><term>Primary expressions</term> are the basic primitives of
    the language. They include literals, variables, function calls,
    and the parenthesized expressions.</p>

    <scrap headstyle="show">
      <head>基本式</head>
      <prod num="84 (XQuery)" id="doc-xquery-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderedExpr" xlink:type="simple">OrderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Constructor" xlink:type="simple">Constructor</nt></rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar production for primary expressions is:</p>
  
      <scrap headstyle="show">
        <head>基本式</head>
        <prod num="55 (Core)" id="doc-core-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Constructor" xlink:type="simple">Constructor</nt></rhs></prod>
      </scrap>
    </smcore>

    <div3 id="id-literals">
      <head>リテラル</head>

      <smintro>
        <p>A <term>literal</term> is a direct syntactic representation
        of an atomic value.  [XPath/XQuery] supports two kinds of literals:
        string literals and numeric literals.</p>
      </smintro>

<scrap headstyle="show">
  <head>リテラル</head>
  <prod num="85 (XQuery)" id="doc-xquery-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
  <prod num="86 (XQuery)" id="doc-xquery-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod>
  <prod num="141 (XQuery)" id="doc-xquery-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt></rhs></prod>
  <prod num="142 (XQuery)" id="doc-xquery-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs></prod>
  <prod num="143 (XQuery)" id="doc-xquery-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt></rhs></prod>
  <prod num="144 (XQuery)" id="doc-xquery-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs></prod>
  <prod num="140 (XQuery)" id="doc-xquery-URILiteral"><lhs>URILiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
  <prod num="145 (XQuery)" id="doc-xquery-PredefinedEntityRef"><lhs>PredefinedEntityRef</lhs><rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs></prod>
  <prod num="158 (XQuery)" id="doc-xquery-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod>
</scrap>

      <smcore>
        <p>The Core grammar productions for literals are:</p>

<scrap headstyle="show">
  <head>リテラル</head>

  <prod num="56 (Core)" id="doc-core-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
  <prod num="57 (Core)" id="doc-core-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod>
  <prod num="98 (Core)" id="doc-core-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt></rhs></prod>
  <prod num="99 (Core)" id="doc-core-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs></prod>
  <prod num="100 (Core)" id="doc-core-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" xlink:type="simple">Digits</nt></rhs></prod>
  <prod num="101 (Core)" id="doc-core-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs></prod>
  <prod num="97 (Core)" id="doc-core-URILiteral"><lhs>URILiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
  <prod num="112 (Core)" id="doc-core-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod>
</scrap>
      </smcore>

      <smnotation>
         <p>To define the dynamic semantics of literals, we introduce
         the following auxiliary judgments.</p>

        <p id="jd_has_atomic_value">The judgment</p>
        <display>
          <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression><emph>Literal</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression>
          </clause>
        </display>

          <p>Holds if the literal expression <emph>Literal</emph> corresponds
          to the value <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>. This judgment yields an
          atomic value, according to the rules described in <bibref ref="xquery"/>. Notably, this judgment deals with handling
          of literal overflows for numeric literals, and handling of
          character references, and predefined entity references for
          string literals.</p>
      </smnotation>

      <smnorm>
        <p>Literals are left unchanged through normalization.</p>

        <mapping>
         <xquery>
          <expression>
           <map><emph>IntegerLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
            <emph>IntegerLiteral</emph>
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map><emph>DecimalLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
            <emph>DecimalLiteral</emph>
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map><emph>DoubleLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
            <emph>DoubleLiteral</emph>
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map><emph>StringLiteral</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
            <emph>StringLiteral</emph>
          </expression>
         </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static type of a literal expression is its
        corresponding atomic type.</p>

	<infergr>
	  <infer>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><emph>IntegerLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:integer</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <postjudge>
	      <multiclause>
		<clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression><emph>DecimalLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:decimal</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <infergr>
          <infer>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>DoubleLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:double</expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>StringLiteral</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:string</expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>
        <p>In the dynamic semantics, a literal is evaluated by
        constructing an atomic value in the data model, using the
        <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> judgment defined above.</p>

	<infergr>
	  <infer>
 	    <prejudge>
 	      <multiclause>
 	        <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	        <expression><emph>Literal</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>
 	        </expression>
 	        </clause>
 	      </multiclause>
 	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
			<expression><emph>Literal</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>
      </smeval>

  </div3>

  <div3 id="id-variables">
    <head>変数参照</head>

    <smintro>
      <p>A <term>variable</term> evaluates to the value to which the
      variable's QName is bound in the <term>dynamic
      context</term>.</p>
    </smintro>

    <scrap headstyle="show">
      <head>変数参照</head>
      <prod num="87 (XQuery)" id="doc-xquery-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod>
      <prod num="88 (XQuery)" id="doc-xquery-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar productions for variable references are:</p>
  
      <scrap headstyle="show">
        <head>基本式</head>
        <prod num="58 (Core)" id="doc-core-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt></rhs></prod>
        <prod num="59 (Core)" id="doc-core-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Variable references are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><a href="#prod-core-VarRef"><emph>VarRef</emph></a></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <a href="#prod-core-VarRef"><emph>VarRef</emph></a>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>In the static semantics, the type of a variable is simply its
      type in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>:</p>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>(<emph>Variable</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		      <expression>$<emph>VarName</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>If the variable is not bound in the static environment, a
      static type error is raised.</p>
    </smtype>

    <smeval>
      <p>In the dynamic semantics, a locally declared variable is
      evaluated by "looking up" its value in <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>:</p>
    
      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		      <expression>$<emph>VarName</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <p>In the dynamic semantics, a reference to a variable imported
      from a module is evaluated by accessing the dynamic context of
      the module in which the variable is declared.</p>

      <p>The notation <emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> is
      used to access a module context and is defined in <specref ref="id-module-declaration"/>.</p>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 	      <expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
 		<expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a>(<emph>Variable</emph>) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		      <expression>$<emph>VarName</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smeval>

  </div3>

  <div3 id="id-paren-expressions">
    <head>括弧付き式</head>

    <scrap headstyle="show"> 
      <head/>
      <prod num="89 (XQuery)" id="doc-xquery-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod> 
    </scrap>

    <smcore>
      <p>The Core grammar production for parenthesized expressions is:</p>

      <scrap headstyle="show">
        <head/>
        <prod num="60 (Core)" id="doc-core-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod> 
      </scrap>
    </smcore>

    <p>Empty parentheses <code>()</code> always have the empty
    type. Remember that it is a static type error for most expressions
    other than <code>()</code> to have the empty type (see <specref ref="id-expressions"/> for the complete rule.)</p>

    <smtype>
      <infergr>
    	<infer>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		      <expression>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>empty</code></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		      <expression>( <emph>Expr</emph> ) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smtype>

    <smeval>
      <p>Empty parentheses <code>()</code> evaluate to the empty
      sequence.</p>

      <infergr>
    	<infer>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		      <expression>() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>

      <infergr>
    	<infer>
 	  <prejudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	      <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </prejudge>
 	  <postjudge>
 	    <multiclause>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		      <expression>( <emph>Expr</emph> ) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	      </clause>
 	    </multiclause>
 	  </postjudge>
    	</infer>
      </infergr>
    </smeval>

  </div3>

         <div3 id="id-context-item-expression">
           <head>文脈項目式</head>

           <scrap headstyle="show"> <head/><prod num="90 (XQuery)" id="doc-xquery-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod> </scrap>

           <smintro>
             <p>A <term>context item expression</term> evaluates to
             the context item, which may be either a node or an atomic
             value.</p>
           </smintro>

         <smnorm>
           <p>A context item expression is normalized to the built-in
           variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>. Because it can only be bound through the
           external context or a path expression, there is no need for
           a specific static typing rule to enforce that its value is
           a singleton item.</p>

           <mapping>
            <xquery>
              <expression><map>.</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
            </xquery>
            <core>
              <expression><a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a></expression>
            </core>
           </mapping>
         </smnorm>

         </div3>

  <div3 id="id-function-calls">
    <head>関数呼び出し</head>

    <smintro>
      <p>A function call consists of a QName followed by a
      parenthesized list of zero or more expressions.  In [XPath/XQuery],
      the actual argument to a function is called an
      <term>argument</term> and the formal argument of a function is
      called a <term>parameter</term>.  We use the same terminology
      here. </p>
      
      <scrap headstyle="show">
        <head>関数呼び出し</head>
        <prod num="93 (XQuery)" id="doc-xquery-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod>
      </scrap>

      <p>Because [XPath/XQuery] implicitly converts the values of function
      arguments, a normalization step is required.</p>
    </smintro>

    <smcore>
      <p>The Core grammar production for function calls is:</p>

      <scrap headstyle="show">
        <head>関数呼び出し</head>
        <prod num="63 (Core)" id="doc-core-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod>
      </scrap>
    </smcore>
 
    <smnotation>
      <p id="jd_map_function_argument">Normalization of function calls
      uses an auxiliary mapping <map/><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a>
      used to insert conversions of function arguments that depend
      only on the expected <a href="#doc-fs-Type"><emph>Type</emph></a> of the corresponding
      parameters. It is defined as follows:</p>

      <mapping>
       <xquery>
         <expression><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a></expression>
       </xquery>
       <core>
         <expression><map><map><map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></map><a href="#jd_map_function_argument" class="judgment"><subscript>AtomizeAtomic(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a></map><a href="#jd_map_function_argument" class="judgment"><subscript>Convert(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a></expression>
       </core>
      </mapping>

      <p>where</p>

        <ulist>

          <item>
            <p><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>AtomizeAtomic(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a> denotes</p>
            <table>
              <tbody>
                <tr>
                  <td rowspan="1" colspan="1">If
                  </td>

                  <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Then</td>
                  <td rowspan="1" colspan="1"><code>fn:data</code>(<emph>Expr</emph>)</td><td rowspan="1" colspan="1">  </td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Else</td>
                  <td rowspan="1" colspan="1"><emph>Expr</emph></td><td rowspan="1" colspan="1">  </td>
                </tr>
              </tbody>
            </table>

            <p>which specifies that if the function expects atomic
            parameters, then <code>fn:data</code> is called to obtain them.</p>
          </item>

          <item>
            <p><map><emph>Expr</emph></map><a href="#jd_map_function_argument" class="judgment"><subscript>Convert(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a> denotes</p>
            <table>
              <tbody>
                <tr>
                  <td rowspan="1" colspan="1">If</td>
                  <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Then</td>
                  <td rowspan="1" colspan="1"><a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a>(<emph>Expr</emph>,<emph>PrototypicalValue</emph>)</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Else</td>
                  <td rowspan="1" colspan="1"><emph>Expr</emph></td>
                </tr>
              </tbody>
            </table>

          <p>where <emph>PrototypicalValue</emph> is a built-in atomic
          value used to encode the expected atomic type (for instance
          the value <code>1.0</code> if the expected type is
          <code>xs:decimal</code>). A value is used here since [XPath/XQuery]
          expressions cannot operate directly on types. Which value is
          chosen does not have any impact on the actual semantics,
          only its actual atomic type matters.</p>
        </item>
      </ulist>

    </smnotation>

      <smnote>
        <p>The <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> function takes a
        <emph>PrototypicalValue</emph>, which is a value of the target
        type, to ensure that conversion to base types is possible even
        though types are not first class objects in [XPath/XQuery]. Also,
        note that in the case of built-in functions where the expected
        type is specified as numeric, the prototypical value is a
        value of type <code>xs:double</code>.</p>
      </smnote>

      <smnorm>
        <p>Each argument expression in a function call is normalized
        to its corresponding Core expression by applying
        <map/><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a>)</subscript></a> for each argument with
        the expected <emph>SequenceType</emph> for the argument inserted.</p>

         <infergr>
          <infer>
           <prejudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-AtomicTypeDerivation"><emph>AtomicTypeDerivation</emph></a>
              </expression>
             </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,n) =
                  declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
              </clause>
            </multiclause>
           </prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
              <map><emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript>)</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              =
              <emph>QName</emph>
              ( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</subscript></a>, ...,
                <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)</subscript></a> )
            </expression>
           </clause>
          </postjudge>
         </infer>
         </infergr>

        <mapping>
          <xquery>
            <expression>
              
            </expression>
          </xquery>
          <core>
            <expression>
              <emph>QName</emph>
              ( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</subscript></a>, ...,
                <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_function_argument" class="judgment"><subscript>FunctionArgument(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)</subscript></a> )
            </expression>
          </core>
        </mapping>

        <p>Note that this normalization rule depends on the function
        signatures, which is used to get the types of the function
        parameters (<emph>SequenceType</emph><subscript>1</subscript>,...,<emph>SequenceType</emph><subscript>n</subscript>). For
        user-defined functions, the function signature can be obtained
        from the XQuery prolog where the function is declared.  For
        built-in functions, the signature is given in the
        <bibref ref="xpath-functions"/> document. For overloaded built-in functions,
        several signatures may exists, however, because they all
        correspond to sequences of atomic values, they all result in
        the same normalization.</p>
      </smnorm>

      <smtype>
        <p>Different sets of static typing rules are used to type
        check function calls depending on which of the following
        categories the belong to: overloaded internal functions,
        built-in functions with a specific static typing rule, and
        other built-in and user-defined functions.</p>

        <p>The following two rules are common to all those categories,
        and are used to bootstrap type inference, by first looking-up
        the expanded QName for the function, then applying the
        appropriate set of static typing rules depending on the
        category in which the function is.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <emph>QName</emph>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> 
                  <expression>
                    <emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <emph>QName</emph> (<emph>Expr</emph><subscript>1</subscript>,...,<emph>Expr</emph><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>The following depends on the kind of function call.</p>

        <olist>
          <item>
            <p>If the expanded QName for the function corresponds to
            one of the overloaded internal <emph>fs:</emph> functions
            listed in <specref ref="sec_operators"/>, the static
            typing rules in <specref ref="sec_operators"/> are
            applied.</p>
          </item>
          <item>
            <p>If the expanded QName for the function corresponds to
            one of the built-in functions with a specialized static
            typing rule, listed in <specref ref="sec_special_functions"/>, the static typing rules in
            <specref ref="sec_special_functions"/> are applied.</p>
          </item>
          <item><p>Otherwise, the following general static typing
            rules are applied.</p></item>
        </olist>

        <p>The two following rules look up the function in the static
        environment and check that some signature for the function
        satisfies the following constraint: the type of each actual
        argument is a subtype of some type that can be promoted to the
        type of the corresponding function parameter.  In this case,
        the function call is well typed and the result type is the
        return type specified in the function's signature. </p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,0) =
                    declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>,n) =
                    declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>', ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>') as <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'</expression></clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'</expression></clause>
              </multiclause>

            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <p>The function body itself is not analyzed for each
        invocation: static typing of the function definition itself
        guarantees that the function body always returns a value of
        the declared return type.</p>

        <p>Notice that the static context contains at most one
        function declaration for each function. This is possible since
        the treatment of overloaded operators is done through a set of
        specific static typing rules which do not require access to
        the environment. See <specref ref="sec_operators"/>.</p>
      </smtype>

      <smnotation>
        <p id="jd_function_with_types">The following auxiliary
        judgment</p>

        <display>
         <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
         </clause>
        </display>

        <p>holds when applying the function with and expanded QName
        <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> and no parameter yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>.</p>

        <display>
         <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
         </clause>
        </display>

        <p>holds when applying the function with expanded QName
        <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>, and parameters of type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        on the values (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value
        <a href="#doc-fs-Value"><emph>Value</emph></a>.</p>

        <p>That judgment is defined below for each kind of function
        (user-defined, built-in, external, and imported
        functions).</p>
      </smnotation>

      <smeval>
        <p>The following rules apply to all the different kinds of
        functions using the previously defined judgment.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>FunctionSig</emph>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
         <expression>
          <emph>QName</emph>() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          <emph>Expr</emph><subscript>n</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>FunctionSig</emph>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>')
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
         <expression>
          <emph>QName</emph> ( <emph>Expr</emph><subscript>1</subscript>, ...,  <emph>Expr</emph><subscript>n</subscript> ) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>First the function name is expanded, and the expanded name is
    used to retrieve the function signature from the static
    environment. Then, the rule evaluates each function argument
    expression, and the resulting values are promoted according to the
    expected type for the function. The result of evaluating the
    function is obtained through the auxiliary judgment previously
    defined, and the resulting value is promoted according to the
    expected return type.</p>

    <p>In case the function is a user defined function in a main
    module, the expression body is retrieved from the dynamic
    environment and used to compute the value of the function. The
    rule extends <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> by binding each formal variable to its
    corresponding value, and evaluates the body of the function in the
    new environment. The resulting value is the value of the function
    call.</p>

    <p>The notation <emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> is used
    to access a module context and is defined in <specref ref="id-module-declaration"/>.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
          =
          (<emph>Expr</emph>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment>
         <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))
          =
          (<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>, ... , <emph>Variable</emph><subscript>n</subscript>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
          <update>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment>
           <expression>
            <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>;
            ...;
            <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
          </update>
         </environment>
         <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>Note that the function body is evaluated in the dynamic
    environment containing the main module declarations.</p>

    <p>The rule for evaluating an function imported from a module is
    similar to that for evaluating a user-defined function in a main
    module, except that the function call is evaluated in the dynamic
    context of the module in which it is declared, and that the
    appropriate additional type matching must be performed.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>())
          = <code>#IMPORTED</code>(<emph>AnyURI</emph>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a><subscript>1</subscript>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>FunctionSig</emph>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <emph>FunctionSig</emph>'
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() as <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
          =
          (<emph>Expr</emph>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment>
         <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))
          = <code>#IMPORTED</code>(<emph>AnyURI</emph>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
 	<clause>
 	 <expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
 	</clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a><subscript>1</subscript>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>FunctionSig</emph>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <emph>FunctionSig</emph>'
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>', ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>') as <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><expression>...</expression></clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>', ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'))
          =
          (<emph>Expr</emph>, <emph>Variable</emph><subscript>1</subscript>, ... , <emph>Variable</emph><subscript>n</subscript>)
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment>
          <update>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment>
           <expression>
            <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>;
            ...;
            <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
          </update>
         </environment>
         <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'
         </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>If the function is a built-in function (resp. special formal
    semantics function), the value returned by the function is the one
    specified in <bibref ref="xpath-functions"/> (resp. <specref ref="sec_special_functions"/>).</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>())
          = <code>#BUILT-IN</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The built-in function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (See <bibref ref="xpath-functions"/> or
           <specref ref="sec_special_functions"/>) yields the value
           <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))
          = <code>#BUILT-IN</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The built-in function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> (See <bibref ref="xpath-functions"/> or
           <specref ref="sec_special_functions"/>) applied to values
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <p>If the function is an external function, the value returned by
    the function is implementation-defined.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()) = <code>#EXTERNAL</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The external function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> yields the value
           <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <expression>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))
          = <code>#EXTERNAL</code>
         </expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <expression>
           The external function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> applied to values
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>) yields the value <a href="#doc-fs-Value"><emph>Value</emph></a>
          </expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
       <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
           <a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </multiclause>
      </postjudge>
     </infer>
    </infergr>
   </smeval>

  </div3>

  </div2>

  <div2 id="id-path-expressions">
    <head>経路式</head>

    <smintro>
      <p>Path expressions are used to locate nodes within a
      tree. There are two kinds of path expressions, absolute path
      expressions and relative path expressions. An absolute path
      expression is a rooted relative path expression. A relative path
      expression is composed of a sequence of steps.</p>
  
      <scrap headstyle="show">
        <head>経路式</head>
        <prod num="68 (XQuery)" id="doc-xquery-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs></prod>
        <prod num="69 (XQuery)" id="doc-xquery-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod>
      </scrap>

    </smintro>

    <smcore>
      <p>PathExpr and RelativePathExpr are fully normalized, therefore
      they have no corresponding productions in the Core. The grammar
      for path expressions in the Core starts with the StepExpr
      production.</p>
    </smcore>

    <smnorm>
      <p>Absolute path expressions are path expressions starting with
      the <code>/</code> or <code>//</code> symbols, indicating that
      the expression must be applied on the root node in the current
      context.  The root node in the current context is the greatest
      ancestor of the context node. The following two rules normalize
      absolute path expressions to relative ones. They use the
      <code>fn:root</code> function, which returns the greatest ancestor of its
      argument node. The treat expressions guarantee that the value
      bound to the context variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> is a document node.</p>

      <mapping>
       <xquery>
         <expression><map>/</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><map>(<code>fn:root</code>(self::node()) treat as document-node())</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>/ <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><map>((<code>fn:root</code>(self::node())) treat as document-node()) /
         <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>// <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><map>((<code>fn:root</code>(self::node())) treat as document-node()) /
         <code>descendant-or-self::node()</code> /
         <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </core>
      </mapping>

      <mapping>
        <xquery>
          <expression><map> <emph>RelativePathExpr</emph> // <emph>StepExpr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
        </xquery>
        <core>
          <expression> <map><emph>StepExpr</emph> / descendant-or-self::node() / <emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
        </core>
      </mapping>

      <p>A composite relative path expression (using <code>/</code>)
      is normalized into a <code>for</code> expression by
      concatenating the sequences obtained by mapping each node of the
      left-hand side in document order to the sequence it generates on
      the right-hand side.  The call to the <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>
      function ensures that the result is in document order without
      duplicates.  The dynamic context is defined by binding the
      <code>$</code><emph>fs:</emph><code>dot</code>,
      <code>$</code><emph>fs:</emph><code>sequence</code>,
      <code>$</code><emph>fs:</emph><code>position</code> and
      <code>$</code><emph>fs:</emph><code>last</code> variables.</p>

      <p>Note that sorting by document order enforces the restriction
      that input and output sequences contains only nodes, and that
      the last step in a path expression may actually return atomic
      values.</p>

      <mapping>
       <xquery>
        <expression><map><emph>RelativePathExpr</emph> / <emph>StepExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
        <expression>
         <table><tbody>
           <tr><td rowspan="1" colspan="1"><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> (</td></tr>
           <tr><td rowspan="1" colspan="1"><a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> (</td></tr>
           <tr><td rowspan="1" colspan="1">  let <code>$</code><emph>fs:</emph><code>sequence</code> as node()* := <map><emph>RelativePathExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>   return</td></tr>  
           <tr><td rowspan="1" colspan="1">  let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>)   return</td></tr>  
           <tr><td rowspan="1" colspan="1">  for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr>  
           <tr><td rowspan="1" colspan="1">    <map><emph>StepExpr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
           <tr><td rowspan="1" colspan="1">))</td></tr>
         </tbody></table>
        </expression>
       </core>
      </mapping>

    </smnorm>

    <div3 id="id-axis-steps">
      <head>ステップ</head>

      <p>Note that this section uses some auxiliary judgments which
      are defined in <specref ref="sec_auxiliary_xpath"/>.</p>

      <smintro>
        <scrap headstyle="show">
          <head>ステップ</head>
          <prod num="70 (XQuery)" id="doc-xquery-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod>
          <prod num="71 (XQuery)" id="doc-xquery-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>
          <prod num="72 (XQuery)" id="doc-xquery-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod>
          <prod num="75 (XQuery)" id="doc-xquery-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod>
          <prod num="82 (XQuery)" id="doc-xquery-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod>
        </scrap>
      </smintro>

      <smcore>
        <p>The Core grammar productions for XPath steps are:</p>
    
        <scrap headstyle="show">
          <head>ステップ</head>
          <prod num="46 (Core)" id="doc-core-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod>
          <prod num="47 (Core)" id="doc-core-AxisStep"><lhs>AxisStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ForwardStep" xlink:type="simple">ForwardStep</nt></rhs></prod>
          <prod num="48 (Core)" id="doc-core-ForwardStep"><lhs>ForwardStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod>
          <prod num="50 (Core)" id="doc-core-ReverseStep"><lhs>ReverseStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod>
        </scrap>
      </smcore>

      <smnote>
        <p>Step expressions can be followed by
        predicates. Normalization of predicates uses the following
        auxiliary mapping rule: <map/><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>, which
        is specified in <specref ref="id-predicates"/>. Normalization
        for step expressions also uses the following auxiliary mapping
        rule: <map/><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>, which is specified in <specref ref="sec_axes"/>.</p>
      </smnote>

      <smnorm>
        <p>Normalization of predicates need to distinguish between
        forward steps, reverse steps, and primary expressions.</p>
  
        <p>As explained in the [XPath/XQuery] document, applying a step in
        XPath changes the focus (or context). The change of focus is
        made explicit by the normalization rule below, which binds the
        variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> to the node currently being processed, and
        the variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> to the position (i.e., the position
        within the input sequence) of that node.</p>

        <p>There are two sets of normalization rules for Predicates.
        The first set of rules apply when the predicate is a numeric
        literal or the expression <code>last()</code>.  The second set
        of rules apply to all predicate expressions other than numeric
        literals and the expression <code>last()</code>.  In the first
        case, the normalization rules provides a more precise static
        type than if the general rules were applied.</p>

        <p>When the predicate expression is a numeric literal or the
        <code>fn:last</code> function, the following normalization rules
        apply.</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
<tr><td rowspan="1" colspan="1"><code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,<emph>NumericLiteral</emph>,1)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <mapping>
          <xquery>
            <expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <code>fn:last</code>() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
                <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := <code>fn:count</code>(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr>
<tr><td rowspan="1" colspan="1"><code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>,1)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <p>When predicates are applied on a reverse step, the position
        variable is bound in reverse document order. </p>
  
        <mapping>
          <xquery>
            <expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
          <expression>
             <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
                <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr>
                <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> := <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> - <emph>NumericLiteral</emph> + 1 return</td></tr>
                <tr><td rowspan="1" colspan="1">  <code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>,1)</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>

        <p>When the step is a reverse axis, then the last item in the
        context sequence is the first in document order.</p>

        <mapping>
          <xquery>
            <expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <code>fn:last</code>() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
          <expression>
             <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
                <tr><td rowspan="1" colspan="1">  <code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,1,1)</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>
  
        <p>The normalization rules above all use the function
        <code>fn:subsequence</code> to select a particular item.  The static
        typing rules for this function are defined in <specref ref="sec_fn_subsequence"/>.</p>
  
        <p>When predicates are applied on a forward step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>
        variable to each node in document order.</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>ForwardStep</emph> <emph>PredicateList</emph> [
            <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>( <map><emph>ForwardStep</emph>
                <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
                <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr>
                <tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr>
                <tr><td rowspan="1" colspan="1">   if <map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a> then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
  
        <p>When predicates are applied on a reverse step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>
        variable to each node in document order. </p>

        <mapping>
          <xquery>
            <expression><map><emph>ReverseStep</emph> <emph>PredicateList</emph> [
            <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
          <expression>
             <table><tbody>
               <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>(
               <map><emph>ReverseStep</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )) return</td></tr>
               <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr>
               <tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at $<emph>fs:</emph>new in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr>
               <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> := <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> - $<emph>fs:</emph>new + 1 return </td></tr>
               <tr><td rowspan="1" colspan="1">  if <map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>
                            then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr>
             </tbody></table>
           </expression>
          </core>
        </mapping>
  

        <p>Finally, a stand-alone forward or reverse step is
        normalized by the auxiliary normalization rule for
        <emph>Axis</emph>.</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>ForwardStep</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<map><emph>ForwardStep</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>)</expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression><map><emph>ReverseStep</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<map><emph>ReverseStep</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>)</expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static semantics of an <emph>Axis</emph> <emph>NodeTest</emph> pair is
        obtained by retrieving the type of the context node, and
        applying the two filters (the <emph>Axis</emph>, and then the
        <emph>NodeTest</emph> with a <emph>PrincipalNodeKind</emph>) on the
        result.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
            <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>dot</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <map>node()</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             </expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> <emph>PrincipalNodeKind</emph></expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression>
            </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <emph>Axis</emph> <emph>NodeTest</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
            </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <smnote>
          <p>Note that the second judgment in the rule requires that
          the context item be a node, guaranteeing that a type error
          is raised when the context item is an atomic value.</p>
        </smnote>
      
      </smtype>
      
      <smeval>
        <p>The dynamic semantics of an <emph>Axis</emph> <emph>NodeTest</emph> pair is
        obtained by retrieving the context node, and applying the two
        filters (<emph>Axis</emph>, then <emph>NodeTest</emph>) on the result. The
        application of each filter is expressed through several
        auxiliary judgments (<a href="#jd_axis" class="judgment"><term>of</term></a>, <a href="#jd_principal" class="judgment"><term>has principal</term></a>, and
        <a href="#jd_test" class="judgment"><term>test</term></a>), as follows.</p>
      
        <infergr>
         <infer>
          <prejudge>
           <multiclause>
            <clause>
             <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a>) = <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> node</expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
             <expression>
              <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             </expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> <emph>PrincipalNodeKind</emph></expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
             <expression>
              <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
            </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression>
             <emph>Axis</emph> <emph>NodeTest</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>)
            </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
      
        <smnote>
          <p>Note that the second judgment in the rule guarantees that
          the context item is bound to a node.</p>
        </smnote>
      
      </smeval>
      
      <div4 id="sec_axes">
        <head>軸</head>

        <smintro>
          <p>The XQuery grammar for forward and reverse axis is as
          follows.</p>

          <scrap headstyle="show">
            <head>軸</head>
            <prod num="73 (XQuery)" id="doc-xquery-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs></prod>
            <prod num="76 (XQuery)" id="doc-xquery-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod>
          </scrap>

          <p>In the case of XPath, forward axis also contain the
          <code>namespace::</code> axis.</p>

          <scrap headstyle="show">
            <head>軸</head>
            <prod num="30 (XPath)" id="noid_N14949.doc-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod>
          </scrap>

        </smintro>

        <smcore>
          <p>The Core grammar productions for XPath axis are:</p>
      
            <scrap headstyle="show">
            <head>軸</head>
              <prod num="49 (Core)" id="doc-core-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("namespace"  "::")</rhs></prod>
              <prod num="51 (Core)" id="doc-core-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod>
            </scrap>
        </smcore>

        <smnotation>
          <p id="jd_map_axis">The normalization of axes uses the
          following auxiliary mapping rule:
          <map/><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a>.</p>
        </smnotation>

        <smnorm>
          <p>The normalization for all axes is specified as
          follows.</p>

          <p>The semantics of the following(-sibling) and
          preceding(-sibling) axes are expressed by mapping them to
          Core expressions. All other axes are part of the Core and
          therefore are left unchanged through normalization.</p>
           
          <mapping>
            <xquery>
              <expression><map><code>following-sibling::</code>
              <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
            </xquery>
            <core>
              <expression><map>let $e := . return $e/parent::node()/child:: <emph>NodeTest</emph> [.&gt;&gt;$e]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
            </core>
          </mapping>
    
          <mapping>
          <xquery>
            <expression><map><code>following::</code>
            <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><map><code>ancestor-or-self::node()/following-sibling::node()/descendant-or-self::</code><emph>NodeTest</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </core>
          </mapping>
    
          <p>All other forward axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p>
    
          <mapping>
          <xquery>
            <expression><map><code>child::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>child::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>attribute::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>attribute::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>self::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>descendant::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>descendant::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>descendant-or-self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>descendant-or-self::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
            <expression><map><code>namespace::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><code>namespace::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
    
          <p>Reverse axes:</p>
          
          <mapping>
          <xquery>
            <expression><map><code>preceding-sibling::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
            <expression><map>let $e := . return $e/parent::node()/child:: <emph>NodeTest</emph> [.&lt;&lt;$e]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>preceding::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
          <expression><map><code>ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::</code><emph>NodeTest</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </core>
          </mapping>
           
          <p>All other reverse axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p>
           
          <mapping>
          <xquery>
          <expression><map><code>parent::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
          <expression><code>parent::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>ancestor::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
          <expression><code>ancestor::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
          
          <mapping>
          <xquery>
          <expression><map><code>ancestor-or-self::</code> <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
          </xquery>
          <core>
          <expression><code>ancestor-or-self::</code> <emph>NodeTest</emph></expression>
          </core>
          </mapping>
    
        </smnorm>

      </div4>

      <div4 id="node-tests">
        <head>節点テスト</head>
  
        <smintro>
          <p>A node test is a condition applied on the nodes selected
          by an axis step. Node tests are described by the following
          grammar productions.</p>
    
          <scrap headstyle="show">
            <head>節点テスト</head>
            <prod num="78 (XQuery)" id="doc-xquery-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NameTest" xlink:type="simple">NameTest</nt></rhs></prod>
            <prod num="79 (XQuery)" id="doc-xquery-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod>
            <prod num="80 (XQuery)" id="doc-xquery-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>)</rhs></prod>
          </scrap>
        </smintro>
  
        <smcore>
          <p>The Core grammar productions for node tests are:</p>

          <scrap headstyle="show">
            <head>節点テスト</head>
            <prod num="52 (Core)" id="doc-core-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-NameTest" xlink:type="simple">NameTest</nt></rhs></prod>
            <prod num="53 (Core)" id="doc-core-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod>
            <prod num="54 (Core)" id="doc-core-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>)</rhs></prod>
          </scrap>
        </smcore>

        <smnotation>
          <p>For convenience, we will use the grammar non-terminals
          <emph>Prefix</emph>, and <emph>LocalPart</emph>, both of which are
          <emph>NCName</emph>s, in some of the inference rules. They are
          defined by the following grammar productions.</p>

          <scrap headstyle="show">
            <head>接頭辞と局所部分</head>
            <prod num="18 (Formal)" id="doc-fs-Prefix"><lhs>Prefix</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt></rhs></prod>
            <prod num="19 (Formal)" id="doc-fs-LocalPart"><lhs>LocalPart</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt></rhs></prod>
          </scrap>

        </smnotation>

      </div4>

    </div3>

    <div3 id="id-predicates">
      <head>述語</head>
  
      <smintro>
        <p>A predicate consists of an expression, called a <term>predicate
        expression</term>, enclosed in square brackets.</p>
  
        <scrap headstyle="show">
          <head/>
          <prod num="83 (XQuery)" id="doc-xquery-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod>
        </scrap>
  
      </smintro>
  
      <smnotation>
        <p id="jd_map_predicates">Normalization of predicates uses the
        following auxiliary mapping rule:
        <map/><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>.</p>
      </smnotation>

      <smnorm>
        <p>Predicates in path expressions are normalized with a
        special mapping rule:</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
              <tr><td rowspan="1" colspan="1">typeswitch (<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr>
              <tr><td rowspan="1" colspan="1">  case $v as <emph>fs:</emph><code>numeric</code> return <emph>op:</emph>numeric-equal($v, <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>)</td></tr>
              <tr><td rowspan="1" colspan="1">  default $v return <code>fn:boolean</code>($v)</td></tr> 
              </tbody>
              </table>
            </expression>
          </core>
        </mapping>
  
        <p>Note that the semantics of predicates whose input
        expression returns a numeric value also work if that value is
        not an integer. In those cases the
        <code>op:numeric-equal</code> returns false when compared to a
        position. For example, the expression <code>//a[3.4]</code>
        always returns the empty sequence.</p>
      </smnorm>
  
    </div3>

    <div3 id="unabbrev">
      <head>非省略構文</head>
  
      <p>The corresponding Section in the [XPath/XQuery] document just
      contains examples.</p>
  
    </div3>

    <div3 id="abbrev">
      <head>省略構文</head>
  
      <scrap headstyle="show">
        <head>省略構文</head>
        <prod num="74 (XQuery)" id="doc-xquery-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod> 
        <prod num="77 (XQuery)" id="doc-xquery-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod>
      </scrap>
  
      <smnorm>
        <p>Here are normalization rules for the abbreviated
        syntax.</p>

        <mapping>
        <xquery>
          <expression><map> .. </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
        </xquery>
        <core>
          <expression><map>parent::node()</map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
        </core>
        </mapping>
        
        <mapping>
        <xquery>
          <expression><map> @ NameTest </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
        </xquery>
        <core>
          <expression>attribute :: NameTest</expression>
        </core>
        </mapping>
        <mapping>
        <xquery>
          <expression><map> <emph>NodeTest</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
        </xquery>
        <core>
          <expression><map>child :: <emph>NodeTest</emph></map><a href="#jd_map_axis" class="judgment"><subscript>Axis</subscript></a></expression>
        </core>
        </mapping>

      </smnorm>

    </div3>

  </div2>

  <div2 id="id-sequence-expressions">
    <head>列式</head>

    <smintro>
      <p>[XPath/XQuery] supports operators to construct and combine
      sequences.  A <term>sequence</term> is an ordered collection of
      zero or more items. An <term>item</term> is either an atomic
      value or a node.</p>
    </smintro>

    <div3 id="sec_constructing_sequences">
      <head>構成列</head>

      <scrap headstyle="show">
        <head>構成列</head>
        <prod num="31 (XQuery)" id="noid_N14C99.doc-xquery-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
        <prod num="49 (XQuery)" id="doc-xquery-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod>
      </scrap>

      <smcore>
        <p>The Core grammar production for sequence expressions is:</p>

        <scrap headstyle="show">
          <head>Core Sequence Expressions</head>
          <prod num="22 (Core)" id="noid_N14CAE.doc-core-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
        </scrap>
      </smcore>

      <smnorm>
        <p>A sequence expression is normalized into a sequence of
        normalized single expressions:</p>

        <mapping>
          <xquery>
            <expression>
              <map><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>
              <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>, <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p><!--The static semantics of the sequence expression follows.-->
        The type of the sequence expression is the sequence over the
        types of the individual expressions.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><emph>Expr</emph><subscript>1</subscript> , <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>  
        <p><!-- The dynamic semantics of the sequence expression follows.-->
        Each expression in the sequence is evaluated and the resulting
        values are concatenated into one sequence.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression></clause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression></clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

      </smeval>

      <smnorm>
        <p>The range operator is normalized to the <emph>fs:</emph><code>to</code>
        function.</p>

        <mapping>
          <xquery>
            <expression>
             <map><emph>Expr</emph><subscript>1</subscript> <code>to</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>
              <emph>fs:</emph><code>to</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>),(<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
            </expression>
          </core>
        </mapping>
      </smnorm>

      <smtype>
        <p>The static semantics of the <emph>fs:</emph><code>to</code> function is defined in
        <specref ref="sec_fs_to"/>.</p>
      </smtype>

      <smeval>
        <p>The dynamic semantics of the <emph>fs:</emph><code>to</code> function is defined in
        <specref ref="sec_fs_to"/>.</p>
      </smeval>

    </div3>

    <div3 id="sec_filter_exprs">
      <head>Filter Expressions</head>
      <smintro>
        <scrap headstyle="show">
          <head>Filter Expression</head>
          <prod num="81 (XQuery)" id="doc-xquery-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>
        </scrap>
      </smintro>

      <smcore>
        <p>There are no Core grammar productions for filter
        expressions as they are normalized to other Core
        expressions. </p>
      </smcore>

      <smnorm>
        <p>When a predicate with a numeric literal or the
        <code>last()</code> expression is applied on a primary
        expression, it is normalized using the <code>fn:subsequence</code>
        function. This results in a more precise static type for those
        cases.</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ <emph>NumericLiteral</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr>
                <tr><td rowspan="1" colspan="1"><code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,<emph>NumericLiteral</emph>,1)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
        
        <mapping>
          <xquery>
            <expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ fn:last() ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr>
                <tr><td rowspan="1" colspan="1"><code>fn:subsequence</code>(<code>$</code><emph>fs:</emph><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>,1)</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
        
        <p>In the general case, when a predicate is applied on a
        primary expression, it is normalized to a FLWOR expression as
        follows. The input sequence is processed in sequence order and
        the context item is bound to each item in the input
        sequence.</p>

        <mapping>
          <xquery>
            <expression><map><emph>PrimaryExpr</emph> <emph>PredicateList</emph> [ <emph>Expr</emph> ]</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
          </xquery>
          <core>
            <expression>
              <table><tbody>
                <tr><td rowspan="1" colspan="1">let <code>$</code><emph>fs:</emph><code>sequence</code> := <map><emph>PrimaryExpr</emph> <emph>PredicateList</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td></tr>
                <tr><td rowspan="1" colspan="1">let <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a> := fn:count(<code>$</code><emph>fs:</emph><code>sequence</code>) return</td></tr>
                <tr><td rowspan="1" colspan="1">for <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a> in <code>$</code><emph>fs:</emph><code>sequence</code> return</td></tr>
                <tr><td rowspan="1" colspan="1">   if (<map><emph>Expr</emph></map><a href="#jd_map_predicates" class="judgment"><subscript>Predicates</subscript></a>) then <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>dot</code></a> else ()</td></tr>
              </tbody></table>
            </expression>
          </core>
        </mapping>
    </smnorm>

    <smtype>
      <p>There are no additional static typing rules for filter
      expressions.</p>
    </smtype>

    <smeval>
      <p>There are no additional dynamic evaluation rules for filter
      expressions.</p>
    </smeval>
    </div3>

    <div3 id="sec_combining_sequences">
      <head>Combining Node Sequences</head>

      <p>[XPath/XQuery] provides several operators for combining
      sequences of nodes.</p>

      <scrap headstyle="show">
        <head>Combining Sequences</head>
        <prod num="52 (XQuery)" id="doc-xquery-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod>
        <prod num="53 (XQuery)" id="doc-xquery-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod>
      </scrap>

    <smnotation>
      <p id="jd_map_sequenceop">The union, intersect, and except
      expressions are normalized into function calls to the
      appropriate functions. The mapping function
      <map/><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a> is defined by the following
      table:</p>

      <table border="1"><tbody>
      <tr><td rowspan="1" colspan="1">SequenceOp</td><td rowspan="1" colspan="1"><map><emph>SequenceOp</emph></map><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a></td></tr>
      <tr><td rowspan="1" colspan="1">"union"</td><td rowspan="1" colspan="1"><emph>op:</emph>union</td></tr>
      <tr><td rowspan="1" colspan="1">"|"</td><td rowspan="1" colspan="1"><emph>op:</emph>union</td></tr>
      <tr><td rowspan="1" colspan="1">"intersect"</td><td rowspan="1" colspan="1"><emph>op:</emph>intersect</td></tr>
      <tr><td rowspan="1" colspan="1">"except"</td><td rowspan="1" colspan="1"><emph>op:</emph>except</td></tr> </tbody></table>
    </smnotation>

    <smnorm>
      <p>Operators for combining node sequences are normalized as
      follows.</p>

      <mapping>
       <xquery>
        <expression>
        <map><emph>Expr</emph><subscript>1</subscript> <emph>SequenceOp</emph> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> (<map><emph>SequenceOp</emph></map><a href="#jd_map_sequenceop" class="judgment"><subscript>SequenceOp</subscript></a> (
        <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>, <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ))
        </expression>
       </core>
      </mapping>

    </smnorm>

    <smtype>
      <p>The static semantics of the operators that combine sequences
      are defined in <specref ref="sec_op_union_intersect_except"/>.</p>
    </smtype>

    <smeval>
      <p>The dynamic semantics for function calls is given in <specref ref="id-function-calls"/>.</p>
    </smeval>

  </div3>

  </div2>

  <div2 id="sec_arithmetic">
    <head>Arithmetic Expressions</head>

    <p>[XPath/XQuery] provides arithmetic operators for addition,
    subtraction, multiplication, division, and modulus, in their usual
    binary and unary forms.</p>

    <scrap headstyle="show">
     <head>Arithmetic Expressions</head>
     <prod num="50 (XQuery)" id="doc-xquery-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod>
     <prod num="51 (XQuery)" id="doc-xquery-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod>
     <prod num="58 (XQuery)" id="doc-xquery-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod>
     <prod num="59 (XQuery)" id="doc-xquery-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt></rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar production for arithmetic expressions
      is:</p>

      <scrap headstyle="show">
        <head/>
        <prod num="40 (Core)" id="doc-core-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-StepExpr" xlink:type="simple">StepExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt></rhs></prod>
      </scrap>
    </smcore>

    <smnotation>
      <p id="jd_map_arithop">The mapping functions
      <map/><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a> and <a href="#jd_map_arithop" class="judgment"><subscript>UnaryArithOp</subscript></a> are
      defined by the following tables:</p>

      <table border="1">
        <tbody>
          <tr><td rowspan="1" colspan="1"><emph>ArithOp</emph></td><td rowspan="1" colspan="1"><map><emph>ArithOp</emph></map><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a></td></tr>
          <tr><td rowspan="1" colspan="1">"+"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>plus</code></td></tr>
          <tr><td rowspan="1" colspan="1">"-"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>minus</code></td></tr>
          <tr><td rowspan="1" colspan="1">"*"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>times</code></td></tr>
          <tr><td rowspan="1" colspan="1">"div"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>div</code></td></tr>
          <tr><td rowspan="1" colspan="1">"mod"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>mod</code></td></tr>
        </tbody>
      </table>

      <table border="1">
        <tbody>
          <tr><td rowspan="1" colspan="1"><emph>UnaryArithOp</emph></td><td rowspan="1" colspan="1"><map><emph>UnaryArithOp</emph></map><a href="#jd_map_arithop" class="judgment"><subscript>UnaryArithOp</subscript></a></td></tr>
          <tr><td rowspan="1" colspan="1">"+"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>unary-plus</code></td></tr>
          <tr><td rowspan="1" colspan="1">"-"</td><td rowspan="1" colspan="1"><emph>fs:</emph><code>unary-minus</code></td></tr>
        </tbody>
      </table>

   </smnotation>

  <smcore>
    <p>There are no Core grammar productions for arithmetic
    expressions as they are normalized to other Core expressions. </p>
  </smcore>

  <smnorm>
     <p>The normalization rules for all the arithmetic operators
     except <code>idiv</code> first atomize each argument by applying
     <code>fn:data</code> and then apply the internal function
     <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> to each argument.  If the first argument to
     this function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first
     argument is cast to a double, otherwise it is returned unchanged.
     The overloaded internal function corresponding to the arithmetic
     operator is then applied to the two converted arguments.  The
     table above maps the operators to the corresponding internal
     function.  The mapping from the overloaded internal functions to
     the corresponding non-overloaded function is given in <specref ref="sec_operators"/>.</p>

   <mapping>
    <xquery>
     <expression>
      <map><emph>Expr</emph><subscript>1</subscript> <emph>ArithOp</emph>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
      <table summary=""><tbody>
        <tr><td rowspan="1" colspan="1"><map><emph>ArithOp</emph></map><a href="#jd_map_arithop" class="judgment"><subscript>ArithOp</subscript></a>
          (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0),
         </td></tr>
        <tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
         </td></tr>
       </tbody></table>
     </expression>
    </core>
   </mapping>

   <p>The normalization rules for the <code>idiv</code> operator are similar,
   but instead of casting arguments with type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to
   <code>xs:double</code>, they are cast to <code>xs:integer</code>.</p>

   <mapping>
    <xquery>
     <expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>idiv</code>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
      <table summary=""><tbody>
        <tr valign="baseline"><td rowspan="1" colspan="1"><emph>fs:</emph><code>idiv</code>
          (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1),
         </td></tr>
        <tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1))
         </td></tr>
       </tbody></table>
     </expression>
    </core>
   </mapping>
  

   <p>The unary operators are mapped similarly.</p>

   <mapping>
    <xquery>
     <expression>
      <map><code>+</code> <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
            <emph>fs:</emph><code>unary-plus</code>(<a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
     </expression>
    </core>
   </mapping>

   <mapping>
    <xquery>
     <expression>
      <map><code>-</code> <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
        <emph>fs:</emph><code>unary-minus</code>(0, <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), 1.0E0))
     </expression>
    </core>
   </mapping>

</smnorm>

<smtype>
  <p>The static semantics for function calls is given in
  <specref ref="id-function-calls"/>.</p>
</smtype>

<smeval>
  <p>The dynamic semantics for
  function calls is given in <specref ref="id-function-calls"/>.</p>
</smeval>

  </div2>

  <div2 id="sec_comparisons">
    <head>Comparison Expressions</head>

    <smintro>

      <p>Comparison expressions allow two values to be
      compared. [XPath/XQuery] provides three kinds of comparison
      expressions, called value comparisons, general comparisons, and
      node comparisons.</p>

      <scrap headstyle="show">
        <head>Comparison Expressions</head>
        <prod num="48 (XQuery)" id="doc-xquery-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod>
        <prod num="61 (XQuery)" id="doc-xquery-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod>
        <prod num="60 (XQuery)" id="doc-xquery-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod>
        <prod num="62 (XQuery)" id="doc-xquery-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod>
      </scrap>
    </smintro>

  <div3 id="sec_value_comparisons">
    <head>Value Comparisons</head>

    <smnotation>
      <p id="jd_map_valueop">The mapping function
      <map/><a href="#jd_map_valueop" class="judgment"><subscript>ValueOp</subscript></a> is defined by the following
      table:</p>

      <table border="1"><tbody>
      <tr><td rowspan="1" colspan="1">ValueOp</td><td rowspan="1" colspan="1"><map>ValueOp</map><a href="#jd_map_valueop" class="judgment"><subscript>ValueOp</subscript></a></td></tr>
      <tr><td rowspan="1" colspan="1">"<code>eq</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>eq</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>ne</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ne</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>lt</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>lt</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>le</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>le</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>gt</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>gt</td></tr> 
      <tr><td rowspan="1" colspan="1">"<code>ge</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ge</td></tr></tbody></table>
    </smnotation>

    <smcore>
      <p>There are no Core grammar productions for value comparisons
      as they are normalized to other Core expressions. </p>
    </smcore>

    <smnorm>
      <p>The normalization rules for the value comparison operators
      first atomize each argument by applying <code>fn:data</code> and then apply
      the internal function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> defined in <specref ref="sec_convert_operand"/>.  If the first argument to this
      function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first argument is
      cast to a string, otherwise it is returned unchanged.  The
      overloaded internal function corresponding to the value
      comparison operator is then applied to the two converted
      arguments.  The table above maps the value operators to the
      corresponding internal function.  The mapping from the
      overloaded internal functions to the corresponding
      non-overloaded function is given in <specref ref="sec_operators"/>.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>Expr</emph><subscript>1</subscript> <emph>ValueOp</emph>  <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
         <table summary=""><tbody>
           <tr><td rowspan="1" colspan="1"><map><emph>ValueOp</emph></map><a href="#jd_map_valueop" class="judgment"><subscript>ValueOp</subscript></a>
             (</td><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), "string"),
            </td></tr>
           <tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>(<code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)), "string") )
            </td></tr>
          </tbody></table>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics for function calls is given in <specref ref="id-function-calls"/>.  The comparison functions all have
      return type <code>xs:boolean</code>, as specified in <bibref ref="xpath-functions"/>. </p>
    </smtype>

    <smeval>
      <p>The dynamic semantics for function calls is given in <specref ref="id-function-calls"/>.</p>
    </smeval>

  </div3>

  <div3 id="sec_general_comparisons">
    <head>General Comparisons</head>

    <smintro>
      <p>General comparisons are defined by adding existential
      semantics to value comparisons. The operands of a general
      comparison may be sequences of any length. The result of a
      general comparison is always <code>true</code> or
      <code>false</code>.</p>
    </smintro>

    <smnotation>

      <p>For convenience, GeneralOp denotes the operators "<code>=</code>",
      "<code>!=</code>", "<code>&lt;</code>", "<code>&lt;=</code>", "<code>&gt;</code>", or "<code>&gt;=</code>".</p>

      <p id="jd_map_generalop">The function
      <map/><a href="#jd_map_generalop" class="judgment"><subscript>GeneralOp</subscript></a> is defined by the following
      table:</p>

      <table border="1"><tbody>
      <tr><td rowspan="1" colspan="1"><emph>GeneralOp</emph></td><td rowspan="1" colspan="1"><map><emph>GeneralOp</emph></map><a href="#jd_map_generalop" class="judgment"><subscript>GeneralOp</subscript></a></td></tr>
      <tr><td rowspan="1" colspan="1">"<code>=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>eq</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>!=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ne</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>&lt;</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>lt</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>&lt;=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>le</td></tr>
      <tr><td rowspan="1" colspan="1">"<code>&gt;</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>gt</td></tr> 
      <tr><td rowspan="1" colspan="1">"<code>&gt;=</code>"</td><td rowspan="1" colspan="1"><emph>fs:</emph>ge</td></tr></tbody></table>

    </smnotation>

    <smcore>
      <p>There are no Core grammar productions for general comparisons
      as they are normalized to existentially quantified Core
      expressions.</p>
    </smcore>

    <smnorm>
      <p>The normalization rule for a general comparison expression
      first atomizes each argument by applying <code>fn:data</code> and then
      applies the existentially quantified <emph>SomeExpr</emph> expression to
      each sequence.  The internal function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> is
      applied to each pair of atomic values.  If the first argument to
      this function has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then the first
      argument is cast to type of the second argument.  If the second
      argument has type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, the first argument is cast
      to a string.  The overloaded internal function corresponding to
      the general comparison operator is then applied to the two
      converted values.</p>

          <mapping>
            <xquery>
              <expression>
                <map><emph>Expr</emph><subscript>1</subscript> <emph>GeneralOp</emph> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              </expression>
            </xquery>
            <core>
              <expression>
                <table summary="">
                  <tbody>
                    <tr><td rowspan="1" colspan="1">some $v1 in <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) satisfies</td></tr>
                    <tr><td rowspan="1" colspan="1">some $v2 in <code>fn:data</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) satisfies</td></tr>
                    <tr><td rowspan="1" colspan="1">let $u1 := <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>($v1, $v2) return </td></tr>
                    <tr><td rowspan="1" colspan="1">let $u2 := <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a>($v2, $v1) return </td></tr>
                    <tr><td rowspan="1" colspan="1"><map><emph>GeneralOp</emph></map><a href="#jd_map_generalop" class="judgment"><subscript>GeneralOp</subscript></a> ($u1, $u2)</td></tr>
                  </tbody>
                </table>
              </expression>
            </core>
          </mapping>
      </smnorm>

  </div3>

  <div3 id="sec_node-comparisons">
    <head>Node Comparisons</head>

<smcore>
  <p>There are no Core grammar productions for node comparisons as
  they are normalized to other Core expressions.</p>
</smcore>

<smnorm>
  <p>The normalization rules for node comparisons map each argument
  expression and then apply the internal function corresponding to the
  node comparison operator. The internal function are defined in
  <specref ref="sec_operators"/>.</p>

<mapping>
<xquery>
<expression>
<map><emph>Expr</emph><subscript>1</subscript> <code>is</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression>
</xquery>
<core>
     <expression>
       <table summary=""><tbody>
       <tr><td rowspan="1" colspan="1">   <emph>fs:</emph><code>is-same-node</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr>
       </tbody></table>
     </expression>
</core>
</mapping>

<mapping>
<xquery>
<expression>
<map><emph>Expr</emph><subscript>1</subscript> &lt;&lt; <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression>
</xquery>
<core>
<expression>
       <table summary=""><tbody>
       <tr><td rowspan="1" colspan="1"><emph>fs:</emph><code>node-before</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr>
       </tbody></table>
</expression>
</core>
</mapping>

<mapping>
<xquery>
<expression>
<map><emph>Expr</emph><subscript>1</subscript> &gt;&gt; <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
</expression>
</xquery>
<core>
<expression>
       <table summary=""><tbody>
       <tr><td rowspan="1" colspan="1"><emph>fs:</emph><code>node-after</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>), (<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))</td></tr>
       </tbody></table>
</expression>
</core>
</mapping>

</smnorm>

<smtype>
  <p>The static semantics for the internal functions are defined in
  <specref ref="sec_operators"/>. </p>
</smtype>

<smeval>
  <p>The dynamic semantics for internal function is defined in
  <specref ref="sec_operators"/>.</p>
</smeval>

  </div3>

  </div2>

  <div2 id="id-logical-expressions"> 
    <head>Logical Expressions</head>

    <smintro>
      <p>A <term>logical expression</term> is either an
      <term>and-expression</term> or an
      <term>or-expression</term>. The value of a logical expression is
      always one of the boolean values: <code>true</code> or
      <code>false</code>.</p>
    </smintro>

    <scrap headstyle="show">
      <head>Logical Expressions</head>
      <prod num="46 (XQuery)" id="doc-xquery-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod>
      <prod num="47 (XQuery)" id="doc-xquery-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar productions for logical expressions are:</p>

      <scrap headstyle="show">
        <head>Core Logical Expressions</head>
        <prod num="36 (Core)" id="doc-core-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod>
        <prod num="37 (Core)" id="doc-core-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CastableExpr" xlink:type="simple">CastableExpr</nt> )*</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>The normalization rules for "<code>and</code>" and "<code>or</code>" first
      get the effective boolean value of each argument, then apply the
      appropriate Core operator.</p>

   <mapping>
    <xquery>
     <expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
      <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) <code>and</code> <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
     </expression>
    </core>
   </mapping>

   <mapping>
    <xquery>
     <expression>
      <map><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
      <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) <code>or</code> <code>fn:boolean</code>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))
     </expression>
    </core>
   </mapping>
    </smnorm>

    <smtype>
      <p>The logical expressions require that each subexpression have
type <code>xs:boolean</code>.  The result type is also <code>xs:boolean</code>.</p>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>n</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

    </smtype>
    
    <smeval>
      <p>The dynamic semantics of logical expressions is
non-deterministic.   This non-determinism permits implementations to use
short-circuit evaluation strategies when evaluating logical expressions. In the expression, <emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript>,
if either expression raises an error or evaluates to false, the entire
expression may raise an error or evaluate to false. 
In the expression, <emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript>,
if either expression raises an error or evaluates to true, the entire
expression may raise an error or evaluate to true. </p>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>i</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression>
        </clause>
      </multiclause>
      <multiclause>
        <clause><expression>i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,2 }</expression></clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                false</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression>
        </clause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression>
        </clause>

      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>and</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                true</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>i</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression>
        </clause>
      </multiclause>
      <multiclause>
        <clause><expression>i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,2 }</expression></clause>
      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                true</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

<infergr>
  <infer>
    <prejudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression>
        </clause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
          <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression>
        </clause>

      </multiclause>
    </prejudge>
    <postjudge>
      <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
                <expression><emph>Expr</emph><subscript>1</subscript> <code>or</code> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                false</expression>
        </clause>
      </multiclause>
    </postjudge>
  </infer>
</infergr>

    </smeval>

  </div2>

  <div2 id="sec_constructors">
    <head>Constructors</head>

    <p>[XPath/XQuery] supports two forms of constructors. <term>Direct
    constructors</term> support literal XML syntax for elements,
    attributes, text nodes, processing-instructions and
    comments. <term>Computed constructors</term> can be used to
    construct elements, attributes, text nodes,
    processing-instructions, comments, and document nodes.  All direct
    constructors are normalized into computed constructors, i.e.,
    there are no direct-constructor expressions in the Core.</p>

    <scrap headstyle="show">
      <head>Constructors</head>
      <prod num="94 (XQuery)" id="doc-xquery-Constructor"><lhs>Constructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt></rhs></prod>
      <prod num="95 (XQuery)" id="doc-xquery-DirectConstructor"><lhs>DirectConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt></rhs></prod>
      <prod num="96 (XQuery)" id="doc-xquery-DirElemConstructor"><lhs>DirElemConstructor</lhs><rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs></prod>
      <prod num="101 (XQuery)" id="doc-xquery-DirElemContent"><lhs>DirElemContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CDataSection</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt></rhs></prod>
      <prod num="148 (XQuery)" id="doc-xquery-ElementContentChar"><lhs>ElementContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs></prod>
      <prod num="102 (XQuery)" id="doc-xquery-CommonContent"><lhs>CommonContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt></rhs></prod>
      <prod num="107 (XQuery)" id="doc-xquery-CDataSection"><lhs>CDataSection</lhs><rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs></prod>
      <prod num="108 (XQuery)" id="doc-xquery-CDataSectionContents"><lhs>CDataSectionContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs></prod>
      <prod num="97 (XQuery)" id="doc-xquery-DirAttributeList"><lhs>DirAttributeList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs></prod>
      <prod num="98 (XQuery)" id="doc-xquery-DirAttributeValue"><lhs>DirAttributeValue</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs></prod>
      <prod num="99 (XQuery)" id="doc-xquery-QuotAttrValueContent"><lhs>QuotAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod>
      <prod num="100 (XQuery)" id="doc-xquery-AposAttrValueContent"><lhs>AposAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod>
      <prod num="149 (XQuery)" id="doc-xquery-QuotAttrContentChar"><lhs>QuotAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs></prod>
      <prod num="150 (XQuery)" id="doc-xquery-AposAttrContentChar"><lhs>AposAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs></prod>
      <prod num="146 (XQuery)" id="doc-xquery-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod>
      <prod num="147 (XQuery)" id="doc-xquery-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod>
      <prod num="29 (XQuery)" id="doc-xquery-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar productions for constructors are:</p>

<scrap headstyle="show">
  <head>Constructors</head>
  <prod num="64 (Core)" id="doc-core-Constructor"><lhs>Constructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt></rhs></prod>
  <prod num="65 (Core)" id="doc-core-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt></rhs></prod>
  <prod num="21 (Core)" id="doc-core-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
</scrap>

      <p>There are no Core grammar productions for direct XML element
      or attribute constructors as they are normalized to computed
      constructors.</p>
    </smcore>

  <div3 id="id_element_constructor">
    <head>Direct Element Constructors</head>

    <smintro>
      <p>The static and dynamic semantics of the direct forms of
      element and attribute constructors are specified on the
      equivalent computed element and attribute constructors.</p>
    </smintro>

    <smnotation>
      <p id="jd_map_element_content">The auxiliary mapping rules
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a>,
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a>,
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a>, and
      <map/><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnits</subscript></a> are defined in this section and
      are used for the normalization of the content of direct element
      constructors.</p>
    </smnotation>

    <smnotation>
      <p>An element-content unit is either a maximal contiguous
      sequence of literal characters (including character references,
      escaped braces, and predefined entity references), an enclosed
      expression, a direct element constructor, an XML comment, or an
      XML processing instruction. We use the following auxiliary
      grammar productions to describe element-content units.</p>

      <scrap headstyle="show">
        <head/>
        <prod num="83 (Formal)" id="doc-fs-ElementContentUnit"><lhs>ElementContentUnit</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-DirCharsUnit" xlink:type="simple">DirCharsUnit</nt></rhs></prod>
        <prod num="84 (Formal)" id="doc-fs-DirCharsUnit"><lhs>DirCharsUnit</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CDataSection</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <rhs-group role="xquery">"{{"</rhs-group>  |  <rhs-group role="xquery">"}}"</rhs-group>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt>)+</rhs></prod>
      </scrap>

      <p>We use the auxiliary normalization rule <map>
      <emph>DirElemContent</emph>* </map><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a> to
      restructure the original element content, <emph>DirElemContent</emph>*,
      into the appropriate sequence of element-content units. This
      normalization rule is not specified formally.</p>

      <p>Here are three direct element constructors that each contain
      one element-content unit:</p>

<eg xml:space="preserve">
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;

&lt;name&gt;Dizzy Gillespie&lt;/name&gt;

&lt;comment&gt;&lt;!-- Just a comment --&gt;&lt;/comment&gt;
</eg>

     <p>The first contains one enclosed expression, the second
     contains one contiguous sequence of characters, and the third
     contains one XML comment.</p>

     <p>After boundary whitespace is stripped, the next example
     contains six element-content units: </p>

<eg xml:space="preserve">
&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
</eg>

     <p>It contains an XML comment, followed by an enclosed expression
     that contains the integer 123, a contiguous sequence of
     characters ("-0A "), a direct XML element constructor, a
     contiguous sequence of characters (" Flushing, NY "), and an
     enclosed expression that contains the integer 11368. Evaluation
     of that constructor will result in the following element.</p>

<eg xml:space="preserve">
&lt;address&gt;&lt;!-- Dizzy's address --&gt;123-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY 11368&lt;/address&gt;
</eg>

    </smnotation>

    <smnorm>
      <p>We start by giving the rules for the two forms of direct XML
      element constructors.  Note that the direct attribute
      constructors are normalized twice: the
      <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> normalizes the
      namespace-declaration attributes and
      <map/><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> normalizes all other attributes
      that are not namespace-declaration attributes. </p>

      <mapping>
      <xquery>
        <expression><map> &lt; <emph>QName</emph> <emph>DirAttributeList</emph> &gt;
          <emph>DirElemContent</emph>* &lt;/ <emph>QName</emph> S? &gt;
          </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
      </xquery>
      <core>
        <expression>element <emph>QName</emph> { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> , <map>
          <map> <emph>DirElemContent</emph>* </map><a href="#jd_map_element_content" class="judgment"><subscript>PartitionIntoUnits</subscript></a>
          </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a> } { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> }
        </expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression><map> &lt; <emph>QName</emph> <emph>DirAttributeList</emph> /&gt;
          </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
      </xquery>
      <core>
        <expression>element <emph>QName</emph> { <map>
        <emph>DirAttributeList</emph> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a> } { <map>
          <emph>DirAttributeList</emph> </map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> }
        </expression>
      </core>
      </mapping>

      <p>We can now give the rules for normalizing a direct element
      constructor's content. We distinguish between direct element
      constructors that contain only one element-content unit and
      those that contain more than one element-content unit.</p>

      <p>Adjacent element-content units are convenient because they
      permit arbitrary interleaving of text and atomic data.  During
      evaluation, atomic values are converted to text nodes containing
      the string representations of the atomic values, and then
      adjacent text nodes are concatenated together.  In the example
      at the beginning of this section, the integer 123 is converted
      to a string and concatenated with "-0A" and the result is a
      single text node containing "123-0A".</p>

      <p>In general, we do not want to convert all atomic values to
      text nodes, especially when performing static-type analysis,
      because we lose useful type information.  For example, if we
      normalize the first example above as follows, we lose the
      important information that the user constructed a date value,
      not just a text node containing an arbitrary string: </p>

<eg xml:space="preserve">
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 (normalization that loses type information) = 
element date { text { "2003-03-18" } } 
</eg>

      <p>To preserve useful type information, we distinguish between
      direct element constructors that contain one element-content
      unit and those that contain more than one (because multiple
      element-content units commonly denote concatenation of atomic
      data and text). Below are two examples of normalization for
      element constructors.</p>

<eg xml:space="preserve">
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 =
element date { xs:date("2003-03-18") } 

&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
 =
element address {
  fs:item-sequence-to-node-sequence(
    comment { " Dizzy's address "},
    123, 
    text { "-0A "}, 
    element street {"Roosevelt Ave."},
    text { " Flushing, NY "  },
    11368
  )
}
</eg>

    <p>We give two normalization rules for a direct element
    constructor's content.  If the direct element constructor contains
    exactly one element-content unit, we simply normalize that unit by
    applying the normalization rule for the element content:</p>

    <mapping>
      <xquery>
        <expression><map>
          <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a>
        </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a></expression>
      </xquery>
      <core>
        <expression><map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a> </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a> 
        </expression>
      </core>
    </mapping>

    <p>If the direct element constructor contains more than one
    element-content unit, we normalize each unit individually and
    construct a sequence of the normalized results interleaved with
    empty text nodes.  The empty text nodes guarantee that the results
    of evaluating consecutive element-content units can be
    distinguished.  Then we apply the function
    <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>.  <xspecref spec="XQ" ref="id-element-constructor"/> specifies the rules for converting
    a sequence of atomic values and nodes into a sequence of nodes
    before element construction.  The Formal Semantics function
    <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> implements these conversion rules.</p>

      <mapping>
        <xquery>
          <expression><map><a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript> ...,  <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>n</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContent</subscript></a></expression>
        </xquery>
        <core>
          <expression><a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>1</subscript> </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a> , text { "" }, ..., text { "" }, <map> <a href="#doc-fs-ElementContentUnit"><emph>ElementContentUnit</emph></a><subscript>n</subscript></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a>))
          </expression>
        </core>
      </mapping>

    <p>We must distinguish between the results of consecutive
    element-content units, because the rule for converting sequences
    of atomic values into strings applies to sequences within distinct
    enclosed expressions.  The empty text nodes are eliminated during
    evaluation of <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> when consecutive text
    nodes are coalesced into a single text node.  The text node
    guarantees that a whitespace character will not be inserted
    between atomic values computed by distinct enclosed expressions.
    For example, here is an expression, its normalization, and the
    resulting XML value:</p>

<eg xml:space="preserve">
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 =
element example { fs:item-sequence-to-node-sequence ((1, text {""}, 2)) }
 ==&gt;
&lt;example&gt;12&lt;/example&gt;
</eg>

      <p>In the absence of the empty text node, the expression would
      evaluate to the following incorrect value:</p>

<eg xml:space="preserve">
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 (incorrect normalization) =
element example { fs:item-sequence-to-node-sequence ((1, 2)) }
 (incorrect value) ==&gt;
&lt;example&gt;1 2&lt;/example&gt;
</eg>

      <p>Next, we give the normalization rules for each
      element-content unit. The normalization rule for a contiguous
      sequence of characters assumes that the significant whitespace
      characters in element constructors have been preserved, as
      described in <specref ref="sec_whitespace"/>.</p>

      <p>The following normalization rule takes the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, character references,
      and predefined entity references and normalizes the character
      sequence as a text node containing the string of characters.</p>

      <mapping>
        <xquery>
       <expression><map><a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression>
        </xquery>
        <core>
       <expression>text { <map> <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a>
       </map><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnits</subscript></a> }</expression>
        </core>
      </mapping>

    <p>The application of <map/><a href="#jd_map_element_content" class="judgment"><subscript>DirCharsUnits</subscript></a> to
    <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a> is defined informally. It produces a string
    literal corresponding to the content of the <a href="#doc-fs-DirCharsUnit"><emph>DirCharsUnit</emph></a>, in
    boundary whitespace is processed and non-literal characters
    (CharRefs, PredefinedEntityRefs, CDataSections, and
    escaped-braces) are resolved according to the rules in <xspecref spec="XQ" ref="id-content"/>.</p>

    <p>XML processing instructions and comments in element content are
    normalized by applying the standard normalization rules for
    expressions, which appear in <specref ref="sec_other_constructors"/>.</p>

      <mapping>
      <xquery>
        <expression><map><emph>DirPIConstructor</emph></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression>
      </xquery>
      <core>
        <expression><map><emph>DirPIConstructor</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression><map>DirCommentConstructor</map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression>
      </xquery>
      <core>
        <expression><map>DirCommentConstructor</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
      </core>
      </mapping>

    <p>A direct element constructor is normalized using the
    normalization rule for expressions.</p>

      <mapping>
      <xquery>
        <expression><map><emph>DirElemConstructor</emph></map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression>
      </xquery>
      <core>
        <expression><map><emph>DirElemConstructor</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
      </core>
      </mapping>

    <p>An enclosed expression in element content is normalized by
    normalizing each individual expression in its expression sequence
    and then constructing a sequence of the normalized values:</p>

      <mapping>
        <xquery>
          <expression><map>
            { <emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript> }
          </map><a href="#jd_map_element_content" class="judgment"><subscript>ElementContentUnit</subscript></a></expression>
        </xquery>
        <core>
          <expression><map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> , ..., <map> <emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
        </core>
      </mapping>
      </smnorm>

      <smtype>
        <p>There are no additional static typing rules for direct XML
        element or attribute constructors.</p>
      </smtype>

      <smeval>
        <p>There are no additional dynamic evaluation rules for direct
        XML element or attribute constructors.</p>
      </smeval>

      <div4 id="sec_direct_attributes">
        <head>Attributes</head>

        <p>Like direct element constructors, direct attribute
        constructors are normalized to computed attribute
        constructors.</p>

      <smnotation>
        <p id="jd_map_attr_content">The auxiliary mapping rules
        <map/><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>,
        <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a>, and
        <map/><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>, are defined in
        this section and are used for the normalization of direct
        attribute constructors.</p>

        <p>We use the following grammar productions to represent
        <emph>AttributeContentUnit</emph>s, i.e., the expressions used to
        compute the content of an attribute.</p>

      <scrap headstyle="show">
      <head/>
      <prod num="87 (Formal)" id="doc-fs-AttributeContentUnits"><lhs>AttributeContentUnits</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeContentUnit" xlink:type="simple">AttributeContentUnit</nt>*</rhs></prod>
      <prod num="88 (Formal)" id="doc-fs-AttributeContentUnit"><lhs>AttributeContentUnit</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt></rhs></prod>
      </scrap>
      </smnotation>

      <smnorm>
        <p id="sec_attribute_normalization">Direct attributes may
        contain namespace-declaration attributes.  The normalization
        rules in this section ignore namespace-declaration attributes
        -- they are handled by the normalization rules in <specref ref="sec_namespace_attrs"/>.</p>

        <p>An <emph>DirAttributeList</emph> is normalized by the following
        rule, which maps each of the individual attribute-value
        expressions in the attribute list and constructs a sequence of
        the normalized values.</p>

      <mapping>
      <xquery>
        <expression>
      <map><table><tbody>
      <tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript>
      </td></tr>
      <tr><td rowspan="1" colspan="1">
          ...
      </td></tr>
      <tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript>
      </td></tr>
      </tbody></table></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
        </expression>
        </xquery>
      <core>
      <expression>
      <table><tbody>
      <tr><td rowspan="1" colspan="1">
        (<map><emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript> </map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
      </td></tr>
      <tr><td rowspan="1" colspan="1">
         ..., 
      </td></tr>
      <tr><td rowspan="1" colspan="1">
        <map><emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>)
      </td></tr>
      </tbody></table>
      </expression>
      </core>
      </mapping>

      <p id="jd_map_attribute">Namespace-declaration attributes, i.e.,
      those attributes whose prefix is <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <mapping>
      <xquery>
        <expression>
<table><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S?
      <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
</td></tr>
<tr><td rowspan="1" colspan="1">
      (<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        ()
      </expression>
      </core>
      </mapping>

      <p>All attributes that are not namespace-declaration attributes
      are mapped to computed attribute constructors.</p>

      <mapping>
      <xquery>
        <expression>
<table><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S? "
      <emph>AttributeContentUnits</emph> "</map><a href="#jd_map_attribute" class="judgment"><subscript>Attribute</subscript></a>
</td></tr>
<tr><td rowspan="1" colspan="1">
      <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        attribute <emph>Prefix</emph>:<emph>LocalPart</emph> { <map><emph>AttributeContentUnits</emph></map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a>}
      </expression>
      </core>
      </mapping>

      <p>As with literal XML elements, we need to distinguish between
      direct attribute constructors that contain one attribute-content
      unit and those that contain multiple attribute-content units,
      because the rule for converting sequences of atomic values into
      strings is applied to sequences within distinct enclosed
      expressions.  If the direct attribute constructor contains
      exactly one attribute-content unit, we simply normalize that
      unit by applying the normalization rule for attribute content
      units:</p>

      <mapping>
      <xquery>
        <expression><map> <emph>AttributeContentUnit</emph><subscript>1</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a></expression>
      </xquery>
      <core>
        <expression>
          <map><emph>AttributeContentUnit</emph><subscript>1</subscript></map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>
        </expression>
      </core>
      </mapping>

      <p>If the direct attribute constructor contains more than one
      attribute-content unit, we normalize each unit individually and
      construct a sequence of the normalized results interleaved with
      empty text nodes.  The empty text nodes guarantee that the
      results of evaluating consecutive attribute-content units can be
      distinguished.  Then we apply the function
      <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>, which applies the appropriate
      conversion rules to the normalized attribute content:</p>

      <mapping>
      <xquery>
        <expression><map> <emph>AttributeContentUnit</emph><subscript>1</subscript> ...
          <emph>AttributeContentUnit</emph><subscript>n</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContent</subscript></a></expression>
      </xquery>
      <core>
        <expression>
          <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>((<map> <emph>AttributeContentUnit</emph><subscript>1</subscript>
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a> , text { "" }, ..., text
          {""}, <map>
          <emph>AttributeContentUnit</emph><subscript>n</subscript></map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a>))
        </expression>
      </core>
      </mapping>

      <p>Literal characters, escaped curly braces, character
      references, and predefined entity references in attribute
      content are treated as in element content.  In addition, the
      normalization rule for characters in attributes assumes:</p>

      <olist>
        <item><p>that an escaped single or double quote is converted
        to an individual single or double quote.</p></item>
      </olist>

      <p>The following normalization rules take the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, escaped quotes,
      character references, predefined entity references, and escaped
      single and double quotes and normalizes the character sequence
      as a string. </p>

      <mapping>
        <xquery>
          <expression><map>( <emph>Char</emph> | <emph>CharRef</emph> |
          <emph>EscapeQuot</emph> | <emph>EscapeApos</emph> | <emph>PredefinedEntityRef</emph>
          ) +</map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a></expression>
        </xquery>
        <core>
          <expression><code>fn:codepoints-to-string</code>(( <emph>Char</emph> | <emph>CharRef</emph> |
          <emph>EscapeQuot</emph> | <emph>EscapeApos</emph> | <emph>PredefinedEntityRef</emph>
          )+)</expression>
        </core>
      </mapping>

      <p>We normalize an enclosed expression by normalizing each
      individual expression in its expression sequence and then
      constructing a sequence of the normalized values:</p>

      <mapping>
      <xquery>
        <expression><map> { <emph>Expr</emph><subscript>1</subscript>, ..., <emph>Expr</emph><subscript>n</subscript> }
          </map><a href="#jd_map_attr_content" class="judgment"><subscript>AttributeContentUnit</subscript></a></expression>
      </xquery>
      <core>
        <expression>(<map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> , ..., <map>
        <emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)
        </expression>
      </core>
      </mapping>
    </smnorm>
    </div4>

    <div4 id="sec_namespace_attrs">
      <head>Namespace Declaration Attributes</head>

      <smnotation>
        <p id="jd_map_namespace_attr">The auxiliary mapping rules
        <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>, and
        <map/><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a> are defined in this
        section and are used for the normalization of namespace
        declaration attributes.</p>
      </smnotation>

      <smnorm>
        <p>Some direct attributes may be namespace-declaration
        attributes.  The normalization rules for namespace-declaration
        attributes ignore all non-namespace attributes -- they are
        handled by the normalization rules in <specref ref="sec_direct_attributes"/>.</p>

        <p>An <emph>DirAttributeList</emph> containing namespace-declaration
        attributes is normalized by the following rule, which maps
        each of the individual namespace-declaration attributes in the
        attribute list and constructs a sequence of the normalized
        namespace attribute values.</p>

      <mapping>
      <xquery>
        <expression>
      <map><table><tbody>
      <tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript>
      </td></tr>
      <tr><td rowspan="1" colspan="1">
          ...
      </td></tr>
      <tr><td rowspan="1" colspan="1">
          <emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript>
      </td></tr>
      </tbody></table></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttrs</subscript></a>
        </expression>
        </xquery>
      <core>
      <expression>
      <table><tbody>
      <tr><td rowspan="1" colspan="1">
        (<map><emph>QName</emph><subscript>1</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>1</subscript></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
      </td></tr>
      <tr><td rowspan="1" colspan="1">
         ..., 
      </td></tr>
      <tr><td rowspan="1" colspan="1">
        <map><emph>QName</emph><subscript>n</subscript> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a><subscript>n</subscript></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>)
      </td></tr>
      </tbody></table>
      </expression>
      </core>
      </mapping>

      <p>Attributes whose prefix is not <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <mapping>
      <xquery>
        <expression>
<table><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S? <a href="#doc-xquery-DirAttributeValue"><emph>DirAttributeValue</emph></a></map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
</td></tr>
<tr><td rowspan="1" colspan="1">
      <a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr>
</tbody></table>
</expression>
        </xquery>
      <core>
      <expression>
        ()
      </expression>
      </core>
      </mapping>

      <p>Namespace-declaration attributes are normalized to local
      namespace declarations (<a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a>). The content of
      such attributes must be defined with a URI literal.</p>

      <mapping>
      <xquery>
        <expression>
<table><tbody><tr><td rowspan="1" colspan="1">
      <map><emph>Prefix</emph>:<emph>LocalPart</emph> S? = S? " <emph>URILiteral</emph> "</map><a href="#jd_map_namespace_attr" class="judgment"><subscript>NamespaceAttr</subscript></a>
</td></tr>
<tr><td rowspan="1" colspan="1">
      (<emph>Prefix</emph> = <code>xmlns</code>)
</td></tr>
</tbody></table>
        </expression>
        </xquery>
      <core>
      <expression>
        namespace <emph>LocalPart</emph> { <emph>URILiteral</emph> }
      </expression>
      </core>
      </mapping>

    </smnorm>
    </div4>

    <div4 id="sec_content">
      <head>Content</head>
<p>The rules for normalizing element content are given above in
<specref ref="id_element_constructor"/>.</p>
    </div4>

    <div4 id="sec_whitespace">
      <head>Boundary Whitespace</head>

      <p><xspecref spec="XQ" ref="id-whitespace"/> describes how
      whitespace is processed in element constructors depending on the
      value of the <code>boundary-space</code> declaration in the
      query prolog. The Formal Semantics assumes that the rules for
      handling whitespace are applied prior to normalization rules,
      for example, during parsing of a query.  Therefore, there are no
      formal rules for handling whitespace.</p>
    </div4>

  </div3>
  <!-- ***************** PI and Comments       ****** -->
  <div3 id="sec_other_constructors">
    <head>Other Direct Constructors</head>

    <scrap headstyle="show">
      <head>Other Constructors</head>
      <prod num="105 (XQuery)" id="doc-xquery-DirPIConstructor"><lhs>DirPIConstructor</lhs><rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs></prod>
      <prod num="106 (XQuery)" id="doc-xquery-DirPIContents"><lhs>DirPIContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs></prod>
      <prod num="103 (XQuery)" id="doc-xquery-DirCommentConstructor"><lhs>DirCommentConstructor</lhs><rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs></prod>
      <prod num="104 (XQuery)" id="doc-xquery-DirCommentContents"><lhs>DirCommentContents</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')))*</rhs></prod>
    </scrap>

    <smnotation>
      <p id="jd_map_characters">The auxiliary mapping rule
      <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> is defined in this section and
      used for the normalization of direct PI and comment
      constructors.</p>
    </smnotation>

    <smnorm>
      <p>A literal XML processing instruction is normalized into a
      computed processing-instruction constructor; its character
      content is converted to a string using the auxiliary mapping
      rule <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a>.</p>

   <mapping>
    <xquery>
     <expression>
      <map>&lt;? <emph>NCName</emph> <emph>DirPIContents</emph> ?&gt;</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </xquery>
    <core>
     <expression>
      <map>processing-instruction <emph>NCName</emph> { <map><emph>DirPIContents</emph></map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
     </expression>
    </core>
   </mapping>

    <p>A literal XML comment is normalized into a computed comment
    constructor; its character content is converted to a string using
    the auxiliary mapping rule <map/><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a>.</p>

    <mapping>
    <xquery>
    <expression>
     <map>&lt;!-- <emph>DirCommentContents</emph> --&gt;</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
    </expression>
    </xquery>
    <core>
    <expression>
     <map>comment { <map><emph>DirCommentContents</emph></map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
    </expression>
    </core>
    </mapping>

      <p>The following normalization rule takes the character content
      of PI or comment constructors and creates a corresponding
      string.</p>

      <mapping>
        <xquery>
       <expression><map><emph>Char</emph>*</map><a href="#jd_map_characters" class="judgment"><subscript>Characters</subscript></a></expression>
        </xquery>
        <core>
       <expression><code>fn:codepoints-to-string</code>(<emph>Char</emph>*)</expression>
        </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>There are no additional static typing rules for direct
      processing-instruction or comment constructors.</p>
    </smtype>

    <smeval>
      <p>There are no additional dynamic evaluation rules for direct
      processing-instruction or comment constructors.</p>
    </smeval>

  </div3>
   
  <div3 id="sec_computedConstructors">
    <head>Computed Constructors</head>

    <scrap headstyle="show">
      <head>Computed Constructors</head>
      <prod num="109 (XQuery)" id="doc-xquery-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt></rhs></prod>
    </scrap>

  <div4 id="sec_comp_elem_constructor">
    <head>Computed Element Constructors</head>

    <smintro><p>This section describes the semantics of computed
    element constructors. Remember that direct element constructors
    are normalized into computed element constructors. This document
    does not formally specify how namespaces are copied. The semantics
    of namespaces copying in element constructors can be found in
    <bibref ref="xquery"/>.</p></smintro>

    <scrap headstyle="show">
      <head/>
      <prod num="111 (XQuery)" id="doc-xquery-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs></prod>
      <prod num="112 (XQuery)" id="doc-xquery-ContentExpr"><lhs>ContentExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod>
    </scrap>

<!--
    <smnotation>
      <p id="jd_split_namespaces">Local namespace declarations may
      occur explicitly in a computed element constructor or may be the
      result of normalizing namespace-declaration attributes contained
      in direct element constructors.  For local element declarations
      that occur explicitly in a query, the immediately enclosing
      expression of the local namespace declaration
      (&gr_NamespaceBinding;) must be a computed element constructor;
      otherwise, as specified in &language;, a static error is
      raised.</p>
    </smnotation>
-->

    <smcore>
      <p>The Core grammar productions for computed element
      constructors are:</p>

      <scrap headstyle="show"><head>Computed Element Constructors</head>
      <prod num="67 (Core)" id="doc-core-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ContentExpr" xlink:type="simple">ContentExpr</nt>  "}"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>*  "}"</rhs></prod>
      <prod num="69 (Core)" id="doc-core-ContentExpr"><lhs>ContentExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt></rhs></prod>
      <prod num="68 (Core)" id="doc-core-NamespaceBinding"><lhs>NamespaceBinding</lhs><rhs>"namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  "}"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>If the content expression is missing, the computed element
      constructor is normalized as if its content expression was the
      empty sequence.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element <emph>QName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
         <map>element <emph>QName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </core>
      </mapping>

      <p>Computed element constructors are normalized using the
      <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function over their content
      expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element <emph>QName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
         element <emph>QName</emph> { <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression>
       </core>
      </mapping>

      <p>When the name of the element is also computed, the
      normalization rule applies atomization to the name
      expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          element { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }{ <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smnotation>
      <p id="jd_add_namespace_bindings">The following auxiliary
      judgment adds a sequence of namespace bindings to the static
      context.</p>

        <display>
          <clause>
          <expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
          <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
          </clause>
        </display>

      <p>This judgment is defined as follows.</p>

        <infergr>
          <infer>
            <prejudge>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript> = namespace <emph>LocalPart</emph><subscript>1</subscript> { <emph>URILiteral</emph><subscript>1</subscript> }</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript> = namespace <emph>LocalPart</emph><subscript>n</subscript> { <emph>URILiteral</emph><subscript>n</subscript> }</expression>
                </clause>
              </multiclause>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment>
 	    <expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
            <clause>
              <expression>
                ...
              </expression>
            </clause>
          </multiclause>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment>
 	    <expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
          <multiclause>
          <clause>
            <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_ns_env" class="env">namespace</a> =
              <update>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                <expression><emph>LocalPart</emph><subscript>1</subscript> =&gt; (passive, <emph>AnyURI</emph><subscript>1</subscript>)</expression>
              </update></expression>
          </clause>
          </multiclause>
              <multiclause>
                <clause>
                  <expression>
                    ...
                  </expression>
                </clause>
              </multiclause>
          <multiclause>
          <clause>
            <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>.<a href="#xq_ns_env" class="env">namespace</a> =
              <update>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                <expression><emph>LocalPart</emph><subscript>n</subscript> =&gt; (passive, <emph>AnyURI</emph><subscript>n</subscript>)</expression>
              </update></expression>
          </clause>
          </multiclause>
            </prejudge>
            <postjudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
          <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript> ... <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>0</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
          <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
            </postjudge>
          </infer>
        </infergr>
    </smnotation>

    <smtype>
      <p>The normalization rules of direct element and attribute
      constructors leave us with only the computed forms of
      constructors. The static semantics for constructors is defined
      on all the computed forms. The computed element constructor
      itself has two forms: one in which the element name is a literal
      <emph>QName</emph>, and the other in which the element name is a
      computed expression.</p>

      <p>A computed element constructor creates a new element with
      either the <xtermref spec="XQ" ref="dt-type-annotation"/>
      <a href="#dt-xs_untyped"><code>xs:untyped</code></a> (in strip construction mode), or with the <xtermref spec="XQ" ref="dt-type-annotation"/> <code>xs:anyType</code> (in preserve
      construction mode). The content expression must return a
      sequence of nodes with attribute nodes at the beginning.</p>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute *, (element | text | comment | processing-instruction) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
	            <expression> element <emph>QName</emph> {
	            <emph>Expr</emph> } { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element <emph>QName</emph> of type <code>xs:anyType</code>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute *, (element | text | comment | processing-instruction) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
	            <expression> element <emph>QName</emph> {
	            <emph>Expr</emph> } { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element <emph>QName</emph> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <p>In case the element name is computed as well, the name
      expression must be of type <code>xs:QName</code>, <code>xs:string</code>, or
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute *, (element | text | comment | processing-instruction) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
	            <expression> element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element of type <code>xs:anyType</code>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
               <clause>
               <expression><a href="#jd_add_namespace_bindings" class="judgment"><term>add namespace bindings</term></a>
               <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> <a href="#jd_add_namespace_bindings" class="judgment"><term>to</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> <a href="#jd_add_namespace_bindings" class="judgment"><term>yields</term></a>
               <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
               </clause>
 	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
	      <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
	      <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      attribute *, (element | text | comment | processing-instruction) * </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
	            <expression> element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> element of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

     </smtype>

     <smeval>
       <p>The following rules take a computed element constructor
       expression and construct an element node.  The dynamic
       semantics for computed element constructors is the most complex
       of all expressions in XQuery.  Here is how to read the rule
       below.</p>

       <p>First, the element's content expression is partitioned into
       the local namespace declarations and all other expressions, and
       the local namespace declarations are evaluated, yielding a
       sequence of namespace bindings.  The static environment is
       extended to include the new namespace bindings, which are all
       <a href="#term_active">active</a>.  In <xspecref spec="XQ" ref="id-namespaces"/>, it is implementation-defined whether
       undeclaration of namespace prefixes (by setting the namespace
       prefix to the zero-length string) in an element constructor is
       supported.  In the dynamic semantics below, we assume all local
       namespace declarations declare a binding of a prefix to a
       URI.</p>

      <p>Second, the function <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> is applied to
      the element's content expression (excluding local namespace
      declarations); this function call is evaluated in the new static
      and dynamic environment.  Recall from <specref ref="id_element_constructor"/> that during normalization, we do
      not convert the content of direct element constructors that
      contain one element-content unit.  This guarantees that useful
      type information is preserved for static analysis.  Since the
      conversion function <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> was not applied to
      all element constructors during normalization, we have to apply
      it at evaluation time.  (Obviously, it is possible to elide the
      application of <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> injected during
      normalization and the application injected during evaluation.)
      The resulting value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> must match zero-or-more
      attributes followed by zero-or-more element, text,
      processing-instruction or comment nodes.</p>

      <p>Third, the namespace bindings are concatenated with the list
      of active namespaces in the namespace environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>
      and the namespaces corresponding to the element's name and all
      attributes names.  The resulting sequence is the sequence of
      namespace bindings for the element.</p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <expression> <emph>Expr</emph> = <emph>Expr</emph><subscript>0</subscript> </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		 <expression> <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<emph>Expr</emph><subscript>0</subscript>)) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                 <expression> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> (attribute*, (element | text | processing-instruction | comment)*)</expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		     element <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     element <emph>QName</emph> of type <code>xs:anyType</code> {
		     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> } { }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <expression> <emph>Expr</emph> = <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript>, <emph>Expr</emph><subscript>0</subscript> </expression>
	       </clause>
	     </multiclause>

            <multiclause> 
            <clause>          
            <expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript> = namespace <emph>NCName</emph><subscript>1</subscript> { <emph>AnyURI</emph><subscript>1</subscript> }</expression>
            </clause>
            </multiclause>
	     <multiclause>
               <clause><expression>...</expression></clause>
             </multiclause>
            <multiclause>
            <clause>          
            <expression><a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript> = namespace  <emph>NCName</emph><subscript>n</subscript> { <emph>AnyURI</emph><subscript>n</subscript> }</expression>
            </clause>
            </multiclause>
            <multiclause>
            <clause>
            <expression>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> = 
              <update>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                <expression><emph>NCName</emph><subscript>1</subscript> =&gt; (active, <emph>AnyURI</emph><subscript>1</subscript>)</expression>
              </update>
            </expression>
            </clause>
            </multiclause>
            <multiclause>
            <clause><expression>...</expression></clause>
            </multiclause>
            <multiclause>
            <clause>
            <expression>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript> = 
              <update>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                <expression><emph>NCName</emph><subscript>n</subscript> =&gt; (active, <emph>AnyURI</emph><subscript>n</subscript>)</expression>
              </update>
            </expression>
            </clause>
            </multiclause>

	     <multiclause>
	       <clause>
		 <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		 <expression> <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a>((<emph>Expr</emph><subscript>0</subscript>)) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                 <expression> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> (attribute*, (element | text | processing-instruction | comment)*)</expression>
	       </clause>
	     </multiclause>

	     <multiclause>
	       <clause>
		 <expression><a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> = 
		 <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>1</subscript>,
		 ..., <a href="#doc-fs-NamespaceBinding"><emph>NamespaceBinding</emph></a><subscript>n</subscript>,
		 <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>),
		 <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>)</expression>
	       </clause>
	     </multiclause>

	   </prejudge>
	   <postjudge>
	     <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		     element <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     element <emph>QName</emph> of type <code>xs:anyType</code> {
		     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> } { <a href="#doc-fs-NamespaceBindings"><emph>NamespaceBindings</emph></a> }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <p>The dynamic evaluation of an element constructor with a
       computed name is similar.  There is one additional rule that
       checks that the value of the element's name expression matches
       <code>xs:QName</code>.</p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment><expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
                 <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		 <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:QName</code>
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <expression><emph>QName</emph> = <code>fn:prefix-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript>)</expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	     <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		     element <emph>QName</emph> { <emph>Expr</emph><subscript>2</subscript> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
	       </expression>
	     </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		     element { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

    </smeval>

    </div4>

    <div4 id="sec_attribute_constructor">
      <head>Computed Attribute Constructors</head>

      <scrap headstyle="show">
        <head/>
        <prod num="113 (XQuery)" id="doc-xquery-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
      </scrap>

      <smcore>
        <p>The Core grammar production for computed attribute
        constructors is:</p>

      <scrap headstyle="show"><head>Computed Attribute Constructors</head>
      <prod num="70 (Core)" id="doc-core-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
      </scrap>
      </smcore>

      <smnorm>
        <p>Computed attribute constructors are normalized by mapping
        their name and content expression in a similar way as computed
        element constructors. The normalization rule uses the
        <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> function.</p>

        <mapping>
         <xquery>
          <expression>
           <map>attribute <emph>QName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
           <map>attribute <emph>QName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>attribute <emph>QName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>attribute <emph>QName</emph> { <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
          </expression>
         </core>
        </mapping>

        <mapping>
         <xquery>
          <expression>
           <map>attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
         <core>
          <expression>
            attribute { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } { <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
          </expression>
         </core>
        </mapping>
    </smnorm>

    <smtype>
      <p>The normalization rules for direct attribute constructors
      leave us with only the computed form of the attribute
      constructors.  Like in a computed element constructor, a
      computed attribute constructor has two forms: one in which the
      attribute name is a literal <emph>QName</emph>, and the other in which
      the attribute name is a computed expression.</p>

      <p>In the case of attribute constructors, the <xtermref spec="XQ" ref="dt-type-annotation"/> is always
      <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

     <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
              <clause>
	        <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	        <expression> <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></expression>
              </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	      <expression> attribute <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute <emph>QName</emph> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
       </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
              <clause>
	      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	      <expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>) </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
	      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	      <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	            <expression> attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
	            <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
	      </expression>
	    </clause>
	  </postjudge>
	</infer>
     </infergr>

     </smtype>

     <smeval>
       <p>The following rules take a computed attribute constructor
       expression and construct an attribute node.  The rules are
       similar to those rules for element constructors.  First, the
       attribute's name is expanded into a qualified name.  Second,
       the function <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> is applied to the
       content expression and this function call is evaluated in the
       dynamic environment.  Recall from <specref ref="sec_attribute_constructor"/> that during normalization, we
       do not convert the content of direct attribute constructors
       that contain one attribute-content unit.  This guarantees that
       useful type information is preserved for static analysis.
       Since the conversion function <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>
       was not applied to all attribute constructors during
       normalization, we have to apply it at evaluation time.  (As
       before, it is possible to elide the application of
       <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> injected during normalization
       and the application injected during evaluation.)</p>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		 <expression><a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>(<emph>Expr</emph>) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a> </expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		     attribute <emph>QName</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		     attribute <emph>QName</emph> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a> }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>

       <infergr>
	 <infer>
	   <prejudge>
	     <multiclause>
	       <clause>
		 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		 <expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
                 <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		 <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:QName</code>
		 </expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <expression><emph>QName</emph><subscript>1</subscript> = <code>fn:prefix-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)<code>:</code><code>fn:local-name-from-QName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)</expression>
	       </clause>
	     </multiclause>
	     <multiclause>
	       <clause>
		 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		 <expression> <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a>(<emph>Expr</emph><subscript>2</subscript>) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
	       </clause>
	     </multiclause>
	   </prejudge>
	   <postjudge>
	     <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
	       <expression>
		 attribute { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
		 attribute <emph>QName</emph><subscript>1</subscript> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript> }
	       </expression>
	     </clause>
	   </postjudge>
	 </infer>
       </infergr>
    </smeval>

    </div4>

  <div4 id="sec_documentConstructors">
    <head>Document Node Constructors</head>
 
    <scrap headstyle="show">
      <head/>
      <prod num="110 (XQuery)" id="doc-xquery-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar production for a computed document
      constructor is:</p>

      <scrap headstyle="show">
        <head>Core computed document constructor</head>
        <prod num="66 (Core)" id="doc-core-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>A document node constructor contains an expression, which
      must evaluate to a sequence of element, text, comment, or
      processing-instruction nodes.  <xspecref spec="XQ" ref="id-documentConstructors"/> specifies the rules for
      converting a sequence of atomic values and nodes into a sequence
      of nodes before document construction.  The built-in function
      <specref ref="sec_items_to_nodes_doc"/> implements this
      conversion.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>document { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          document { <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static typing rule does not need to check that the the
      type of the argument expression is a sequence of element, text,
      processing-instruction, and comment nodes, as it is already
      checked by the <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> introduced during
      normalization. The type of the entire expression is the most
      general <code>document</code> type, because the document
      constructor erases all <xtermref spec="XQ" ref="dt-type-annotation"/> on its content nodes.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  document { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
      </smtype>

    <smeval>
      <p>The dynamic semantics checks that the argument expression
      evaluates to a value that is a sequence of element, text,
      processing-instruction, or comment nodes. The entire expression
      evaluates to a new document node value. If the construction mode
      is set to <code>strip</code>, the <xtermref spec="XQ" ref="dt-type-annotation"/> for all the nodes in content of a
      document node are erased.</p>

	<infergr>
	  <infer>
	    <prejudge>
 	    <multiclause>
 	      <clause>
 	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve</expression>
 	      </clause>
 	    </multiclause>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> 
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> (element | text | processing-instruction | comment)* 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      document { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
	    <multiclause>
	      <clause>
	      <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip</expression>
	      </clause>
	    </multiclause>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
		<expression>
   	          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> 
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> (element | text | processing-instruction | comment)* 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      document { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>

  <div4 id="sec_textConstructors">
    <head>Text Node Constructors</head>

    <scrap headstyle="show">
      <head/>
      <prod num="114 (XQuery)" id="doc-xquery-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar production for a computed text constructor
      is:</p>

      <scrap headstyle="show">
       <head/>
       <prod num="71 (Core)" id="doc-core-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>A text node constructor contains an expression, which must
      evaluate to an <code>xs:string</code> value. <xspecref spec="XQ" ref="id-textConstructors"/> specifies the rules for converting a
      sequence of atomic values into a string prior to construction of
      a text node.  Each node is replaced by its string value. For
      each adjacent sequence of one or more atomic values returned by
      an enclosed expression, a untyped atomic value is constructed,
      containing the canonical lexical representation of all the
      atomic values, with a single blank character inserted between
      adjacent values.  As formal specification of these conversion
      rules is not instructive, <specref ref="sec_item_seq_to_untypedAtomic"/> implements this
      conversion.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>text { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
         text {
         (<a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a>(<code>fn:data</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))))
         cast as <code>xs:string</code>? }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics checks that the argument expression has
      type <code>xs:string</code> or <code>empty</code>. The type of the entire
      expression is an optional text node type, as the text node
      constructor returns the empty sequence if its argument is the
      empty sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code>?
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      text { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> text?
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smtype>

    <smeval>
      <p>If the argument expression returns the empty sequence, the
      text node constructor returns the empty sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
                  <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <code>()</code>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		  text { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <code>()</code>
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

      <p>If the argument expression returns a value of type
      <code>xs:string</code>, the text node constructor returns a text node with
      that string as content.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
                  <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> 
		</expression>
	      </clause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:string</code> 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		  text { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> text { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>

  <div4 id="sec_computed-pis">
    <head>Computed Processing Instruction Constructors</head>

    <scrap headstyle="show">
      <head/>
      <prod num="116 (XQuery)" id="doc-xquery-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
    </scrap>

    <smcore>
      <p>The Core grammar production for computed
      processing-instruction constructors is:</p>

      <scrap headstyle="show"><head/>
        <prod num="73 (Core)" id="doc-core-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Computed processing-instruction constructors are normalized
      by mapping their name and content expression in the same way
      that computed element and attribute constructors are
      normalized.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  <emph>NCName</emph> { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
 	<expression>
         <map>processing-instruction  <emph>NCName</emph> { () }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>processing-instruction <emph>NCName</emph> { <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } 
        </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
 	<expression>
         <map>processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
 	<expression>
         processing-instruction  { <code>fn:data</code>((<map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) } { <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a>((<map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) }
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static typing rules for processing-instruction
      constructors are straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> processing-instruction
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
	      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> (<code>xs:NCName</code> | <code>xs:string</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)
		</expression>
	      </clause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
	      <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> processing-instruction
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smtype>

    <smeval>
      <p>The dynamic evaluation rules for computed processing
      instructions are straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
	      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
		</expression>
	      </clause>
       	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
	      <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
	      processing-instruction  <emph>NCName</emph> { <emph>Expr</emph> }
	      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> processing-instruction <emph>NCName</emph> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
       	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> (<code>xs:NCName</code> | <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> | <code>xs:string</code>)
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
       	      <clause>
		<expression>
		      <code>xs:NCName</code>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <emph>NCName</emph><subscript>1</subscript>
		</expression>
	      </clause>
              </multiclause>
              <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
		</expression>
	      </clause>
       	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> 
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      processing-instruction  { <emph>Expr</emph><subscript>1</subscript> } { <emph>Expr</emph><subscript>2</subscript> }
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> processing-instruction <emph>NCName</emph><subscript>1</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
    </smeval>

  </div4>
  <div4 id="sec_computed-comments">
    <head>Computed Comment Constructors</head>

<scrap headstyle="show">
  <head/>
  <prod num="115 (XQuery)" id="doc-xquery-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
</scrap>

    <smcore>
      <p>The Core grammar production for computed comment constructors
      is:</p>

<scrap headstyle="show"><head/>
<prod num="72 (Core)" id="doc-core-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
</scrap>
    </smcore>

    <smnorm>
      <p>Computed comment constructors are normalized by mapping their
      content expression.</p>

      <mapping>
       <xquery>
 	<expression>
         <map>comment { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>comment { (<a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))) cast as <code>xs:string</code> } 
        </expression>
       </core>
      </mapping>
      </smnorm>

      <smtype>
        <p>The static typing rule for computed comment constructors is
        straightforward.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code> 
		</expression>
	      </clause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      comment { <emph>Expr</emph> }
		      <a href="#jd_has_type" class="judgment"><term>:</term></a> comment
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
</smtype>

<smeval>
<p>
The dynamic evaluation rule for computed comment constructors is
straightforward. 
</p>
	<infergr>
	  <infer>
	    <prejudge>
            <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> 
		</expression>
	      </clause>
       	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		      <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>xs:string</code> 
		</expression>
	      </clause>
            </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
		<expression>
		      comment { <emph>Expr</emph> }
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> comment { <a href="#doc-fs-Value"><emph>Value</emph></a> }
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>
</smeval>

  </div4>

  </div3>

    <div3 id="id-ns-nodes-on-elements">

      <head>In-scope Namespaces of a Constructed Element</head>

      <p>The effect of in-scope namespaces on constructed elements is
      specified in <specref ref="id_element_constructor"/> and
      <specref ref="sec_comp_elem_constructor"/>. </p>
    </div3>

</div2>
  <div2 id="sec_for-expressions">
    <head>[For/FLWOR] Expressions</head> 


    <smintro>
      <p>[XPath/XQuery] provides [For/FLWOR] expressions for iteration, for
      binding variables to intermediate results, and filtering bound
      variables according to a predicate.</p>

      <p>A <emph>FLWORExpr</emph> in XQuery 1.0 consists of a sequence of
      <emph>ForClause</emph>s and <emph>LetClause</emph>s, followed by an optional
      <emph>WhereClause</emph>, followed by an optional <emph>OrderByClause</emph>, as
      described by the following grammar productions. Each variable
      binding is preceded by an optional type declaration which
      specify the type expected for the variable.</p>

      <p>The dynamic semantics of the ordering mode in FLWOR
      expressions is not specified formally, as it would require the
      introduction of tuples, which are not supported in the
      [XPath/XQuery] data model.</p>

      <scrap headstyle="show">
    	<head>[For/FLWOR] Expressions</head>
    	<prod num="33 (XQuery)" id="doc-xquery-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LetClause" xlink:type="simple">LetClause</nt>)+  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-WhereClause" xlink:type="simple">WhereClause</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt>?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
    	<prod num="34 (XQuery)" id="doc-xquery-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
    	<prod num="36 (XQuery)" id="doc-xquery-LetClause"><lhs>LetClause</lhs><rhs>"let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
        <prod num="118 (XQuery)" id="doc-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod>
        <prod num="35 (XQuery)" id="doc-xquery-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod>
    	<prod num="37 (XQuery)" id="doc-xquery-WhereClause"><lhs>WhereClause</lhs><rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
        <prod num="38 (XQuery)" id="doc-xquery-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpecList" xlink:type="simple">OrderSpecList</nt></rhs></prod>
        <prod num="39 (XQuery)" id="doc-xquery-OrderSpecList"><lhs>OrderSpecList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod>
        <prod num="40 (XQuery)" id="doc-xquery-OrderSpec"><lhs>OrderSpec</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderModifier" xlink:type="simple">OrderModifier</nt></rhs></prod>
        <prod num="41 (XQuery)" id="doc-xquery-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod>
    	<prod num="4 (XPath)" id="doc-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
        <prod num="5 (XPath)" id="doc-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
      </scrap>
    </smintro>

      <smcore>
        <p>The Core grammar productions for FLWOR expressions are:</p>
      	<scrap headstyle="show">
     	  <head>For Expressions</head>
      	  <prod num="24 (Core)" id="doc-core-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-LetClause" xlink:type="simple">LetClause</nt>)  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      	  <prod num="25 (Core)" id="doc-core-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      	  <prod num="27 (Core)" id="doc-core-LetClause"><lhs>LetClause</lhs><rhs>"let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      	  <prod num="26 (Core)" id="doc-core-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt></rhs></prod>
          <prod num="75 (Core)" id="doc-core-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod>
          <prod num="28 (Core)" id="doc-core-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OrderSpecList" xlink:type="simple">OrderSpecList</nt></rhs></prod>
          <prod num="29 (Core)" id="doc-core-OrderSpecList"><lhs>OrderSpecList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod>
          <prod num="30 (Core)" id="doc-core-OrderSpec"><lhs>OrderSpec</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-OrderModifier" xlink:type="simple">OrderModifier</nt></rhs></prod>
          <prod num="31 (Core)" id="doc-core-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod>
      	</scrap>
      </smcore>

    <div3 id="sec_flwor-expressions">
      <head>FLWOR expressions</head>

      <smnotation>
        <p>For convenience, we introduce the following auxiliary
        grammar productions to represent optional type declarations
        and positional variables in For and Let clauses.</p>

        <scrap headstyle="show">
          <head/>
          <prod num="79 (Formal)" id="doc-fs-OptTypeDeclaration"><lhs>OptTypeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod>
          <prod num="80 (Formal)" id="doc-fs-OptPositionalVar"><lhs>OptPositionalVar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PositionalVar" xlink:type="simple">PositionalVar</nt>?</rhs></prod>
        </scrap>
      </smnotation>

      <smnotation>
        <p>To facilitate the specification of normalization, we also
        introduce the following auxiliary grammar productions as an
        alternative grammar for FLWOR expressions.</p>

        <scrap headstyle="show">
          <head/>
          <prod num="65 (Formal)" id="doc-fs-FormalFLWORClause"><lhs>FormalFLWORClause</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LetClause" xlink:type="simple">LetClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-WhereClause" xlink:type="simple">WhereClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt></rhs></prod>
          <prod num="66 (Formal)" id="doc-fs-FormalReturnClause"><lhs>FormalReturnClause</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalFLWORExpr" xlink:type="simple">FormalFLWORExpr</nt>  |  ("return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>)</rhs></prod>
          <prod num="67 (Formal)" id="doc-fs-FormalFLWORExpr"><lhs>FormalFLWORExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalFLWORClause" xlink:type="simple">FormalFLWORClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalReturnClause" xlink:type="simple">FormalReturnClause</nt></rhs></prod>
        </scrap>

      </smnotation>

      <smnorm>
    	<p>Full FLWOR expressions are normalized to nested Core FLWOR
    	expressions with a single for or let clause. Note that some of
    	the normalization rules below accept ungrammatical FLWOR
    	expressions such as "where <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript>". This
    	does not matter, as normalization is always applied on parsed
    	[XPath/XQuery] expressions, and such ungrammatical FLWOR
    	expressions would be rejected by the parser beforehand.</p>

        <p>Normalized FLWOR expressions restrict a For and Let clause
        to bind only one variable. Otherwise, the Core FLWOR
        expression is the same as the XQuery FLWOR expression. The
        first normalization rule is applied on a full [For/FLWOR]
        expression, splitting it at the clause level, then applying
        further normalization on each separate clause.</p>

<!--
    	<mapping>
    	 <xquery>
    	  <expression>
    	   <map>for &gr_DVarName0; in &gr_Expr0;, ...,  &gr_DVarNamen;
    	    in &gr_Exprn; &gr_FormalReturnClause;
    	    </map>&jd_map_expr;
    	  </expression>
    	 </xquery>
    	 <core>
          <expression>
          <table><tbody><tr><td>
    	  for &gr_DVarName0; in  <map>&gr_Expr0;</map>&jd_map_expr; return</td></tr>
          <tr><td>...</td></tr> 
<tr><td>
    	  for &gr_DVarNamen; in  <map>&gr_Exprn;</map>&jd_map_expr;
    	  return</td></tr>
           <tr><td><map>&gr_FormalReturnClause;</map>&jd_map_expr;</td></tr>
          </tbody></table>
          </expression>
    	 </core>
    	</mapping>

    	<p>Then each &for-name; clause is normalized separately. A
    	&gr_ForClause; may bind more than one variable, whereas a For
    	expression in the &language; Core binds and iterates over only
    	one variable. Therefore, a &gr_ForClause; is normalized to
    	nested for expressions:</p>
-->

	<mapping>
	 <xquery>
	  <expression>
	   <map>
            <table>
            <tbody>
            <tr><td rowspan="1" colspan="1">
	    for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript>
	    <emph>OptPositionalVar</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, </td></tr>
            <tr><td rowspan="1" colspan="1">···,</td></tr>
            <tr><td rowspan="1" colspan="1">$<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript>
	    <emph>OptPositionalVar</emph><subscript>n</subscript> in <emph>Expr</emph><subscript>n</subscript></td></tr>
           <tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
            </tbody>
            </table>
	   </map>
           <a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
         </xquery>
	 <core>
	  <expression>
	   <table>
	    <tbody>
	     <tr>
              <td rowspan="1" colspan="1"> for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> <emph>OptPositionalVar</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td>
             </tr>
             <tr>
              <td rowspan="1" colspan="1">  ···</td>
             </tr>
	     <tr>
              <td rowspan="1" colspan="1">     for $<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript>
              <emph>OptPositionalVar</emph><subscript>n</subscript>
              in <map> <emph>Expr</emph><subscript>n</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td>
             </tr>
             <tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
            </tbody>
	   </table>
	  </expression>
	 </core>
	</mapping>

        <p>Likewise, a <emph>LetClause</emph> clause is normalized to nested
        let expressions, each of which binds one variable:</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map>
<table>
<tbody>
<tr><td rowspan="1" colspan="1">let $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> := <emph>Expr</emph><subscript>1</subscript>,</td></tr>
<tr><td rowspan="1" colspan="1">···,</td></tr>
<tr><td rowspan="1" colspan="1">$<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript> := <emph>Expr</emph><subscript>n</subscript></td></tr>
             <tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
</tbody>
</table></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
  	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   <table>
	    <tbody>
	     <tr>
              <td rowspan="1" colspan="1">let $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph><subscript>1</subscript> := <map><emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return</td>
             </tr>
  	     <tr>
              <td rowspan="1" colspan="1">  ···</td>
             </tr>
	     <tr>
              <td rowspan="1" colspan="1">    let $<emph>VarName</emph><subscript>n</subscript> <emph>OptTypeDeclaration</emph><subscript>n</subscript> := <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> return <emph>Expr</emph></td>
             </tr>
             <tr><td rowspan="1" colspan="1"><map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
            </tbody>
           </table>
	  </expression>
	 </core>
	</mapping>

        <p>A <emph>WhereClause</emph> is normalized to an <emph>IfExpr</emph>, with
        the else-branch returning the empty sequence:</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> where <emph>Expr</emph><subscript>1</subscript> <emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   if ( <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> ) then <map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> else ()
	  </expression>
	 </core>
	</mapping>

        <p>The order by clause is normalized using the auxiliary
        mapping rule <map/><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a> which is
        defined in <specref ref="id_orderby_clause"/>.</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> stable? order by <emph>OrderSpecList</emph> <emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	    <map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a> return <map><emph>FormalReturnClause</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression>
	 </core>
	</mapping>

        <p>Finally, a stand-alone return clause is normalized into the
        corresponding expression. Recall that <code>return</code>
        keywords are introduced in the previous rule after the
        normalization of each clause.</p>

	<mapping>
	 <xquery>
	  <expression>
	   <map> return <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression>
	 </xquery>
	 <core>
	  <expression>
	   <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
	  </expression>
	 </core>
	</mapping>

      </smnorm>

      <smexample>

        <p>The following simple example illustrates how a
        <emph>FLWORExpr</emph> is normalized. The <code>for</code> expression
        in the example below is used to iterate over two collections,
        binding variables <code>$i</code> and <code>$j</code> to items
        in these collections. It uses a <code>let</code> clause to
        bind the local variable <code>$k</code> to the sum of both
        numbers, and a <code>where</code> clause to select only those
        numbers that have a sum equal to or greater than the integer
        <code>5</code>.</p>

<eg xml:space="preserve">  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k &gt;= 5
  return
    &lt;tuple&gt;
       &lt;i&gt; { $i } &lt;/i&gt;
       &lt;j&gt; { $j } &lt;/j&gt;
    &lt;/tuple&gt;
</eg>

        <p>By the first set of rules, this is normalized to (except
        for the operators and element constructor which are not
        treated here):</p>

<eg xml:space="preserve">  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k &gt;= 5) then 
          &lt;tuple&gt;
            &lt;i&gt; { $i } &lt;/i&gt;
            &lt;j&gt; { $j } &lt;/j&gt;
          &lt;/tuple&gt;
        else
          ()
</eg>

        <p>For each binding of <code>$i</code> to an item in the
        sequence <code>(1 , 2)</code> the inner <code>for</code>
        expression iterates over the sequence <code>(3 , 4)</code> to
        produce tuples ordered by the ordering of the outer sequence
        and then by the ordering of the inner sequence. This Core
        expression eventually results in the following document
        fragment:</p>

<eg xml:space="preserve">
  (&lt;tuple&gt;
      &lt;i&gt;1&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;3&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;)
</eg>

      </smexample>

    </div3>

    <div3 id="id-for-expression">
      <head>For expression</head>

      <smtype>

        <p>A single <code>for</code> expression is typed as follows:
        First <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> of the iteration expression <emph>Expr</emph><subscript>1</subscript> is
        inferred. Then the <termref def="term-prime-type">prime
        type</termref> of <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), is
        computed. This is a union over all item types in <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
        (See <specref ref="sec_factor"/>). With the variable component
        of the static environment <a href="#xq_stat_env_def" class="env">statEnv</a> extended with
        $<emph>VarName</emph><subscript>1</subscript> as type <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), the type
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> of <emph>Expr</emph><subscript>2</subscript> is inferred. Because the
        <code>for</code> expression iterates over the result of
        <emph>Expr</emph><subscript>1</subscript>, the final type of the iteration is <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        multiplied with the possible number of items in <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
        (one, <code>?</code>, <code>*</code>, or <code>+</code>).
        This number is determined by the auxiliary type-function
        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>). Operations between quantifiers
        and types, such as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a>
        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), used in the following rule, are
        defined in <specref ref="sec_factor"/>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>for $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a positional variable <emph>Variable</emph><subscript>pos</subscript> is present, the
        static environment is also extended with the positional
        variable typed as an <code>xs:integer</code>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>pos</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>);</expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; <code>xs:integer</code></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>for $<emph>VarName</emph><subscript>1</subscript> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing $<emph>VarName</emph><subscript>1</subscript> with type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>. This semantics is
        specified by the following static typing rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                 <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                 <expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>for $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The last rule handles For expressions that contain a type
        declaration and a positional variable.  When the positional
        variable is present, the static environment is also extended
        with the positional variable typed as an integer.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause>
              </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>pos</subscript>
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>; </expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; <code>xs:integer</code></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>for $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>

      <smexample>

        <p>For example, if <code>$example</code> is bound to the
        sequence <code>10.0, 1.0E1, 10</code> of type
        <code>xs:decimal, xs:float, xs:integer</code>, then the query</p>

<eg xml:space="preserve">  for $s in $example
  return $s * 2</eg>

        <p>is typed as follows:</p>

<eg xml:space="preserve">  (1) prime(xs:decimal, xs:float, xs:integer) =
      xs:decimal | xs:float | xs:integer
  (2) quantifier(xs:decimal, xs:float, xs:integer) = +
  (3) $s : xs:decimal | xs:float | xs:integer
  (4) $s * 2 : 
      xs:decimal | xs:float | xs:integer
  (5) result-type :
      ( xs:decimal | xs:float | xs:integer ) +
</eg>

        <p>This result-type is not the most specific type possible. It
        does not take into account the order of elements in the input
        type, and it ignores the individual and overall number of
        elements in the input type. The most specific type possible
        is: <code>xs:decimal, xs:float, xs:integer</code>.  However,
        inferring such a specific type for arbitrary input types and
        arbitrary return clauses requires significantly more complex
        static typing rules. In addition, if put into the context of
        an element, the specific type violates the "unique particle
        attribution" restriction of XML schema, which requires that an
        element must have a unique content model within a particular
        context.</p>

      </smexample>

      <smeval>

        <p>The evaluation of a <code>for</code> expression
        distinguishes two cases: If the iteration expression
        <emph>Expr</emph><subscript>1</subscript> evaluates to the empty sequence, then the entire
        expression evaluates to the empty sequence:</p>

         <infergr>
 	  <infer>
 	    <prejudge>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		<expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression>
 	      </clause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 		<expression>for $<emph>VarName</emph><subscript>1</subscript> <emph>OptTypeDeclaration</emph> <emph>OptPositionalVar</emph> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>Otherwise, the iteration expression <emph>Expr</emph><subscript>1</subscript> is evaluated
        to produce the sequence <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>.
        For each item <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> in this sequence, the body of the
        <code>for</code> expression <emph>Expr</emph><subscript>2</subscript> is evaluated in the
        dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a> extended with $<emph>VarName</emph><subscript>1</subscript>
        bound to <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript>. This produces values <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>i</subscript>,
        ..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript> which are concatenated to produce the result
        sequence. </p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>···</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  for $<emph>VarName</emph> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> 
                  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The following rule is the same as the rule above, but
        includes the optional positional variable $<emph>VarName</emph><subscript>pos</subscript>.
        If present, $<emph>VarName</emph><subscript>pos</subscript> is bound to the position of the
        item in the input sequence, i.e., the value
        <emph>i</emph>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>pos</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>; </expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; 1</expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>···</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>; </expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; n</expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  for $<emph>VarName</emph> at $<emph>VarName</emph><subscript>pos</subscript> in <emph>Expr</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>2</subscript> 
                  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the dynamic semantics
        also checks that each item in the result of evaluating
        <emph>Expr</emph><subscript>1</subscript> matches the declared type.  This semantics is
        specified by the following dynamic evaluation rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>···</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  for $<emph>VarName</emph> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript>
                  return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The last rule covers a <code>for</code> expression that
        contains a type declaration and a positional variable.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression> 
                      <emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>
                  </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>pos</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>pos</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>; </expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; 1</expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression>···</expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript>; </expression>
                      <expression><emph>Variable</emph><subscript>pos</subscript> =&gt; n</expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  for $<emph>VarName</emph> as <emph>SequenceType</emph> at $<emph>VarName</emph><subscript>pos</subscript>  in <emph>Expr</emph><subscript>1</subscript>
                  return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                  <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ,..., <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      <p>Note that this definition allows
      <emph>non-deterministic</emph> evaluation of the resulting
      sequence, since the preconditions in the above rule can be
      evaluated in any order.</p>

    </smeval>

      <smexample>

        <p>Note that if the expression in the <code>return</code> clause 
        results in a sequence, sequences are never nested in the
        [XPath/XQuery] data model. For instance, in the following for
        expression:</p>

<eg xml:space="preserve">  
  for $i in (1,2)
    return (&lt;i&gt; {$i} &lt;/i&gt;, &lt;negi&gt; {-$i} &lt;/negi&gt;)
</eg>

        <p>each iteration in the <code>for</code> results in a sequence of two
        elements, which are then concatenated and flattened in the
        resulting sequence:</p>

<eg xml:space="preserve">  
  (&lt;i&gt;1&lt;/i&gt;,
   &lt;negi&gt;-1&lt;/negi&gt;,
   &lt;i&gt;2&lt;/i&gt;,
   &lt;negi&gt;-2&lt;/negi&gt;)
</eg>

      </smexample>

    </div3>

    <div3 id="sec_lets">
      <head>Let Expression</head>

      <smtype>
        <p>A <code>let</code> expression extends the static
        environment <a href="#xq_stat_env_def" class="env">statEnv</a> with <emph>Variable</emph><subscript>1</subscript> of type
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> inferred from <emph>Expr</emph><subscript>1</subscript>, and infers the type of
        <emph>Expr</emph><subscript>2</subscript> in the extended environment to produce the result
        type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>

        <infergr>
 	  <infer>
 	   <prejudge>
              <multiclause>
 	    <clause>
 	     <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	     <expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
 	    </clause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
 	    <clause>
 	     <environment>
                        <update>
                          <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                          <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                        </update>
                      </environment>
                      <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
                    </clause>
              </multiclause>
                  </prejudge>
                  <postjudge>
                    <clause>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression>let $<emph>VarName</emph> :=  <emph>Expr</emph><subscript>1</subscript>
 		    return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                      </expression>
                    </clause>
                  </postjudge>
                </infer>
              </infergr>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing <emph>Variable</emph><subscript>1</subscript> with type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>.  This semantics is
        specified by the following static typing rule.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
 	        <clause>
 	         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	         <expression> <emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
 	        </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
 	        <clause>
 	          <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>let $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> :=  <emph>Expr</emph><subscript>1</subscript>
 	      return <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>

      <smeval>

        <p>A <code>let</code> expression extends the dynamic environment
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> with <emph>Variable</emph> bound to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> returned by
        <emph>Expr</emph><subscript>1</subscript>, and evaluates <emph>Expr</emph><subscript>2</subscript> in the extended
        environment to produce <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>let $<emph>VarName</emph><subscript>1</subscript> := <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When a type declaration is present, the dynamic semantics
        also checks that the result of evaluating <emph>Expr</emph><subscript>1</subscript> matches
        the declared type. This semantics is specified as the
        following dynamic evaluation rule.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>  <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>let $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> := <emph>Expr</emph><subscript>1</subscript> return
                    <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smeval>

      <smexample>
        <p>Note the use of the environments to define the scope of
        each variable. For instance, in the following nested
        <code>let</code> expression:</p>

<eg xml:space="preserve">  let $k := 5 return
    let $k := $k + 1 return
      $k+1
</eg>

        <p>the outermost <code>let</code> expression binds variable 
        <code>$k</code> to the
        integer <code>5</code> in the environment, then the expression
        <code>$k+1</code> is computed, yielding value <code>6</code>, to 
        which the second variable <code>$k</code> is bound. 
        The expression then results in 
        the final integer <code>7</code>.</p>
      </smexample>

    </div3>

    <div3 id="id_orderby_clause">
      <head>Order By and Return Clauses</head>

      <smintro>
        <p>The dynamic semantics of the <emph>OrderByClause</emph> is not
        specified formally, as doing so would require the introduction
        of tuples, which are not supported in the [XPath/XQuery] data
        model. The dynamic semantics of the order-by clause can be
        found in <xspecref spec="XQ" ref="id-orderby-return"/>.</p>

        <p>Because an <emph>OrderByClause</emph> does not affect the type of a
        <emph>FLWORExpr</emph> expression, the static semantics of a
        <emph>FLWORExpr</emph> expression with an <emph>OrderByClause</emph> is
        equivalent to the static semantics of an equivalent
        <emph>FLWORExpr</emph> in which the <emph>OrderByClause</emph> is replaced by
        a call to the <code>gt</code> comparison over the
        corresponding <emph>OrderSpec</emph> expression(s).</p>
      </smintro>

      <smnotation>
        <p id="jd_map_orderspeclist">To define normalization of
        OrderBy, the following auxiliary mapping rule is used.</p>
      
          <mapping>
           <xquery>
            <expression>
             <map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
             <emph>LetClause</emph> ... <emph>LetClause</emph>
            </expression>
           </core>
          </mapping>
      
        <p>This rules specifies that <emph>OrderSpecList</emph> is mapped to a
        sequence of <emph>LetClause</emph>s.</p>
      </smnotation>

      <smnorm>
        <p>Proper static typing for FLWOR expressions with an
        <emph>OrderByClause</emph> is obtained by normalizing the
        <emph>OrderByClause</emph> to a Let clause, nested For expressions,
        and atomization, then by applying the standard static typing
        rules for those expressions. Note that if evaluated
        dynamically, the normalization of <emph>OrderByClause</emph> given
        here does not express the required sorting semantics. Notably,
        the normalization rule introduces the <code>gt</code>
        operation which is used implicitely in the semantics of order
        by.</p>

        <p>Each <emph>OrderSpec</emph> is normalized by the following
        rules.</p>

            <mapping>
             <xquery>
              <expression>
               <map><emph>OrderSpec</emph><subscript>1</subscript> ... <emph>OrderSpec</emph><subscript>n</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               <map><emph>OrderSpec</emph><subscript>1</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>, ...
               <map><emph>OrderSpec</emph><subscript>n</subscript></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
              </expression>
             </core>
            </mapping>

	<mapping>
	 <xquery>
	  <expression>
           <map><emph>Expr</emph> <emph>OrderModifier</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a>
	  </expression>
	 </xquery>
	 <core>
	  <expression>
            <table summary=""><tbody>
                <tr><td rowspan="1" colspan="1">let $<emph>fs:</emph>new<subscript>0</subscript> := </td></tr>
                <tr><td rowspan="1" colspan="1">   let $<emph>fs:</emph>new<subscript>1</subscript> := <map><emph>Expr</emph></map></td></tr>
                <tr><td rowspan="1" colspan="1">   for $<emph>fs:</emph>new<subscript>2</subscript> in $<emph>fs:</emph>new<subscript>1</subscript> return</td></tr>
                <tr><td rowspan="1" colspan="1">   for $<emph>fs:</emph>new<subscript>3</subscript> in $<emph>fs:</emph>new<subscript>1</subscript> return</td></tr>
                <tr><td rowspan="1" colspan="1">     <map>$<emph>fs:</emph>new<subscript>2</subscript> gt $<emph>fs:</emph>new<subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
                <tr><td rowspan="1" colspan="1"><map><emph>OrderSpecList</emph></map><a href="#jd_map_orderspeclist" class="judgment"><subscript>OrderSpecList</subscript></a></td></tr>
              </tbody></table>
	  </expression>
	 </core>
	</mapping>

      </smnorm>
    </div3>
  </div2>
  <div2 id="sec_unordered-expressions">
    <head>Ordered and Unordered Expressions</head>

    <smintro>
      <p>The purpose of <code>ordered</code> and
      <code>unordered</code> expressions is to set the ordering mode
      in the static context to <code>ordered</code> or
      <code>unordered</code> for a certain region in a query. The
      specified ordering mode applies to the expression nested inside
      the curly braces.</p>

      <scrap headstyle="show">
        <head/>
        <prod num="91 (XQuery)" id="doc-xquery-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod> 
        <prod num="92 (XQuery)" id="doc-xquery-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
      </scrap>

    </smintro>

    <smcore>
      <p>The Core grammar productions for ordered/unordered
      expressions are:</p>

      <scrap headstyle="show">
        <head/>
        <prod num="61 (Core)" id="doc-core-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
        <prod num="62 (Core)" id="doc-core-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p><emph>OrderedExpr</emph> (resp. <emph>UnorderedExpr</emph>) expressions are
      normalized to <emph>OrderedExpr</emph> (resp. <emph>UnorderedExpr</emph>)
      expressions in the [XPath/XQuery] Core.</p>

      <mapping>
       <xquery>
         <expression><map>ordered { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression>ordered { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
         <expression><map>unordered { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression>unordered { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression>
       </core>
      </mapping>
    </smnorm>

   <smtype>
     <p><emph>OrderedExpr</emph> and <emph>UnorderedExpr</emph> expressions set the
     ordering mode in the static context to <code>ordered</code> or
     <code>unordered</code>.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
             <update>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></environment>
               <expression><code>ordered</code></expression>
             </update>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          ordered { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
             <update>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></environment>
               <expression><code>unordered</code></expression>
             </update>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          unordered { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smtype>

   <smeval>
     <p><emph>OrderedExpr</emph> and <emph>UnorderedExpr</emph> expressions only have
     an effect on the static context. The effect on the evaluation of
     its subexpression(s) is captured using the
     <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function, which introduced during
     normalization of axis steps, <code>union</code>,
     <code>intersect</code>, and <code>except</code> expressions, and
     FLWOR expressions that have no <code>order by</code> clause.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          ordered { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          unordered { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smeval>

  </div2>

  <div2 id="sec_conditionals">
    <head>Conditional Expressions</head>

    <smintro>

     <p>A conditional expression supports conditional evaluation of
      one of two expressions.</p>

      <scrap headstyle="show">
        <head>Conditional Expression</head>
        <prod num="45 (XQuery)" id="doc-xquery-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
    </smintro>

    <smcore>
      <p>The Core grammar production for the conditional expression
      is:</p>

      <scrap headstyle="show">
        <head>Core Conditional Expression</head>
        <prod num="35 (Core)" id="doc-core-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Conditional expressions are normalized as follows.</p>

      <mapping>
        <xquery>
          <expression>
            <map>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> else <emph>Expr</emph><subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
          </expression>
        </xquery>
        <core>
          <expression>
          <table><tbody>
            <tr><td rowspan="1" colspan="1">    if (<code>fn:boolean</code>((<map> <emph>Expr</emph><subscript>1</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>))) then <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> else <map><emph>Expr</emph><subscript>3</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></td></tr>
          </tbody></table>
          </expression>
        </core>
      </mapping>

    </smnorm>

    <smtype>
       <infergr>
         <infer>
          <prejudge>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a>  <code>xs:boolean</code> </expression>
           </clause>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
           </clause>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> </expression>
           </clause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression> <code>if</code> (<emph>Expr</emph><subscript>1</subscript>) <code>then </code>
                     <emph>Expr</emph><subscript>2</subscript>  <code>else </code> <emph>Expr</emph><subscript>3</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a>
                     (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)
            </expression>
           </clause>
          </postjudge>
         </infer>
       </infergr>
    
    </smtype>

    <smeval>
      <p>If the conditional's boolean expression <emph>Expr</emph><subscript>1</subscript> evaluates
      to true, <emph>Expr</emph><subscript>2</subscript> is evaluated and its value is produced.  If
      the conditional's boolean expression evaluates to false,
      <emph>Expr</emph><subscript>3</subscript> is evaluated and its value is produced.  Note that
      the existence of two separate dynamic evaluation rules ensures
      that only one branch of the conditional is evaluated.</p>

      <infergr>
      <infer>
        <prejudge>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression>
          </clause>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
          </clause>
        </prejudge>
        <postjudge>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> else <emph>Expr</emph><subscript>3</subscript>  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> 
            </expression>
          </clause>
        </postjudge>
      </infer>

      <infer>
        <prejudge>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression>
          </clause>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression><emph>Expr</emph><subscript>3</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript> </expression>
          </clause>
        </prejudge>
        <postjudge>
          <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression>if (<emph>Expr</emph><subscript>1</subscript>) then <emph>Expr</emph><subscript>2</subscript> 
                        else <emph>Expr</emph><subscript>3</subscript>  <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
            </expression>
          </clause>
        </postjudge>
      </infer>
      </infergr>

    </smeval>

  </div2>

  <div2 id="id-quantified-expressions">
    <head>Quantified Expressions</head>

    <smintro>
      <p>[XPath/XQuery] defines two quantification expressions:</p>

      <scrap headstyle="show">
        <head>Quantified Expression</head>
        <prod num="42 (XQuery)" id="doc-xquery-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
        <prod num="6 (XPath)" id="noid_N18A54.doc-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>

    </smintro>

    <smcore>
      <p>The Core grammar production for quantified expressions
      is:</p>

      <scrap headstyle="show">
        <head/>
        <prod num="32 (Core)" id="doc-core-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>The quantified expressions are normalized into nested Core
      quantified expressions, each of which binds one variable.</p>

      <mapping>
      <xquery>
        <expression>
          <map>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, ..., $<emph>VarName</emph><subscript>n</subscript> in
          <emph>Expr</emph><subscript>n</subscript> satisfies <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
      </xquery>
      <core>
        <expression>
          <table><tbody>
            <tr><td rowspan="1" colspan="1"> some $<emph>VarName</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">    some $<emph>VarName</emph><subscript>2</subscript> in <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">          ...</td></tr>
            <tr><td rowspan="1" colspan="1">      some $<emph>VarName</emph><subscript>n</subscript> in <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">      <code>fn:boolean</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) </td></tr>
          </tbody></table>
        </expression>
      </core>
      </mapping>

      <mapping>
      <xquery>
        <expression>
          <map>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>, ..., $<emph>VarName</emph><subscript>n</subscript> in
          <emph>Expr</emph><subscript>n</subscript> satisfies <emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
      </xquery>
      <core>
        <expression>
          <table><tbody>
            <tr><td rowspan="1" colspan="1"> every $<emph>VarName</emph><subscript>1</subscript> in <map><emph>Expr</emph><subscript>1</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>  satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">    every $<emph>VarName</emph><subscript>2</subscript> in <map><emph>Expr</emph><subscript>2</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">          ...</td></tr>
            <tr><td rowspan="1" colspan="1">      every $<emph>VarName</emph><subscript>n</subscript> in <map><emph>Expr</emph><subscript>n</subscript></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> satisfies</td></tr>
            <tr><td rowspan="1" colspan="1">      <code>fn:boolean</code>((<map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) </td></tr>
          </tbody></table>
        </expression>
      </core>
      </mapping>
    </smnorm>

    <smtype>
      <p>The static semantics of the quantified expressions uses the
      notion of <termref def="term-prime-type">prime
      type</termref>. These rules are similar to those for
      <code>for</code> expressions in <specref ref="id-for-expression"/>.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for <emph>EveryExpr</emph> without the
            optional type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript>
                satisfies <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
               </clause>
              </postjudge>
       
             </infer>
            </infergr>

            <p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript>
                satisfies <emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code> </expression>
               </clause>
              </postjudge>
       
             </infer>
            </infergr>

</smtype>

          <smeval>
            <p>If its input expression returns the empty sequence, the
            <emph>SomeExpr</emph> expression returns false.</p>

            <infergr>
             <infer>
              <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript>
                <emph>OptTypeDeclaration</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The <emph>SomeExpr</emph> expression yields true if any
            evaluation of the satisfies expression yields true. The
            <emph>SomeExpr</emph> expression yields false if every evaluation
            of the satisfies expression is false.  A quantified
            expression may raise an error if any evaluation of the
            satisfies expression raises an error.  The dynamic
            semantics of quantified expressions is non-deterministic.
            This non-determinism permits implementations to use
            short-circuit evaluation strategies when evaluating
            quantified expressions.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>


              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for <emph>SomeExpr</emph> without the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for <emph>SomeExpr</emph> with the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>


              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>some $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>If its input expression returns the empty sequence, the
            <emph>EveryExpr</emph> expression returns true.</p>

            <infergr>
             <infer>
              <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> ()</expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript>
                <emph>OptTypeDeclaration</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The <emph>EveryExpr</emph> expression yields false if any
            evaluation of the satisfies expression yields false.  The
            <emph>EveryExpr</emph> expression yields true if every evaluation
            of the satisfies expression is true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields false.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>

              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>

              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>i</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                 <expression>
                   i <a href="#jd_isin" class="judgment"><term>in</term></a> { 1,...,n }
                 </expression>
                </clause>
              </multiclause>
              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false </expression>
               </clause>
              </postjudge>

             </infer>
            </infergr>

            <p>The next rule is for <emph>EveryExpr</emph> in which all
            evaluations of the satisfies expression yield true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

            <p>The next rule is for <emph>EveryExpr</emph> with the optional
            type declaration in which all evaluations of the satisfies
            expression yield true.</p>

            <infergr>
             <infer>
              <prejudge>

              <multiclause>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript>,
                  ..., <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> </expression>
                </clause>
              </multiclause>

              <multiclause>
               <clause>
                <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
               </clause>
              </multiclause>


              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>
              <multiclause><clause><expression>...</expression></clause></multiclause>
              <multiclause>
                <clause>
                  <environment>
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                      <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript></expression>
                    </update>
                  </environment>
                  <expression> <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                   <a href="#doc-fs-Item"><emph>Item</emph></a><subscript>n</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                </expression>
               </clause>
              </multiclause>

              </prejudge>
              <postjudge>
               <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>every $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph> in <emph>Expr</emph><subscript>1</subscript> satisfies
                <emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true </expression>
               </clause>
              </postjudge>
             </infer>
            </infergr>

</smeval>

  </div2>

  <div2 id="sec_sequencetype-matching">
    <head>Expressions on SequenceTypes</head>

    <!-- Corresponds to XQuery Section 2.13 - Allocated to Jerome -->

    <smintro>

      <p>Some of the expressions relying on the SequenceTypes syntax
      are called expressions on SequenceTypes. The syntax of
      SequenceTypes is described in <specref ref="id-sequencetype"/>.</p>

    </smintro>

    <div3 id="sec_instance-of">
      <head>Instance Of</head>

      <scrap headstyle="show">
        <head>SequenceType expressions</head>
        <prod num="54 (XQuery)" id="doc-xquery-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>
      </scrap>

      <smintro>
        <p>The SequenceType expression <quote><emph>Expr</emph> instance of
        <emph>SequenceType</emph></quote> is true if and only if the result of
        evaluating expression <emph>Expr</emph> is an instance of the type
        referred to by <emph>SequenceType</emph>.</p>

        </smintro>

        <smnorm>
          <p>An <emph>InstanceofExpr</emph> expression is normalized into a
          <emph>TypeswitchExpr</emph> expression. Note that the following
          normalization rule uses a variable $<emph>fs:</emph>new, which is a
          newly created variable which must not conflict with any
          variables already in scope. This variable is necessary to
          comply with the syntax of typeswitch expressions in the Core
          [XPath/XQuery], but is never used.</p>

        <mapping>
         <xquery>
          <expression><map><emph>Expr</emph> instance of <emph>SequenceType</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
         </xquery>
         <core>
          <expression>
           <table><tbody>
            <tr><td rowspan="1" colspan="1">typeswitch (<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr>
            <tr><td rowspan="1" colspan="1">  case $<emph>fs:</emph>new as <emph>SequenceType</emph> return <code>fn:true</code>() </td></tr>
            <tr><td rowspan="1" colspan="1">  default $<emph>fs:</emph>new return <code>fn:false</code>()</td></tr>
           </tbody></table>
          </expression>
         </core>
        </mapping>

        </smnorm>

        </div3>

        <div3 id="sec_typeswitch">
          <head>Typeswitch</head>

          <scrap headstyle="show">
            <head>SequenceType expressions</head>
            <prod num="43 (XQuery)" id="doc-xquery-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
            <prod num="44 (XQuery)" id="doc-xquery-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
          </scrap>

        <smintro>
          <p>The <term>typeswitch</term> expression chooses one of
          several expressions to evaluate based on the dynamic type of
          an input value.</p>

          <p>Each branch of a typeswitch expression may have an
          optional $<emph>VarName</emph>, which is bound to the value of the
          input expression. One reason for using a variable on one of
          the branches is that it is assigned a type specific for that
          branch. This variable is optional in [XPath/XQuery] but made
          mandatory in the [XPath/XQuery] Core.</p>
        </smintro>

        <smcore>
          <p>The Core grammar productions for <code>typeswitch</code>
          are:</p>
      
          <scrap headstyle="show">
          <head/>
            <prod num="33 (Core)" id="doc-core-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
            <prod num="34 (Core)" id="doc-core-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
          </scrap>
        </smcore>

        <smnotation>
          <p>For convenience, we introduce the following auxiliary
          grammar production.</p>

          <scrap headstyle="show">
            <head/>
            <prod num="81 (Formal)" id="doc-fs-OptVarName"><lhs>OptVarName</lhs><rhs>("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>)?</rhs></prod>
          </scrap>
        </smnotation>

        <smnotation>
          <p id="jd_map_case">To define normalization of case clauses
          to the [XPath/XQuery] Core, the following auxiliary mapping
          rules are used.</p>
        
            <mapping>
             <xquery>
              <expression>
               <map><emph>CaseClause</emph></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
              </expression>
             </xquery>
             <core>
              <expression>
               <emph>CaseClause</emph>
              </expression>
             </core>
            </mapping>

          <p>specifies that <emph>CaseClause</emph> is mapped to <emph>CaseClause</emph>,
          in the [XPath/XQuery] Core.</p>
        </smnotation>

        <smnorm>
          <p>Normalization of a typeswitch expression guarantees that
          every branch has an associated $<emph>VarName</emph>.  The following
          normalization rules add newly created variables that must
          not conflict with any variables already in scope and that
          are not used in any of the sub-expressions.</p>

          <mapping>
           <xquery>
            <expression>
             <map>
                 case <emph>SequenceType</emph> return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
                case $<emph>fs:</emph>new<subscript>1</subscript> as <emph>SequenceType</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
                 case $<emph>VarName</emph> as <emph>SequenceType</emph> return
             <emph>Expr</emph> </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
                case $<emph>VarName</emph> as <emph>SequenceType</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              default return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
              default $<emph>fs:</emph>new<subscript>1</subscript> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              default $<emph>VarName</emph> return <emph>Expr</emph>
             </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
              default $<emph>VarName</emph> return <map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression>
             <map>
              <table><tbody>
               <tr><td rowspan="1" colspan="1">typeswitch ( <emph>Expr</emph><subscript>0</subscript>  ) </td></tr>
               <tr><td rowspan="1" colspan="1">  <emph>CaseClause</emph><subscript>1</subscript> </td></tr>
               <tr><td rowspan="1" colspan="1">    ···</td></tr>
               <tr><td rowspan="1" colspan="1">  <emph>CaseClause</emph><subscript>n</subscript> </td></tr>
               <tr><td rowspan="1" colspan="1">  default <emph>OptVarName</emph> return <emph>Expr</emph><subscript>n+1</subscript></td></tr>
              </tbody></table>
             </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </xquery>
           <core>
            <expression>
             <table><tbody>
              <tr><td rowspan="1" colspan="1">typeswitch ( <map> <emph>Expr</emph><subscript>0</subscript> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> )</td></tr>
              <tr><td rowspan="1" colspan="1"><map><emph>CaseClause</emph><subscript>1</subscript></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr>
              <tr><td rowspan="1" colspan="1">    ···</td></tr>
              <tr><td rowspan="1" colspan="1"><map><emph>CaseClause</emph><subscript>n</subscript></map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr>
              <tr><td rowspan="1" colspan="1"><map>  default <emph>OptVarName</emph> return <emph>Expr</emph><subscript>n+1</subscript> </map><a href="#jd_map_case" class="judgment"><subscript>Case</subscript></a></td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

        </smnorm>

        <smnotation>
          <p>For convenience, we use the following auxiliary grammar
          productions to denote case clauses in a typeswitch.</p>

          <scrap headstyle="show">
            <head>FormalCaseClauses</head>
            <prod num="68 (Formal)" id="doc-fs-FormalCaseClauses"><lhs>FormalCaseClauses</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalCaseClause" xlink:type="simple">FormalCaseClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalCaseClauses" xlink:type="simple">FormalCaseClauses</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalDefaultCaseClause" xlink:type="simple">FormalDefaultCaseClause</nt></rhs></prod>
            <prod num="69 (Formal)" id="doc-fs-FormalCaseClause"><lhs>FormalCaseClause</lhs><rhs>"case"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod>
            <prod num="70 (Formal)" id="doc-fs-FormalDefaultCaseClause"><lhs>FormalDefaultCaseClause</lhs><rhs>"default"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod>
          </scrap>

          <p id="jd_type_case">The following judgments</p>
 
          <display>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                     <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
          </display>

          <display>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                     <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalDefaultCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
          </display>

          <p>is used in the static semantics of typeswitch. It
          indicates that under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>,
          and with the input type of the typeswitch being <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
          the given case clause yields the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p>

          <p id="jd_against">The following judgment</p>
 
        <display>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                   <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
           </clause>
        </display>

          <p>is used in the dynamic semantics of typeswitch. It
          indicates that under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>,
          with the input value of the typeswitch being <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,
          the given case clauses yield the value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p>

        </smnotation>

        <smtype>

          <p>The static typing rules for the typeswitch expression are
          simple.  Each case clause and the default clause of the
          typeswitch is typed independently. The type of the entire
          typeswitch expression is the union of the types of all the
          clauses.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                       <expression><emph>Expr</emph><subscript>0</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression>
               </clause>
              </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>1</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression>    ···</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> return <emph>Expr</emph><subscript>n</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
                      <a href="#jd_type_case" class="judgment"><term>case</term></a> default $<emph>VarName</emph><subscript>n+1</subscript> return <emph>Expr</emph><subscript>n</subscript>
                      <a href="#jd_type_case" class="judgment"><term>:</term></a>
                      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <table><tbody>
                <tr><td valign="top" rowspan="1" colspan="1"><a href="#xq_stat_env_def" class="env">statEnv</a> |-  </td>
                    <td rowspan="1" colspan="1">
                      <table><tbody> 
                      <tr><td rowspan="1" colspan="1">(typeswitch (<emph>Expr</emph><subscript>0</subscript>)</td></tr> 
                      <tr><td rowspan="1" colspan="1">  case $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript> return <emph>Expr</emph><subscript>1</subscript></td></tr>
                      <tr><td rowspan="1" colspan="1">    ···</td></tr>
                      <tr><td rowspan="1" colspan="1">  case $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> return <emph>Expr</emph><subscript>n</subscript></td></tr>
                      <tr><td rowspan="1" colspan="1">  default $<emph>VarName</emph><subscript>n+1</subscript> return <emph>Expr</emph><subscript>n+1</subscript>)</td></tr> </tbody></table>
                    </td>
                </tr>
                </tbody></table>
                <a href="#jd_has_type" class="judgment"><term>:</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>)
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>To type one case clause, the case variable is assigned
          the type of the case clause <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> and the body of
          the clause is typed in the extended environment.  Thus, the
          type of a case clause is independent of the type of the
          input expression.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
               <clause>
                <expression>
                <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph>
                </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a></expression>
               </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause><environment><update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                       <expression><emph>Variable</emph> =&gt;
                       <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> </expression></update></environment>
               <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
               </clause>
              </multiclause>
            </prejudge>
            <postjudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> case $<emph>VarName</emph> as
              <emph>SequenceType</emph> return <emph>Expr</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>To type the default clause, the variable is assigned the
          type of the input expression and the body of the default
          clause is typed in the extended environment.</p>

          <infergr>
           <infer>
            <prejudge>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 	      <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph>
 	      </expression>
 	      </clause>
 	    </multiclause>
              <multiclause>
               <clause><environment><update><environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                       <expression><emph>Variable</emph> =&gt;
                       <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> </expression></update></environment>
               <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
               </clause>
              </multiclause>
            </prejudge>
            <postjudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> default $<emph>VarName</emph> 
              return <emph>Expr</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

  </smtype>

        <smeval>
          <p>The evaluation of a typeswitch proceeds as
          follows. First, the input expression is evaluated, yielding
          an input value.  The <term>effective case</term> is the
          first <code>case</code> clause such that the input value
          matches the SequenceType in the <code>case</code> clause.
          The <code>return</code> clause of the effective case is
          evaluated and the value of the <code>return</code>
          expression is the value of the typeswitch expression.</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression>
             </clause>
             </multiclause>
             <multiclause>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
             </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression>typeswitch (<emph>Expr</emph>) <emph>FormalCaseClauses</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the value matches the sequence type, the following
          rule applies: It extends the dynamic environment by binding
          the variable <emph>Variable</emph> to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> and evaluates the
          body of the <code>return</code> clause.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression>
                 <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
                <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
               <clause>
                 <environment>
                   <update>
                     <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                     <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression>
                   </update>
                 </environment>
                 <expression>
                   <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                 </expression>
               </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression>
                     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> case $<emph>VarName</emph> as
                     <emph>SequenceType</emph> return <emph>Expr</emph> <emph>FormalCaseClauses</emph>
                     <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                     </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the value does not match the sequence type, the
          current case is not evaluated, and the remaining case rules
          are evaluated in order by applying the inference rule
          recursively.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
             <clause>
              <expression>
                <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
              </expression>
             </clause>
             <clause>
              <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
              <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <emph>Case</emph><a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
             </clause>
             <clause><environment> <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a>
                     <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a>
                     <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
             </clause>
            </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                     <expression> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> case
                     $<emph>VarName</emph> as <emph>SequenceType</emph> return <emph>Expr</emph>
                     <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                     </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The last rule states that the <code>default</code> branch
          of a typeswitch expression always evaluates to the value of
          its <code>return</code> clause.</p>

          <infergr>
           <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph></expression>
                </clause>
              </multiclause>
              <multiclause>
             <clause>
               <environment><update>
	         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
	         <expression><emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript></expression>
               </update></environment>
               <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
             </clause>
              </multiclause>
            </prejudge>
            <postjudge>
            <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                    <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>0</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> default
                    $<emph>VarName</emph> return <emph>Expr</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a>
                    <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript></expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

        </smeval>

      </div3>

      <div3 id="sec_cast">
        <head>Cast</head>

        <smintro>
          <p>The <code>cast</code> expression can be used to convert a
          value to a specific datatype. It changes both the type and
          value of the result of an expression, and can only be
          applied to an atomic value.</p>
        </smintro>

        <scrap headstyle="show">
          <head/>
          <prod num="57 (XQuery)" id="doc-xquery-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>
          <prod num="117 (XQuery)" id="doc-xquery-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>
        </scrap>

        <smcore>
          <p>The Core grammar productions for <code>cast</code>
          expressions are:</p>
      
          <scrap headstyle="show">
            <head/>
            <prod num="39 (Core)" id="doc-core-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ValueExpr" xlink:type="simple">ValueExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>
            <prod num="74 (Core)" id="doc-core-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>
          </scrap>
        </smcore>

        <smnorm>
          <p>The normalization of cast applies atomization to its
          argument. The type declaration asserts that the result is a
          single atomic value.  The second normalization rule applies
          when the target type is optional.</p>

          <mapping>
           <xquery>
            <expression><map><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
           </xquery>
           <core>
            <expression>
             <table><tbody>
              <tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr>
              <tr><td rowspan="1" colspan="1">  $v cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression><map><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>? </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
           </xquery>
           <core>
            <expression>
             <table><tbody>
              <tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr>
              <tr><td rowspan="1" colspan="1">  typeswitch ($v)</td></tr>
              <tr><td rowspan="1" colspan="1">    case $<emph>fs:</emph>new as empty-sequence() return ()</td></tr>
              <tr><td rowspan="1" colspan="1">    default $<emph>fs:</emph>new return $v cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> </td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

        </smnorm>

        <smtype>
          <p>The static typing rule of <code>cast</code> expression is
          as follows. The type of a Core <code>cast</code> expression
          is always the target type. Note that a <code>cast</code>
          expression can fail at run-time if the given value cannot be
          cast to the target type.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smtype>

        <smnotation>
          <p>The dynamic semantics of <code>cast</code> expressions is
          defined in <xspecref spec="FO" ref="casting"/>. The
          semantics of cast expressions depends on the type of the
          input value and on the target type. For any source and
          target primitive types, the <emph>casting table</emph> in
          <xspecref spec="FO" ref="casting"/> indicates whether the
          cast from the source type to the target type is permitted.
          When a cast is permitted, the detailed dynamic evaluation
          rules for cast in <xspecref spec="FO" ref="casting"/> are
          applied. We refer to those rules using an auxiliary judgment
          defined as follows.</p>

          <p id="jd_cast_value_to">The judgment</p>
          <display>
            <clause>
            <expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
            <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
            </clause>
          </display>
          <p>holds if <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> can be cast to type
          <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>, resulting in the new value
          <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript> according to the rules in <xspecref spec="FO" ref="casting"/>.</p>
        </smnotation>

        <smeval>
          <infergr>
           <infer>
            <prejudge>
            <multiclause>
              <clause>
               <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression>
                 <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript>
               </expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
              <expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
              <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
              </clause>
            </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smeval>

      </div3>

      <div3 id="sec_castable">
        <head>Castable</head>

        <scrap headstyle="show">
          <head/>
          <prod num="56 (XQuery)" id="doc-xquery-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>
        </scrap>

        <p>Castable expressions check whether a value can be cast to a
        given type.</p>

        <smcore>
          <p>The Core grammar production for castable is:</p>
      
          <scrap headstyle="show">
            <head/>
            <prod num="38 (Core)" id="doc-core-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>
          </scrap>
        </smcore>

        <smnorm>
          <p>The normalization of castable simply maps its expression
          argument.</p>

          <mapping>
           <xquery>
            <expression><map><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
           </xquery>
           <core>
            <expression>
             <table><tbody>
              <tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr>
              <tr><td rowspan="1" colspan="1">$v castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a></td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

          <mapping>
           <xquery>
            <expression><map><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
           </xquery>
           <core>
            <expression>
             <table><tbody>
              <tr><td rowspan="1" colspan="1">let $v as <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>? := <code>fn:data</code>((<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)) return</td></tr>
              <tr><td rowspan="1" colspan="1">$v castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>?</td></tr>
             </tbody></table>
            </expression>
           </core>
          </mapping>

        </smnorm>

        <smtype>
          <p>The type of a Core <code>castable</code> expression is
          always a boolean.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

        </smtype>

        <smeval>
          <p>If casting succeeds, then the <code>castable</code>
          expression evaluates to true.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression><emph>Expr</emph> cast as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                      <expression><emph>Expr</emph> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> true</expression>
              </clause>
             </multiclause>
            </postjudge>
           </infer>
          </infergr>

          <p>Otherwise, 'castable as' evaluates to false.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                      <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)</expression></clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                      <expression><emph>Expr</emph><subscript>1</subscript> castable as <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> false</expression>
              </clause>
             </multiclause>
            </postjudge>
           </infer>
          </infergr>

        </smeval>

      </div3>

      <div3 id="sec_constructor-functions">
        <head>Constructor Functions</head>

        <p>Constructor functions provide an alternative syntax for
        casting.</p>

        <smnorm>
          <p>Constructor functions for atomic types are normalized to
          explicit <code>cast as</code> expressions. Note that the
          following normalization rule requires to resolve the name of
          the function call and checks whether than name stands for an
          atomic type in the static context.</p>

         <infergr>
          <infer>
           <prejudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-AtomicTypeDerivation"><emph>AtomicTypeDerivation</emph></a>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
              <map><emph>QName</emph>(<emph>ExprSingle</emph><subscript>1</subscript>)</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
              =
              <map><emph>ExprSingle</emph><subscript>1</subscript> cast as <emph>QName</emph>?</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
         </infergr>
        </smnorm>

      </div3>

        <div3 id="sec_treat">
          <head>Treat</head>

<scrap headstyle="show">
<head/>
   <prod num="55 (XQuery)" id="doc-xquery-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>
</scrap>

          <smintro>
            <p>The expression <quote><emph>Expr</emph> treat as
            <emph>SequenceType</emph></quote>, can be used to change the
            static type of the result of an expression without
            changing its value.  The treat-as expression raises a
            dynamic error if the dynamic type of the input value does
            not match the specified type.</p>
          </smintro>

          <smnorm>
            <p>Treat as expressions are normalized to typeswitch
            expressions. Note that the following normalization rule
            uses a variable $<emph>fs:</emph>new, which is a newly created
            variable that does not conflict with any variables already
            in scope.</p>

            <mapping>
             <xquery>
              <expression><map><emph>Expr</emph> treat as <emph>SequenceType</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
             </xquery>
             <core>
              <expression>
               <table><tbody>
                <tr><td rowspan="1" colspan="1">typeswitch (<map> <emph>Expr</emph> </map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>)</td></tr>
                <tr><td rowspan="1" colspan="1">  case $<emph>fs:</emph>new as <emph>SequenceType</emph> return $<emph>fs:</emph>new</td></tr>
                <tr><td rowspan="1" colspan="1">  default $<emph>fs:</emph>new return <code>fn:error</code>()</td></tr>
               </tbody></table>
              </expression>
             </core>
            </mapping>
          </smnorm>

      </div3>

    </div2>

    <div2 id="sec_validate_expr">
      <head>Validate Expressions</head>

      <scrap headstyle="show">
        <head/>
        <prod num="63 (XQuery)" id="doc-xquery-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
        <prod num="64 (XQuery)" id="doc-xquery-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod>
      </scrap>

      <smcore>
        <p>The Core grammar productions for validate are:</p>
      
    <scrap headstyle="show">
        <head/>
        <prod num="41 (Core)" id="doc-core-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
        <prod num="42 (Core)" id="doc-core-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod>
    </scrap>
      </smcore>

      <p>A <code>validate</code> expression validates its argument
      with respect to the <term>in-scope schema definitions</term>,
      using the schema validation process described in
      <bibref ref="xmlschema-1"/>. The argument to a validate expression must be
      either an element or a document node. Validation replaces all
      nodes with new nodes that have their own identity, the <xtermref spec="XQ" ref="dt-type-annotation"/>, and default values created
      during the validation process.</p>

      <smnorm>
        <p>A validate expression with no validation mode is normalized
        into a validate expression with the validation mode set to
        strict.</p>

        <mapping>
        <xquery>
        <expression>
          <map>validate { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
        </xquery>
        <core>
        <expression>
          validate strict { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }
        </expression>
        </core>
        </mapping>

        <mapping>
        <xquery>
        <expression>
          <map>validate <emph>ValidationMode</emph> { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a>
        </expression>
        </xquery>
        <core>
        <expression>
          validate <emph>ValidationMode</emph> { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }
        </expression>
        </core>
        </mapping>

      </smnorm>

      <smtype>
        <p>Static typing of the validate operation is defined by the
        following rule.  Note the use of a subtyping check to ensure
        that the type of the expression to validate is either an
        element or a well-formed document node (i.e., with only one
        root element and no text nodes).  The type of the expression
        to validate may be a union of more than one element type.  We
        apply the <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> judgment to each element type to
        determine the meaning of that element type with the given
        validation mode, which yields a new element type.  The result
        type is the union over all new element types.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (element | document { <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> })</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) =  <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> |
            ... | <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>1</subscript></expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>···</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>n</subscript>  <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a><subscript>n</subscript></expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> </expression>
           </clause>
           </multiclause>
           <multiclause>
           <clause>
            <expression>···</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>n</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript> </expression>
           </clause>
           </multiclause>


           <multiclause>
           <clause>
            <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>1</subscript> | ... | <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>n</subscript></expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
      </smtype>

    <div3 id="sec_validating_element">
      <head>Validating an Element Node</head>
      <smeval>

        <p>The normative dynamic semantics of validation is specified
        in <xspecref spec="XQ" ref="id-validate"/>.  The effect of
        validation of a data model value is equivalent to:

        <ulist>
          <item><p>serialization of the data model, as described in
          <bibref ref="xslt-xquery-serialization"/>, followed by</p></item>
          <item><p>validation of the serialized value into a Post-Schema
          Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item>
          <item><p>construction of a new data model value, as described in
          <bibref ref="xpath-datamodel"/>.</p></item>
        </ulist>
        </p>

        <p>The above steps are expressed formally by the "erasure" and
        "annotation" judgments.  Formally, validation removes existing
        type annotations from nodes ("erasure"), and it re-validates
        the corresponding data model instance, possibly adding new
        type annotations to nodes ("annotation"). Both erasure and
        annotation are described formally in <specref ref="sec_validation_judgments"/>. Indeed, the conjunction of
        erasure and annotation provides a formal model for a large
        part of actual schema validation. The semantics of the
        <code>validate</code> expression is specified as follows.</p>

        <p>In the first premise below, the expression to validate is
        evaluated. The resulting value must be an element or document
        node. The second premise constructs a new value in which all
        existing type annotations have been erased. The third premise
        determines the element type that corresponds to the element
        node's name in the given validation mode. The last premise
        validates erased element node with the type against which it
        is validated, using the <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment, yielding
        the final validated element.</p>

        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
             <environment>
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             </environment>
             <expression>
               <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript>
             </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression><a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> 
            </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>
            <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> 
             <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> ( <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> </expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                   <expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                   <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> 
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>
</smeval>
    </div3>

    <div3 id="sec_validating_document">
      <head>Validating a Document Node</head>

      <p>The rule for validating a document node is similar to that
      for validating an element node.</p>

       <smeval>
        <infergr>
         <infer>
          <prejudge>
           <multiclause>
           <clause>
             <environment>
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             </environment>
             <expression>
               <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> }
             </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
            document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> }</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <expression>
            <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> { <a href="#doc-fs-Value"><emph>Value</emph></a> }
</expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a>
            <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a>
            <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> </expression>
           </clause>
           </multiclause>

           <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> document { <a href="#doc-fs-ElementType"><emph>ElementType</emph></a><subscript>2</subscript> } (document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>2</subscript> }) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
            document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> }</expression>
           </clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                   <expression>validate <emph>ValidationMode</emph> { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a>
                   document { <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a><subscript>3</subscript> }
                   </expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

      </smeval>
      
  </div3>

 </div2>

 <div2 id="id-extension-expressions" role="xquery">
   <head>Extension Expressions</head>

   <smintro>
     <p>An extension expression is an expression whose semantics are
     implementation-defined. An extension expression consists of one
     or more pragmas, followed by an expression enclosed in curly
     braces.</p>

     <scrap headstyle="show">
       <head/>

       <prod num="65 (XQuery)" id="doc-xquery-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
       <prod num="66 (XQuery)" id="doc-xquery-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs></prod>
       <prod num="67 (XQuery)" id="doc-xquery-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod>
     </scrap>
   </smintro>

   <smcore>
     <p>The Core grammar productions for ExtensionExpr are:</p>

     <scrap headstyle="show">
       <head/>

       <prod num="43 (Core)" id="doc-core-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
       <prod num="44 (Core)" id="doc-core-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs></prod>
       <prod num="45 (Core)" id="doc-core-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod>
     </scrap>
   </smcore>

    <smnorm>
      <p>Extension expressions are normalized as extension expressions
      in the [XPath/XQuery] Core.</p>

      <mapping>
       <xquery>
         <expression><map><emph>Pragma</emph>+ { <emph>Expr</emph> }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><emph>Pragma</emph>+ { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }</expression>
       </core>
      </mapping>

      <p>If the extension expression does not contain any expression,
      this is normalized into an extension expression with a call to
      the <code>fn:error</code> function.</p>

      <mapping>
       <xquery>
         <expression><map><emph>Pragma</emph>+ { }</map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a></expression>
       </xquery>
       <core>
         <expression><emph>Pragma</emph>+ { <code>fn:error</code>() }</expression>
       </core>
      </mapping>

   </smnorm>

   <smtype>
     <p>If at least one of the pragmas is recognized, the static
     semantics are implementation-defined.</p>

     <p>If none of the pragmas is recognized, the static semantics
     are the same as for the input expression. In both cases, the
     static typing must be applied on the input expression, possibly
     raising the corresponding type errors.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             A <emph>Pragma</emph> is recognized, yielding the
             implementation-defined static type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression>
          </clause>
        </multiclause>
        <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             No <emph>Pragma</emph> is recognized.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smtype>

   <smeval>
     <p>The QName of a pragma must resolve to a namespace URI and
     local name, using the statically known namespaces. If at least
     one of the pragmas is recognized, the dynamic semantics is
     implementation-defined.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
           <expression>
             Some <emph>Pragma</emph> are recognized, yielding the
             implementation-defined value <a href="#doc-fs-Value"><emph>Value</emph></a>.
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <p>If none of the pragmas is recognized the dynamic semantics of
     an <emph>ExtensionExpr</emph> are the same as evaluating the given
     expression.</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
          <clause>
           <expression>
             No <emph>Pragma</emph> is recognized.
           </expression>
          </clause>
          <clause>
           <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
           <expression>
             <emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression>
          </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression>
          <emph>Pragma</emph>+ { <emph>Expr</emph> } <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

   </smeval>

 </div2>

</div1>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
-->

     <div1 id="id-query-prolog">
  <head>Modules and Prologs</head>

  <p>The organization of this section parallels the organization of
  <xspecref spec="XQ" ref="id-query-prolog"/>.</p>

  <smintro>
    <p>XQuery supports modules as defined in <xspecref spec="XQ" ref="id-query-prolog"/>.  A <xtermref spec="XQ" ref="dt-main-module"/> contains a <xtermref spec="XQ" ref="dt-prolog"/> followed by a <xtermref spec="XQ" ref="dt-queryBody"/>.  A query has exactly one main module. In a
    main module, the <xtermref spec="XQ" ref="dt-queryBody"/> can be
    evaluated, and its value is the result of the query. A <xtermref spec="XQ" ref="dt-library-module"/> contains a module declaration
    followed by a <xtermref spec="XQ" ref="dt-prolog"/>.</p>

    <p>The Prolog is a sequence of declarations that affect query
    processing. The Prolog can be used, for example, to declare
    namespace prefixes, import types from XML Schemas, and declare
    functions and variables.  Namespace declarations and schema
    imports always precede function and variable declarations, as
    specified by the following grammar productions.</p>

    <scrap headstyle="show">
      <head>Query Module</head>
      <prod num="1 (XQuery)" id="doc-xquery-Module"><lhs>Module</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MainModule" xlink:type="simple">MainModule</nt>)</rhs></prod>
      <prod num="3 (XQuery)" id="doc-xquery-MainModule"><lhs>MainModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QueryBody" xlink:type="simple">QueryBody</nt></rhs></prod>
      <prod num="4 (XQuery)" id="doc-xquery-LibraryModule"><lhs>LibraryModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt></rhs></prod>
      <prod num="6 (XQuery)" id="doc-xquery-Prolog"><lhs>Prolog</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Import" xlink:type="simple">Import</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt>)*</rhs></prod>
      <prod num="7 (XQuery)" id="doc-xquery-Setter"><lhs>Setter</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt></rhs></prod>
      <prod num="8 (XQuery)" id="doc-xquery-Import"><lhs>Import</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt></rhs></prod>
      <prod num="9 (XQuery)" id="doc-xquery-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod>
      <prod num="30 (XQuery)" id="doc-xquery-QueryBody"><lhs>QueryBody</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod>
    </scrap>

    <p>Function declarations are globally scoped, that is, the use of
    a function name in a function call may precede declaration of the
    function.  Variable declarations are lexically scoped, i.e.,
    variable declarations must precede variable uses.</p>

  </smintro>
 
  <smcore>
     <p>The module declarations and prolog are processed as part of
     the static and dynamic context processing. In addition,
     normalization of prolog declarations is performed into a
     simplified formal grammar given below. As a result, the XQuery
     core does not need to include the prolog and module
     declarations. The entry point for the core grammar is the
     <emph>Expr</emph> non-terminal, as given in <specref ref="id-expressions"/>.</p>

<!--
    <scrap>
      <head>Query Module</head>
      <prodrecap id="core-Module"          ref="Module"          orig="core"/>
      <prodrecap id="core-MainModule"      ref="MainModule"      orig="core"/>
      <prodrecap id="core-LibraryModule"   ref="LibraryModule"   orig="core"/>
      <prodrecap id="core-Prolog"          ref="Prolog"          orig="core"/>
      <prodrecap id="core-Setter"          ref="Setter"          orig="core"/>
      <prodrecap id="core-Import"          ref="Import"          orig="core"/>
      <prodrecap id="core-QueryBody"       ref="QueryBody"       orig="core"/>
    </scrap>
-->

  </smcore>

  <smnotation>
    <p>Modules are identified and can be imported using a target
    namespace (a URI). In [XPath/XQuery], the process by which a module is
    obtained from a given target namespace is implementation
    defined. In this specification, we use the following auxiliary
    judgment to model that implementation defined process.</p>

    <p id="jd_is_target_namespace_of_module">The judgment:</p>

    <display>
      <clause>
        <expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_module" class="judgment"><term>is target namespace of module</term></a> <emph>Module</emph>
        </expression>
      </clause>
    </display>

    <p>holds if <emph>Module</emph> is the module associated to the target
    namespace <emph>AnyURI</emph>.</p>
  </smnotation>

  <smnotation>
    <p>The XQuery Prolog requires that declarations appear in a
    particular order.  In the Formal Semantics, it is simpler to
    assume the declarations can appear in any order, as it does not
    change their semantics -- we simply assume that an XQuery parser
    has enforced the required order.</p>

    <p>The Prolog contains a variety of declarations that specify the
    initial static and dynamic context of the query.  The following
    formal grammar productions represent any Prolog declaration.</p>
  
    <scrap headstyle="show">
      <head>Prolog Declarations</head>
        <prod num="71 (Formal)" id="doc-fs-PrologDeclList"><lhs>PrologDeclList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-PrologDecl" xlink:type="simple">PrologDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Separator" xlink:type="simple">Separator</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-PrologDeclList" xlink:type="simple">PrologDeclList</nt>)?</rhs></prod>
        <prod num="72 (Formal)" id="doc-fs-PrologDecl"><lhs>PrologDecl</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarDecl" xlink:type="simple">VarDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt></rhs></prod>
    </scrap>

    <p id="jd_map_prolog">The function <map/><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
    takes a prolog declaration and maps it into its equivalent
    declaration in the Core grammar.</p>

    <mapping>
     <xquery>
      <expression>
       <map><emph>PrologDecl</emph><subscript>1</subscript></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
      </expression>
     </xquery>
     <core>
      <expression>
       <emph>PrologDecl</emph><subscript>2</subscript>
      </expression>
     </core>
    </mapping>

    <p id="jd_yields_context">The following auxiliary judgments are
    applied when statically processing the declarations in the prolog.
    The effect of the judgment is to process each prolog declaration
    in order, constructing a new static environment from the static
    environment constructed from previous prolog declarations.</p>

    <p>The judgment:</p>

    <display>
      <clause>
      	<environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
        <expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
        <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript>
        </expression>
      </clause>
    </display>

    <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
    sequence of prolog declarations <emph>PrologDeclList</emph> yields the
    static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> and the normalized sequence of
    prolog declarations in the Core grammar.</p>

    <p>The judgment:</p>

    <display>
      <clause>
        <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
        <expression><emph>PrologDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
      </clause>
    </display>

    <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
    single prolog declaration <emph>PrologDecl</emph> yields the new static
    environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p>

  </smnotation>

  <smcontext>
    <p>Prolog declarations are processed in the order they are
    encountered.  The normalization of a prolog declaration
    <emph>PrologDecl</emph> depends on the static context processing of all
    previous prolog declarations.  In turn, static context processing
    of <emph>PrologDecl</emph> depends on the normalization of the
    <emph>PrologDecl</emph>.  For example, because variables are lexically
    scoped, the normalization and static context processing of a
    variable declaration depends on the normalization and static
    context processing of all previous variable declarations.
    Therefore, the normalization phase and static context processing
    are interleaved, with normalization preceding static context
    processing for each prolog declaration.</p>

    <p>The following inference rules express this dependency.  The
    first rule specifies that for an empty sequence of prolog
    declarations, the initial static environment is left
    unchanged.</p>

    <infergr>
     <infer>
      <postjudge>
       <clause>
     	   <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression><a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><term>with</term></a></expression>
       </clause>
      </postjudge>
     </infer>
    </infergr>

    <p>The next rule interleaves normalization and static context
    processing.  The result of static context processing and
    normalization is a static context and the normalized prolog
    declarations.</p>

    <infergr>
  	<infer>
  	  <prejudge>
  	    <multiclause>
  	      <clause>
              <expression><map><emph>PrologDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
              == <emph>PrologDecl</emph><subscript>1</subscript></expression>
  	      </clause>
  	    </multiclause>
  	    <multiclause>
            <clause>
      	<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	<expression><emph>PrologDecl</emph><subscript>1</subscript> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
            </clause>
  	    </multiclause>
  	    <multiclause>
  	      <clause>
      	<environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
              <expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression>
  	      </clause>
  	    </multiclause>
  	  </prejudge>
  	  <postjudge>
  	      <clause>
      	<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph>
              <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a>
              <emph>PrologDecl</emph><subscript>1</subscript> ; <emph>PrologDeclList</emph><subscript>1</subscript></expression>
  	      </clause>
  	  </postjudge>
  	</infer>
    </infergr>
  </smcontext>

  <smtype>
    <p>Static typing of a main module follows context processing and
    normalization.  Context processing and normalization of a main
    module applies the rules above to the prolog, then using the
    resulting static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the query body is
    normalized into a Core expression, and the static typing rules are
    applied to this Core expression.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
      	 <environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment>
         <expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
         <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression>
        </clause>
       </multiclause>
       <multiclause>
       <clause>
        <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        <expression><map><emph>QueryBody</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> == <emph>Expr</emph><subscript>2</subscript> </expression>
       </clause>
       </multiclause>
       <multiclause>
       <clause>
        <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
       </clause>
       </multiclause>
      </prejudge>
       <postjudge>
           <clause>
           <expression><emph>PrologDeclList</emph> <emph>QueryBody</emph>
           <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
           </clause>
       </postjudge>
     </infer>
    </infergr>
  </smtype>

  <smnotation>
    <p id="jd_yields_dyn_context">Similarly, the judgment:</p>

    <display>
      <clause>
      	<environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment>
        <expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
      </clause>
    </display>

    <p>holds if under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>, the
    sequence of prolog declarations <emph>PrologDeclList</emph> yields the
    dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>.</p>

    <p>The judgment:</p>

    <display>
      <clause>
        <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
        <expression><emph>PrologDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
      </clause>
    </display>

    <p>holds if under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the single
    prolog declaration <emph>PrologDecl</emph> yields the new dynamic
    environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.</p>
  </smnotation>

  <smdyncontext>
    <p>The rules for initializing the dynamic context are as follows.
    The first rule specifies that for an empty sequence of prolog
    declarations, the dynamic environment is left unchanged.</p>

    <infergr>
     <infer>
      <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression><a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
        </clause>
      </postjudge>
     </infer>
    </infergr>

    <p>The second rule simply computes the dynamic environment by
    processing the prolog declarations in order.</p>

    <infergr>
     <infer>
      <prejudge>
       <multiclause>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression><emph>PrologDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
        </clause>
       </multiclause>
       <multiclause>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment>
         <expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
        </clause>
       </multiclause>
      </prejudge>
      <postjudge>
        <clause>
         <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
         <expression><emph>PrologDecl</emph> ; <emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
        </clause>
      </postjudge>
     </infer>
    </infergr>

  </smdyncontext>

  <smeval>
    <p>Dynamic evaluation of a main module applies the rules for
    dynamic-context processing to the prolog declarations, then using
    the resulting dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the dynamic
    evaluation rules are applied to the normalized query body.</p>

    <infergr>
      <infer>
        <prejudge>
          <multiclause>
           <clause>
            <environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment>
             <expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
           </clause>
          </multiclause>
  	    <multiclause>
            <clause>
      	<environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment>
      	<expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
            </clause>
  	    </multiclause>
          <multiclause>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><map><emph>QueryBody</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> == <emph>Expr</emph><subscript>2</subscript></expression>
           </clause>
          </multiclause>
          <multiclause>
           <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
           </clause>
          </multiclause>
        </prejudge>
        <postjudge>
          <multiclause>
            <clause>
              <expression><emph>PrologDeclList</emph> <emph>QueryBody</emph>
              <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
            </clause>
          </multiclause>
        </postjudge>
      </infer>
    </infergr>
  </smeval>

  <smnotation>
    <p id="jd_module_statEnv">We define a new judgment that maps a
    module's target namespace (or a main module) to the corresponding
    module's static environment:</p>

    <display>
     <clause>
      <expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
     </clause>
    </display>

    <p id="jd_module_dynEnv">We also define a new judgment that maps a
    module's target namespace (or a main module) to the corresponding
    module's dynamic environment:</p>

    <display>
     <clause>
      <expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
     </clause>
    </display>

    <p>For a main module, those judgments are defined as follows.</p>

    <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
          <clause><environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment>
     <expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
          </clause>
          </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
            <clause>
     <expression>#MAIN <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
            </clause>
          </multiclause>
	  </postjudge>
      </infer>
    </infergr>

    <infergr>
    	<infer>
    	  <prejudge>
    	    <multiclause>
            <clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment>
     <expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
            </clause>
          </multiclause>
    	  </prejudge>
    	  <postjudge>
    	    <multiclause>
     <clause><expression>#MAIN <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause>
          </multiclause>
    	  </postjudge>
      </infer>
    </infergr>

    <p>For a library module, those judgments are defined in <specref ref="id-module-imports"/>.</p>
  </smnotation>

  <div2 id="sec_version-declaration">

    <head>Version Declaration</head>

    <scrap headstyle="show"><head/>
    <prod num="2 (XQuery)" id="doc-xquery-VersionDecl"><lhs>VersionDecl</lhs><rhs>"xquery"  "version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod>
    </scrap>

    <smintro>
      <p>A version declaration specifies the applicable XQuery syntax
      and semantics for a module.  An XQuery implementation must raise
      a static error when processing a query labeled with a version
      that the implementation does not support.  This document applies
      to XQuery 1.0 only and does not specify this static error
      formally. Verifying whether the proper version declaration is
      used is not formally specified.</p>
    </smintro>

<!--
    <smcore>
      <p>The core grammar production for version declarations is:</p>

      <scrap><head></head>
    	<prodrecap id="core-VersionDecl" ref="VersionDecl" orig="core"/>
      </scrap>
    </smcore>

    <smnorm>
      <p>Version declaration are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map>&gr_VersionDecl;</map>&jd_map_prolog;
        </expression>
       </xquery>
       <core>
        <expression>
          &gr_VersionDecl;
        </expression>
       </core>
      </mapping>
    </smnorm>
-->

  </div2>

  <div2 id="id-module-declaration">
    <head>Module Declaration</head>

    <smintro>
      <scrap headstyle="show"><head/>
        <prod num="5 (XQuery)" id="doc-xquery-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod>
      </scrap>

      <p>We assume that the static-context processing and
      dynamic-context processing described in <specref ref="id-query-prolog"/> are applied to all library modules
      <emph>before</emph> the normalization, static context
      processing, and dynamic context processing of the main module.
      That is, at the time an "import module" declaration is
      processed, we assume that the static and dynamic context of the
      imported module is already available.  This assumption does not
      require or assume separate compilation of modules.  An
      implementation might process all or some imported modules
      statically (i.e., before the importing module is identified) or
      dynamically (i.e., when the importing module is identified and
      processed).</p>
    </smintro>

    <smcore>
      <p>The core grammar production for module declarations is:</p>

      <scrap headstyle="show"><head/>
    	<prod num="1 (Core)" id="doc-core-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Separator" xlink:type="simple">Separator</nt></rhs></prod>
        <prod num="2 (Core)" id="doc-core-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Module declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>ModuleDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>ModuleDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>The effect of a module declaration is to apply the static
      context processing rules defined in <specref ref="id-query-prolog"/> to the module's prolog.  The resulting
      static context is then available to any importing module.</p>

      <p>The module declaration extends the prolog with a namespace
      declaration that binds the module's prefix to its target
      namespace (a URI), then computes the static context for the
      complete module.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
      	      <clause>
      	        <expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_module" class="judgment"><term>is target namespace of module</term></a> <emph>Module</emph>
      	        </expression>
      	      </clause>
	    </multiclause>
	    <multiclause>
              <clause><expression><emph>Module</emph> = module namespace <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph></expression></clause>
            </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	      <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	      </expression>
 	      </clause>
 	    </multiclause>
	    <multiclause>
              <clause><environment><a href="#xq_default_stat_env" class="env">statEnvDefault</a></environment>
 	      <expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph>
 	      <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph></expression></clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
              <clause><expression><emph>AnyURI</emph> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression></clause>
            </multiclause>
	  </postjudge>
        </infer>
      </infergr>

      <p>Note that the rule above and the rules for static context
      processing of an "import module" declaration in <specref ref="id-module-imports"/> are mutually recursive.</p>

    </smcontext>

    <smdyncontext>
      <p>The dynamic context processing of a module declaration is
      similar to that of static processing.  The module declaration
      extends the prolog with a namespace declaration that binds the
      module's prefix to its target namespace (a URI), then computes
      the dynamic context for the complete module.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
      	      <clause>
      	        <expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_module" class="judgment"><term>is target namespace of module</term></a> <emph>Module</emph>
      	        </expression>
      	      </clause>
	    </multiclause>
	    <multiclause>
              <clause><expression><emph>Module</emph> = module namespace <emph>NCName</emph> = <emph>URILiteral</emph>; <emph>PrologDeclList</emph></expression></clause>
            </multiclause>
 	    <multiclause>
 	      <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	      <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	      </expression>
 	      </clause>
 	    </multiclause>
	    <multiclause>
              <clause><environment><a href="#xq_default_dyn_env" class="env">dynEnvDefault</a></environment>
              <expression>declare namespace <emph>NCName</emph> =
                    <emph>URILiteral</emph>; <emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
              <clause><expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression></clause>
            </multiclause>
	  </postjudge>
        </infer>
      </infergr>

      <p>Note that the rule above and the rules for dynamic context
      processing of an "import module" declaration in <specref ref="id-module-imports"/> are mutually recursive.</p>

    </smdyncontext>
  </div2>

  <div2 id="sec_boundary-space-decls">
    <head>Boundary-space Declaration</head>

    <scrap headstyle="show">
      <head/>
      <prod num="11 (XQuery)" id="doc-xquery-BoundarySpaceDecl"><lhs>BoundarySpaceDecl</lhs><rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs></prod>
    </scrap>

    <p>The semantics of a boundary-space declaration is not specified
    formally.</p>
  </div2>

  <div2 id="sec_default-collation-declaration">
    <head>Default Collation Declaration</head>

    <scrap headstyle="show">
    <head/>
    <prod num="19 (XQuery)" id="doc-xquery-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
    </scrap>

    <smcore>
     <p>The core grammar production for default collation declarations is:</p>

     <scrap headstyle="show"><head/>
     <prod num="11 (Core)" id="doc-core-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
     </scrap>
    </smcore>

    <smnorm>
      <p>Default collation declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>DefaultCollationDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>DefaultCollationDecl</emph>
        </expression>
       </core>
      </mapping>

    </smnorm>

    <smcontext>
      <p>The default collation declaration updates the collations
      environment component within the static environment.  The
      collations environment component is used by several functions in
      <bibref ref="xpath-functions"/>, but is not used in the Formal Semantics.</p>

      <infergr>
	<infer>
	  <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
            <multiclause>
	      <clause>
                <expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a>(<emph>AnyURI</emph>) = <emph>Collation</emph>
                </expression>
	      </clause>
            </multiclause>
            <multiclause>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a></environment>
                      <expression><emph>Collation</emph></expression>
                    </update>
                </expression>
	      </clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare default collation <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

    </smcontext>

    <smdyncontext>
      <p>The default collation declaration does not affect the dynamic
      context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare default collation <emph>URILiteral</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
</smdyncontext>
  </div2>

  <div2 id="sec_base-uri-decl"><head>Base URI Declaration</head>

  <scrap headstyle="show"><head/>
  <prod num="20 (XQuery)" id="doc-xquery-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
  </scrap>

  <smcore>
     <p>The core grammar production for base uri declarations is:</p>

      <scrap headstyle="show"><head/>
    	<prod num="12 (Core)" id="doc-core-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
      </scrap>
  </smcore>

  <smnorm>
    <p>Base URI declarations are left unchanged through
    normalization.</p>

    <mapping>
     <xquery>
      <expression>
       <map><emph>BaseURIDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
      </expression>
     </xquery>
     <core>
      <expression>
        <emph>BaseURIDecl</emph>
      </expression>
     </core>
    </mapping>
  </smnorm>

  <smcontext>
    <p>A base URI declaration specifies the base URI property of the
    static context, which is used when resolving relative URIs within
    a module.</p>

      <infergr>
	<infer>
	  <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
	    <multiclause>
              <clause><expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a></environment>
                      <expression><emph>AnyURI</emph></expression>
                    </update>
</expression></clause>
</multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
<clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment><expression>
declare base-uri <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
</expression></clause>
</multiclause>
	  </postjudge>
        </infer>
      </infergr>
</smcontext>
<smdyncontext>
<p>The base URI declaration does not affect the dynamic
context. </p>
      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare base-uri <emph>URILiteral</emph>  <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
</smdyncontext>
</div2>

  <div2 id="sec_validation_decl">
    <head>Construction Declaration</head>

    <scrap headstyle="show"><head/>
      <prod num="25 (XQuery)" id="doc-xquery-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod>
    </scrap>

    <smcore>
     <p>The core grammar production for construction declarations is:</p>

       <scrap headstyle="show"><head/>
       <prod num="17 (Core)" id="doc-core-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod>
       </scrap>
    </smcore>

    <smnotation>
      <p>For convenience, we introduce the following auxiliary
      grammar production.</p>

      <scrap headstyle="show">
        <head>Constr Mode</head>
        <prod num="89 (Formal)" id="doc-fs-ConstructionMode"><lhs>ConstructionMode</lhs><rhs>"preserve"  |  "strip"</rhs></prod>
      </scrap>

    </smnotation>

    <smnorm>
      <p>Construction declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>ConstructionDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>ConstructionDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>The construction declaration modifies the construction mode
      in the static context.</p>

      <infergr>
	<infer>
	  <prejudge>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a></environment>
                      <expression>
                      <emph>ConstructionMode</emph></expression>
                    </update>
                </expression>
	      </clause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare construction <emph>ConstructionMode</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
</smcontext>

<smdyncontext>
<p>The construction declaration does not have any effect on the dynamic
context.</p>
      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare construction <emph>ConstructionMode</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
</smdyncontext>
  </div2>

<div2 id="id-default-ordering-decl">
  <head>Ordering Mode Declaration</head>
  <scrap headstyle="show">
    <head/>
    <prod num="14 (XQuery)" id="doc-xquery-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod>
  </scrap>

    <smcore>
     <p>The core grammar production for ordering mode declarations is:</p>

       <scrap headstyle="show">
       <head/>
       <prod num="6 (Core)" id="doc-core-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod>
       </scrap>
    </smcore>

    <smnorm>
      <p>Ordering mode declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>OrderingModeDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>OrderingModeDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>The ordering mode declaration does not have any effect on the
      static context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>OrderingModeDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smcontext>

    <smdyncontext>
      <p>The ordering mode declaration does not have any effect on the
      dynamic context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>OrderingModeDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
   </div2>

<div2 id="id-empty-order-decl">
  <head>Empty Order Declaration</head>
  <scrap headstyle="show">
    <head/>
    <prod num="15 (XQuery)" id="doc-xquery-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod>
  </scrap>

    <smcore>
     <p>The core grammar production for empty order declarations is:</p>

       <scrap headstyle="show">
       <head/>
       <prod num="7 (Core)" id="doc-core-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod>
       </scrap>
    </smcore>

    <smnorm>
      <p>Empty order declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>EmptyOrderDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>EmptyOrderDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>The empty order declaration does not have any effect on the
      static context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>EmptyOrderDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smcontext>

    <smdyncontext>
      <p>The empty order declaration does not have any effect on the
      dynamic context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>EmptyOrderDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

  <div2 id="id-copy-namespaces-decl">
    <head>Copy-Namespaces Declaration</head>

    <scrap headstyle="show">
      <head/>
      <prod num="16 (XQuery)" id="doc-xquery-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InheritMode" xlink:type="simple">InheritMode</nt></rhs></prod>
      <prod num="17 (XQuery)" id="doc-xquery-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod>
      <prod num="18 (XQuery)" id="doc-xquery-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod>
    </scrap>

    <smcore>
      <p>The core grammar productions for copy-namespaces declarations
      are:</p>

      <scrap headstyle="show">
        <head/>
        <prod num="8 (Core)" id="doc-core-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-InheritMode" xlink:type="simple">InheritMode</nt></rhs></prod>
        <prod num="9 (Core)" id="doc-core-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod>
        <prod num="10 (Core)" id="doc-core-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Copy-namespace declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>CopyNamespacesDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>CopyNamespacesDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>The copy-namespace declaration does not have any effect on the
      static context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>CopyNamespacesDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smcontext>

    <smdyncontext>
      <p>The copy-namespace declaration does not have any effect on
      the dynamic context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>CopyNamespacesDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

  <div2 id="sec_schema_imports">
    <head>Schema Import</head>

    <scrap headstyle="show">
      <head>Schema Imports</head>
      <prod num="21 (XQuery)" id="doc-xquery-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod>
      <prod num="22 (XQuery)" id="doc-xquery-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod>
    </scrap>

    <p>The semantics of Schema Import is described in terms of the
    [XPath/XQuery] type system. The process of converting an XML Schema
    into a sequence of type declarations is described in Section
    <specref ref="sec_importing_schema"/>.  This section describes how
    the resulting sequence of type declarations is added into the
    static context when the Prolog is processed.</p>

    <smcore>
      <p>The Core grammar productions for schema imports are:</p>

      <scrap headstyle="show">
        <head>Schema Imports</head>
        <prod num="13 (Core)" id="doc-core-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod>
        <prod num="14 (Core)" id="doc-core-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Schema imports are left unchanged through normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>SchemaImport</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>SchemaImport</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smnotation>
      <p>For convenience, we introduce the following auxiliary
      grammar productions.</p>

      <scrap headstyle="show">
        <head>Location Hints</head>
        <prod num="16 (Formal)" id="doc-fs-LocationHints"><lhs>LocationHints</lhs><rhs>"at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*</rhs></prod>
        <prod num="82 (Formal)" id="doc-fs-OptLocationHints"><lhs>OptLocationHints</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-LocationHints" xlink:type="simple">LocationHints</nt>?</rhs></prod>
      </scrap>

    </smnotation>

    <smnotation>
      <p id="jd_yields_type_context">The following auxiliary judgments
      are used when processing schema imports.</p>

      <p>The judgment:</p>

      <display>
        <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
          <expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
        </clause>
      </display>

      <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
      sequence of type definitions <emph>Definitions</emph> yields the new
      static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p>

      <p>The judgment:</p>

      <display>
        <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
          <expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
        </clause>
      </display>

      <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>, the
      single definition <a href="#sec_top_level_definitions"><emph>Definition</emph></a> yields the new static
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>.</p>
    </smnotation>

    <smcontext>

      <p>A schema imported into a query is first mapped into the
      [XPath/XQuery] type system, which yields a sequence of XQuery type
      definitions.  The rules for mapping the imported schema begin in
      <specref ref="sec_schema_as_a_whole"/>.  Each type definition in
      an imported schema is then added to the static environment.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        	<expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
              </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>import schema <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>The schema import declaration may also assign an element/type
      namespace prefix to the URI of the imported schema, or assign
      the default element namespace to the URI of the imported
      schema.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        	<expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
              </clause>
	    </multiclause>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
            <multiclause>
	      <clause>
                <expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                      <expression><emph>NCName</emph> 
                      =&gt; (passive, <emph>AnyURI</emph>)</expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>import schema namespace <emph>NCName</emph> =
                <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <expression><emph>Definitions</emph> = <map>schema
                <emph>URILiteral</emph> <emph>OptLocationHints</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        	<expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
              </clause>
	    </multiclause>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
            <multiclause>
	      <clause>
                <expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment>
                      <expression> <emph>AnyURI</emph></expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>import schema default element namespace
                <emph>URILiteral</emph> <emph>OptLocationHints</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>An empty sequence of type definitions yields the input
      environment.</p>

      <infergr>
	<infer>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>No Type Definition</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Each type definition is added into the static
      environment.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
              <clause>
        	<environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
        	<expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a><subscript>1</subscript> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
        	<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
              </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#sec_top_level_definitions"><emph>Definition</emph></a><subscript>1</subscript> <emph>Definitions</emph>
                <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Each type, element, or attribute declaration is added
      respectively to the type, element and attribute declarations
      components of the static environment.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define type
                      <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> </expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
        	<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define
                      element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a>
                      <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
        	<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
                <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; define
                      attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                      <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
        	<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Note that it is a static error to import two schemas that
      both define the same name in the same symbol space and in the
      same scope. That is multiple top-level definitions of the same
      type, element, or attribute name raises a static error.  For
      instance, a query may not import two schemas that include
      top-level element declarations for two elements with the same
      expanded name.</p>

    </smcontext>

    <smdyncontext>
      <p>The schema import declarations do not affect the dynamic
      context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><emph>SchemaImport</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

  <div2 id="id-module-imports">
    <head>Module Import</head>
    <scrap headstyle="show"><head/>
        <prod num="23 (XQuery)" id="doc-xquery-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod>
    </scrap>

    <smintro>
      <p>The effect of an "import module" declaration is to extend the
      importing module's dynamic (and static) context with the global
      variables (and their types) and the functions (and their
      signatures) of the imported module.  Module import is not
      transitive, only the global variables and functions declared
      explicitly in the imported module are available in the importing
      module.  Also, module import does not import schemas, therefore
      the importing module must explicitly import any schemas on which
      the imported global variables or functions depend.</p>
    </smintro>

    <smcore>
      <p>The core grammar production for module imports is:</p>

      <scrap headstyle="show">
        <head>Module Import</head>
        <prod num="15 (Core)" id="doc-core-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Module imports are left unchanged through normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>ModuleImport</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>ModuleImport</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smnotation>
      <p>The rules below depend on the following auxiliary functions
      which are used to import the proper fragment of the static
      context.</p>

      <p id="fs_local_variables">The function
      <a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <emph>AnyURI</emph>) returns all the
      (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>) pairs in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> such that the URI
      part of the variable's expanded-QName equals the given URI, that
      is, the variables that are declared locally in the module with
      the given namespace URI.</p>

      <p id="fs_local_functions">
      The function <a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <emph>AnyURI</emph>)
      returns all the function signatures in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> such that
      the URI part of the function's expanded-QName equals the given
      URI, that is, the function signatures that are declared locally
      in the module with the given namespace URI.</p>
    </smnotation>

    <smnotation>
      <p>The following auxiliary judgments is used to extend a given
      static environment with the static environment from an imported
      module.</p>

      <p id="jd_extended_with_static_environment">The judgment</p>

      <display>
        <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
        </clause>
      </display>

      <p>holds if extending the environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> with the
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> yields the environment <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
      under the given namespace uri <emph>AnyURI</emph>.</p>

      <p>This judgment is defined as follows.</p>

      <infergr>
      <infer>
      <prejudge>
      <multiclause>
      <clause>
        <expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>, <emph>AnyURI</emph>) =
        (<emph>Variable</emph><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) ... (<emph>Variable</emph><subscript>m</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>m</subscript>)</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript> =
        <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>.<a href="#xq_type_env" class="env">varType</a></environment>
        <expression><emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> ... ;
        <emph>Variable</emph><subscript>m</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>m</subscript></expression></update></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
        <emph>AnyURI</emph>) = (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>,<emph>FunctionSig</emph><subscript>1</subscript>) ... (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>,<emph>FunctionSig</emph><subscript>n</subscript>)</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>4</subscript> =
        <update><environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>.<a href="#xq_functy_env" class="env">funcType</a></environment>
        <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> =&gt; <emph>FunctionSig</emph><subscript>1</subscript>;
        ... ;<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript> =&gt; <emph>FunctionSig</emph><subscript>n</subscript></expression></update></expression>
      </clause>
      </multiclause>
      </prejudge>
      <postjudge>
      <multiclause>
      <clause>
      <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>4</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      </postjudge>
      </infer>
      </infergr>
    </smnotation>

      <smnotation>
        <p>The rules below depend on the following auxiliary
        judgments.</p>

        <p id="jd_import_variables">
        The following rules add each variable explicitly declared in
        the imported module to the importing module's dynamic variable
        environment.</p>

        <infergr>
        <infer>
        <prejudge>
        </prejudge>
        <postjudge>
        <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
        <expression><a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> </expression>
        </clause>
        </multiclause>
        </postjudge>
        </infer>
        </infergr>

        <infergr>
        <infer>
        <prejudge>
        <multiclause>
        <clause>
          <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> = <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_val_env" class="env">varValue</a></environment><expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
          =&gt;
          <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression></update></expression>
        </clause>
        </multiclause>
        <multiclause>
        <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> ; <emph>AnyURI</emph></environment>
          <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression>
        </clause>
        </multiclause>
        </prejudge>
        <postjudge>
        <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
        <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
        <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression>
        </clause>
        </multiclause>
        </postjudge>
        </infer>
        </infergr>

        <p id="jd_import_functions">The following rules add each
        function explicitly declared in the imported module to the
        importing module's dynamic function environment.</p>

        <infergr>
        <infer>
        <prejudge>
        </prejudge>
        <postjudge>
        <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
        <expression><a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> </expression>
        </clause>
        </multiclause>
        </postjudge>
        </infer>
        </infergr>

        <infergr>
        <infer>
        <prejudge>
        <multiclause>
        <clause>
          <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> =
          <update><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>.<a href="#xq_func_env" class="env">funcDefn</a></environment><expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,1</subscript>,
          ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,n</subscript>)) =&gt;
          <code>#IMPORTED</code>(<emph>AnyURI</emph>)</expression></update></expression>
        </clause>
        </multiclause>
        <multiclause>
        <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> ; <emph>AnyURI</emph></environment>
          <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>2</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2,n</subscript>)), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>k</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,n</subscript>))
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression>
        </clause>
        </multiclause>
        </prejudge>
        <postjudge>
        <multiclause>
        <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
        <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,n</subscript>)), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>k</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,n</subscript>))
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> </expression>
        </clause>
        </multiclause>
        </postjudge>
        </infer>
        </infergr>
      </smnotation>

    <smnotation>
      <p>The following auxiliary judgments is used to extend a given
      dynamic environment with the dynamic environment from an
      imported module.</p>

      <p id="jd_extended_with_dynamic_environment">The judgment</p>
        <display>
          <clause>
          <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
          </clause>
        </display>

      <p>holds if extending the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> with
      the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript> yields the dynamic
      environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> under the given namespace uri
      <emph>AnyURI</emph>.</p>

      <p>This judgment is defined as follows.</p>

      <infergr>
      <infer>
      <prejudge>
      <multiclause>
      <clause>
    	 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
    	 <expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
    	 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
    	 <expression><a href="#fs_local_variables"><emph>fs:</emph><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
    	 <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript> ; <emph>AnyURI</emph></environment>
    	 <expression><a href="#fs_local_functions"><emph>fs:</emph><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>,
    	 <emph>AnyURI</emph>) <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>4</subscript></expression>
      </clause>
      </multiclause>
      </prejudge>
      <postjudge>
      <multiclause>
      <clause>
      <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>4</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      </postjudge>
      </infer>
      </infergr>
    </smnotation>

    <smcontext>
      <p>The first set of premises below "look up" the static contexts
      of all the imported modules, as defined in <specref ref="id-module-declaration"/>. The second set of premises extend
      the input static context with the global variables and function
      signatures declared in the imported static contexts.</p>

      <infergr>
      <infer>
      <prejudge>
      <multiclause>
      <clause>
        <expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression>...</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>'
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression>...</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>'
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      </prejudge>
      <postjudge>
      <multiclause>
      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression>import module <emph>AnyURI</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>'</expression>
      </clause>
      </multiclause>
      </postjudge>
      </infer>
      </infergr>

      <infergr>
      <infer>
      <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph><subscript>1</subscript> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph><subscript>1</subscript>
 	    </expression>
 	    </clause>
 	  </multiclause>
      <multiclause>
      <clause>
        <expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression>...</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><emph>AnyURI</emph><subscript>1</subscript> <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>'
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression>...</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n-1</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>
          <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>'
          <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      <multiclause>
        <clause>
          <expression>
            <a href="#xq_stat_env_def" class="env">statEnv</a>' =
            <update>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>'.<a href="#xq_ns_env" class="env">namespace</a></environment>
              <expression><emph>NCName</emph> 
              =&gt; (passive, <emph>AnyURI</emph>)</expression>
            </update>
          </expression>
        </clause>
      </multiclause>
      </prejudge>
      <postjudge>
      <multiclause>
      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression>import module namespace <emph>NCName</emph> = <emph>URILiteral</emph><subscript>1</subscript> <emph>LocationHints</emph>? <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>n</subscript>'</expression>
      </clause>
      </multiclause>
      </postjudge>
      </infer>
      </infergr>

      <p>Note that the rules above and the rules for processing a
      library module in <specref ref="id-module-declaration"/> above
      are mutually recursive. It is possible to define the semantics
      in that way, since XQuery forbids the use of recursive
      modules.</p>
    </smcontext>

    <smdyncontext>
      <p>During dynamic context processing, each variable and function
      name is mapped to the special value
      <code>#IMPORTED</code>(<emph>AnyURI</emph>) to indicate that the variable
      or function is defined in the imported module with the given
      URI.</p>

      <p>The first set of premises below "look up" the dynamic
      contexts of all the imported modules, as defined in <specref ref="id-module-declaration"/>. The second set of premises extend
      the input dynamic context with the global variables and
      functions declared in the imported dynamic contexts.</p>

  <infergr>
  <infer>
  <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
  <multiclause>
  <clause>
    <expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression>
  </clause>
  </multiclause>
  <multiclause>
  <clause>
    <expression>...</expression>
  </clause>
  </multiclause>
  <multiclause>
  <clause>
    <expression><emph>AnyURI</emph> <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript></expression>
  </clause>
  </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression>...</expression>
      </clause>
      </multiclause>
      <multiclause>
      <clause>
        <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n-1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
      </clause>
      </multiclause>
  </prejudge>
  <postjudge>
  <multiclause>
  <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment>
  <expression>import module (namespace <emph>NCName</emph> =)? <emph>URILiteral</emph> <emph>LocationHints</emph>?
         <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>  <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>n</subscript>'</expression>
  </clause>
  </multiclause>
  </postjudge>
  </infer>
  </infergr>

  <p>Note that the rule above and the rules for processing a library
  module in <specref ref="id-module-declaration"/> above are mutually
  recursive. It is possible to define the semantics in that way, since
  XQuery forbids the use of recursive modules.</p>

  </smdyncontext>

  </div2>

  <div2 id="sec_namespace_decls">
    <head>Namespace Declaration</head>

      <scrap headstyle="show"><head/>
    	<prod num="10 (XQuery)" id="doc-xquery-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
      </scrap>

     <smcore>
      <p>The core grammar production for namespace declarations is:</p>

      <scrap headstyle="show"><head/>
    	<prod num="3 (Core)" id="doc-core-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
      </scrap>

     </smcore>

    <smnorm>
      <p>Namespace declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>NamespaceDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>NamespaceDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>A namespace declaration adds a new (prefix,uri) binding in
      the namespace component of the static environment.  All
      namespace declarations in the prolog are <term>passive</term>
      declarations.  Namespace declaration attributes of element
      constructors are <term>active</term> declarations.</p>

      <infergr>
	<infer>
	  <prejudge>
 	  <multiclause>
 	    <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	    <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	    </expression>
 	    </clause>
 	  </multiclause>
 	  <multiclause>
	      <clause>
                <expression>
                   <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                   <update>
                     <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                     <expression><emph>NCName</emph> =&gt; (passive, <emph>AnyURI</emph>)</expression>
                   </update>
                </expression>
	      </clause>
 	  </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare namespace <emph>NCName</emph> = <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>In case the <emph>URILiteral</emph> part of a namespace declaration
      is a zero-length string, it is set as any #UNDECLARED in the
      static context.</p>

      <infergr>
	<infer>
	  <prejudge>
 	  <multiclause>
	      <clause>
                <expression>
                   <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                   <update>
                     <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></environment>
                     <expression><emph>NCName</emph> =&gt; (passive, #UNDECLARED)</expression>
                   </update>
                </expression>
	      </clause>
 	  </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare namespace <emph>NCName</emph> = "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smcontext>

    <smdyncontext>
      <p>The namespace declaration does not affect the dynamic
      context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare namespace <emph>NCName</emph> = <emph>URILiteral</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

  <div2 id="sec_default_namespace_decls">
    <head>Default Namespace Declaration</head>

    <scrap headstyle="show">
      <head/>
      <prod num="12 (XQuery)" id="doc-xquery-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
    </scrap>

    <smcore>
      <p>The core grammar production for default namespace
      declarations is:</p>

     <scrap headstyle="show"><head/>
     <prod num="4 (Core)" id="doc-core-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod>
     </scrap>
    </smcore>

    <smnorm>
      <p>Default namespace declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>DefaultNamespaceDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>DefaultNamespaceDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>A default element namespace declaration changes the default
      element namespace component of the static environment. If the
      URI literal is the zero-length string, the default element
      namespace is set to the null namespace. </p>

      <infergr>
	<infer>
	  <prejudge>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment>
                      <expression>#NULL-NAMESPACE</expression>
                    </update>
                </expression>
	      </clause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare default element namespace "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
           <multiclause>
            <clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>URILiteral</emph> = "")</expression></clause>
           </multiclause>
 	   <multiclause>
 	     <clause>
             <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	     <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	     </expression>
 	     </clause>
 	   </multiclause>
           <multiclause>
	    <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                  <update>
                    <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></environment>
                    <expression>
                    <emph>AnyURI</emph></expression>
                  </update>
              </expression>
	    </clause>
           </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare default element namespace <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>A default function namespace declaration changes the default
      function namespace component of the static environment. If the
      URI literal is the zero-length string, the default function
      namespace is set to the null namespace.</p>

      <infergr>
	<infer>
	  <prejudge>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></environment>
                      <expression>#NULL-NAMESPACE</expression>
                    </update>
                </expression>
	      </clause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare default function namespace "" <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
           <multiclause>
            <clause><expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>URILiteral</emph> = "")</expression></clause>
           </multiclause>
 	   <multiclause>
 	     <clause>
             <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	     <expression><emph>URILiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>AnyURI</emph>
 	     </expression>
 	     </clause>
 	   </multiclause>
           <multiclause>
            <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                  <update>
                    <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></environment>
                    <expression>
                    <emph>AnyURI</emph></expression>
                  </update>
              </expression>
	    </clause>
           </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare default function namespace <emph>URILiteral</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Note that multiple declarations of the same namespace prefix
      in the Prolog result in a static error.  However, a declaration
      of a namespace in the Prolog can override a prefix that has been
      predeclared in the static context.</p>
    </smcontext>

<smdyncontext>
<p>Default namespace declarations do not affect the dynamic
context. </p>
      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>DefaultNamespaceDecl</emph>  <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
</smdyncontext>
  </div2>

  <div2 id="sec_variable-declarations">
    <head>Variable Declaration</head>

    <scrap headstyle="show">
      <head/>
      <prod num="24 (XQuery)" id="doc-xquery-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod>
    </scrap>

    <smcore>
      <p>The core grammar production for variable declarations is:</p>

      <scrap headstyle="show"><head/>
        <prod num="16 (Core)" id="doc-core-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Normalization of a variable declaration normalizes its
      initializing expression, if it is present.</p>

      <mapping>
       <xquery>
  	 <expression><map>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> := <emph>Expr</emph>
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	 <expression>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> :=
  	   <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> 
  	 </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
  	 <expression><map>
  	   declare variable $<emph>VarName</emph> := <emph>Expr</emph>
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	 <expression>
  	   declare variable $<emph>VarName</emph> :=
  	   <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> 
  	 </expression>
       </core>
      </mapping>

      <p>If an external variable declaration does not have a type
      declaration it is treated as if the type declaration was
      <code>item()*</code>.</p>

      <mapping>
       <xquery>
  	<expression><map>
  	  declare variable $<emph>VarName</emph> external
  	</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	<expression>
  	  declare variable $<emph>VarName</emph> as item()* external
  	</expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
  	 <expression><map>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> external
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	 <expression>
  	   declare variable $<emph>VarName</emph> as <emph>SequenceType</emph> external
  	 </expression>
       </core>
      </mapping>
 
    </smnorm>

    <smcontext>
      <p>A variable declaration updates the variable component of the
      static context by associating the given variable with a static
      type.</p>

      <p>If a variable declaration has an associated expression but
      does not have a type declaration, the static type of the
      variable is the static type of the expression.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment>
                <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression>
              </clause>
	    </multiclause>
            <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                    </update>
                </expression>
	      </clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph>
                := <emph>Expr</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>If the variable declaration has an associated expression and
      has a type declaration, the static type of the variable is the
      specified type. The type of the expression must be a subtype of
      the declared type.</p>

      <infergr>
	<infer>
	  <prejudge>
            <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment>
                <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression>
              </clause>
	    </multiclause>
            <multiclause>
	      <clause>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
  	     <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
  	       <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
  	       </expression>
  	     </clause>
	    </multiclause>
  	    <multiclause>
  	      <clause>
  		<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
  	      </clause>
  	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                    </update>
                </expression>
	      </clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> := <emph>Expr</emph>
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>If the variable declaration is external and has a type
      declaration, the static type of the variable is the specified
      type.</p>

      <infergr>
	<infer>
	  <prejudge>
            <multiclause>
              <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                </environment>
                <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                <emph>Variable</emph></expression>
              </clause>
	    </multiclause>
            <multiclause>
	      <clause>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SequenceType</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                </expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                  <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
                      <expression>
                      <emph>Variable</emph> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                    </update>
                </expression>
	      </clause>
            </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> external
                <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

    </smcontext>

    <smdyncontext>
      <p>To evaluate a variable declaration, its associated expression
      is evaluated, and the dynamic context is updated with the
      variable bound to the resulting value.</p>

      <infergr>
	<infer>
	  <prejudge>
	   <multiclause>
	    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression><emph>Expr</emph>
	    <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause>
	   </multiclause>
	   <multiclause>
            <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
              </environment>
              <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
              <emph>Variable</emph></expression>
            </clause>
	   </multiclause>
	   <multiclause>
	     <clause>
               <expression>
                 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                   <update>
                     <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                     <expression>
                     <emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
                   </update>
               </expression>
	     </clause>
           </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph> := <emph>Expr</emph>
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
	   <multiclause>
	    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression><emph>Expr</emph>
	    <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a> </expression></clause>
	   </multiclause>
           <multiclause>
            <clause>
             <expression>
                <a href="#doc-fs-Type"><emph>Type</emph></a> = <map> <emph>SequenceType</emph> </map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
             </expression>
            </clause>
           </multiclause>
           <multiclause>
            <clause>
             <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
             <expression>
                <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
             </expression>
            </clause>
           </multiclause>
	   <multiclause>
            <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
              </environment>
              <expression><emph>VarName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
              <emph>Variable</emph></expression>
            </clause>
	   </multiclause>
	   <multiclause>
	     <clause>
               <expression>
                 <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                   <update>
                     <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></environment>
                     <expression>
                     <emph>Variable</emph> =&gt; <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
                   </update>
               </expression>
	     </clause>
           </multiclause>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> := <emph>Expr</emph>
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Dynamic evaluation does not apply to externally defined
      variables.  The dynamic environment must provide the values of
      external variables in the initial dynamic context
      (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>).</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>declare variable $<emph>VarName</emph>
                as <emph>SequenceType</emph> external
                <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression> 
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

  <div2 id="sec_FunctionDeclns">
    <head>Function Declaration</head>

    <smintro>

      <p>User-defined functions specify the name of the function, the
      names and types of the parameters, and the type of the
      result. The <term>function body</term> defines how the result of
      the function is computed from its parameters.</p>

      <scrap headstyle="show">
    	<head>Function declarations</head>
    	<prod num="26 (XQuery)" id="doc-xquery-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod>
    	<prod num="27 (XQuery)" id="doc-xquery-ParamList"><lhs>ParamList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Param" xlink:type="simple">Param</nt>)*</rhs></prod>
    	<prod num="28 (XQuery)" id="doc-xquery-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod>
      </scrap>
    </smintro>

    <smcore>
      <p>The core grammar productions for function declarations
      are:</p>

      <scrap headstyle="show">
    	<head>Function declarations</head>
    	<prod num="18 (Core)" id="doc-core-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod>
    	<prod num="19 (Core)" id="doc-core-ParamList"><lhs>ParamList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Param" xlink:type="simple">Param</nt>)*</rhs></prod>
    	<prod num="20 (Core)" id="doc-core-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod>
      </scrap>
    </smcore>

    <smnotation>
      <p id="jd_map_param">The following auxiliary mapping rule is
      used for the normalization of parameters in function
      declarations:
      <expression><map/><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a></expression>.</p>

      <p>Parameters without a declared type are given the item()*
      sequence type.</p>

      <mapping>
       <xquery>
  	 <expression>
           <map>$<emph>VarName</emph></map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
           $<emph>VarName</emph> as item()* 
         </expression>
       </core>
      </mapping>

      <mapping>
       <xquery>
  	 <expression>
           <map>$<emph>VarName</emph> as <emph>SequenceType</emph> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
           $<emph>VarName</emph> as <emph>SequenceType</emph> 
         </expression>
       </core>
      </mapping>

      <p>An empty parameter list is left unchanged.</p>

      <mapping>
       <xquery>
  	 <expression>
           <map/><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
         </expression>
       </core>
      </mapping>

      <p>A parameter list is normalized by applying the normalization
      rule to each parameter.</p>

      <mapping>
       <xquery>
  	 <expression>
           <map> <emph>Param</emph><subscript>1</subscript>, ..., <emph>Param</emph><subscript>n</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
           <map> <emph>Param</emph><subscript>1</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>, ..., <map> <emph>Param</emph><subscript>n</subscript> </map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a>
         </expression>
       </core>
      </mapping>

    </smnotation>

    <smnorm>
      <p>The parameter list and body of a user-defined function are
      all normalized into Core expressions.</p>
  
      <mapping>
       <xquery>
  	 <expression><map>
  	   declare function <emph>QName</emph> ( <emph>ParamList</emph>? ) as
  	   <emph>SequenceType</emph> { <emph>Expr</emph> }
  	 </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	 <expression>
  	   declare function <emph>QName</emph> (
  	   <map><emph>ParamList</emph>?</map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a> )
  	   as <emph>SequenceType</emph>
  	   { <map><emph>Expr</emph></map><a href="#jd_map_expr" class="judgment"><subscript>Expr</subscript></a> }
  	 </expression>
       </core>
      </mapping>
 
      <p>If the return type of the function is not provided, it is
      given the <code>item()*</code> sequence type.</p>

      <mapping>
       <xquery>
  	 <expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  )
  	   { <emph>Expr</emph> }</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  ) as item()*
  	   { <emph>Expr</emph> }</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
  	 </expression>
       </core>
      </mapping>

      <p>Externally defined functions are normalized similarly.</p>

      <mapping>
       <xquery>
  	 <expression><map>
  	   declare function <emph>QName</emph> ( <emph>ParamList</emph>? ) as
  	   <emph>SequenceType</emph> external</map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a></expression>
       </xquery>
       <core>
  	 <expression>
  	   declare function <emph>QName</emph>(
  	   <map><emph>ParamList</emph>?</map><a href="#jd_map_param" class="judgment"><subscript>Param</subscript></a> )
  	   as <emph>SequenceType</emph> external
  	 </expression>
       </core>
      </mapping>
 
      <mapping>
       <xquery>
  	 <expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  )
  	   external </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
         </expression>
       </xquery>
       <core>
  	 <expression>
           <map>declare function <emph>QName</emph> ( <emph>ParamList</emph>?  ) as item()*
  	   external </map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
  	 </expression>
       </core>
      </mapping>

    </smnorm>

    <smnotation>
       <p>We use the following auxiliary judgment during static
       context processing and static type analysis of function
       declarations.</p>

       <p id="jd_function_declaration">The judgment:</p>

       <display>
         <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
           <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression>
         </clause>
       </display>

       <p>holds if the function declaration <emph>FunctionDecl</emph> with the
       signature <emph>FunctionSig</emph> has the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p>
    </smnotation>

    <smcontext>
      <p>Because functions can be mutually referential, function
      signatures must be defined in the static environment before
      static type analysis is applied to the function
      bodies. Therefore, this rule updates the function signatures
      component of the static context to indicate the function is
      declared within the given module.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <expression><emph>FunctionDecl</emph> = declare function
                <emph>QName</emph> ( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>,
                ..., $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript>) as <emph>SequenceType</emph><subscript>r</subscript> (<emph>EnclosedExpr</emph> | external)</expression>
	      </clause>
	    </multiclause>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
	      </clause>
	    </multiclause>
              <multiclause>
                <clause>
                        <expression><map><emph>SequenceType</emph><subscript>1</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                        <expression><map><emph>SequenceType</emph><subscript>n</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                        <expression><map><emph>SequenceType</emph><subscript>r</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression></clause>
              </multiclause>
       <multiclause>
        <clause>
         <expression>
          <emph>FunctionSig</emph>
          =
          declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
         </expression>
        </clause>
       </multiclause>
	    <multiclause>
	      <clause>
                <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> =&gt; <emph>FunctionSig</emph></expression>
                    </update>
                </expression>
              </clause>
	    </multiclause>
	   <multiclause>
             <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
               <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
               </expression>
             </clause>
	   </multiclause>
	  </prejudge>
	  <postjudge>
	    <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <emph>FunctionDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
  	     </expression>
	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <p>Note that the static context processing is performing type
      checking of the function, as defined below. Note also that the
      type checking is done in the new environment in which the
      function declaration has been added which ensures that recursive
      calls are type-checked properly.</p>
    </smcontext>

    <smtype>
      <p>The static typing rules for function bodies follow
      normalization and processing of the static context.  The static
      typing rules below construct a new environment in which each
      parameter has the given expected type, then the static type of
      the function's body is computed under the new environment.  The
      function body's type must be a subtype of the expected return
      type.  If static typing fails, a static type error is raised.
      Otherwise, static typing of the function has no other effect, as
      function signatures are already inside the static
      environment.</p>
  
      <infergr> 
  	<infer>
  	   <prejudge>
  	    <multiclause>
  	      <clause>
  		<environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
  		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
  	      </clause>
  	    </multiclause>
  	    <multiclause>
  	      <clause>
  		<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression>
  	      </clause>
  	    </multiclause>
  	   </prejudge>
  	   <postjudge>
  	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
  	      <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression>
  	    </clause>
  	  </postjudge>
  	</infer>
      </infergr>

      <infergr> 
  	<infer>
  	   <prejudge>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression>
                </clause>
              </multiclause>
  	    <multiclause>
  	      <clause>
  		<environment>
  		  <update>
  		    <environment><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></environment>
  		    <expression>
  		      <emph>Variable</emph><subscript>1</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
  		      ;...;
  		      <emph>Variable</emph><subscript>n</subscript> =&gt; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>
  		    </expression>
  		  </update>
  		</environment>
  		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
  	      </clause>
  	    </multiclause>
  	    <multiclause>
  	      <clause>
  		<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript></expression>
  	      </clause>
  	    </multiclause>
  	   </prejudge>
  	   <postjudge>
  	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
  	      <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph>
  		($<emph>VarName</emph><subscript>1</subscript> as  <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript>)
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression>
  	    </clause>
  	  </postjudge>
  	</infer>
      </infergr>

      <p>The bodies of external functions are not available and
      therefore cannot by type checked.  To ensure type soundness, the
      implementation must guarantee that the value returned by the
      external function matches the expected return type. </p>

      <infergr>
  	<infer>
  	   <prejudge>
  	   </prejudge>
  	   <postjudge>
  	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
  	      <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>()
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression>
  	    </clause>
  	  </postjudge>
  	</infer>
      </infergr>

      <infergr>
  	<infer>
  	   <prejudge>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression>
                </clause>
              </multiclause>
  	   </prejudge>
  	   <postjudge>
  	    <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
  	      <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a>
  	      declare function <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
  	      as <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
  	      </expression>
  	    </clause>
  	  </postjudge>
  	</infer>
      </infergr>

     </smtype>

     <smdyncontext>
       <p>A function declaration updates the dynamic context.  The
       function name with arity N is associated with the given
       function body.  The number of arguments is required, because
       XQuery permits overloading of function names as long as each
       function signature has a different number of arguments.</p>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
	      </clause>
	    </multiclause>
            <multiclause>
	      <clause>
                <expression>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>() =&gt; (<emph>Expr</emph>)</expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
  	    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
  	      <expression>declare function <emph>QName</emph> ()
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
  	      </expression>
  	    </clause>
	  </postjudge>
	</infer>
      </infergr>

      <infergr>
	<infer>
	  <prejudge>
	    <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
	      </clause>
	    </multiclause>
	    <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>VarName</emph><subscript>1</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>1</subscript></expression>
                </clause>
	    </multiclause>
	    <multiclause>
                <clause><expression>···</expression></clause>
	    </multiclause>
	    <multiclause>
                <clause>
                  <environment><a href="#xq_stat_env_def" class="env">statEnv</a>
                  </environment>
                  <expression><emph>VarName</emph><subscript>n</subscript> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a>
                  <emph>Variable</emph><subscript>n</subscript></expression>
                </clause>
            </multiclause>
              <multiclause>
                <clause>
                        <expression><map><emph>SequenceType</emph><subscript>1</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression></clause>
              </multiclause>
              <multiclause>
                <clause><expression>...</expression></clause>
              </multiclause>
              <multiclause>
                <clause>
                        <expression><map><emph>SequenceType</emph><subscript>n</subscript></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                        = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript></expression></clause>
              </multiclause>
            <multiclause>
	      <clause>
                <expression>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> =
                    <update>
                      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></environment>
                      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) =&gt; (
                      <emph>Expr</emph> , <emph>Variable</emph><subscript>1</subscript> , ···,
                      <emph>Variable</emph><subscript>n</subscript>)</expression>
                    </update>
                </expression>
	      </clause>
	    </multiclause>
	  </prejudge>
	  <postjudge>
  	    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
  	      <expression>declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript>  as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      { <emph>Expr</emph> } <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
  	      </expression>
  	    </clause>
	  </postjudge>
	</infer>
      </infergr>

       <p>An external function declaration does not affect the dynamic
       environment. The implementation must support the declared
       external functions.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
  	    <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
  	      <expression>declare function <emph>QName</emph>
  		( $<emph>VarName</emph><subscript>1</subscript> as <emph>SequenceType</emph><subscript>1</subscript>, ···,
  	      $<emph>VarName</emph><subscript>n</subscript> as <emph>SequenceType</emph><subscript>n</subscript> )
  	      as <emph>SequenceType</emph><subscript>r</subscript>
  	      external <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
  	      </expression>
  	    </clause>
	  </postjudge>
	</infer>
      </infergr>
       <p>The dynamic semantics of a function body are applied when
       the function is called, as described in <specref ref="id-function-calls"/>.</p>

     </smdyncontext>

  </div2>

  <div2 id="id-option-declaration">
    <head>Option Declaration</head>
    <scrap headstyle="show">
      <head/>
      <prod num="13 (XQuery)" id="doc-xquery-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
    </scrap>

    <smcore>
      <p>The core grammar production for option declarations is:</p>

      <scrap headstyle="show">
      <head/>
        <prod num="5 (Core)" id="doc-core-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
      </scrap>
    </smcore>

    <smnorm>
      <p>Option declarations are left unchanged through
      normalization.</p>

      <mapping>
       <xquery>
        <expression>
         <map><emph>OptionDecl</emph></map><a href="#jd_map_prolog" class="judgment"><subscript>PrologDecl</subscript></a>
        </expression>
       </xquery>
       <core>
        <expression>
          <emph>OptionDecl</emph>
        </expression>
       </core>
      </mapping>
    </smnorm>

    <smcontext>
      <p>An option declaration does not have any effect on the static
      context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><emph>OptionDecl</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smcontext>

    <smdyncontext>
      <p>An option declaration does not have any effect on the dynamic
      context.</p>

      <infergr>
	<infer>
	  <prejudge>
	  </prejudge>
	  <postjudge>
	    <multiclause>
	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression><emph>OptionDecl</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
	      </clause>
	    </multiclause>
	  </postjudge>
	</infer>
      </infergr>
    </smdyncontext>
  </div2>

</div1>


     
<div1 id="id-xquery-conformance" role="xquery">
  <head>Conformance</head>

  <p>The XQuery Formal Semantics is intended primarily as a component
  that can be used by <bibref ref="xquery"/>, or a host language of
  <bibref ref="xpath20"/>. Therefore, the XQuery Formal Semantics
  relies on specifications that use it (such as [XPath 2.0], [XSLT
  2.0], and [XQuery]) to specify conformance criteria in their
  respective environments. Specifications that set conformance
  criteria for their use of the formal semantics must not relax the
  constraints expressed in this specification.</p>

  <div2 id="id-static-typing-feature">
    <head>Static Typing Feature</head>

    <p>This specification normatively defines the static typing
    feature which can be used in <bibref ref="xquery"/> or a host
    language of <bibref ref="xpath20"/>. The static typing feature is
    specified using the static typing judgment introduced in <specref ref="sec_static"/>.</p>

    <div3 id="id-static-extensions">
      <head>Static Typing Extensions</head>

      <p>In some cases, the static typing rules are not very precise
      (see, for example, the type inference rules for the ancestor
      axes—parent, ancestor, and ancestor-or-self—and for
      the function <code>fn:root</code>). If an implementation
      supports a static typing extension, it must always provide a
      more precise type than the one defined in this
      specification.</p>

      <p id="jd_has_type_extension">This constraint is formally
      expressed as follows. A static typing extension <emph>Expr</emph>
      <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a> must be such that for every
      expression <emph>Expr</emph> the following holds.</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      	    <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a>' <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph> <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a>'</expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <note><p>It is not recommended for a static typing extension to
      change the static typing behavior of expressions that specify a
      type explicitly (<code>treat as</code>, <code>cast as</code>,
      <code>typeswitch</code>, function parameters, and type
      declarations in variable bindings), since the purpose of those
      expressions is to impose a specific type.</p></note>

    </div3>
  </div2>
</div1>


     <div1 id="sec_special_functions">
  <head>Additional Semantics of Functions</head>

  <p>This section defines the auxiliary functions required to define
  the formal semantics of [XPath/XQuery], and gives special normalization
  and static typing rules for some functions in <bibref ref="xpath-functions"/>.</p>

  <p>Remember from <specref ref="id-function-calls"/> that the
  following rules operate after namespace resolution for the function
  name, and directly over the input type of the parameters. In the
  rest of the section, we will use the following shortcuts notations
  for specific relevant URIs:</p>

  <ulist>
    <item><p><code>FN-URI</code> for functions from the <bibref ref="xpath-functions"/>
    document.</p></item>
    <item><p><code>OP-URI</code> for operators from the <bibref ref="xpath-functions"/>
    document.</p></item>
    <item><p><code>FS-URI</code> for formal semantics functions.</p></item>
  </ulist>

  <div2 id="sec_special_fs_functions">
    <head>Formal Semantics Functions</head>

    <smintro>
      <p>This section gives the definition and semantics of functions
      that are used in the formal semantics but are not in
      <bibref ref="xpath-functions"/>.  Their dynamic semantics are defined in the same
      informal style as in the <bibref ref="xpath-functions"/> document.  The static
      semantics of some formal-semantics functions require custom
      static typing rules.</p>
    </smintro>

    <div3 id="sec_convert_operand">
      <head><phrase>The <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> function</phrase></head>

	<example role="signature">
		<proto name="convert-operand" return-type="xs:anyAtomicType ?" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
			<arg name="actual" type="xs:anyAtomicType?"/>
			<arg name="expected" type="xs:anyAtomicType"/>
		</proto>
	</example>

      <p>The formal-semantics function <a href="#sec_convert_operand"><emph>fs:</emph><code>convert-operand</code></a> converts
      the operands of arithmetic and comparison operators as
      follows:</p>

      <olist>
        <item>
          <p>If <code>$actual</code> is the empty sequence, returns the
          empty sequence.</p>
        </item>

        <item>
          <p>If <code>$actual</code> is an instance of type
          <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, then</p>
          <olist>
            <item>
              <p>if <code>$expected</code> is an instance of type
              <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or <code>xs:string</code>, returns
              <code>$actual</code> cast to <code>xs:string</code>;</p>
            </item>
            <item>
              <p>if <code>$expected</code> is of numeric type, returns
              <code>$actual</code> cast to <code>xs:double</code></p>
            </item>
            <item>
              <p>otherwise returns <code>$actual</code> cast to the
              type of <code>$expected</code>.</p>
            </item>
          </olist>
        </item>

        <item>
          <p>Otherwise, returns <code>$actual</code>.</p>
        </item>

      </olist>

      <smtype>
        <p>No conversion is needed unless $actual is an instance of
        type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    not(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>?)
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>Pairs of untyped atomic operands are converted to
        strings.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> xs:untypedAtomic</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <code>xs:string</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>When an untyped operand is paired with a numeric operand,
        it is converted to xs:double.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <emph>fs:</emph><code>numeric</code></expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <code>xs:double</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>Finally, an untyped atomic operand not dealt with by the
        above rules is converted to the type of the other operand.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> ?</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                  <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>|<emph>fs:</emph><code>numeric</code>))
                  </expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,<quote><code>convert-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>
    </div3>

    <div3 id="sec_convert_simple_operand">
      <head><phrase>The <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> function</phrase></head>

      <example role="signature">
	<proto name="convert-simple-operand" return-type="xs:anyAtomicTypeAtomic *" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
  	 <arg name="actual" type="xs:anyAtomicTypeAtomic *"/>
	 <arg name="expected" type="xs:anyAtomicType"/>
	</proto>
      </example>

      <p>The formal-semantics function <a href="#sec_convert_simple_operand"><emph>fs:</emph><code>convert-simple-operand</code></a> is
      used to convert the value of the <code>$actual</code> argument
      such that it matches the type of the <code>$expected</code>
      argument (or matches a sequence of that type).</p>

      <p>The dynamic semantics of this function are as follows:</p>

      <ulist>
        <item>
          <p>For each item in <code>$actual</code> argument that is of
          type xs:untypedAtomic, that item is cast to the type of the
          <code>$expected</code> argument, and the resulting sequence
          is returned.</p>
        </item>
      </ulist>

      <smtype>
        <p>The following static typing rules correspond to the dynamic
        semantics rules given above.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> =
                  <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</expression>
                </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#sec_convert_simple_operand">(<code>FS-URI</code>,<quote><code>convert-simple-operand</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

    </div3>

    <div3 id="sec_distinct_docorder">
      <head><phrase>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function</phrase></head>

				<example role="signature">
					<proto name="distinct-doc-order" return-type="node *" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
						<arg name="nodes" type="node *"/>
					</proto>
				</example>


      <p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function sorts its input sequence
      of nodes by document order
      and removes duplicates.</p>

      <smtype>
        <p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function expects a sequence of
        nodes as input. The resulting type is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.</p>

	<infergr>
	  <infer>
       
	    <prejudge>
	      <multiclause>
                <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> node*
                  </expression>
                </clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#sec_distinct_docorder">(<code>FS-URI</code>,<quote><code>distinct-doc-order</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

</smtype>
    </div3>

    <div3 id="sec_distinct_docorder_or_atomic_sequence">
      <head><phrase>The <a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> function</phrase></head>

				<example role="signature">
					<proto name="distinct-doc-order-or-atomic-sequence" return-type="item()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
						<arg name="item" type="item()*"/>
					</proto>
				</example>


      <p>The <a href="#sec_distinct_docorder_or_atomic_sequence"><emph>fs:</emph><code>distinct-doc-order-or-atomic-sequence</code></a> function operates
      on either an homogeneous sequence of nodes or an homogeneous
      sequence of atomic values. If the input is a sequence of nodes,
      is sorts those nodes by document order and removes duplicates,
      using the fs:distinct-doc-order function. If it is a sequence of
      atomic values, it returns it unchanged.</p>

      <smtype>

        <p>The <a href="#sec_distinct_docorder"><emph>fs:</emph><code>distinct-doc-order</code></a> function expects either a
        sequence of nodes as input or a sequence of atomic values. The
        resulting type is computed using <a href="#jd_prime" class="judgment">prime</a> and
        <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.</p>

	<infergr>
	  <infer>
       
	    <prejudge>
	      <multiclause>
                <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>*
                  </expression>
                </clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,<quote><code>distinct-doc-order-or-atomic-sequence</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
       
	    <prejudge>
	      <multiclause>
                <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                  </expression>
                </clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression><a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,<quote><code>distinct-doc-order-or-atomic-sequence</code></quote>)</a> ( <a href="#doc-fs-Type"><emph>Type</emph></a>
			) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

</smtype>
    </div3>

    <div3 id="sec_items_to_nodes">
      <head><phrase>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function</phrase></head>

				<example role="signature">
					<proto name="item-sequence-to-node-sequence" return-type="node()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
						<arg name="items" type="item()*"/>
					</proto>
				</example>

      <p>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence</code></a> function converts a sequence of
      item values to nodes by applying the normative rules numbered
      <code>1</code>, <code>2</code>, <code>3</code> after the
      sentence <quote>Processing of the computed element constructor
      proceeds as follows:</quote> in <xspecref spec="XQ" ref="id-computedElements"/>.</p>

      <smtype>
	<infergr>
	  <infer>
	    <prejudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
			attribute*,
			(element|document|text|processing-instruction|comment|<code>xs:string</code>|<code>xs:float</code>|
			...|<code>xs:NOTATION</code>)*</expression>
		</clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#sec_items_to_nodes_doc">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence</code></quote>)</a>
			(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> attribute*, (element|text|processing-instruction|comment)*</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

      </smtype>
    </div3>

    <div3 id="sec_items_to_nodes_doc">
      <head><phrase>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> function</phrase></head>

				<example role="signature">
					<proto name="item-sequence-to-node-sequence" return-type="node()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
						<arg name="items" type="item()*"/>
					</proto>
				</example>

      <p>The <a href="#sec_items_to_nodes"><emph>fs:</emph><code>item-sequence-to-node-sequence-doc</code></a> function converts a
      sequence of item values to nodes by applying the normative rules
      numbered <code>1</code>, <code>2</code>, <code>3</code> after
      the sentence <quote>Processing of the document node constructor
      then proceeds as follows:</quote> in <xspecref spec="XQ" ref="id-documentConstructors"/>.</p>

      <smtype>
	<infergr>
	  <infer>
	    <prejudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
			(element|document|text|processing-instruction|comment|<code>xs:string</code>|<code>xs:float</code>|
			...|<code>xs:NOTATION</code>)*</expression>
		</clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a></environment>
			<expression><a href="#sec_items_to_nodes_doc">(<code>FS-URI</code>,<quote><code>item-sequence-to-node-sequence-doc</code></quote>)</a>
			(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> (element|text|processing-instruction|comment)*</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

      </smtype>
    </div3>

    <div3 id="sec_item_seq_to_untypedAtomic">
      <head><phrase>The <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> function</phrase></head>

      <smintro> 
	<example role="signature">
 	 <proto name="item-sequence-to-untypedAtomic" return-type="xs:untypedAtomic" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
	  <arg name="items" type="item()*"/>
	 </proto>
	</example>

        <p>The <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> function converts a
        sequence of item values to a string of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
        by applying the normative rules in <xspecref spec="XQ" ref="id-computedAttributes"/> for processing the content
        expression.</p>
      </smintro>

      <smeval>
        <p>If the input of the <a href="#sec_item_seq_to_untypedAtomic"><emph>fs:</emph><code>item-sequence-to-untypedAtomic</code></a> function
        is an empty sequence, it returns a zero-length
        string. Otherwise, each atomic value in the input sequence is
        cast into a string. The individual strings resulting from the
        previous step are merged into a single string by concatenating
        them with a single space character between each pair.</p>
      </smeval>

      <smtype>
        <p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p>
      </smtype>

    </div3>

    <div3 id="sec_item_seq_to_untypedAtomic_PI">
      <head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function</phrase></head>
 
      <smintro>

	<example role="signature">
       <proto name="item-sequence-to-untypedAtomic-PI" return-type="xs:untypedAtomic" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
       <arg name="items" type="item()*"/>
       </proto>
	</example>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function converts a
        sequence of item values to a string of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
        by applying the normative rules in <xspecref spec="XQ" ref="id-computed-pis"/> for processing the content
        expression.</p>
      </smintro>

      <smeval>
        <p>If the input is an empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_PI"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-PI</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. If any of the resulting
        strings contains the string "?&gt;", a dynamic error is
        raised. The individual strings resulting from the previous
        step are merged into a single string by concatenating them
        with a single space character between each pair. Leading
        whitespace is removed from the resulting string.</p>
      </smeval>

     <smtype>
       <p>There are no special static typing rules for this
       function. Static type analysis for this function should be
       performed as for a built-in function declared with the given
       signature.</p>
     </smtype>

    </div3>

    <div3 id="sec_item_seq_to_untypedAtomic_text">
      <head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function</phrase></head>

      <smintro> 
	<example role="signature">
 	 <proto name="item-sequence-to-untypedAtomic-text" return-type="xs:untypedAtomic?" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
	  <arg name="items" type="item()*"/>
	 </proto>
	</example>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function converts a
        sequence of item values to a string of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, or empty, by applying the rules in
        <xspecref spec="XQ" ref="id-textConstructors"/> for processing
        the content expression.</p>
      </smintro>

      <smeval>
        <p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_text"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-text</code></a> function returns the empty
        sequence. Otherwise, each atomic value in the input sequence
        is cast into a string. The individual strings resulting from
        the previous step are merged into a single string by
        concatenating them with a single space character between each
        pair.</p>
      </smeval>

      <smtype>
        <p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p>
      </smtype>
    </div3>

    <div3 id="sec_item_seq_to_untypedAtomic_comment">
      <head><phrase>The <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function</phrase></head>

      <smintro> 
	<example role="signature">
 	 <proto name="item-sequence-to-untypedAtomic-comment" return-type="xs:untypedAtomic" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
	  <arg name="items" type="item()*"/>
	 </proto>
	</example>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function
        converts a sequence of item values to a string of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> by applying the normative rules in
        <xspecref spec="XQ" ref="id-computed-comments"/> for
        processing the content expression.</p>
      </smintro>

      <smeval> 
        <p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_comment"><emph>fs:</emph><code>item-sequence-to-untypedAtomic-comment</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. The individual strings
        resulting from the previous step are merged into a single
        string by concatenating them with a single space character
        between each pair. It is a dynamic error if the result of the
        content expression of a computed comment constructor contains
        two adjacent hyphens or ends with a hyphen.</p>
      </smeval> 

      <smtype>
        <p>There are no special static typing rules for this
        function. Static type analysis for this function should be
        performed as for a built-in function declared with the given
        signature.</p>
      </smtype>

    </div3>

    <div3 id="sec_apply_ordering_mode">
      <head><phrase>The <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>
      function</phrase></head>
 
      <example role="signature">
       <proto name="apply-ordering-mode" return-type="item()*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
        <arg name="items" type="item()*"/>
       </proto>
      </example>

      <smeval>
        <p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to ordered, the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is the identity function,
        returning its input sequence in its original order.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code></expression>
	      </clause>
  	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
		      <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
              </clause>
	    </prejudge>
	    <postjudge>
  	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
		      <expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<emph>Expr</emph>)
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
              </clause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to unordered, the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> is equivalent to the <code>fn:unordered</code>
        function, returning the items from its input sequence in
        arbitrary order.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>unordered</code></expression>
	      </clause>
  	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
		      <expression><code>fn:unordered</code>(<emph>Expr</emph>) <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
              </clause>
	    </prejudge>
	    <postjudge>
  	      <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a> </environment>
		      <expression><a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a>(<emph>Expr</emph>)
		      <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
              </clause>
	    </postjudge>
	  </infer>
	</infergr>

      </smeval>

      <smtype>
        <p>If the ordering context is set to <code>ordered</code>, the
        static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is left unchanged.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code></expression>
	      </clause>
	    </prejudge>
	    <postjudge>
  	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
		      <expression><a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,<quote><code>apply-ordering-mode</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
		     <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>If the ordering context is set to <code>unordered</code>,
        the static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><emph>fs:</emph><code>apply-ordering-mode</code></a> function is computed using the
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a> judgments, as for the
        <code>fn:unordered</code> function.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <clause><expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>unordered</code></expression>
	      </clause>
	    </prejudge>
	    <postjudge>
  	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
		      <expression><a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,<quote><code>apply-ordering-mode</code></quote>)</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
		     <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
		     <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
	    </postjudge>
	  </infer>
	</infergr>
      </smtype>
    </div3>

    <div3 id="sec_fs_to">
      <head>The <emph>fs:</emph><code>to</code> function</head>

      <example role="signature">
	<proto name="to" return-type="xs:integer*" returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no" isOp="no">
	  <arg name="firstval" type="xs:integer?"/>
	  <arg name="lastval" type="xs:integer?"/>
	</proto>
      </example>

      <p>The formal semantics function <emph>fs:</emph><code>to</code> is a wrapper function
      for the <code>op:to</code> operator, taking the semantics of the range
      expression over empty sequences into account.</p>

      <smeval>
        <p>If one of the input parameters for <emph>fs:</emph><code>to</code> is the empty
        sequence, the function returns the empty sequence, otherwise
        it returns the result of calling the <code>op:to</code> operator. This
        semantics is equivalent to the following user-defined
        function.</p>

<eg xml:space="preserve">
declare function fs:to($firstval as xs:integer?, $lastval as xs:integer?) as xs:integer* {
  if (fn:empty($firstval) or fn:empty($lastval)
  then ()
  else op:to($firstval,$lastval)
};
</eg>
      </smeval>

      <smtype>
        <p>The static type of <emph>fs:</emph><code>to</code> does not require any additional
        static typing rule, and is typed as a function call based on
        the above signature.</p>
      </smtype>
    </div3>

  </div2>

  <div2 id="function_rules">
    <head>Standard functions with specific static typing rules</head>

    <smintro>
      <p>This section gives special normalization and static typing
      rules for functions in <bibref ref="xpath-functions"/> for which the standard
      normalization or static typing rules are not appropriate. All
      functions that are not mentioned behave as described in Section
      <specref ref="id-function-calls"/>. When given, the static
      typing rules in this section always give more precise type
      information than the generic rule based on the function's
      signature.</p>
    </smintro>

    <div3 id="sec_fn_last">
      <head>The <code>fn:last</code> context function</head>

      <p>As explained in <specref ref="eval_context"/>, the
      <code>fn:last()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>. For that function the
      following static typing and dynamic evaluation rules apply.</p>

      <smtype>
        <infergr>
          <infer>
            <prejudge>
 	      <multiclause>
 	        <clause>
 	          <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>last</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	        </clause>
 	      </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>last</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>
        <infergr>
          <infer>
            <prejudge>
 	      <multiclause>
 	        <clause>
 	          <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>((<code>FS-URI</code>,<quote><code>last</code></quote>)) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	        </clause>
 	      </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>last</code></quote>)() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smeval>

    </div3>

    <div3 id="sec_fn_position">
      <head>The <code>fn:position</code> context function</head>

      <p>As explained in <specref ref="eval_context"/>, the
      <code>fn:position()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>. For that function the
      following static typing and dynamic evaluation rules apply.</p>

      <smtype>
        <infergr>
          <infer>
            <prejudge>
 	      <multiclause>
 	        <clause>
 	          <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>((<code>FS-URI</code>,<quote><code>position</code></quote>)) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
 	        </clause>
 	      </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>position</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

      <smeval>
        <infergr>
          <infer>
            <prejudge>
 	      <multiclause>
 	        <clause>
 	          <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>((<code>FS-URI</code>,<quote><code>position</code></quote>)) = <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
 	        </clause>
 	      </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>position</code></quote>)() <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smeval>

    </div3>

    <div3 id="sec_fn_abs_ceil_floor_round">
      <head><phrase>The <code>fn:abs</code>, <code>fn:ceiling</code>, <code>fn:floor</code>,
      <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions</phrase></head>

      <smtype>
        <p>The static typing rules for the <code>fn:abs</code>, <code>fn:ceiling</code>,
        <code>fn:floor</code>, <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions promote
        their input type to the (least) base primitive numeric type
        from which the input type is derived. Note that the fact that
        the type should be the least is cannot expressed by the
        inference rule notation used here. Parameters of type
        <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> are always promoted to <code>xs:double</code>.
        Instead of writing a separate judgment for each function, we
        write one rule with function variable <emph>F</emph>, which is
        one of the (<code>FN-URI</code>,<quote><code>abs</code></quote>), (<code>FN-URI</code>,<quote><code>ceiling</code></quote>), (<code>FN-URI</code>,<quote><code>floor</code></quote>),
        (<code>FN-URI</code>,<quote><code>round</code></quote>), or (<code>FN-URI</code>,<quote><code>round-half-to-even</code></quote>) functions.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a>,  <code>xs:double</code>)</expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_isin" class="judgment"><term>in</term></a> { <code>xs:integer</code>,
                  <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code> } </expression>
                </clause>
              </multiclause>
            </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <emph>F</emph> (<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression>
 	      </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>
    </div3>

    <div3 id="sec_fn_boolean">
      <head><phrase>The <code>fn:boolean</code> function</phrase></head>

      <smtype>
        <p>The <code>fn:boolean</code> function as described in the
        <bibref ref="xpath-functions"/> document takes an empty sequence, a sequence of
        one or more nodes, or a singleton value of type <code>xs:boolean</code>,
        <code>xs:string</code>, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> or some numeric type.  All
        other values are illegal.</p>
        <infergr>
          <infer>
            <prejudge>
              <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (empty |
                <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>+ | <code>xs:boolean</code> | <code>xs:string</code> |
                <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> | <emph>fs:</emph><code>numeric</code>)</expression>
              </clause>
              </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>(<code>FN-URI</code>,<quote><code>boolean</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:boolean</code></expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>
    </div3> 

    <div3 id="sec_fn_doc_collection">
      <head><phrase>The <code>fn:collection</code> and <code>fn:doc</code> functions</phrase></head>

      <smintro>
        <p>The static typing rules for <code>fn:collection</code> and <code>fn:doc</code>
        depend on the syntactic form of their input expression. As a
        result, the corresponding static typing rules must be written
        directly over the input expression, unlike the other functions
        in this section.</p>
      </smintro>

      <smtype>
        <p>The <code>fn:collection</code> function as described in the
        <bibref ref="xpath-functions"/> document, takes a string-valued expression,
        which denotes a URI, and returns a value.</p>

        <p>If the <code>fn:collection</code> function has no parameter, the
        result type is given by the implementation for the default
        sequence if it exists.</p>

        <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>Implementation-defined default sequence
                has type <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>() <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>If the argument to <code>fn:collection</code> is a <emph>URILiteral</emph>
        expression which is defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, then
        the result type is the type corresponding to the
        <emph>URILiteral</emph> in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>. </p>

        <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause>
                <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<emph>URILiteral</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>Otherwise, if the argument is a URI literal but is not
        defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, or if it is not a URI
        literal, then we don't know anything about the URI and the
        static type is a collection of nodes.</p>

         <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause>
                <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<emph>URILiteral</emph>) undefined</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                (element | attribute | processing-instruction | text |
                comment | document ) *</expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

         <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>collection</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause>
                <expression><emph>Expr</emph> is not a <emph>URILiteral</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>(<emph>Expr</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> (element | attribute | processing-instruction | text |
                comment | document ) *</expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>The <code>fn:doc</code> function has similar static typing rules, but,
        in addition, the static type must be a document node.</p>

        <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause>
                <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<emph>URILiteral</emph>) = <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> document </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

        <p>Otherwise, if the argument is a URI literal not defined in
        the domain of <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> or if it is not a URI literal,
        then we don't know anything about the URI, and the static type
        is document.</p>

         <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause>
                <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<emph>URILiteral</emph>) undefined</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
              <expression><emph>QName</emph>(<emph>URILiteral</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> document?</expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

         <infergr>
          <infer>
            <prejudge>
             <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>QName</emph>
                  <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>doc</code></quote>)</expression>
                </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>Expr</emph> is not a <emph>URILiteral</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression><emph>QName</emph>(<emph>Expr</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> document?</expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>

      </smtype>

    </div3>
    <div3 id="sec_fn_data">
      <head>The <code>fn:data</code> function</head>

      <smintro>
        <p>The <code>fn:data</code> function converts a sequence of items to a
        sequence of atomic values.</p>
      </smintro>

      <smnotation>
        <p id="jd_data">Inferring the type for the <code>fn:data</code> function
        is done by applying the <a href="#jd_data" class="judgment"><term>data on</term></a> auxiliary judgment, using
        the same approach as for the XPath steps.</p>

        <display>
   	  <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
   	  </clause>
   	</display>

      </smnotation>

      <smtype>
        <p>The general rule for <code>fn:data</code> is to apply the filter
        <a href="#jd_data" class="judgment"><term>data on</term></a> to the prime type of its argument type, then
        apply the quantifier to the result:</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
 	      	<clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                  </expression>
 	      	</clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  (<code>FN-URI</code>,<quote><code>data</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to none, <a href="#jd_data" class="judgment"><term>data on</term></a> yields none.</p>

      	<infergr>
 	  <infer>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <code>none</code> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to empty, <a href="#jd_data" class="judgment"><term>data on</term></a> yields empty.</p>

      	<infergr>
 	  <infer>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <code>empty</code> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>empty</code>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to the union of two types, <a href="#jd_data" class="judgment"><term>data on</term></a> is
        applied to each of the two types. The resulting type is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <specref ref="sec_factor"/>.  This rule is
        necessary because <a href="#jd_data" class="judgment"><term>data on</term></a> may return a sequence of atomic
        types.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'</expression>
 	        </clause>
              </multiclause>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>'</expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to an atomic type, <a href="#jd_data" class="judgment"><term>data on</term></a> simply
        returns the atomic type:</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a></expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to comment or processing instruction node types, <a href="#jd_data" class="judgment"><term>data on</term></a> returns
        <code>xs:string</code></p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> comment | processing-instruction
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:string</code>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to text or document node types, <a href="#jd_data" class="judgment"><term>data on</term></a>
        returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                    <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> text | document
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to element node types with <xtermref spec="XQ" ref="dt-type-annotation"/> <a href="#dt-xs_untyped"><code>xs:untyped</code></a>, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter
        returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

<!--
      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment>&xq_stat_env;</environment>
                  <expression>
                    &gr_AttributeType; &jd_static_lookup; of type &xs_untypedAtomic;
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment>&xq_stat_env;</environment>
 		<expression>
                  &jd_data; &gr_AttributeType; &jd_has_type; &xs_untypedAtomic;
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>
-->
      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a>
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to an attribute node type, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter returns the
        attribute's simple type.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                  </expression>
 	        </clause>
              </multiclause>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to an element type whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a simple type or a complex
        type of simple content, <a href="#jd_data" class="judgment"><term>data on</term></a> returns the element's simple
        type.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  </expression>
 	        </clause>
              </multiclause>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                     <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                  </expression>
 	        </clause>
              </multiclause>
              <multiclause>
  	        <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                     <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> (attribute*, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                  </expression>
 	        </clause>
  	        <clause>
                  <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                  <expression>
                     <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>When applied to an element type whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a complex type of mixed
        content, the <a href="#jd_data" class="judgment"><term>data on</term></a> filter returns <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

      	<infergr>
 	  <infer>
 	    <prejudge>
              <multiclause>
  	        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression>
                    <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
                  </expression>
 	        </clause>
              </multiclause>
              <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
  	        <clause>
                  <expression>
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                    define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-Derivation"><emph>Derivation</emph></a> mixed { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
                  </expression>
 	        </clause>
              </multiclause>
 	    </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_has_type" class="judgment"><term>:</term></a> xs:untypedAtomic
 		</expression>
 	      </clause>
 	    </postjudge>
 	  </infer>
      	</infergr>

        <p>The <a href="#jd_data" class="judgment"><term>data on</term></a> filter is not defined on any element type
        whose <xtermref spec="XQ" ref="dt-type-annotation"/> denotes a
        complex type of complex content and therefore applying
        <a href="#jd_data" class="judgment"><term>data on</term></a> to such a node raises a static error.</p>
      </smtype>

      <smexample>
        <p>Consider the following variable and its corresponding
        static type.</p>
      
<eg xml:space="preserve">
    $x : (element price { attribute currency { xs:string }, xs:decimal }
         | element price_code { xs:integer })
</eg>

        <p>Applying the <code>fn:data</code> function on that variable results in
        the following type.</p>
      
<eg xml:space="preserve">
    fn:data($x) : (xs:decimal | xs:integer)
</eg>

        <p>Because the input type is a choice, applying the
        <a href="#jd_data" class="judgment"><term>data on</term></a> filter results in a choice of simple types for the
        output of the <code>fn:data</code> function.</p>
      </smexample>

    </div3>

    <div3 id="sec_fn_distinct_node_vals">
      <head><phrase>The <code>fn:distinct-values</code> function</phrase></head>

      <smtype>
        <p>The <code>fn:distinct-values</code> function expects a sequence of atomic
        values as input and returns a sequence of prime types, which
        are defined in <specref ref="sec_factor"/>.</p>

	<infergr>
	  <infer>
	    <prejudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</expression>
		 </clause>
	      </multiclause>
	    </prejudge>
	    <postjudge>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>distinct-values</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
		 </clause>
	    </postjudge>
	  </infer>
	</infergr>

      </smtype>
    </div3>

    <div3 id="sec_fn_unordered">
      <head><phrase>The <code>fn:unordered</code> function</phrase></head>

      <smtype>
        <p>The static semantics for <code>fn:unordered</code> is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>. The type of the argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        that type.</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>unordered</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
		 </clause>
	    </postjudge>
	  </infer>
	</infergr>
      </smtype>
    </div3>

    <div3 id="sec_fnerror">
      <head><phrase>The <code>fn:error</code> function</phrase></head>

      <smtype>
        <p>The fn:error function always has the <code>none</code> type.</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)() <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code></expression></clause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code>?</expression></clause>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:string</code></expression></clause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:QName</code>?</expression></clause>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:string</code></expression></clause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>error</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>none</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

      </smtype>
    </div3>

    <div3 id="sec_fn_aggregates">
      <head><phrase>The <code>fn:min</code>, <code>fn:max</code>, <code>fn:avg</code>, and <code>fn:sum</code>
      functions</phrase></head>

     <smintro>
       <p>The semantics of aggregate functions convert any item of
       type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> in the input sequence to <code>xs:double</code>,
       then attempt to promote all values in the input sequence to
       values that are comparable.  The static typing rules reflect
       the dynamic evaluation rules.</p>

      <p>The <code>fn:sum</code> function has two forms.  The first form takes
      two arguments: The first argument is the input sequence and the
      second argument is the value that should be returned if the
      input sequence is empty. In case there is no second argument,
      the value returned for an empty sequence is the <code>xs:integer</code>
      value 0. The following static typing rule applies in the case
      there is no second argument.</p>
     </smintro>

     <smtype>
        <infergr>
          <infer>
            <prejudge>
 	      <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<emph>Expr</emph>,0) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
              </clause>
 	      </multiclause>
            </prejudge>
            <postjudge>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<emph>Expr</emph>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                </expression>
              </clause>
            </postjudge>
          </infer>
        </infergr>
     </smtype>

     <smnotation>
       <p id="jd_convert_untypedAtomic">The type function
       <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a> takes a prime type and converts all
       occurrences of the type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to a target type.
       It is defined recursively as follows.</p>
    
      <table summary="" role="figure">
        <col align="left" span="1"/>
        <col align="left" span="1"/>
        <col align="center" span="1"/>
        <col align="left" span="1"/>
        <col align="left" span="1"/>
        <tbody>
        <tr><td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a></td>
        </tr>
        <tr><td rowspan="1" colspan="1">if not(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a> = <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a></td>      
        </tr>
        <tr><td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<code>empty</code>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>empty</code></td>
        </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<code>none</code>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>none</code></td>
        </tr>
        <tr><td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>) | <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
        </tr>
        </tbody>
      </table>

     </smnotation>

     <smnotation>

       <p id="jd_agg_quantifier">The function <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>
       converts the input type quantifier zero-or-more or zero-or-one
       to the result type quantifier zero-or-one, and converts the
       input type quantifier one or one-or-more, to the result type
       quantifier one.</p>

      <table summary="" role="figure">
        <col align="left" span="1"/> <col align="center" span="1"/> <col align="left" span="1"/>
        <tbody>
        <tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>?</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>?</code></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>*</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>?</code></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>1</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>1</code></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<code>+</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>1</code></td>
        </tr>
        </tbody>
      </table>
     </smnotation>

     <smtype>
       <p>Now we can define the static typing rules for the aggregate
       functions.  First, the input type is converted to a prime type.
       Second, the type function <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a> is applied
       to the prime type, yielding a new prime type, in which
       occurrences of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> are converted to
       <code>xs:double</code>.  Third, the judgment <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> is
       applied to the new prime type and target type. The result type
       is combined with the aggregate quantifier of the input
       type.</p>

       <p>For a given aggregate function, instead of writing a
       separate judgment for each target type, we write one rule using
       a target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>.</p>

       <p>For <code>fn:min</code> and <code>fn:max</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> is
       either <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      .</p>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression>
              </clause>
            </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>min</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
            <expression>...</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression>
        </clause>
       </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>min</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression>
              </clause>
            </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>max</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
            <expression>...</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression>
        </clause>
       </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>max</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <p>For <code>fn:avg</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a> is either
      <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>,
      or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      .</p>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression>
              </clause>
            </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>avg</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
            <expression>...</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>,
      <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>       }
         </expression>
        </clause>
       </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>avg</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>))
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <p>For <code>fn:sum</code>, the target type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> is either
      <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>,
      <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a>, or <a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      . The second
      argument in <code>fn:sum</code> is the value that should be returned if the
      input sequence is empty. The result type is the union of the
      target type and the type of the second argument. Note that the
      rule checks that the type for the zero value is consistent with
      the type of the input sequence.</p>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty</expression>
              </clause>
            </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:integer</code>
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> ?</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><term>convert_untypedAtomic</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>, <code>xs:double</code>)</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
               <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript>, ...,<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
            <expression>...</expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a><subscript>n</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript></expression></clause>
            </multiclause>
       <multiclause>
        <clause>
         <expression>
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_isin" class="judgment"><term>in</term></a>
          { <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a> }
         </expression>
        </clause>
       </multiclause>
          </prejudge>
          <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              (<code>FN-URI</code>,<quote><code>sum</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
              <a href="#jd_quantifier" class="judgment">·</a>
              <a href="#jd_agg_quantifier" class="judgment"><term>aggregate_quantifier</term></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>))
      	     </expression>
            </clause>
          </postjudge>
        </infer>
      </infergr>

    </smtype>

    </div3>

    <div3 id="sec_fn_remove">
      <head><phrase>The <code>fn:remove</code> function</phrase></head>

      <smtype>
        <p>The static type for the <code>fn:remove</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <specref ref="sec_factor"/>. Since one item may be removed
        from the sequence, the resulting type is made optional.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code></expression>
                </clause>
              </multiclause>
            </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  (<code>FN-URI</code>,<quote><code>remove</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a>
                  <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?
 		</expression>
 	      </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>
    </div3>

    <div3 id="sec_fn_reverse">
      <head><phrase>The <code>fn:reverse</code> function</phrase></head>

      <smtype>
        <p>The static type for the <code>fn:reverse</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <specref ref="sec_factor"/>.</p>

        <infergr>
          <infer>
            <prejudge>
            </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  (<code>FN-URI</code>,<quote><code>reverse</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
 		</expression>
 	      </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

    </div3>

    <div3 id="sec_fn_subsequence">
      <head><phrase>The <code>fn:subsequence</code> function</phrase></head>

      <smintro>
        <p>The <code>fn:subsequence</code> function has special static typing
        rules when its second argument is the numeric literal value 1
        or the built-in variable <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>.  These rules provide
        better typing for path expressions such as <emph>Expr</emph>[1] and
        <emph>Expr</emph>[<code>fn:last</code>()].</p>

        <p>The static typing rules for <code>fn:subsequence</code> depends on the
        syntactic form of their input expression. As a result, the
        corresponding static typing rules must be written directly
        over the input expression, unlike the other functions in this
        section.</p>
      </smintro>

      <smtype>

        <p>If the type of the input expression has exactly one or
        one-or-more items, then the type inferred for <code>fn:subsequence</code>
        is the prime type of the input type.</p>

	<infergr>
	  <infer>
	    <prejudge>
              <multiclause>
                 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression>
                 </clause>
              </multiclause>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                </clause>
                <clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>1</code>, <code>+</code> }</expression></clause>
              </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><emph>QName</emph>(<emph>Expr</emph>,
			 1, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>If the type of the input expression has zero or more items,
        <code>fn:subsequence</code> is applied on a numeric literal,
        <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>, or <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>, then the static type is
        zero-or-one of the prime type of the input type. Those static
        typing rules are intended to support more precise typing for
        the cases where <code>fn:subsequence</code> is the result of normalizing
        an XPath predicate of the form <emph>Expr</emph>[<emph>NumericLiteral</emph>]
        of <emph>Expr</emph>[last()], see <specref ref="id-axis-steps"/>.</p>

	<infergr>
	  <infer>
	    <prejudge>
              <multiclause>
                 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression>
                 </clause>
              </multiclause>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                </clause>
                <clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code> }</expression></clause>
              </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><emph>QName</emph>(<emph>Expr</emph>,
			 <emph>NumericLiteral</emph>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>The same rule applies when the last item in the input
        sequence is selected.</p>

	<infergr>
	  <infer>
	    <prejudge>
              <multiclause>
                 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression>
                 </clause>
              </multiclause>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                </clause>
                <clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code> }</expression></clause>
              </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><emph>QName</emph>(<emph>Expr</emph>,
			 <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>last</code></a>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>The same rule applies when an item is selected based on its
        position in the input sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
              <multiclause>
                 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression>
                 </clause>
              </multiclause>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a>
 		<a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                </clause>
                <clause><expression><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_isin" class="judgment"><term>in</term></a>
                { <code>*</code> }</expression></clause>
              </multiclause>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression><emph>QName</emph>(<emph>Expr</emph>,
			 <a href="#fs_builtin_vars"><code>$</code><emph>fs:</emph><code>position</code></a>, 1) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <code>?</code></expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>The last rule applies to all other applications of the
        <code>fn:subsequence</code> function. </p>
        <infergr>

          <infer>
            <prejudge>
              <multiclause>
                 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression><emph>QName</emph>
                   <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> (<code>FN-URI</code>,<quote><code>subsequence</code></quote>)</expression>
                 </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:double</code></expression>
                </clause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><emph>Expr</emph><subscript>2</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <code>xs:double</code></expression>
                </clause>
              </multiclause>
            </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  <emph>QName</emph>(<emph>Expr</emph>, <emph>Expr</emph><subscript>1</subscript>, <emph>Expr</emph><subscript>2</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?
 		</expression>
 	      </clause>
            </postjudge>
          </infer>
</infergr>

      </smtype>
    </div3>

    <div3 id="sec_op_union_intersect_except">
      <head><phrase>The <code>op:union</code>, <code>op:intersect</code>, and
      <code>op:except</code> operators</phrase></head>

      <smtype>
        <p>The static semantics for <code>op:union</code> is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <specref ref="sec_factor"/>.  The type of each argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        the sequence type (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>).</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>OP-URI</code>,<quote><code>union</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>The static semantics of <code>op:intersect</code> is analogous to that
        for <code>op:union</code>. Because an intersection may be empty, the
        result type is optional.</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		<clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
		        <expression>(<code>OP-URI</code>,<quote><code>intersect</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,
		        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
		        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_quantifier" class="judgment">·</a> ?</expression>
		</clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>The static semantics of <code>op:except</code> follows.  The type of
        the second argument is ignored as it does not contribute to
        the result type.  As with <code>op:intersect</code>, the result of
        <code>op:except</code> may be the empty sequence.</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>OP-URI</code>,<quote><code>except</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_quantifier" class="judgment">·</a>
			 ?</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>
      </smtype>

    </div3>   

    <div3 id="sec_fn_insert_before">
      <head><phrase>The <code>fn:insert-before</code> function</phrase></head>

      <smtype>
        <p>The static type for the <code>fn:insert-before</code> function is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <specref ref="sec_factor"/>.</p>

        <infergr>
          <infer>
            <prejudge>
              <multiclause>
                <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>xs:integer</code></expression>
                </clause>
              </multiclause>
              <multiclause>
                <clause>
                  <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> = (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>)</expression>
                </clause>
              </multiclause>
            </prejudge>
 	    <postjudge>
 	      <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
 		<expression>
                  (<code>FN-URI</code>,<quote><code>insert-before</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>)
 		</expression>
 	      </clause>
            </postjudge>
          </infer>
        </infergr>
      </smtype>

    </div3>

    <div3 id="sec_fn_cardinality_funcs">
      <head><phrase>The <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> functions</phrase></head>

      <p>The functions <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> check that the cardinality of a sequence is in
      the expected range.  They are useful to override the static type
      inferred for a given query.</p>

      <p>For example, in the following query, the user may know that
      all ISBN numbers are unique and therefore that the function
      always returns at most one book element. However, the static
      typing feature cannot infer a precise enough type and will raise
      a type error during static type analysis.</p>

<eg xml:space="preserve">
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    //book[@isbn=$isbn]
  }
</eg>

      <p>In that query, the <code>fn:zero-or-one</code> function can be used to
      tell the type system that the cardinality is known to be zero or
      one.</p>

<eg xml:space="preserve">
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    fn:zero-or-one(//book[@isbn=$isbn])
  }
</eg>

      <smtype>
        <p>The static typing rules for those functions always infer a
        type with the cardinality indicated by that function.</p>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>zero-or-one</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)?</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>one-or-more</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)+</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
	    </prejudge>
	    <postjudge>
	      <multiclause>
		 <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
			 <expression>(<code>FN-URI</code>,<quote><code>exactly-one</code></quote>)(<a href="#doc-fs-Type"><emph>Type</emph></a>)
			 <a href="#jd_has_type" class="judgment"><term>:</term></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</expression>
		 </clause>
	      </multiclause>
	    </postjudge>
	  </infer>
	</infergr>

      </smtype>
    </div3>

  </div2>

</div1>


<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
-->

     <!-- *************************** Auxiliary judgments **************** -->

<div1 id="sec_auxiliary_judgments">
  <head>Auxiliary Judgments</head>

  <p>This section defines auxiliary judgments used in defining the
  formal semantics.  Many auxiliary judgments are used in both static
  typing and dynamic evaluation rules.  Those auxiliary judgments that
  are used in only the static or dynamic semantics are labeled as
  such.</p>

  <div2 id="sec_accessing_types">
    <head>Judgments for accessing types</head>

    <smintro>
      <p>This section defines several auxiliary judgments to access
      components of the [XPath/XQuery] type system. The first two
      judgments (<a href="#jd_derives_from" class="judgment"><term>derives from</term></a> and <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a>) are used
      to access the type and element name hierarchies in an XML
      Schema. The other judgments (<a href="#jd_lookup" class="judgment"><term>name lookup</term></a>, <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a>,
      <a href="#jd_extended_by" class="judgment"><term>extended by</term></a>, <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> and <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>) are used
      to lookup the meaning of element or attribute types from the
      schema. These judgments are used in many expressions, notably in
      the specification of type matching (See <specref ref="sec_type_matching"/>), validation (See <specref ref="sec_validate"/>), and the static semantics of step
      expressions (See <specref ref="sec_auxiliary_xpath"/>).</p>
    </smintro>

    <div3 id="jd_aux_derives_from">
      <head>Derives from</head>
    
      <smnotation>
        <p id="jd_derives_from">The judgment</p>
    
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>
    
        <p>holds when <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> derives from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript>.
        This judgment formalizes the definition of the
        <code>derives-from</code> function in <xspecref spec="XQ" ref="id-sequencetype-matching"/>. </p>

      </smnotation>
    
      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg xml:space="preserve">
  USAddress            derives from  xs:anyType
  NYCAddress           derives from  USAddress
  NYCAddress           derives from  xs:anyType
  xsd:positiveInteger  derives from  xsd:integer
  xsd:integer          derives from  xs:anySimpleType
  fs:anon3             derives from  xsd:positiveInteger
  fs:anon3             derives from  xsd:integer
  fs:anon3             derives from  xs:anySimpleType
  fs:anon3             derives from  xs:anyType
</eg>

      </smexample>

      <smnote>
        <p>Derivation is a partial order. It is reflexive and
        transitive by the definition below.</p>
      </smnote>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

<!--    
        <p>Some rules have hypotheses that simply list a type,
        element, or attribute declaration.</p>
-->
 
        <p>Every type name derives from itself.</p>
    
      <infergr>
        <infer>
         <prejudge>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <p>Every type name derives from the type it is declared to
      derive from by extension or restriction.</p>
    
      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
           <expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             extends <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
           </expression>
          </clause>
         </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
         <multiclause>

          <clause>
           <expression>
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             restricts <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }
           </expression>
          </clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>The above rules all require that the type names be defined in
      the static context, but [XPath/XQuery] permits references to
      "unknown" type names, i.e., type names that are not defined in
      the static context.  An unknown type name might be encountered,
      if a module in which the given type name occurs does not import
      the schema in which the given type name is defined. In this
      case, an implementation is allowed (but is not required) to
      provide an implementation-dependent mechanism for determining
      whether the unknown type name is the same as or derived by
      restriction from the expected type name.  The following rule
      formalizes this implementation dependent mechanism.</p>

      <infergr>
        <infer>
         <prejudge>
<multiclause>
          <clause>
           <expression>
             "The implementation is able to determine that
<a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> is derived by
restriction from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript>."
           </expression>
          </clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      <p>The derivation relation is transitive.</p>
    
      <infergr>
        <infer>
         <prejudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript></expression>
          </clause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>2</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>3</subscript></expression>
          </clause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>3</subscript></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>
    
      </smrules>
    </div3>
    
    <div3 id="sec_substitutes">
      <head>Substitutes for</head>

      <p>The substitutes judgment is used to know whether an element
      name is in the substitution group of another element name.</p>
    
      <smnotation>
        <p id="jd_substitutes_for">The judgment</p>
    
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a>
          <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>
    
        <p>holds when <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> substitutes for
        <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript>.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg xml:space="preserve">
  usaddress  substitutes for  address
  nyaddress  substitutes for  usaddress
  nyaddress  substitutes for  address
</eg>
      </smexample>
    
      <smnote>
        <p>Substitution is a partial order.  It is reflexive and
        transitive by the definition below.  It is asymmetric because
        no cycles are allowed in substitution groups.</p>
      </smnote>
    
      <smrules>
        <p>The substitutes judgment for element names is specified by
        the following rules.</p>
    
        <p>Every element name substitutes for itself.</p>
    
        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Every element name substitutes for the element it is
        declared to substitute for.</p>

        <infergr>
          <infer>
           <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
         <multiclause>
            <clause>
             <expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                 define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a>
                   substitutes for <a href="#doc-fs-ElementName"><emph>BaseElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             </expression>
            </clause>
         </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>BaseElementName</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
    
        <p>Substitution is transitive.</p>
    
        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression>
            </clause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>3</subscript></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>3</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
    
    </div3>

    <div3 id="sec_element_lookup">
      <head>Element and attribute name lookup (Dynamic)</head>

      <p>The <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> judgment is used in the definition of the
      <a href="#jd_matches" class="judgment"><term>matches</term></a> judgment, which takes a value and a type and
      determines whether the value matches, or is an instance of, the
      given type.  Both <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> and <a href="#jd_matches" class="judgment"><term>matches</term></a> are used in the
      dynamic semantics. </p>

      <p>The <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> judgment takes an element(attribute) name
      (derived from a node value) and an element(attribute) type and
      if the element(attribute) name matches the corresponding name in
      the element(attribute) type, the judgment yields the type's
      corresponding type reference and for elements, its nillable
      property.</p>

      <smnotation>
        <p id="jd_lookup">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
          <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
          </clause>
        </display>

        <p>holds when the given element name matches the given element
        type and requires that the element be nillable as indicated
        and have the given type reference.</p>

      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg xml:space="preserve">
  comment    name lookup element comment                          yields of type xsd:string
  size       name lookup element size nillable of type xs:integer yields nillable of type xsd:string
  apt        name lookup element apt                              yields of type fs:anon3
  nycaddress name lookup element address                          yields of type NYCAddress
</eg>

        <p>Note that when the element name is in a substitution group,
        the name lookup returns the type name corresponding to the
        original element name (here the type <code>NYCAddress</code>
        for the element <code>nycaddress</code>, instead of
        <code>Address</code> for the element
        <code>address</code>).</p>
      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the element type is a reference to a global element,
        then name lookup yields the type reference in the element
        declaration for the given element name.  The given element
        name must be in the substitution group of the global
        element.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
          </clause>
         </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) =
                  define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript>
                    <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the given element name matches the element name in the
        element type, and the element type contains a type reference,
        then name lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name but contains a type
        reference, then name lookup yields the type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name and no type
        reference, then name lookup yields <code>xs:anyType</code>.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> element
             <a href="#jd_lookup" class="judgment"><term>yields</term></a> of type <code>xs:anyType</code></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

      <smnotation>
        <p id="jd_attribute_lookup">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
          <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
          </clause>
        </display>

        <p>holds when matching an attribute with the given attribute
        name against the given attribute type matches the type
        reference.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg xml:space="preserve">
  orderDate  name lookup  attribute orderDate of type xsd:date  yields  of type xsd:date?
  orderDate  name lookup  attribute of type xsd:date            yields  of type xsd:date?
</eg>
      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the attribute type is a reference to a global attribute,
        then name lookup yields the type reference in the attribute
        declaration for the given attribute name.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                    <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the given attribute name matches the attribute name in
        the attribute type, and the attribute type contains a type
        reference, then name lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name but contains a
        type reference, then name lookup yields the type
        reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name and no type
        reference, then name lookup yields <code>xs:anySimpleType</code>.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
             attribute <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a> of type
             <code>xs:anySimpleType</code></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

    </div3>

    <div3 id="jd_aux_static_lookup">
      <head>Element and attribute type lookup (Static)</head>

      <p>The type lookup judgments are used to obtain the
      appropriate type reference for an attribute or element.</p>

      <smnotation>
        <p id="jd_static_lookup">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
          </clause>
        </display>

        <p>holds when the element type is optionally nillable and has
        the given type reference.</p>

      </smnotation>

      <smrules>     
        <p>The element type lookup judgments are specified by the
        following rules.</p>

        <p>A reference to a global element yields the type reference
        in the global element declaration with the given element
        name.</p>

        <infergr>
          <infer>
           <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define element
                  <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                  <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In the case of a local element type, type lookup yields the
        corresponding type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name but contains a type
        reference, then type lookup yields that type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
             <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the element type has no element name and no type
        reference, then lookup yields <code>xs:anyType</code>.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> of type
             <code>xs:anyType</code></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

      <smnotation>
        <p id="jd_attribute_static_lookup">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
          </clause>
        </display>

        <p>holds when the attribute type has the  given type reference.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>A reference to a global attribute yields the type reference in
        the global attribute declaration with the given attribute name.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
                    <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

       <p>If the attribute name is not defined, i.e., it is not declared
       in the in-scope schema definitions, then the attribute's
       default type is <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

        <infergr>
          <infer>
           <prejudge>
	    <multiclause>
             <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
             </clause>
	    </multiclause>
            <multiclause>
             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) undefined
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In the case of a local attribute type, type lookup yields
        the corresponding type reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name but contains a
        type reference, then type lookup yields the type
        reference.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
             <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the attribute type has no attribute name and no type
        reference, then type lookup yields <code>xs:anySimpleType</code>.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a> of
             type <code>xs:anySimpleType</code></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     

    </div3>

    <div3 id="sec_extension">
      <head>Extension</head>

      <smnotation>

        <p id="jd_extended_by">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
        </display>

        <p>holds when the result of extending <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> by <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        is <a href="#doc-fs-Type"><emph>Type</emph></a>.  This judgment is used in the definition of type
        expansion <specref ref="sec_type_expansion"/>, which expands a
        type to include the union of all types derived from the given
        type, </p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>1</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>1</subscript></expression>
            </clause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>2</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>2</subscript></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a>
                 (<a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a><subscript>2</subscript>) , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>1</subscript> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
    </div3>


    <div3 id="sec_mixed">
      <head>Mixed content</head>

      <smnotation>
        <p id="jd_mixes_to">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>

        <p>holds when the result of creating a mixed content from
        <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> is <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rule, which
        interleaves the element content with a sequence of text nodes
        and adds a union of <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> values.  The
        <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> sequence is required because it is
        possible to derive an element containing only atomic values
        from an element that is mixed.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> , <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> , (
             <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a> &amp; text* | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a> *)</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

    </div3>

    <div3 id="sec_adjustment">
      <head>Type adjustment</head>

      <p>In the [XPath/XQuery] type system, a complex-type declaration
      does not include the implicit attributes and nodes that may be
      included in the type.  Type adjustment takes a complex type and
      adjusts it to include implicit attributes and nodes.  In
      particular, type adjustment:

      <ulist>
      <item><p>adds the four (optional) built-in attributes xsi:type,
        xsi:nil, xsi:schemaLocation, or
        xsi:noNamespaceSchemaLocation,</p>
      </item>
      <item><p>interleaves the type with a sequence of comments and
        processing-instructions, and </p></item> <item><p>if the
        complex type is mixed, interleaves the type with a sequence of
        text nodes and <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>.</p></item>
      </ulist>
      </p>

      <smnotation>
        <p id="jd_adjusts_to">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>

        <p>holds when the second type is the same as the first after
        the first has been adjusted as described above.  </p>
      </smnotation>

      <smrules>     
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is flagged as mixed, then mix the type and
        extend it by the built-in attributes.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#sec_built_in_attributes"><code>BuiltInAttributes</code></a> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> &amp;
              <code>processing-instruction*</code> &amp;
              <code>comment*</code></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>mixed <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Otherwise, just extend the type by the built-in
        attributes.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#sec_built_in_attributes"><code>BuiltInAttributes</code></a> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
            </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> &amp;
              <code>processing-instruction*</code> &amp;
              <code>comment*</code></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>
    </div3>

    <div3 id="sec_built_in_attributes">
      <head>Builtin attributes</head>

      <p>Schema defines four built-in attributes that can appear on
      any element in the document without being explicitly declared in
      the schema. Those four attributes need to be added inside
      content models when doing matching. The four built-in attributes
      of Schema are declared as follows.</p>

<eg xml:space="preserve">
  define attribute xsi:type of type xs:QName
  define attribute xsi:nil of type xs:boolean
  define attribute xsi:schemaLocation of type fs:anon
  define type fs:anon1 { xs:anyURI* }
  define attribute xsi:noNamespaceSchemaLocation of type xs:anyURI
</eg>

       <p>For convenience, a type that is an all group of the four
       built-in XML Schema attributes is defined.</p>

<eg xml:space="preserve">
  BuiltInAttributes =
      attribute xsi:type ?
    &amp; attribute xsi:nil ?
    &amp; attribute xsi:schemaLocation ?
    &amp; attribute xsi:noNamespaceSchemaLocation ?
</eg>

    </div3>

    <div3 id="sec_type_expansion">
      <head>Type expansion</head>

      <p>The <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment is one of the most important
      static judgments.  It is used in the static semantics of the
      child axis <specref ref="sec_static_axis_judge"/>, which is used
      in the definition of many other rules that extract element types
      from an arbitrary content type.</p>

      <p>The judgment takes a type name and computes the union of all
      types derived from the given type.  If the type is nillable, it
      also makes sure the content model allows the empty sequence.  If
      the type is mixed, it also adjusts the type to include the mixed
      content model.  The judgment depends on the
      <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> judgment to recursively compute all
      derived types.</p>

      <smnotation>
        <p id="jd_expands_to">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
        </display>

        <p>holds when expanding the type specifier results in the
        given type.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is nillable, then it expands into an optional
        type.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
             <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>nillable <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
             <a href="#doc-fs-Type"><emph>Type</emph></a>?</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The type definition for the type reference is contained in
        its expansion.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
            </multiclause>

            <multiclause>
            <clause>
             <expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> extends <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
             </expression>
            </clause>
            </multiclause>

            <multiclause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
             </expression></clause>
            </multiclause>

            <multiclause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
            </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In case the type is <a href="#dt-xs_untyped"><code>xs:untyped</code></a>, the type does not need to
        be adjusted as is required for other XML Schema types. See the
        corresponding definition in <specref ref="id-predefined-types"/>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
                <a href="#dt-xs_untyped"><code>xs:untyped</code></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
              </expression>
             </clause>
            </multiclause>
            <multiclause>
            <clause>
             <expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
               <a href="#dt-xs_untyped"><code>xs:untyped</code></a> extends <code>xs:anyType</code> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
             </expression>
            </clause>
            </multiclause>

           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>     
    </div3>

    <div3 id="sec_union_interpretation">
      <head>Union interpretation of derived types</head>

      <smnotation>
        <p id="jd_union_interpretation">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression>
          </clause>
        </display>

        <p>holds when the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> is the expansion of the type
        name <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> with definition <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> to include all
        types derived by extension and restriction from the given type
        name.  This rule is recursive, because each type name itself
        may have other type names that are derived from it.  The
        recursive rules traverse the entire derivation tree,
        identifying every type name derived from the original type
        name.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <infergr>
         <infer>
          <prejudge>
            <multiclause>
            <clause>
            <expression>
            <emph>No type derives from <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></emph>
            </expression>
            </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
<!-- First, the type names immediately derived by restriction -->
<multiclause>
<clause>
<expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>R,1</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,1</subscript> restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>R,1</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript> }
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>· · ·
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>R,n</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,n</subscript> restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>R,n</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript> }
</expression>
</clause>
</multiclause>

<!-- Second, the union interpretation of all the type names immediately derived by restriction -->
<multiclause>
<clause>
<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
<expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,1</subscript> 
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<expression>· · ·
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
<expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>R,n</subscript> 
</expression>
</clause>
</multiclause>

<!-- Third, all type names immediately derived by extension -->
<multiclause>
<clause>
<expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>E,1</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,1</subscript> extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>E,1</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript> }
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>· · ·
</expression>
</clause>
</multiclause>

<multiclause>
<clause>
<expression>
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>E,m</subscript>) = define type
               <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,m</subscript> extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a><subscript>E,m</subscript> {
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript> }
</expression>
</clause>
</multiclause>
<!-- Fourth, the union interpretation of all the type names immediately derived by extension -->

<multiclause>
<clause>
<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
<expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,1</subscript> 
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<expression>· · ·
</expression>
</clause>
</multiclause>
<multiclause>
<clause>
<environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
<expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript>' <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript> <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>E,m</subscript> 
</expression>
</clause>
</multiclause>

<!-- Finally, the entire type -->
<multiclause>
<clause>
<expression>
<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,1</subscript>' | · · · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>R,n</subscript>'
| <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript> | (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,1</subscript>' ) | · · · | (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>E,m</subscript>')
</expression>
</clause>
</multiclause>
           </prejudge>
           <postjudge>
            <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>0</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a><subscript>0</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

<smexamples>

  <p>Note that this expansion does not enforce the <term>unique
  particule attribution</term> property specified by XML Schema in
  the resulting content models. Implementations may want to implement
  an equivalent alternative expansion that enforces that property.
  For example, expanding type <code>T1</code> below yields the
  following type that is not one-deterministic:</p>

<eg xml:space="preserve">
define type T1 { element a }
define type T2 extends T1 { element b }

(element a | element a, element b) is (element a) extended with union interpretation of T1
</eg>

<p>An implementation might want to infer the equivalent content model
that verifies the <term>unique particule attribution</term> property of
XML Schema:</p>

<eg xml:space="preserve">
(element a, (() | element b)) is (element a) extended with union interpretation of T1
</eg>
</smexamples>

      </smrules>

    </div3>
  </div2>

  <div2 id="sec_auxiliary_xpath">
    <head>Judgments for step expressions and filtering</head>

    <smintro>
      <p>Step expressions are one of the elementary operations in
      [XPath/XQuery]. Steps select nodes reachable from the root of an XML tree.
      Defining the semantics of step expressions requires a
      detailed analysis of all the possible cases of axis and node
      tests.</p>

      <p>This section introduces auxiliary judgments used to define
      the semantics of step expressions.  The <a href="#jd_principal" class="judgment"><term>has principal</term></a> judgment
      (<specref ref="sec_jd_principal"/>) captures the notion of
      <emph>principal node kind</emph> in XPath.  The Axis judgments
      (<specref ref="sec_axis_judge"/>) define the static and dynamic
      semantics of all axes, and the Node Test judgments (<specref ref="sec_test_judge"/>) define the static and dynamic semantics
      of all node tests.  The <a href="#jd_filter" class="judgment"><term>filter</term></a> judgment accesses the value
      of an attribute and is used in the definition of validation
      (<specref ref="sec_validation_judgments"/>).</p>
    </smintro>

    <div3 id="sec_jd_principal">
      <head>Principal Node Kind</head>

      <smnotation>
        <p>The following auxiliary grammar production describes
        principal node kinds (See <bibref ref="xpath20"/>).</p>
      
        <scrap headstyle="show">
          <head>PrincipalNodeKind</head>
        
          <prod num="64 (Formal)" id="doc-fs-PrincipalNodeKind"><lhs>PrincipalNodeKind</lhs><rhs>"element"  |  "attribute"  |  "namespace"</rhs></prod>
        </scrap>

      </smnotation>

      <smnotation>
        <p id="jd_principal">The judgment</p>
      
       <display>
        <clause>
         <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a>
         <emph>PrincipalNodeKind</emph></expression>
        </clause>
       </display>
      
        <p>holds when <emph>PrincipalNodeKind</emph> is the principal node
        kind for <emph>Axis</emph>.</p>

      </smnotation>

      <smexample>
        <p>For example, the following judgments hold.</p>

<eg xml:space="preserve">
  child::       principal  element
  descendant::  principal  element
  preceding::   principal  element
  attribute::   principal  attribute
  namespace::   principal  namespace
</eg>

      </smexample>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>The principal node type for the attribute axis is
        attribute.</p>

        <infergr>
         <infer>
          <postjudge>
           <clause>
            <expression><code>attribute::</code> <a href="#jd_principal" class="judgment"><term>has principal</term></a> attribute</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <p>The principal node type for the namespace axis is
        namespace.</p>

        <infergr>
         <infer>
          <postjudge>
           <clause>
            <expression><code>namespace::</code> <a href="#jd_principal" class="judgment"><term>has principal</term></a> namespace</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

        <p>The principal node type for all other axis is element.</p>

        <infergr>
         <infer>
          <prejudge>
           <clause><expression><emph>Axis</emph> != <code>attribute::</code></expression></clause>
           <clause><expression><emph>Axis</emph> != <code>namespace::</code></expression></clause>
          </prejudge>
          <postjudge>
           <clause>
            <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a> element</expression>
           </clause>
          </postjudge>
         </infer>
        </infergr>

      </smrules>

    </div3>

    <div3 id="sec_axis_judge">
      <head>Auxiliary judgments for axes</head>

      <div4 id="sec_static_axis_judge">
        <head>Static semantics of axes</head>

        <smnotation>
          <p id="jd_axis_type">The following judgment</p>

          <display>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
            </expression>
           </clause>
          </display>

          <p>holds when applying the axis <emph>Axis</emph> on type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          yields the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>

          <p id="jd_has_element_content">The following two judgments are used
          in the definition of <a href="#jd_axis_type" class="judgment"><term>axis</term></a>.  The judgment</p>

          <display>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
            </expression>
           </clause>
          </display>

          <p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> has the content type
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.  The judgment separates the attribute types from
          the other node or atomic-valued types of the element content type
          and yields the non-attribute types.</p>

          <p id="jd_has_attribute_content">The judgment</p>

          <display>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
            </expression>
           </clause>
          </display>

          <p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> has attribute types
          <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.  The judgment yields the attribute types of
          the element content type.</p>
        </smnotation>

        <smexample>
          <p>For example, the following judgments hold.</p>

<eg xml:space="preserve">
  axis child::      of  element of type xs:string   :  text
  axis child::      of  element items of type Items :  element item of type fs:anon1*

  axis child::      of  element purchaseOrder       : 
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items

  axis attribute::  of  element of type xs:string   :  empty

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-node-content
    element item of type fs:anon1*

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-attribute-content
    attribute partNum of type SKU

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-node-content
    (element item of type fs:anon1*) |
    (element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-attribute-content
    (attribute partNum of type SKU) |
    (attribute orderDate of type xs:date?)
</eg>
        </smexample>

    <div5 id="sec_inference_axis">
      <head>Inference rules for all axes</head>
        <smrules>
          <p>The following rules compute the type of the axis
          expression when applied to each item type in the content
          model.</p>

         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <emph>OccurrenceIndicator</emph>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <emph>OccurrenceIndicator</emph>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>&amp;<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>&amp;<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>  </expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> none <a href="#jd_axis_type" class="judgment"><term>:</term></a> none
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>  </expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <code>empty</code> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

         <p>The rules in the following subsections specify how to
         compute the type of each axis applied to an item type.</p>

      </smrules>
    </div5>
    <div5 id="sec_inference_self"><head>Inference rules for the <code>self</code> axis</head>
      <smrules>

         <p>Applying the self axis to a node type results in the same
         node type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	           <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	           <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	           <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_child"><head>Inference rules for the <code>child</code> axis</head>
      <smrules>

         <p>In the case of an element type, the static type of the
         child axis is obtained by type lookup and expansion of the
         resulting type.  Note that the <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment
         yields the type that corresponds to a given type name.
         Because the meaning of a type name includes the definitions
         of <emph>all</emph> type names derived by extension and
         restriction from the given type name, <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> yields
         the <emph>union</emph> of all the type definitions of all
         type names derived from the input type name.  Each type in
         the union contains the complete definition of the type name,
         i.e., it includes built-in attributes and, if necessary,
         processing-instruction, comment, and text types.</p>

         <p>After type expansion, the judgment
         <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> is applied to each type in the
         union.  The resulting type is the union of all non-attribute
         types in the expanded type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
                <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | · ·
                  · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
· · · 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>' 
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>If the type is a sequence of attributes, then the content
         type is <code>empty</code>.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>If the type is attributes followed by a simple type, the
         content type is zero-or-one text nodes.  The resulting type
         is optional since an expression returning the empty sequence
         results in no text node being constructed.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
                   <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> text? 
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of an element type with complex content type,
         the content type is simply the non-attribute part of the
         complex content type.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> 
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of an attribute type, the static type of the
         child axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a text node type, the static type of the child
         axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a> text
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a comment node type, the static type of the child
         axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In the case of a processing-instruction node type, the
         static type of the child axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a document node type, the static type of the
         child axis is the type of the document node content,
         interleaved with a sequence of comments and
         processing-instructions.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> &amp;
	               processing-instruction* &amp; comment*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_attribute">
      <head>Inference rules for the <code>attribute</code> axis</head>
      <smrules>

         <p>The static type for the attribute axis is computed in a
         similar way as the static type for the child axis.  As above,
         the <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> judgment may yield a union type.  After
         type expansion, the judgment <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> is
         applied to each type in the union.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> 
                <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
                <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
                  <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | · ·
                  · | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>'
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <expression>
· · · 
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
                </expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' | ... | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>'
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>When applied to an element type,
         <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> yields the type of the element's
         content that are attributes.</p>

	 <infergr>
	   <infer>
	     <prejudge>
              <multiclause>
               <clause>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a> = (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
                attribute*
                </expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>* | <a href="#dt-xs_anyAtomicType"><code>xs:anyAtomicType</code></a>*</expression>
               </clause>
              </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of an attribute type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a text node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> text <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a comment node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a processing-instruction node type, the static type of the
         attribute axis is empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>In case of a document node type, the static type of the
         attribute axis is the empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_parent"><head>Inference rules for the <code>parent</code> axis</head>
      <smrules>

         <p>The type for the parent of an element type, a text node
         type, a PI node type, or a comment node type is either an
         element, a document, or empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> element <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> text <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> (element | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> comment <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element | document)?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>The type for the parent of an attribute node is an
         element or empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> element?
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>The type for the parent of a document node type is always
         empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_namespace"><head>Inference rules for the <code>namespace</code> axis</head>
      <smrules>

         <p>The type for the namespace axis is always empty.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>namespace::</code>
	               <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
	               <a href="#jd_axis_type" class="judgment"><term>:</term></a> <code>empty</code>
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_descendant"><head>Inference rules for the <code>descendant</code> axis</head>
      <smrules>

         <p>The types for the descendant axis is obtained as the
         closure of the type of the child axis. This is expressed by
         the following inference rule.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause>
                   <expression>...</expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <smnote>
           <p>Note that the last premise in the above rule 
           terminates the recursion. The rule computes the n-th
           type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> such that applying the child axis one more
           time does not add any new item type to the union. This
           condition is guaranteed to hold at some point, because the
           number of item types is bounded by all of the item types
           defined in the in-scope schema definitions.</p>
         </smnote>

      </smrules>
    </div5>
    <div5 id="sec_inference_descendant_of_self"><head>Inference rules for the <code>descendant-or-self</code> axis</head>
      <smrules>

         <p>The type for the descendant-or-self axis is the union of
         the type for the self axis and for the descendant axis.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>descendant-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_ancestor"><head>Inference rules for the <code>ancestor</code> axis</head>
      <smrules>

         <p>The type for the ancestor axis is computed similarly as
         for the descendant axis.</p>

	 <infergr>
	   <infer>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
	               <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis_type" class="judgment"><term>of</term></a>
	               <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_axis_type" class="judgment"><term>:</term></a>
	               (element | document)*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

         <p>Note that this rule will always result in the type
         <code>(element | document)*</code> type, but this formulation
         is preferred for consistency, and in case the static typing
         for the parent axis gets improved in a future version.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause>
                   <expression>...</expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript> </expression>
	         </clause>
	       </multiclause>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n+1</subscript>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>

      </smrules>
    </div5>
    <div5 id="sec_inference_ancestor_of_self"><head>Inference rules for the <code>ancestor-or-self</code> axis</head>
      <smrules>

         <p>The type for the ancestor-or-self axis is the union of the
         type for the self axis and for the ancestor axis.</p>

	 <infergr>
	   <infer>
	     <prejudge>
	       <multiclause>
	         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                   <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
	         </clause>
	       </multiclause>
	     </prejudge>
	     <postjudge>
	       <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
	         <expression>
                   <a href="#jd_axis_type" class="judgment"><term>axis</term></a> <code>ancestor-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
                   <a href="#jd_axis_type" class="judgment"><term>:</term></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>))*
	         </expression>
	       </clause>
	     </postjudge>
	   </infer>
	 </infergr>
        </smrules>
    </div5>
      </div4>

      <div4 id="sec_dyn_axes">
        <head>Dynamic semantics of axes</head>

        <smnotation>
          <p id="jd_axis">The following judgment</p>
          <display>
           <clause>
            <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression>
             <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
            </expression>
           </clause>
          </display>
     
          <p>holds when applying the axis <emph>Axis</emph> on <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
          yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>:</p>
    
        </smnotation>

        <smexample>
          <p>For example, the following judgments hold.</p>

<eg xml:space="preserve">
  axis child::      of    element sizes { text { "1 2 3" } }  =&gt;  text { "1 2 3" }

  axis attribute::  of
     element weight of type xs:integer {
       attribute xsi:type of type xs:QName {
         "xs:integer" of type xs:QName
       },
       42 of type xs:integer
     }
  =&gt; attribute xsi:type of type xs:QName {
       "xs:integer" of type xs:QName
     }

  
</eg>
        </smexample>

        <smrules>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules are used to process the axis
          judgment on each individual item in the input sequence.</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> () <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression>
                <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
                <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression>
                <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
                <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The following rules specifies how the value filter
          judgment is applied on each Axis.</p>

          <p>The self axis just returns the context node.</p>

          <infergr>
            <infer>
              <prejudge>
              </prejudge>
              <postjudge>
                <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
                  <expression>
                    <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
                    <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
                  </expression>
                </clause>
              </postjudge>
            </infer>
          </infergr>

          <p>The child, parent, attribute and namespace axis are
          specified as follows.</p>

          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code> child::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> element
               <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> { <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>,<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> } <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>attribute::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> {
               <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>,<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> }
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <emph>dm:</emph>parent(<a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>)
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The descendant, descendant-or-self, ancestor, and
          ancestor-or-self axis are implemented through recursive
          application of the children and parent filters.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>child::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>descendant-or-self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment> <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <code> ancestor::</code> <a href="#jd_axis" class="judgment"><term>of</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_axis" class="judgment"><term>axis</term></a> <code>ancestor-or-self::</code> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_axis" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

<!--

MFF: sibling and preceding and following axes are normalized away.


          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; false
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> descendant-or-self::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_root;(&gr_NodeValue;) &jd_yields; &gr_NodeValue1;
               </expression>
              </clause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &fn_nodeequal;(&gr_NodeValue;, &gr_NodeValue1;) &jd_yields; true
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following::</code> or
               <code>preceding::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_before; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>preceding-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_NodeValue1;
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&jd_axis; <code> child::</code> &jd_axis_of;
               &gr_NodeValue1; &jd_axis_arrow;
               &gr_Value1; </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment>
               <expression>&gr_Value1; &jd_node_after; &gr_NodeValue;
               &jd_yields; &gr_Value2; </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; <code>following-sibling::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; &gr_Value2;
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment>&xq_dyn_env;</environment> <expression>
               &jd_axis; <code>parent::</code> &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment>&xq_dyn_env;</environment>
              <expression>
               &jd_axis; (<code>following-sibling::</code>
               or <code>preceding-sibling::</code>) &jd_axis_of; &gr_NodeValue;
               &jd_axis_arrow; ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
-->

          <p>In all the other cases, the axis application results in
          an empty sequence, and the following judgment holds.</p>

          <display>
           <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
            <expression>
             <a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
             <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> ()
            </expression>
           </clause>
          </display>

         </smrules>
      </div4>

    </div3>

    <div3 id="sec_test_judge">
      <head>Auxiliary judgments for node tests</head>

      <p>A node test may be a name test or a kind test.  In the static
      and dynamic semantics, we begin with name tests, followed by
      kind tests. </p>

      <div4 id="sec_sem_node_tests">
        <head>Static semantics of node tests</head>

        <smnotation>
          <p id="jd_test_type">The following judgment</p>

          <display>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
            </expression>
           </clause>
          </display>

          <p>holds when applying the node test <emph>NodeTest</emph> on the
          type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> in the context of the given principal node
          kind, yields the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>

        </smnotation>

        <smexample>
          <p>For example, assuming the extended XML Schema given in
          section <specref ref="sec_types_example"/>, then the
          following judgments hold.</p>

<eg xml:space="preserve">
  test shipTo with element of
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items
  : element shipTo of type USAddress
</eg>
        </smexample>

        <smrules>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules is similar to that for axes, and
          are used to process the content each individual item type in
          the input content model.</p>
     
         <infergr>
          <infer>
            <prejudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             </expression>
             </clause>
           </prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <emph>OccurrenceIndicator</emph>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <emph>OccurrenceIndicator</emph>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

<!-- T1 & T2 -->
         <infergr>
          <infer>
<prejudge>
<multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression>
</clause>
</multiclause>
<multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
</clause>
</multiclause>
</prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> 
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

<!-- T1 , T2 -->
         <infergr>
          <infer>
<prejudge>
<multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression>
</clause>
</multiclause>
<multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
</clause>
</multiclause>
</prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript> 
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>


         <infergr> 
          <infer>
           <prejudge>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
             </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment> <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
              </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
              <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>4</subscript>
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>

         <infergr>
          <infer>
           <prejudge>
             <clause><expression>  </expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> none
              <a href="#jd_test_type" class="judgment"><term>:</term></a> none
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
     
         <infergr>
          <infer>
           <prejudge>
             <clause><expression>  </expression></clause>
           </prejudge>
           <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
              <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
              <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> empty
              <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
             </expression>
            </clause>
           </postjudge>
          </infer>
         </infergr>
        </smrules>

      <p>The following rules specify how the test judgment apply to
      node tests in the context of a principal node kind.  We start
      with name tests followed by kind tests.</p>

    <div5 id="sec_sem_name_tests">
      <head>Name Tests</head>

      <p>Name tests on elements and attributes always compute the most
      specific type possible. For example, if <code>$v</code> is bound
      to an element with a computed name, the type of <code>$v</code>
      is <code>element</code>. The static type computed for the
      expression <code>$v/self::foo</code> is <code>element foo of
      type xs:anyType</code>, which makes use of <code>foo</code> in
      the name test to compute a more specific type.  Also note that
      each case of name matching restricts the principal node kind
      appropriately.</p>

         <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>2</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> </expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      
        <infergr>
         <infer>
          <prejudge>
          </prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             element <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <code>*</code> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element <emph>QName</emph><subscript>2</subscript>
             <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript> <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>
      
     <infergr>
         <infer>
          <prejudge>
            <multiclause>
             <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
             </clause>
            </multiclause>
           <multiclause>
             <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause>
           </multiclause>
            <multiclause>
           <clause><expression><emph>LocalPart</emph><subscript>2</subscript> = <code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> )</expression></clause>
            </multiclause>
          </prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>
      
     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element * <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <code>*:</code><emph>LocalPart</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>

         <infer>
          <prejudge>
            <multiclause>
             <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
             </clause>
            </multiclause>
           <multiclause>
             <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>1</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause>
           </multiclause>
          </prejudge>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript>:*
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> element
             <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>
      
     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element * <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>Prefix</emph><subscript>2</subscript><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

     <infergr>
         <infer>
          <postjudge>
           <clause>
            <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression>
             <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*</code>
             <a href="#jd_test_type" class="judgment"><term>with</term></a> element
             <a href="#jd_test_type" class="judgment"><term>of</term></a> element
             <emph>QName</emph> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a>
             element <emph>QName</emph> <a href="#doc-fs-OptTypeSpecifier"><emph>OptTypeSpecifier</emph></a>
            </expression>
           </clause>
          </postjudge>
         </infer>
     </infergr>

     <p>Similar static typing rules apply to the attribute name
     tests:</p>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
         <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
         </clause>
        </multiclause>
        <multiclause>
         <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>2</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
         </clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>
      
     <infergr>
      <infer>
       <prejudge>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <code>*</code> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>
      
     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>QName</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <prejudge>
        <multiclause>
         <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
         </clause>
        </multiclause>
        <multiclause>
        <clause><expression><code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript> ) = <emph>LocalPart</emph><subscript>2</subscript></expression></clause>
        </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph><subscript>2</subscript>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute * <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <code>*:</code><emph>LocalPart</emph><subscript>2</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>  

     <infergr>
      <infer>
       <prejudge>
           <multiclause>
             <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph><subscript>2</subscript>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
             </clause>
           </multiclause>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <emph>QName</emph><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
          </clause>
         </multiclause>
           <multiclause>
            <clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = <emph>AnyURI</emph></expression></clause>
           </multiclause>
       </prejudge>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>QName</emph><subscript>1</subscript> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>Prefix</emph><subscript>2</subscript><code>:*</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute * <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute
          <emph>Prefix</emph><subscript>2</subscript><code>:*</code> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>
      
     <infergr>
      <infer>
       <postjudge>
        <clause>
         <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>*</code> <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
          <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <emph>QName</emph> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
          <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute <emph>QName</emph> <a href="#doc-fs-OptTypeReference"><emph>OptTypeReference</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr> 

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> = <emph>NameTest</emph></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> = of type <code>xs:anyType</code></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NameTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

      </div5>

<div5 id="sec_sem_kind_tests">
  <head>Kind Tests</head>

    <p>All the rules for typing the document, element, and attribute
    kind tests are similar.  First, the document, element, or
    attribute test is normalized to the equivalent document, element,
    or attribute type by applying the <map/><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
    normalization rule to the kind test.</p>

    <p>After normalization of the kind test as an XQuery type, that
    type is compared to the expression's inferred type. If the latter
    is a subtype of the former other, then the kind test yields the
    smaller type.</p>

    <p><b><emph>Document kind test</emph></b></p>

    <smrules>
      <p>If the type of the expression is a subtype of the document
      kind test, then we are guaranteed that during evaluation, the
      expression's value will always match the document kind test, and
      therefore the type of the entire expression is the type of the
      input expression.</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
            = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression>
           <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
           <a href="#jd_test_type" class="judgment"><term>with</term></a> element
           <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
           <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
          </expression>
         </clause>
        </postjudge>
       </infer>
      </infergr>

      <p>Conversely, if the type of the document kind test is a
      subtype of the expression, then during evaluation, the
      expression's value may or may not match the document kind test,
      and therefore the type of the entire expression is zero-or-one
      of the type of the document kind test. </p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
            = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression>
           <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
           <a href="#jd_test_type" class="judgment"><term>with</term></a> element
           <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
           <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>?
          </expression>
         </clause>
        </postjudge>
       </infer>
      </infergr>

      <p>If the types of the expression and document kind test are
      unrelated, then we apply the kind test rule recursively on the
      element types, which may yield a non-empty type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>document-node (<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
               </expression>
              </clause>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression>
                <a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code>)
               </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> document-node (<emph>ElementTest</emph>)
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
               <a href="#jd_test_type" class="judgment"><term>:</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> }
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If there is no non-empty type, then the kind test yields
          the empty type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map>document-node (<emph>ElementTest</emph>)</map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a>  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <code>empty</code></expression></clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> document-node (<emph>ElementTest</emph>)
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> }
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Element kind test</emph></b></p>

        <smrules>
     <p>The rules for the element kind test are similar to those for
     the document kind test.</p> <p>If the type of the expression is a
     subtype of the element kind test, then we are guaranteed that
     during evaluation, the expression's element value will always
     match the element kind test, and therefore the type of the entire
     expression is the type of the input expression.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Conversely, if the type of the element kind test is a
          subtype of the expression, then during evaluation, the
          expression's element value may or may not match the element
          kind test, and therefore the type of the entire expression
          is zero-or-one of the type of the element kind test. </p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>?
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the types of the expression and element kind test are
          unrelated (i.e., neither type is a subtype of the other),
          then we must compare the structure of the type of the
          element test with the type of the element expression, as an
          element type or test may contain wildcards.</p>

          <p>In the first case, the element kind test contains an
          element name and a type name and the input expression's type
          contains only a type name.  If the input expression's
          content type is a subtype of the element kind test's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the input expression's
          content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression>
              </clause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an element
          name and a type name and the element kind test's type
          contains only a type name.  If the element kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the element kind
          test's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression>
              </clause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript>)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> element
               <a href="#jd_test_type" class="judgment"><term>of</term></a> element <a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Attribute kind test</emph></b></p>

        <smrules>
     <p>The rules for the attribute kind test are isomorphic to those
     for element kind test.</p> <p>If the type of the expression is a
     subtype of the attribute kind test, then we are guaranteed that
     during evaluation, the expression's attribute value will always
     match the attribute kind test, and therefore the type of the
     entire expression is the type of the input expression.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Conversely, if the type of the attribute kind test is a
          subtype of the expression, then during evaluation, the
          expression's attribute value may or may not match the
          attribute kind test, and therefore the type of the entire
          expression is zero-or-one of the type of the attribute kind
          test. </p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> 
               <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>?
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If the types of the expression and attribute kind test
          are unrelated (i.e., neither type is a subtype of the
          other), then we must compare the structure of the type of
          the attribute test with the type of the attribute
          expression, as an attribute type or test may contain
          wildcards.</p>

          <p>In the first case, the attribute kind test contains an
          attribute name and a type name and the input expression's
          type contains only a type name.  If the input expression's
          content type is a subtype of the attribute kind test's
          content type, then the type of the entire expression is
          zero-or-one of an attribute with the given name and the
          input expression's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression>
              </clause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>In the second case, the structure of the input types is
          reversed: The input expression's type contains an attribute
          name and a type name and the attribute kind test's type
          contains only a type name.  If the attribute kind test's
          content type is a subtype of the input expression's content
          type, then the type of the entire expression is zero-or-one
          of an attribute with the given name and the attribute kind
          test's content type.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression>
              </clause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript>? 
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript>
               <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
               <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>)
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
               <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test_type" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test_type" class="judgment"><term>of</term></a> attribute <a href="#doc-fs-AttributeNameOrWildcard"><emph>AttributeName</emph></a><subscript>2</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>2</subscript>
               <a href="#jd_test_type" class="judgment"><term>:</term></a> empty
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

     <p><b><emph>Processing instruction, comment, and text kind
     tests</emph></b></p>

     <smrules>
     <infergr>
      <infer>
       <postjudge>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> 
          <code>processing-instruction()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> processing-instruction
          <a href="#jd_test_type" class="judgment"><term>:</term></a> processing-instruction
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <p>A processing-instruction node test with a string
     literal or NCName matches a processing instruction whose target
     has the given name.  Since target matching cannot be checked
     statically, the static type of the node test is zero-or-one
     processing instruction.</p>
     <infergr>
      <infer>
       <postjudge>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a>
          <code>processing-instruction(</code><emph>StringLiteral</emph> | <emph>NCName</emph><code>)</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> processing-instruction
          <a href="#jd_test_type" class="judgment"><term>:</term></a> processing-instruction?
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>comment()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> comment <a href="#jd_test_type" class="judgment"><term>:</term></a>
          comment
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>text()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a> text <a href="#jd_test_type" class="judgment"><term>:</term></a> text
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

     <infergr>
      <infer>
       <postjudge>
        <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
         <expression>
          <a href="#jd_test_type" class="judgment"><term>test</term></a> <code>node()</code>
          <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
          <a href="#jd_test_type" class="judgment"><term>of</term></a>
          <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-NodeType"><emph>NodeType</emph></a>
         </expression>
        </clause>
       </postjudge>
      </infer>
     </infergr>

          <p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>Otherwise</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
       <a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph>
       <a href="#jd_test_type" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
       <a href="#jd_test_type" class="judgment"><term>of</term></a>
       <a href="#doc-fs-NodeType"><emph>NodeType</emph></a> <a href="#jd_test_type" class="judgment"><term>:</term></a> <code>empty</code>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     </smrules>
      </div5>

    </div4>

    <div4 id="sec_dyn_node_tests">
      <head>Dynamic semantics of node tests</head>

      <smnotation>
        <p id="jd_test">The following judgment</p>
        <display>
         <clause>
          <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
          <expression>
           <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
           <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          </expression>
         </clause>
        </display>
     
        <p>holds when applying the node test <emph>NodeTest</emph> on
        <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> in the context of the <emph>PrincipalNodeKind</emph>
        yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>:</p>
      </smnotation>
    
      <smexample>
        <p>For example, the following judgments hold.</p>

<eg xml:space="preserve">
  test node()  with element  of    text { "1 2 3" }  =&gt; text { "1 2 3" }
  test size    with element  of    text { "1 2 3" }  =&gt; ()

  test foo:*   with element  of
     (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      element bar:b of type xs:int { 3 },
      element bar:c of type xs:int { 4 },
      element foo:d of type xs:int { 5 })
  =&gt; (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      (),
      (),
      element foo:d of type xs:int { 5 })
</eg>
      </smexample>

      <smnote>
        <p>The last example illustrates how a test judgment operates
        on a sequence of nodes, applying the test on each node in the
        sequence individually, while preserving the structure of the
        sequence.</p>
      </smnote>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>The first set of rules are similar to those for axes, and
        are used to process the test judgment on each individual item
        in the input sequence.</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> () <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression>
                <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>
               </expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
               <expression>
                <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
               </expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
             <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
             <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>4</subscript>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>

      <div5 id="sec_dyn_sem_name_tests">
        <head>Name Tests</head>

        <p>The following rules specify how the value filter judgment
        is applied on a name test in the context of a principal node
        kind.</p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:node-name</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
             </multiclause>
           <multiclause>
             <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>AnyURI</emph></expression></clause>
           </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>LocalPart</emph>
               </expression>
              </clause>
             </multiclause>

            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>Prefix</emph>:<emph>LocalPart</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>*</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
               <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
             </multiclause>
           <multiclause>
             <clause>
             <expression><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<emph>Prefix</emph>) = (<a href="#xq_ns_env"><emph>NamespaceKind</emph></a>,<emph>AnyURI</emph>)</expression>
             </clause>
           </multiclause>
           <multiclause>
            <clause><expression><code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = <emph>AnyURI</emph></expression></clause>
           </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>Prefix</emph><code>:*</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code>( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <emph>PrincipalNodeKind</emph></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>LocalPart</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>*:</code><emph>LocalPart</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>
      </div5>     

      <div5 id="sec_dyn_kind_tests">
        <head>Kind Tests</head>

        <p>All the rules for evaluating the document, element, and
        attribute kind tests are similar.  First, the document,
        element, or attribute test is normalized to the equivalent
        document, element, or attribute type by applying the
        <map/><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a> normalization rule.  As
        explained in <specref ref="id-sequencetype"/>, SequenceTypes
        are normalized to XQuery types whenever a dynamic evaluation
        or static typing rule requires the corresponding type. The
        reason for this deviation from the processing model is that
        the result of SequenceType normalization is not part of the
        [XPath/XQuery] core syntax.</p>

        <p>After normalization of the SequenceType to an XQuery type,
        the document, element, or attribute value is simply matched
        against the XQuery type.  If the value matches the type, then
        the judgment yields the value, otherwise the judgment yields
        the empty sequence.</p>

        <p><b><emph>Document kind test</emph></b></p>   

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>DocumentTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-DocumentType"><emph>DocumentType</emph></a>)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>DocumentTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-DocumentValue"><emph>DocumentValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Element kind test</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>ElementTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>ElementTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> element
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-ElementValue"><emph>ElementValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Attribute kind test</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><map><emph>AttributeTest</emph></map><a href="#jd_map_sequencetype" class="judgment"><subscript>sequencetype</subscript></a>
                = <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a>)</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>AttributeTest</emph>
               <a href="#jd_test" class="judgment"><term>with</term></a> attribute
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-AttributeValue"><emph>AttributeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>     

        <p><b><emph>Processing instruction, comment, and text kind
        tests</emph></b></p>

        <smrules>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction"</expression>
              </clause>
             </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
              </clause>
             </multiclause>
 	     <multiclause>
 	       <clause>
               <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
 	       <expression><emph>StringLiteral</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <emph>String</emph>
 	       </expression>
 	       </clause>
 	     </multiclause>
             <multiclause>
              <clause>
               <expression><code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> ) = <emph>String</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction(</code> <emph>StringLiteral</emph> <code>)</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "processing-instruction")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "comment"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "comment")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
     
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "text"</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><a href="#jd_not" class="judgment"><term>not</term></a>(<emph>dm:</emph><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> ) = "text")</expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>The <code>node()</code> node test is true for all
          nodes. Therefore, the following rule does not have any
          precondition (remember that an empty upper part in the rule
          indicates that the rule is always true).</p>
     
          <infergr>
           <infer>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <code>node()</code>
               <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a>
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>

          <p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p>
          
          <infergr>
           <infer>
            <prejudge>
             <multiclause>
              <clause>
               <expression><emph>Otherwise</emph></expression>
              </clause>
             </multiclause>
            </prejudge>
            <postjudge>
             <clause><environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression>
               <a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph>
                 <a href="#jd_test" class="judgment"><term>with</term></a> <emph>PrincipalNodeKind</emph>
               <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-NodeValue"><emph>NodeValue</emph></a> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> ()
              </expression>
             </clause>
            </postjudge>
           </infer>
          </infergr>
        </smrules>
       </div5>
      </div4>
    </div3>


  </div2>

  <div2 id="sec_type_matching">
    <head>Judgments for type matching</head>

    <smintro>
      <p>XQuery supports type declarations on variable bindings, and
      several operations on types (<code>typeswitch</code>,
      <code>instance of</code>, etc). This section describes judgments
      used for the specification of the semantics of those
      operations.</p>

      <ulist>
        <item>
          <p>The <quote>match</quote> judgment specifies formally type
          matching. It takes as input a value and a type and either
          succeeds or fails. It is used in matching parameters against
          function signatures, type declarations, and matching values
          against cases in <quote>typeswitch</quote>. An informal
          description of type matching is given in <xspecref spec="XQ" ref="id-sequencetype-matching"/>.</p>
        </item>
        <item>
          <p>The <quote>subtyping</quote> judgment takes two types and
          succeeds if all values matching the first type also match
          the second. It is used to define the static semantics of
          operations using type matching.</p>
        </item>
      </ulist>
  
    </smintro>

    <div3 id="sec_matches">
      <head>Matches</head>

      <smnotation>
        <p id="jd_matches">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
        </display>

        <p>holds when the given value matches the given type.</p>
      </smnotation>

      <smexample>
        <p>For example, assuming the extended XML Schema given in
        section <specref ref="sec_types_example"/>, then the following
        judgments hold.</p>

<eg xml:space="preserve">
  element comment of type xsd:string { "This is not important" }
    matches
  element comment of type xsd:string

  (element apt of type fs:anon3 { 2510 },
   element apt of type fs:anon3 { 2511 })
    matches
  element apt+

  ()
    matches
  element usaddress?

  element usaddress of type USAddress {
    element name of type xsd:string { "The Archive" },
    element street of type xsd:string { "Christopher Street" },
    element city of type xsd:string { "New York" },
    element state of type xsd:string { "NY" },
    element zip of type xsd:decimal { 10210 }
  }
    matches
  element usaddress?
</eg>
      </smexample>

      <smrules>

       <p>We start by giving the inference rules for matching an
        item value with an item type.</p>

        <p>An atomic value matches an atomic type if its <xtermref spec="XQ" ref="dt-type-annotation"/> derives from the atomic
        type.  The value itself is ignored -- this is checked as part
        of validation.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a> of type <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A text node matches text.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>text { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> text</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A comment node matches comment.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>comment { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> comment</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A processing-instruction node matches processing-instruction.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>processing-instruction <emph>NCName</emph> { <emph>String</emph> } <a href="#jd_matches" class="judgment"><term>matches</term></a> processing-instruction</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A document node matches a document type if the node's
        content matches the document type's corresponding content
        type.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression> <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
             </expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>document { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The rules for matching an element value with an element
        type are more complicated.  When an element value is not
        nilled, the element matches an element type if the element
        name and the element type resolve to some type name, and the
        element value's <xtermref spec="XQ" ref="dt-type-annotation"/>
        is derived from the resolved type name.  Note that there is no
        need to check structural constraints on the value since those
        have been checked during XML Schema validation and the value
        is assumed to be consistent with its <xtermref spec="XQ" ref="dt-type-annotation"/>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> of
              type <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (), false }</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <smnote>
          <p>Type matching uses the name lookup judgment defined in
          <specref ref="sec_element_lookup"/>.</p>
        </smnote>

        <p>In the case the element has been nilled, that is there
        exists and xsi:nil attribute set to true in the element value,
        the following rule checks that the type is nillable. </p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> nillable of type
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> true</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-ElementType"><emph>ElementType</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The rule for attributes is similar, but does not require
        the check for the xsi:nil attribute.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a> of type
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> } <a href="#jd_matches" class="judgment"><term>matches</term></a>
             <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>A type can also be a sequence of items, in that case the
        matching rules also need to check whether the constraints
        described by the type as a regular expression hold. This is
        specified by the following rules.</p>

        <p>The empty sequence matches the empty sequence type.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>() <a href="#jd_matches" class="judgment"><term>matches</term></a> <code>empty</code></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If two values match two types, then their sequence matches
        the corresponding sequence type.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If a value matches a type, then it also matches a choice
        type where that type is one of the choices.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If two values match two types, then their interleaving
        matches the corresponding all group.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp;
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>An optional type matches a value of that type or the empty
        sequence.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a>
              (<a href="#doc-fs-Type"><emph>Type</emph></a> | empty)</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>?</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The following rules are used to match a value against a
        sequence of zero (or one) or more types.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>() <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>, <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>+</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

      <smnote>
        <p>The above definition of type matching, although complete
        and precise, does not give a simple means to
        <emph>compute</emph> type matching. Notably, some of the above
        rules can be non-deterministic (e.g., the rule for matching of
        choice or repetition).</p>

        <p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing type
        matching then is equivalent to check if a given sequence of
        items is <emph>recognized</emph> by its corresponding finite
        state automata. Finite state automata and their relationships
        to regular expressions have been extensively studied and
        documented in computer-science literature. The interested reader can
        consult the relevant literature, for instance <bibref ref="Languages"/>, or <bibref ref="TATA"/>.</p>
      </smnote>
    </div3>

    <div3 id="sec_subtyping">
      <head>Subtyping (&lt;:)</head>

      <smintro>
        <p>This section defines the semantics of subtyping in
        [XPath/XQuery]. Subtyping is used during static type analysis, in
        typeswitch, treat and assert expressions, and to check the
        correctness of function applications.</p>

        <p>Note that intuitive relationships between types. For
        instance, that (<a href="#doc-fs-Type"><emph>Type</emph></a>,()) is equivalent to <a href="#doc-fs-Type"><emph>Type</emph></a> can
        be deduced using the subtyping judgment (and algorithm)
        described here.</p>
      </smintro>

      <smnotation>
        <p id="jd_subtype_of">The judgment</p>
      
        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>
      
        <p>holds if the first type is a subtype of the second.</p>
      </smnotation>

      <smrules>
        <p>This judgment is true if and only if, for every value
        <a href="#doc-fs-Value"><emph>Value</emph></a>, if <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> holds, then
        <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> also holds.</p>
      </smrules>
  
      <smnote>
        <p>It is easy to see that the subtype relation <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a>
        is a partial order, i.e. it is <term>reflexive</term>:</p>
  
        <clause>
          <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
          </expression>
        </clause>
  
        <p>and it is <term>transitive</term>: if,</p>
  
        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression>
        </clause>
  
        <p>and,</p>
  
        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
          </expression>
        </clause>
  
        <p>then,</p>
  
        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
          </expression>
        </clause>

        <p>Finally, two types are equal if each is a subtype of the
        other, that is: </p>

        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression>
        </clause>
  
        <p>and,</p>
  
        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          </expression>
        </clause>
  
        <p>then,</p>
  
        <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
          <expression>
            <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
          </expression>
        </clause>

      </smnote>

      <smnote>
        <p>The above definition, although complete and precise, does
        not give a simple means to <emph>compute</emph>
        subtyping. Notably the definition above refers to values,
        which are not available at static type checking time.</p>

        <p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing
        subtyping between two types can then be done by computing if
        <emph>inclusion</emph> holds between their corresponding
        finite state automata.</p>
    
        <p>Finite state automata and how to compute operations on
        those automata, such as inclusion, emptiness or intersection,
        have been extensively studied and documented in the
        literature. The interested reader can consult the relevant
        literature on tree grammars, for instance <bibref ref="Languages"/>, or <bibref ref="TATA"/>.</p>
      </smnote>

    </div3>

  </div2>

  <div2 id="sec_factor">
    <head>Judgments for FLWOR and other expressions on sequences</head>

    <smintro>
      <p>Some [XPath/XQuery] operations work on sequences of items. For
      instance, [For/FLWOR] expressions iterate over a sequence of
      items and the <code>fn:unordered</code> function can return all items in a
      sequence in any order, etc.</p>

      <p>Static typing for those operations need to infer a type
      acceptable for <emph>all</emph> the items in the sequence. This
      sometimes requires to approximate the type known for each item
      individually.</p>

    </smintro>
    
    <smexample>

      <p>Assume the variable <code>$shipTo</code> is bound to the
      shipTo element</p>

<eg xml:space="preserve">
    &lt;shipTo country="US"&gt;
        &lt;name&gt;Alice Smith&lt;/name&gt;
        &lt;street&gt;123 Maple Street&lt;/street&gt;
        &lt;city&gt;Mill Valley&lt;/city&gt;
        &lt;state&gt;CA&lt;/state&gt;
        &lt;zip&gt;90952&lt;/zip&gt;
    &lt;/shipTo&gt;
</eg>

      <p>and has type</p>

<eg xml:space="preserve">
   element shipTo of type USAddress
</eg>

      <p>The following query orders all children of the shipTo element
      by alphabetical order of their content.</p>

<eg xml:space="preserve">
   for $x in $shipTo/*
   order by $x/text()
   return $x
</eg>

      <p>resulting in the sequence</p>

<eg xml:space="preserve">
    (&lt;street&gt;123 Maple Street&lt;/street&gt;,
     &lt;zip&gt;90952&lt;/zip&gt;,
     &lt;name&gt;Alice Smith&lt;/name&gt;,
     &lt;state&gt;CA&lt;/state&gt;,
     &lt;city&gt;Mill Valley&lt;/city&gt;)
</eg>

      <p>This operation iterates over the elements in the input
      sequence returned by the expression <code>$shipTo/*</code>,
      whose type is the content of a type USAddress.</p>

<eg xml:space="preserve">
    (element name of type xsd:string,
     element street of type xsd:string,
     element city of type xsd:string,
     element state of type xsd:string,
     element zip of type xsd:decimal)
</eg>

      <p>During static typing, one must give a type to the variable
      <code>$x</code> which corresponds to the type of each element in
      the sequence. Since each item is of a different type, one must
      find an item type which is valid for all cases in the
      sequence. This can be done by using a choice for the variable
      <code>$x</code>, as follows</p>

<eg xml:space="preserve">
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)
</eg>

      <p>This type indicates that the type of the variable can be of
      any of the item types in the input sequence.</p>

      <p>The static inference also needs to approximate the number of
      occurrences of items in the sequence. In this example, there is
      at least one item and more than one, so the closest occurrence
      indicator is <code>+</code> for one or more items.</p>

      <p>The static inference for this example finally results in the
      following type.</p>

<eg xml:space="preserve">
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)+
</eg>

      <p><termdef term="prime type" id="term-prime-type"><term>Prime
      types</term> are the types defined as a choice of item
      types</termdef>. It defines two functions on types that compute
      the prime type of an arbitrary type, and approximate the
      occurrence of items in an arbitrary type.  Those judgments are
      used in the static semantics of many expressions, including
      <quote>for</quote>, <quote>some</quote>, and
      <quote>every</quote> expressions, and many functions, including
      <quote>fn:unordered</quote> and <quote>fn:distinct</quote>.</p>

    </smexample>

    <smnotation>
      <p>A choice of item types is called a <emph>prime type</emph>,
      as described by the following grammar production.</p>
      
      <scrap headstyle="show">
        <head>Prime Types</head>
        <prod num="44 (Formal)" id="doc-fs-PrimeType"><lhs>PrimeType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-FormalItemType" xlink:type="simple">FormalItemType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-PrimeType" xlink:type="simple">PrimeType</nt>  "|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-PrimeType" xlink:type="simple">PrimeType</nt>)</rhs></prod>
      </scrap>
  
    </smnotation>
    
    <smnotation>
      <p id="jd_prime">The type function <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
      extracts all item types from the type <a href="#doc-fs-Type"><emph>Type</emph></a>, and combines
      them into a choice.</p>

      <p id="jd_quantifier">The function <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)
      approximates the possible number of items in <a href="#doc-fs-Type"><emph>Type</emph></a> with the
      occurrence indicators supported by the [XPath/XQuery] type system
      (<code>?, +, *</code>).</p>

      <p>For interim results, the auxiliary occurrence
      indicator <code>1</code> denotes  exactly one occurrence.</p>
    </smnotation>

    <smrules>
      <p>The <a href="#jd_prime" class="judgment">prime</a> function is defined by induction as
      follows.</p>
    
      <table summary="" role="figure">
        <col align="left" span="1"/>
        <col align="center" span="1"/>
        <col align="left" span="1"/>
        <tbody>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<code>empty</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>none</code></td>
        </tr>
          <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<code>none</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><code>none</code></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>?)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>*)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>+)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>)</td>
        </tr>
        </tbody>
      </table>

    </smrules>

    <smrules>
      <p>The <a href="#jd_quantifier" class="judgment">quantifier</a> function is defined by induction as
      follows.</p>
      
      <table summary="" role="figure">
        <col align="left" span="1"/>
        <col align="center" span="1"/>
        <col align="left" span="1"/>
        <tbody>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-FormalItemType"><emph>FormalItemType</emph></a>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1">1</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>empty</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1">?</td>
        </tr>
          <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>none</code>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1">1</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> , <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) | <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>?)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> ?</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>*)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> *</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>+)</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_quantifier" class="judgment">·</a> +</td>
        </tr>
        </tbody>
      </table>
      
      <p>This definition uses the sum (<emph>OccurrenceIndicator</emph><subscript>1</subscript> ,
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>), the choice (<emph>OccurrenceIndicator</emph><subscript>1</subscript> |
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>), and the product (<emph>OccurrenceIndicator</emph><subscript>1</subscript> <a href="#jd_quantifier" class="judgment">·</a>
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>) of two occurrence indicators <emph>OccurrenceIndicator</emph><subscript>1</subscript>,
      <emph>OccurrenceIndicator</emph><subscript>2</subscript>, which are defined by the following tables.</p>
      
      <table summary="" role="figure">
        <tbody>
        <tr>
        <td rowspan="1" colspan="1">
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;,&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> -->
        <tr><td rowspan="1" colspan="1"> , </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td></tr>
        <tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td></tr>
        <tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        </tbody>
        </table>
        </td>
        <td rowspan="1" colspan="1">    </td>
        <td rowspan="1" colspan="1">
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;|&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td rowspan="1" colspan="1"> | </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;*&sp1;</td><td>&sp1;*&sp1;</td></tr>-->
        <tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr>
        </tbody>
        </table>
        </td>
        <td rowspan="1" colspan="1">    </td>
        <td rowspan="1" colspan="1">
        <table summary="" border="1">
        <tbody>
<!--        <tr><td>&sp1;&middot;&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;1&sp1;</td><td>&sp1;?&sp1;</td><td>&sp1;+&sp1;</td><td>&sp1;*&sp1;</td></tr> -->
        <tr><td rowspan="1" colspan="1"> · </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
<!--        <tr><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td><td>&sp1;0&sp1;</td></tr> -->
        <tr><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> 1 </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> ? </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> + </td><td rowspan="1" colspan="1"> * </td></tr>
        <tr><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td><td rowspan="1" colspan="1"> * </td></tr>
        </tbody>
        </table>
        </td>
        </tr>
        </tbody>
      </table>
      
    </smrules>

    <smexamples>
      <p>For example, here are the result of applying <a href="#jd_prime" class="judgment">prime</a> and
      <a href="#jd_quantifier" class="judgment">quantifier</a> on a few simple types.</p>

<eg xml:space="preserve">
  prime(element a+)                         = element a
  prime(element a | empty)                  = element a
  prime(element a?,element b?)              = element a | element b
  prime(element a | element b+, element c*) = element a | element b | element c

  quantifier(element a+)                         = +
  quantifier(element a | empty)                  = ?
  quantifier(element a?,element b?)              = *
  quantifier(element a | element b+, element d*) = +
</eg>

      <p>Note that the last occurrence indicator should be '+', since
      the regular expression is such that there must be at least one
      element in the sequence (this element being an 'a' element or a
      'b' element).</p>
    </smexamples>

    <smnote>
      <p>Note that <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) ·
      <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) is always a super type of the
      original type <a href="#doc-fs-Type"><emph>Type</emph></a> I.e., <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) ·
      <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a>) <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> always
      holds. Therefore, it is appropriate to used it as an
      approximation for the type of an expression. This property is
      required for the soundness of the static type analysis.</p>

    </smnote>

    <smrules>
      <p>Finally, a type <a href="#doc-fs-Type"><emph>Type</emph></a> and an occurrence indicator can be
      combined back together to yield a new type with the ·
      operation, as follows.</p>
    
      <table summary="" role="figure">
        <col align="left" span="1"/>
        <col align="center" span="1"/>
        <col align="left" span="1"/>
        <tbody>
        <tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> 1</td>
            <td rowspan="1" colspan="1">  =  </td>
            <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a></td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> ?</td>
              <td rowspan="1" colspan="1">  =  </td>
              <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>?</td>
        </tr>
        <tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> +</td>
              <td rowspan="1" colspan="1">  =  </td>
              <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>+</td>
          </tr>
          <tr><td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> *</td>
              <td rowspan="1" colspan="1">  =  </td>
              <td rowspan="1" colspan="1"><a href="#doc-fs-Type"><emph>Type</emph></a>*</td>
          </tr>
        </tbody>
      </table>
    
    </smrules>

  </div2>

  <div2 id="sec_promotion_judgments">
    <head>Judgments for function calls</head>

    <smintro>
      <p>Function calls can perform type promotion between atomic
      types. This section introduces judgments which describe type
      promotion for the purpose of the dynamic and static semantics.
      These promotion rules include promoting <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> to any
      other type.
      </p>
    </smintro>

    <div3 id="sec_promotion"><head>Type promotion</head>
    <smnotation>
      <p id="jd_can_be_promoted_to">The judgment</p>

      <display>
          <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
          </clause>
      </display>
    
      <p>holds if type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> can be promoted to type
      <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>
    
    </smnotation>

    <smexample>
      <p>For example, the following judgments hold:</p>

<eg xml:space="preserve">
  xs:integer  can be promoted to  xs:integer
  xs:decimal  can be promoted to  xs:float
  xs:integer  can be promoted to  xs:float
  xs:float    can be promoted to  xs:double
</eg>
    </smexample>

    <smrules>
      <p>This judgment is specified by the following rules.</p>

      <p><code>xs:decimal</code> can be promoted to <code>xs:float</code>:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <code>xs:decimal</code> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <code>xs:float</code>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p><code>xs:float</code> can be promoted to <code>xs:double</code>:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <code>xs:float</code> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <code>xs:double</code>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>A type can be promoted to itself or to any type of which it
      is a subtype:</p>

      <infergr>
       <infer>
        <prejudge>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <infergr>
       <infer>
        <prejudge>
         <clause>
           <environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression>
         </clause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>Type promotion is transitive:</p>

      <infergr>
       <infer>
        <prejudge>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
           </expression>
          </clause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
           </expression>
          </clause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>3</subscript>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>Finally, type promotion distributes over occurrence and union
      constructors.</p>

      <infergr>
        <infer>
          <prejudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
              </expression>
            </clause>
            <clause>
              <expression>
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) &lt;= <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>)
              </expression>
            </clause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>

        <infer>
          <prejudge>
            <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>')
              </expression>
            </clause>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
              </expression>
            </clause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>
                  (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>' | <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>')
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>
      </infergr>
    </smrules>

    <p>where the <quote>&lt;=</quote> operator for occurrence
      indicators denotes set inclusion of the subsets of the allowed
      occurrences.</p>

    <smnotation>
      <p id="jd_promotes_to">The judgment</p>

      <display>
          <clause>
        <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
        <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
          </clause>
      </display>
    
      <p>holds if value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> can be promoted to the value
      <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> against the type <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>.</p>

    </smnotation>

    <smexample>
      <p>For example, the following judgments hold</p>

<eg xml:space="preserve">
  1     of type xs:integer  against  xs:integer  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:decimal  promotes to  1     of type xs:integer
  1     of type xs:integer  against  xs:float    promotes to  1.0e0 of type xs:float
  1.0e0 of type xs:float    against  xs:double   promotes to  1.0e0 of type xs:double
</eg>

       <p>Note that type promotion changes the value, and only occurs
       if the input value does not match the target type.</p>
    </smexample>

    <smrules>
      <p>This judgment is specified by the following rules.</p>

      <p>If the value matches the target type, then it is promoted to
      itself</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
            <a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>

      <p>If the value does not match the target type, but is an atomic
      value and it matches a type which can be promoted to the target
      type, then the value is cast to the target type.</p>

      <infergr>
       <infer>
        <prejudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           </expression>
          </clause>
         </multiclause>
         <multiclause>
          <clause>
           <expression>
             <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> != <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           </expression>
          </clause>
         </multiclause>
         <multiclause>
           <clause>
           <expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
           <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
           </clause>
         </multiclause>
        </prejudge>
        <postjudge>
         <multiclause>
          <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript>
           </expression>
          </clause>
         </multiclause>
        </postjudge>
       </infer>
      </infergr>
    </smrules>

   </div3>

  </div2>

  <div2 id="sec_validation_mode">
    <head>Judgments for validation modes and contexts</head>

    <div3 id="jd_aux_context_is"><head>Elements in validation mode</head>
    <smnotation>

      <p>A validation mode may occur explicitly in a validate
      expression <specref ref="sec_validate_expr"/>. The following
      <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> judgment resolves an element name within a given
      validation mode to the type that the element name denotes. The
      judgment is used in the semantics of the validate expression and
      in sequence type.</p>

      <p id="jd_in_validation_context">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
          </clause>
        </display>
        <p>holds when the possibly optional element name resolves to
        the given type in the given validation mode.</p>
    </smnotation>

    <smrules>
      <p>We start with the rules for the global validation
      context.</p>

      <p>If no element name is present, the global validation context
      resolves to the union of all element types that are globally
      declared.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>
           </expression>
          </clause>
         </multiclause>
<multiclause><clause><expression>...</expression></clause></multiclause>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>
           </expression>
          </clause>
         </multiclause>

<multiclause>
<clause>
<expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a><subscript>1</subscript> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a><subscript>1</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>1</subscript> </expression>
</clause>
</multiclause>
<multiclause><clause><expression>...</expression></clause></multiclause>
<multiclause>
<clause>
<expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a><subscript>n</subscript> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a><subscript>n</subscript> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a><subscript>n</subscript> </expression>
</clause>
</multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph>
          <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> (element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> | ... |
          element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>n</subscript>)</expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>If the element name is globally declared in the schema, it
      resolves to the element type of the corresponding global element
      declaration, independently of the validation mode.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
<multiclause>
<clause>
<expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#doc-fs-OptSubstitution"><emph>OptSubstitution</emph></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a>
          <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

      <p>If an element name is not globally defined and the validation
      mode is lax, then the element name resolves to the element type
      with the given element name with any content type.</p>

      <infergr>
        <infer>
         <prejudge>
         <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
         </multiclause>
<multiclause>
<clause>
<expression>
<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) undefined </expression>
          </clause>
          </multiclause>
         </prejudge>
         <postjudge>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> lax
          <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code></expression>
          </clause>
         </postjudge>
        </infer>
      </infergr>

     </smrules>
    </div3>

  </div2>
</div1>


<!--  Keep this comment at the end of the file
Local variables:
mode: xml
sgml-indent-step:2
indent-tabs-mode:nil
sgml-parent-document:("XPathXQuerySemantics.xml" "body" "div1")
End:
-->

  </body>
  <back>
     
<!-- *************************** Core Grammar         **************** -->
<div1 id="sec_core">
  <head>Normalized core and formal grammars</head>

  <p>This section contains the set of productions for the of
  [XPath/XQuery] grammar after it has been normalized, sometimes referred
  to as the <quote>core</quote> grammar, and for the formal grammar
  productions.</p>

   <div2 id="sec_core_grammar">
     <head>Core BNF</head>

     <p>The following grammar uses the same Basic EBNF notation as
     <bibref ref="REC-xml"/>, except that grammar symbols always have
     initial capital letters. The EBNF contains the lexemes embedded
     in the productions.</p>
     <scrap headstyle="show"> 
		  <head id="DefinedLexemes">Named Terminals</head>
      <prod num="98" id="prod-core-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt></rhs></prod><prod num="99" id="prod-core-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="100" id="prod-core-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Digits" xlink:type="simple">Digits</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="101" id="prod-core-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="102" id="prod-core-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="103" id="prod-core-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="104" id="prod-core-ElementContentChar"><lhs>ElementContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs></prod><prod num="105" id="prod-core-QuotAttrContentChar"><lhs>QuotAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs></prod><prod num="106" id="prod-core-AposAttrContentChar"><lhs>AposAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs></prod><prod num="107" id="prod-core-PITarget"><lhs>PITarget</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-PITarget" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-PITarget]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="108" id="prod-core-QName"><lhs>QName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="109" id="prod-core-NCName"><lhs>NCName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="110" id="prod-core-S"><lhs>S</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="111" id="prod-core-Char"><lhs>Char</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod> 
		 </scrap>

     <scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show">
       <head id="BNF-Grammar-prods">Non-Terminals</head>
       <prod num="1" id="prod-core-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Separator" xlink:type="simple">Separator</nt></rhs></prod><prod num="2" id="prod-core-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod><prod num="3" id="prod-core-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="4" id="prod-core-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="5" id="prod-core-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="6" id="prod-core-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod><prod num="7" id="prod-core-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod><prod num="8" id="prod-core-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-InheritMode" xlink:type="simple">InheritMode</nt></rhs></prod><prod num="9" id="prod-core-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod><prod num="10" id="prod-core-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod><prod num="11" id="prod-core-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="12" id="prod-core-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="13" id="prod-core-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="14" id="prod-core-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod><prod num="15" id="prod-core-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="16" id="prod-core-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod><prod num="17" id="prod-core-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod><prod num="18" id="prod-core-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod><prod num="19" id="prod-core-ParamList"><lhs>ParamList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Param" xlink:type="simple">Param</nt>)*</rhs></prod><prod num="20" id="prod-core-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="21" id="prod-core-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="22" id="prod-core-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="23" id="prod-core-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-FLWORExpr" xlink:type="simple">FLWORExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod><prod num="24" id="prod-core-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-LetClause" xlink:type="simple">LetClause</nt>)  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="25" id="prod-core-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="26" id="prod-core-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="27" id="prod-core-LetClause"><lhs>LetClause</lhs><rhs>"let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="28" id="prod-core-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OrderSpecList" xlink:type="simple">OrderSpecList</nt></rhs></prod><prod num="29" id="prod-core-OrderSpecList"><lhs>OrderSpecList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod><prod num="30" id="prod-core-OrderSpec"><lhs>OrderSpec</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OrderModifier" xlink:type="simple">OrderModifier</nt></rhs></prod><prod num="31" id="prod-core-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod><prod num="32" id="prod-core-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="33" id="prod-core-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="34" id="prod-core-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="35" id="prod-core-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="36" id="prod-core-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="37" id="prod-core-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CastableExpr" xlink:type="simple">CastableExpr</nt> )*</rhs></prod><prod num="38" id="prod-core-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="39" id="prod-core-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ValueExpr" xlink:type="simple">ValueExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="40" id="prod-core-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-StepExpr" xlink:type="simple">StepExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt></rhs></prod><prod num="41" id="prod-core-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="42" id="prod-core-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod><prod num="43" id="prod-core-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="44" id="prod-core-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PragmaContents" xlink:type="simple">PragmaContents</nt>)?  "#)"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="45" id="prod-core-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod><prod num="46" id="prod-core-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod><prod num="47" id="prod-core-AxisStep"><lhs>AxisStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ForwardStep" xlink:type="simple">ForwardStep</nt></rhs></prod><prod num="48" id="prod-core-ForwardStep"><lhs>ForwardStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod><prod num="49" id="prod-core-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="50" id="prod-core-ReverseStep"><lhs>ReverseStep</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod><prod num="51" id="prod-core-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="52" id="prod-core-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NameTest" xlink:type="simple">NameTest</nt></rhs></prod><prod num="53" id="prod-core-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod><prod num="54" id="prod-core-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="55" id="prod-core-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Constructor" xlink:type="simple">Constructor</nt></rhs></prod><prod num="56" id="prod-core-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="57" id="prod-core-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod><prod num="58" id="prod-core-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="59" id="prod-core-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="60" id="prod-core-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="61" id="prod-core-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="62" id="prod-core-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="63" id="prod-core-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: reserved-function-names</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc></com></prod><prod num="64" id="prod-core-Constructor"><lhs>Constructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt></rhs></prod><prod num="65" id="prod-core-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt></rhs></prod><prod num="66" id="prod-core-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="67" id="prod-core-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ContentExpr" xlink:type="simple">ContentExpr</nt>  "}"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>*  "}"</rhs></prod><prod num="68" id="prod-core-NamespaceBinding"><lhs>NamespaceBinding</lhs><rhs>"namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-URILiteral" xlink:type="simple">URILiteral</nt>  "}"</rhs></prod><prod num="69" id="prod-core-ContentExpr"><lhs>ContentExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="70" id="prod-core-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="71" id="prod-core-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="72" id="prod-core-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="73" id="prod-core-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="74" id="prod-core-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="75" id="prod-core-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod><prod num="76" id="prod-core-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="77" id="prod-core-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: occurrence-indicators</loc></com></prod><prod num="78" id="prod-core-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="79" id="prod-core-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="80" id="prod-core-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod><prod num="81" id="prod-core-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="82" id="prod-core-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="83" id="prod-core-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="84" id="prod-core-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="85" id="prod-core-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="86" id="prod-core-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="87" id="prod-core-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="88" id="prod-core-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="89" id="prod-core-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="90" id="prod-core-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="91" id="prod-core-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="92" id="prod-core-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="93" id="prod-core-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="94" id="prod-core-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="95" id="prod-core-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="96" id="prod-core-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="97" id="prod-core-URILiteral"><lhs>URILiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
     </scrap>
     <scrap headstyle="show">
       <head/><prod num="112" id="prod-core-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod> 
     </scrap>
   </div2>

   <div2 id="sec_formal_grammar">
     <head>Formal BNF</head>

     <p>The following grammar uses the same Basic EBNF notation as
     <bibref ref="REC-xml"/>, except that grammar symbols always have
     initial capital letters. The EBNF contains the lexemes embedded
     in the productions.</p>

     <scrap headstyle="show"> 
       <head id="Formal-DefinedLexemes">Named Terminals</head>
       <prod num="90" id="prod-fs-HexDigits" role="xquery"><lhs role="xquery">HexDigits</lhs><rhs><rhs-group role="xquery">[0-9a-fA-F]+</rhs-group></rhs></prod><prod num="91" id="prod-fs-CharRef" role="xquery"><lhs role="xquery">CharRef</lhs><rhs><rhs-group role="xquery"><rhs-group role="xquery">"&amp;#"</rhs-group>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-Digits" role="xquery" xlink:type="simple">Digits</nt>  |  (<rhs-group role="xquery">"x"</rhs-group>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-HexDigits" role="xquery" xlink:type="simple">HexDigits</nt>))  <rhs-group role="xquery">";"</rhs-group></rhs-group></rhs></prod><prod num="92" id="prod-fs-Char"><lhs>Char</lhs><rhs><rhs-group>#x0009#x000D#x000A#x0020-#xFFFD</rhs-group></rhs></prod> 
     </scrap>

     <scrap id="Formal-BNF-Grammar" role="non-terminal-structure-expand" headstyle="show">
       <head id="Formal-BNF-Grammar-prods">Non-Terminals</head>
       <prod num="1" id="prod-fs-AtomicValueContent"><lhs>AtomicValueContent</lhs><rhs>String<br/>|  Boolean<br/>|  Decimal<br/>|  Float<br/>|  Double<br/>|  Duration<br/>|  DateTime<br/>|  Time<br/>|  Date<br/>|  GYearMonth<br/>|  GYear<br/>|  GMonthDay<br/>|  GDay<br/>|  GMonth<br/>|  HexBinary<br/>|  Base64Binary<br/>|  AnyURI<br/>|  expanded-QName<br/>|  NOTATION</rhs></prod><prod num="2" id="prod-fs-TypeAnnotation"><lhs>TypeAnnotation</lhs><rhs>"of"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod><prod num="3" id="prod-fs-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="4" id="prod-fs-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  "*"</rhs></prod><prod num="5" id="prod-fs-AttributeNameOrWildcard"><lhs>AttributeNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt>  |  "*"</rhs></prod><prod num="6" id="prod-fs-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="7" id="prod-fs-Value"><lhs>Value</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Item" xlink:type="simple">Item</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Value" xlink:type="simple">Value</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Value" xlink:type="simple">Value</nt>)<br/>|  ("("  ")")</rhs></prod><prod num="8" id="prod-fs-SimpleValue"><lhs>SimpleValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicValue" xlink:type="simple">AtomicValue</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>)<br/>|  ("("  ")")</rhs></prod><prod num="9" id="prod-fs-ElementValue"><lhs>ElementValue</lhs><rhs>"element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementName" xlink:type="simple">ElementName</nt>  "nilled"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Value" xlink:type="simple">Value</nt>  "}"  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-NamespaceBindings" xlink:type="simple">NamespaceBindings</nt>  "}")?</rhs></prod><prod num="10" id="prod-fs-AttributeValue"><lhs>AttributeValue</lhs><rhs>"attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeName" xlink:type="simple">AttributeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-SimpleValue" xlink:type="simple">SimpleValue</nt>  "}"</rhs></prod><prod num="11" id="prod-fs-DocumentValue"><lhs>DocumentValue</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Value" xlink:type="simple">Value</nt>  "}"</rhs></prod><prod num="12" id="prod-fs-TextValue"><lhs>TextValue</lhs><rhs>"text"  "{"  String  "}"</rhs></prod><prod num="13" id="prod-fs-CommentValue"><lhs>CommentValue</lhs><rhs>"comment"  "{"  String  "}"</rhs></prod><prod num="14" id="prod-fs-ProcessingInstructionValue"><lhs>ProcessingInstructionValue</lhs><rhs>"processing-instruction"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  String  "}"</rhs></prod><prod num="15" id="prod-fs-NamespaceBindings"><lhs>NamespaceBindings</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-NamespaceBinding" xlink:type="simple">NamespaceBinding</nt>)*</rhs></prod><prod num="16" id="prod-fs-LocationHints"><lhs>LocationHints</lhs><rhs>"at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*</rhs></prod><prod num="17" id="prod-fs-NamespaceBinding"><lhs>NamespaceBinding</lhs><rhs>"namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt>  "{"  AnyURI  "}"</rhs></prod><prod num="18" id="prod-fs-Prefix"><lhs>Prefix</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt></rhs></prod><prod num="19" id="prod-fs-LocalPart"><lhs>LocalPart</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-NCName" xlink:type="simple">NCName</nt></rhs></prod><prod num="20" id="prod-fs-NodeValue"><lhs>NodeValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementValue" xlink:type="simple">ElementValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeValue" xlink:type="simple">AttributeValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-DocumentValue" xlink:type="simple">DocumentValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TextValue" xlink:type="simple">TextValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-CommentValue" xlink:type="simple">CommentValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ProcessingInstructionValue" xlink:type="simple">ProcessingInstructionValue</nt></rhs></prod><prod num="21" id="prod-fs-Item"><lhs>Item</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-NodeValue" xlink:type="simple">NodeValue</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicValue" xlink:type="simple">AtomicValue</nt></rhs></prod><prod num="22" id="prod-fs-AtomicValue"><lhs>AtomicValue</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicValueContent" xlink:type="simple">AtomicValueContent</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeAnnotation" xlink:type="simple">TypeAnnotation</nt>?</rhs></prod><prod num="23" id="prod-fs-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="24" id="prod-fs-Type"><lhs>Type</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalItemType" xlink:type="simple">FormalItemType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  "|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>)<br/>|  "empty"<br/>|  "none"<br/>|  ("("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  ")")</rhs></prod><prod num="25" id="prod-fs-FormalItemType"><lhs>FormalItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-NodeType" xlink:type="simple">NodeType</nt></rhs></prod><prod num="26" id="prod-fs-NodeType"><lhs>NodeType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-DocumentType" xlink:type="simple">DocumentType</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeType" xlink:type="simple">AttributeType</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementContentType" xlink:type="simple">ElementContentType</nt></rhs></prod><prod num="27" id="prod-fs-ElementContentType"><lhs>ElementContentType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementType" xlink:type="simple">ElementType</nt><br/>|  "comment"<br/>|  "processing-instruction"<br/>|  "text"</rhs></prod><prod num="28" id="prod-fs-AtomicTypeName"><lhs>AtomicTypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod><prod num="29" id="prod-fs-ElementType"><lhs>ElementType</lhs><rhs>"element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptTypeSpecifier" xlink:type="simple">OptTypeSpecifier</nt></rhs></prod><prod num="30" id="prod-fs-TypeSpecifier"><lhs>TypeSpecifier</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptNillable" xlink:type="simple">OptNillable</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeReference" xlink:type="simple">TypeReference</nt></rhs></prod><prod num="31" id="prod-fs-AttributeType"><lhs>AttributeType</lhs><rhs>"attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeNameOrWildcard" xlink:type="simple">AttributeNameOrWildcard</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptTypeReference" xlink:type="simple">OptTypeReference</nt></rhs></prod><prod num="32" id="prod-fs-Nillable"><lhs>Nillable</lhs><rhs>"nillable"</rhs></prod><prod num="33" id="prod-fs-TypeDerivation"><lhs>TypeDerivation</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ComplexTypeDerivation" xlink:type="simple">ComplexTypeDerivation</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicTypeDerivation" xlink:type="simple">AtomicTypeDerivation</nt></rhs></prod><prod num="34" id="prod-fs-ComplexTypeDerivation"><lhs>ComplexTypeDerivation</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Derivation" xlink:type="simple">Derivation</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptMixed" xlink:type="simple">OptMixed</nt>  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>?  "}"</rhs></prod><prod num="35" id="prod-fs-AtomicTypeDerivation"><lhs>AtomicTypeDerivation</lhs><rhs>"restricts"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt></rhs></prod><prod num="36" id="prod-fs-TypeReference"><lhs>TypeReference</lhs><rhs>"of"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt></rhs></prod><prod num="37" id="prod-fs-Derivation"><lhs>Derivation</lhs><rhs>("restricts"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt>)<br/>|  ("extends"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt>)</rhs></prod><prod num="38" id="prod-fs-Mixed"><lhs>Mixed</lhs><rhs>"mixed"</rhs></prod><prod num="39" id="prod-fs-Definition"><lhs>Definition</lhs><rhs>("define"  "element"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementName" xlink:type="simple">ElementName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptSubstitution" xlink:type="simple">OptSubstitution</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-OptNillable" xlink:type="simple">OptNillable</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "attribute"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeName" xlink:type="simple">AttributeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeReference" xlink:type="simple">TypeReference</nt>)<br/>|  ("define"  "type"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeName" xlink:type="simple">TypeName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeDerivation" xlink:type="simple">TypeDerivation</nt>)</rhs></prod><prod num="40" id="prod-fs-Definitions"><lhs>Definitions</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Definition" xlink:type="simple">Definition</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Definitions" xlink:type="simple">Definitions</nt>)?</rhs></prod><prod num="41" id="prod-fs-Substitution"><lhs>Substitution</lhs><rhs>"substitutes"  "for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="42" id="prod-fs-AttributeModel"><lhs>AttributeModel</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeType" xlink:type="simple">AttributeType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeType" xlink:type="simple">AttributeType</nt>  "?")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeModel" xlink:type="simple">AttributeModel</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeModel" xlink:type="simple">AttributeModel</nt>)<br/>|  ("("  ")")</rhs></prod><prod num="43" id="prod-fs-ElementModel"><lhs>ElementModel</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementType" xlink:type="simple">ElementType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementType" xlink:type="simple">ElementType</nt>  "?")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementModel" xlink:type="simple">ElementModel</nt>  "&amp;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ElementModel" xlink:type="simple">ElementModel</nt>)<br/>|  ("("  ")")<br/>|  "none"</rhs></prod><prod num="44" id="prod-fs-PrimeType"><lhs>PrimeType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalItemType" xlink:type="simple">FormalItemType</nt><br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-PrimeType" xlink:type="simple">PrimeType</nt>  "|"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-PrimeType" xlink:type="simple">PrimeType</nt>)</rhs></prod><prod num="45" id="prod-fs-DocumentType"><lhs>DocumentType</lhs><rhs>"document"  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>  "}")?</rhs></prod><prod num="46" id="prod-fs-SPragma"><lhs>SPragma</lhs><rhs>("include"  |  "import"  |  "redefine"  |  "annotation")*</rhs></prod><prod num="47" id="prod-fs-Content"><lhs>Content</lhs><rhs>(("simpleType"  |  "complexType"  |  "element"  |  "attribute"  |  "attributeGroup"  |  "group"  |  "notation")  "annotation"*)*</rhs></prod><prod num="48" id="prod-fs-MixedAttribute"><lhs>MixedAttribute</lhs><rhs>"mixed"  "="  Boolean</rhs></prod><prod num="49" id="prod-fs-NillableAttribute"><lhs>NillableAttribute</lhs><rhs>"nillable"  "="  Boolean</rhs></prod><prod num="50" id="prod-fs-substitutionGroupAttribute"><lhs>substitutionGroupAttribute</lhs><rhs>"substitutionGroup"  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="51" id="prod-fs-maxLength"><lhs>maxLength</lhs><rhs>"maxLength"  "="  "nonNegativeInteger"</rhs></prod><prod num="52" id="prod-fs-minLength"><lhs>minLength</lhs><rhs>"minLength"  "="  "nonNegativeInteger"</rhs></prod><prod num="53" id="prod-fs-length"><lhs>length</lhs><rhs>"length"  "="  "nonNegativeInteger"</rhs></prod><prod num="54" id="prod-fs-maxOccurs"><lhs>maxOccurs</lhs><rhs>"maxOccurs"  "="  ("nonNegativeInteger"  |  "unbounded")</rhs></prod><prod num="55" id="prod-fs-minOccurs"><lhs>minOccurs</lhs><rhs>"minOccurs"  "="  "nonNegativeInteger"</rhs></prod><prod num="56" id="prod-fs-OccursAttributes"><lhs>OccursAttributes</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-maxOccurs" xlink:type="simple">maxOccurs</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-minOccurs" xlink:type="simple">minOccurs</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-maxLength" xlink:type="simple">maxLength</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-minLength" xlink:type="simple">minLength</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-length" xlink:type="simple">length</nt></rhs></prod><prod num="57" id="prod-fs-ComplexTypeContent"><lhs>ComplexTypeContent</lhs><rhs>"annotation"?  ("simpleContent"  |  "complexContent"  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-ChildrenContent" xlink:type="simple">ChildrenContent</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeContent" xlink:type="simple">AttributeContent</nt>))</rhs></prod><prod num="58" id="prod-fs-ChildrenContent"><lhs>ChildrenContent</lhs><rhs>("group"  |  "all"  |  "choice"  |  "sequence")?</rhs></prod><prod num="59" id="prod-fs-GroupComponent"><lhs>GroupComponent</lhs><rhs>"element"  |  "group"  |  "choice"  |  "sequence"  |  "any"</rhs></prod><prod num="60" id="prod-fs-AttributeContent"><lhs>AttributeContent</lhs><rhs>("attribute"  |  "attributeGroup")*  "anyAttribute"?</rhs></prod><prod num="61" id="prod-fs-UseAttribute"><lhs>UseAttribute</lhs><rhs>"use"  "="  ("optional"  |  "prohibited"  |  "required")</rhs></prod><prod num="62" id="prod-fs-DefaultAttribute"><lhs>DefaultAttribute</lhs><rhs>"default"  "="  String</rhs></prod><prod num="63" id="prod-fs-FixedAttribute"><lhs>FixedAttribute</lhs><rhs>"fixed"  "="  String</rhs></prod><prod num="64" id="prod-fs-PrincipalNodeKind"><lhs>PrincipalNodeKind</lhs><rhs>"element"  |  "attribute"  |  "namespace"</rhs></prod><prod num="65" id="prod-fs-FormalFLWORClause"><lhs>FormalFLWORClause</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LetClause" xlink:type="simple">LetClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-WhereClause" xlink:type="simple">WhereClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt></rhs></prod><prod num="66" id="prod-fs-FormalReturnClause"><lhs>FormalReturnClause</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalFLWORExpr" xlink:type="simple">FormalFLWORExpr</nt>  |  ("return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Expr" xlink:type="simple">Expr</nt>)</rhs></prod><prod num="67" id="prod-fs-FormalFLWORExpr"><lhs>FormalFLWORExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalFLWORClause" xlink:type="simple">FormalFLWORClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalReturnClause" xlink:type="simple">FormalReturnClause</nt></rhs></prod><prod num="68" id="prod-fs-FormalCaseClauses"><lhs>FormalCaseClauses</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalCaseClause" xlink:type="simple">FormalCaseClause</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalCaseClauses" xlink:type="simple">FormalCaseClauses</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-FormalDefaultCaseClause" xlink:type="simple">FormalDefaultCaseClause</nt></rhs></prod><prod num="69" id="prod-fs-FormalCaseClause"><lhs>FormalCaseClause</lhs><rhs>"case"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="70" id="prod-fs-FormalDefaultCaseClause"><lhs>FormalDefaultCaseClause</lhs><rhs>"default"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-core-VarName" xlink:type="simple">VarName</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="71" id="prod-fs-PrologDeclList"><lhs>PrologDeclList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-PrologDecl" xlink:type="simple">PrologDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-Separator" xlink:type="simple">Separator</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-PrologDeclList" xlink:type="simple">PrologDeclList</nt>)?</rhs></prod><prod num="72" id="prod-fs-PrologDecl"><lhs>PrologDecl</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarDecl" xlink:type="simple">VarDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt></rhs></prod><prod num="73" id="prod-fs-OptAtomicType"><lhs>OptAtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  "?")  |  "empty"</rhs></prod><prod num="74" id="prod-fs-OptMixed"><lhs>OptMixed</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Mixed" xlink:type="simple">Mixed</nt>?</rhs></prod><prod num="75" id="prod-fs-OptNillable"><lhs>OptNillable</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Nillable" xlink:type="simple">Nillable</nt>?</rhs></prod><prod num="76" id="prod-fs-OptSubstitution"><lhs>OptSubstitution</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Substitution" xlink:type="simple">Substitution</nt>?</rhs></prod><prod num="77" id="prod-fs-OptTypeSpecifier"><lhs>OptTypeSpecifier</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeSpecifier" xlink:type="simple">TypeSpecifier</nt>?</rhs></prod><prod num="78" id="prod-fs-OptTypeReference"><lhs>OptTypeReference</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeReference" xlink:type="simple">TypeReference</nt>?</rhs></prod><prod num="79" id="prod-fs-OptTypeDeclaration"><lhs>OptTypeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="80" id="prod-fs-OptPositionalVar"><lhs>OptPositionalVar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-PositionalVar" xlink:type="simple">PositionalVar</nt>?</rhs></prod><prod num="81" id="prod-fs-OptVarName"><lhs>OptVarName</lhs><rhs>("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-VarName" xlink:type="simple">VarName</nt>)?</rhs></prod><prod num="82" id="prod-fs-OptLocationHints"><lhs>OptLocationHints</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-LocationHints" xlink:type="simple">LocationHints</nt>?</rhs></prod><prod num="83" id="prod-fs-ElementContentUnit"><lhs>ElementContentUnit</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-DirCharsUnit" xlink:type="simple">DirCharsUnit</nt></rhs></prod><prod num="84" id="prod-fs-DirCharsUnit"><lhs>DirCharsUnit</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CDataSection</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <rhs-group role="xquery">"{{"</rhs-group>  |  <rhs-group role="xquery">"}}"</rhs-group>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt>)+</rhs></prod><prod num="85" id="prod-fs-FunctionSig"><lhs>FunctionSig</lhs><rhs>"declare"  "function"  expanded-QName  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-TypeList" xlink:type="simple">TypeList</nt>?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod><prod num="86" id="prod-fs-TypeList"><lhs>TypeList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-Type" xlink:type="simple">Type</nt>)*</rhs></prod><prod num="87" id="prod-fs-AttributeContentUnits"><lhs>AttributeContentUnits</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-fs-AttributeContentUnit" xlink:type="simple">AttributeContentUnit</nt>*</rhs></prod><prod num="88" id="prod-fs-AttributeContentUnit"><lhs>AttributeContentUnit</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt></rhs></prod><prod num="89" id="prod-fs-ConstructionMode"><lhs>ConstructionMode</lhs><rhs>"preserve"  |  "strip"</rhs></prod>
     </scrap>

   </div2>

</div1>


     <div1 id="sec_indexes">
  <head>Index of judgments</head>

  <p>Here is the list of the judgments defined in this
  specification.</p>
  
    <p>Main judgments:</p>

    <ulist>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>Expr</emph> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>Expr</emph> <a href="#jd_has_type_extension" class="judgment"><term>:</term><subscript>ext</subscript></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><emph>Expr</emph> <a href="#jd_yields" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
    </clause>
</p></item>
    </ulist>

    <p>Auxiliary judgments:</p>

    <ulist>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_subtype_of" class="judgment"><term>&lt;:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_statEnv" class="judgment"><term>=&gt;</term><subscript>module_statEnv</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression>(<emph>AnyURI</emph> | #MAIN) <a href="#jd_module_dynEnv" class="judgment"><term>=&gt;</term><subscript>module_dynEnv</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
      <expression><emph>PrologDeclList</emph> <a href="#jd_yields_context" class="judgment"><term>=&gt;</term><subscript>stat</subscript></a>
        <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript> <a href="#jd_yields_context" class="judgment"><term>with</term></a> <emph>PrologDeclList</emph><subscript>1</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript></environment>
      <expression><emph>PrologDeclList</emph> <a href="#jd_yields_dyn_context" class="judgment"><term>=&gt;</term><subscript>dyn</subscript></a>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript></environment>
      <expression><emph>Definitions</emph> <a href="#jd_yields_type_context" class="judgment"><term>=&gt;</term><subscript>type</subscript></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
      <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1,n</subscript>)), ···, (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>k</subscript>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>k,n</subscript>))
        <a href="#jd_import_functions" class="judgment"><term>=&gt;</term><subscript>import_functions</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript> ; <emph>AnyURI</emph></environment>
      <expression>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>1</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>), ···,
      (<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a><subscript>n</subscript>, <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>) <a href="#jd_import_variables" class="judgment"><term>=&gt;</term><subscript>import_variables</subscript></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_promotes_to" class="judgment"><term>against</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
        <a href="#jd_promotes_to" class="judgment"><term>promotes to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_against" class="judgment"><term>against</term></a> <emph>FormalCaseClauses</emph> <a href="#jd_against" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
          <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_axis_type" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_axis_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><a href="#jd_axis" class="judgment"><term>axis</term></a> <emph>Axis</emph> <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_type_case" class="judgment"><term>case</term></a> <emph>FormalCaseClause</emph> <a href="#jd_type_case" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>1</subscript> <a href="#jd_cast_value_to" class="judgment"><term>cast value to type</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a>
            <a href="#jd_cast_value_to" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_data" class="judgment"><term>data on</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-TypeSpecifier"><emph>TypeSpecifier</emph></a> <a href="#jd_expands_to" class="judgment"><term>expands to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_extended_by" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>1</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>extended with dynamic environment</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>2</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>yields</term></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><subscript>3</subscript>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><a href="#xq_stat_env_def" class="env">statEnv</a><subscript>1</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>extended with static environment</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>2</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>yields</term></a> <a href="#xq_stat_env_def" class="env">statEnv</a><subscript>3</subscript>
        <a href="#jd_extended_with_static_environment" class="judgment"><term>for uri</term></a> <emph>AnyURI</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_function_declaration" class="judgment"><term>function declaration</term></a> <emph>FunctionDecl</emph>
               <a href="#jd_function_declaration" class="judgment"><term>with signature</term></a> <emph>FunctionSig</emph> <a href="#jd_function_declaration" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>r</subscript>
               </expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><a href="#jd_function_with_types" class="judgment"><term>function</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           <a href="#jd_function_with_types" class="judgment"><term>with types</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>on values</term></a>
           (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,...,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>n</subscript>)
           <a href="#jd_function_with_types" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><emph>LiteralExpr</emph> <a href="#jd_has_atomic_value" class="judgment"><term>has atomic value</term></a> <a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_attribute_content" class="judgment"><term>has attribute content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_has_element_content" class="judgment"><term>has node content</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><emph>Axis</emph> <a href="#jd_principal" class="judgment"><term>has principal</term></a>
         <emph>PrincipalNodeKind</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> <a href="#jd_union_interpretation" class="judgment"><term>is</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
          <a href="#jd_union_interpretation" class="judgment"><term>extended with union interpretation of</term></a> 
          <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><emph>AnyURI</emph> <a href="#jd_is_target_namespace_of_module" class="judgment"><term>is target namespace of module</term></a> <emph>Module</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_matches" class="judgment"><term>matches</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> <a href="#jd_mixes_to" class="judgment"><term>mixes to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a>
          <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
          <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-Nillable"><emph>Nillable</emph></a>? <a href="#doc-fs-Type"><emph>Type</emph></a> (
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>QName</emph> <a href="#jd_attr_qname_expands_to" class="judgment"><term>of attr expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>QName</emph> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>QName</emph> <a href="#jd_func_qname_expands_to" class="judgment"><term>of func expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><emph>QName</emph> <a href="#jd_var_qname_expands_to" class="judgment"><term>of var expands to</term></a> <emph>Variable</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <expression><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>
            ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
          <emph>String</emph></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>1</subscript> <a href="#jd_substitutes_for" class="judgment"><term>substitutes for</term></a> <a href="#doc-fs-ElementName"><emph>ElementName</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_static_lookup" class="judgment"><term>type lookup</term></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_static_lookup" class="judgment"><term>type lookup</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
          <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#jd_test_type" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test_type" class="judgment"><term>with</term></a>
             <emph>PrincipalNodeKind</emph> <a href="#jd_test_type" class="judgment"><term>of</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>
             <a href="#jd_test_type" class="judgment"><term>:</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
      <expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>NodeTest</emph> <a href="#jd_test" class="judgment"><term>with</term></a>
           <emph>PrincipalNodeKind</emph> <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
    </clause>
</p></item>
<item><p>
    <clause>
      <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
      <expression><a href="#doc-xquery-ElementNameOrWildcard"><emph>ElementNameOrWildcard</emph></a> <a href="#jd_in_validation_context" class="judgment"><term>with mode</term></a> <emph>ValidationMode</emph> <a href="#jd_in_validation_context" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a></expression>
    </clause>
</p></item>
    </ulist>

</div1>

     <div1 id="sec_functions_and_operators">
  <head>Functions and Operators</head>

  <div2 id="sec_used_functions">
    <head>Functions and Operators used in the Formal Semantics</head>

    <p>Here is the list of functions from the <bibref ref="xpath-functions"/> document
    that are used in the [XPath/XQuery] Formal Semantics:</p>

    <ulist>
      <item><p id="func-add-dayTimeDurations"><xspecref spec="FO" ref="func-add-dayTimeDurations"/></p></item>
      <item><p id="func-add-dayTimeDuration-to-dateTime"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-dateTime"/></p></item>
      <item><p id="func-add-dayTimeDuration-to-date"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-date"/></p></item>
      <item><p id="func-add-dayTimeDuration-to-time"><xspecref spec="FO" ref="func-add-dayTimeDuration-to-time"/></p></item>
      <item><p id="func-add-yearMonthDurations"><xspecref spec="FO" ref="func-add-yearMonthDurations"/></p></item>
      <item><p id="func-add-yearMonthDuration-to-dateTime"><xspecref spec="FO" ref="func-add-yearMonthDuration-to-dateTime"/></p></item>
      <item><p id="func-add-yearMonthDuration-to-date"><xspecref spec="FO" ref="func-add-yearMonthDuration-to-date"/></p></item>
      <item><p id="func-boolean-equal"><xspecref spec="FO" ref="func-boolean-equal"/></p></item>
      <item><p id="func-boolean-greater-than"><xspecref spec="FO" ref="func-boolean-greater-than"/></p></item>
      <item><p id="func-boolean-less-than"><xspecref spec="FO" ref="func-boolean-less-than"/></p></item>
      <item><p id="func-boolean"><xspecref spec="FO" ref="func-boolean"/></p></item>
      <item><p id="func-compare"><xspecref spec="FO" ref="func-compare"/></p></item>
      <item><p id="func-concatenate"><xspecref spec="FO" ref="func-concatenate"/></p></item>
      <item><p id="func-count"><xspecref spec="FO" ref="func-count"/></p></item>
      <item><p id="func-dateTime-equal"><xspecref spec="FO" ref="func-dateTime-equal"/></p></item>
      <item><p id="func-dateTime-greater-than"><xspecref spec="FO" ref="func-dateTime-greater-than"/></p></item>
      <item><p id="func-dateTime-less-than"><xspecref spec="FO" ref="func-dateTime-less-than"/></p></item>
      <item><p id="func-dayTimeDuration-greater-than"><xspecref spec="FO" ref="func-dayTimeDuration-greater-than"/></p></item>
      <item><p id="func-dayTimeDuration-less-than"><xspecref spec="FO" ref="func-dayTimeDuration-less-than"/></p></item>
      <item><p id="func-divide-dayTimeDuration"><xspecref spec="FO" ref="func-divide-dayTimeDuration"/></p></item>
      <item><p id="func-divide-yearMonthDuration"><xspecref spec="FO" ref="func-divide-yearMonthDuration"/></p></item>
      <item><p id="func-data"><xspecref spec="FO" ref="func-data"/></p></item>
      <item><p id="func-empty"><xspecref spec="FO" ref="func-empty"/></p></item>
      <item><p id="func-error"><xspecref spec="FO" ref="func-error"/></p></item>
      <item><p id="func-except"><xspecref spec="FO" ref="func-except"/></p></item>
      <item><p id="func-false"><xspecref spec="FO" ref="func-false"/></p></item>
      <item><p id="func-intersect"><xspecref spec="FO" ref="func-intersect"/></p></item>
      <item><p id="func-is-same-node"><xspecref spec="FO" ref="func-is-same-node"/></p></item>
      <item><p id="func-last"><xspecref spec="FO" ref="func-last"/></p></item>
      <item><p id="func-multiply-dayTimeDuration"><xspecref spec="FO" ref="func-multiply-dayTimeDuration"/></p></item>
      <item><p id="func-multiply-yearMonthDuration"><xspecref spec="FO" ref="func-multiply-yearMonthDuration"/></p></item>
      <item><p id="func-node-after"><xspecref spec="FO" ref="func-node-after"/></p></item>
      <item><p id="func-node-before"><xspecref spec="FO" ref="func-node-before"/></p></item>
      <item><p id="func-NOTATION-equal"><xspecref spec="FO" ref="func-NOTATION-equal"/></p></item>
      <item><p id="func-not"><xspecref spec="FO" ref="func-not"/></p></item>
      <item><p id="func-numeric-add"><xspecref spec="FO" ref="func-numeric-add"/></p></item>
      <item><p id="func-numeric-divide"><xspecref spec="FO" ref="func-numeric-divide"/></p></item>
      <item><p id="func-numeric-equal"><xspecref spec="FO" ref="func-numeric-equal"/></p></item>
      <item><p id="func-numeric-greater-than"><xspecref spec="FO" ref="func-numeric-greater-than"/></p></item>
      <item><p id="func-numeric-less-than"><xspecref spec="FO" ref="func-numeric-less-than"/></p></item>
      <item><p id="func-numeric-mod"><xspecref spec="FO" ref="func-numeric-mod"/></p></item>
      <item><p id="func-numeric-multiply"><xspecref spec="FO" ref="func-numeric-multiply"/></p></item>
      <item><p id="func-numeric-subtract"><xspecref spec="FO" ref="func-numeric-subtract"/></p></item>
      <item><p id="func-numeric-unary-minus"><xspecref spec="FO" ref="func-numeric-unary-minus"/></p></item>
      <item><p id="func-numeric-unary-plus"><xspecref spec="FO" ref="func-numeric-unary-plus"/></p></item>
      <item><p id="func-position"><xspecref spec="FO" ref="func-position"/></p></item>
      <item><p id="func-QName-equal"><xspecref spec="FO" ref="func-QName-equal"/></p></item>
      <item><p id="func-root"><xspecref spec="FO" ref="func-root"/></p></item>
      <item><p id="func-round"><xspecref spec="FO" ref="func-round"/></p></item>
      <item><p id="func-subsequence"><xspecref spec="FO" ref="func-subsequence"/></p></item>
      <item><p id="func-subtract-dayTimeDuration-from-dateTime"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-dateTime"/></p></item>
      <item><p id="func-subtract-dayTimeDuration-from-date"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-date"/></p></item>
      <item><p id="func-subtract-dayTimeDuration-from-time"><xspecref spec="FO" ref="func-subtract-dayTimeDuration-from-time"/></p></item>
      <item><p id="func-subtract-dayTimeDurations"><xspecref spec="FO" ref="func-subtract-dayTimeDurations"/></p></item>
      <item><p id="func-subtract-yearMonthDuration-from-dateTime"><xspecref spec="FO" ref="func-subtract-yearMonthDuration-from-dateTime"/></p></item>
      <item><p id="func-subtract-yearMonthDuration-from-date"><xspecref spec="FO" ref="func-subtract-yearMonthDuration-from-date"/></p></item>
      <item><p id="func-subtract-yearMonthDurations"><xspecref spec="FO" ref="func-subtract-yearMonthDurations"/></p></item>
      <item><p id="func-to"><xspecref spec="FO" ref="func-to"/></p></item>
      <item><p id="func-true"><xspecref spec="FO" ref="func-true"/></p></item>
      <item><p id="func-union"><xspecref spec="FO" ref="func-union"/></p></item>
      <item><p id="func-yearMonthDuration-greater-than"><xspecref spec="FO" ref="func-yearMonthDuration-greater-than"/></p></item>
      <item><p id="func-yearMonthDuration-less-than"><xspecref spec="FO" ref="func-yearMonthDuration-less-than"/></p></item>
    </ulist>
  </div2>

  <div2 id="sec_operators">
    <head>Mapping of Overloaded Internal Functions</head>

    <p>This section gives the semantics specific to overloaded
    internal functions (with prefix <emph>fs:</emph>) that are used to
    define overloaded XQuery operators (with prefix <emph>op:</emph>),
    such as comparison expressions or arithmetic expressions. Static
    typing for those functions are defined over unions of (possibly
    optional) atomic types. The semantics is obtained in three
    steps. First, a rule is applied to deal with the union of those
    (possibly optional) atomic types. A second set of rules treat the
    cases where one of the operands of those functions is the empty
    type (resp. empty sequence) or optional. Finally, a final rule
    deals with type promotion and access to an operators mapping table
    which maps the overloaded internal functions to the appropriate
    operator functions defined in <bibref ref="xpath-functions"/> and give the
    corresponding type.</p>

    <smnotation>
      <p>The following auxiliary grammar production describe optional
      atomic types.</p>

      <scrap headstyle="show">
        <head>OptAtomicType</head>
      
        <prod num="73 (Formal)" id="doc-fs-OptAtomicType"><lhs>OptAtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AtomicTypeName" xlink:type="simple">AtomicTypeName</nt>  "?")  |  "empty"</rhs></prod>
      </scrap>

    </smnotation>

    <smtype>
      <p>The following static typing rules apply generically to all
      the <emph>fs:</emph> special functions. They do not apply to any
      other function calls, which are treated in <specref ref="id-function-calls"/>.</p>

      <p>First, if the static type of one or several of the
      expressions passed as argument is a union of atomic types, the
      function call is type checked once separately for each atomic
      type in that union. The static type of the entire function call
      expression is then the union of the types computed in each
      case.</p>

      <infergr>
        <infer>
          <prejudge>
            <multiclause>
              <clause>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,1</subscript>|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,1</subscript>)
                </expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression>
                  ...
                </expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause>
                <expression>
                  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript> = (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,n</subscript>|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,n</subscript>)
                </expression>
              </clause>
            </multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,1</subscript>,..., <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript><subscript>,n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript>'
                </expression>
              </clause>
            </multiclause>
            <multiclause><clause><expression>...</expression></clause></multiclause>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,1</subscript>,..., <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>m</subscript><subscript>,n</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>r</subscript>'
                </expression>
              </clause>
            </multiclause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>, ..., <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>n</subscript>)
                  <a href="#jd_has_type" class="judgment"><term>:</term></a>
                  (<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>1</subscript>'|...|<a href="#doc-fs-OptAtomicType"><emph>OptAtomicType</emph></a><subscript>r</subscript>')
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>
      </infergr>

      <smnote>
        <p>Note that this approach can be used since the type declared
        for a function parameter is never itself be a union.</p>
      </smnote>

      <p>The following rules deal with optional arguments. In the case
      of binary operators, if either one of the types of the operands
      is empty, the resulting type is empty.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = empty
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = empty
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

        <p>If either one of the types of the operands is optional, the
        type obtained by propagating the optional occurrence
        indicator.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>?
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>?
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>?
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> = <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>?
		</expression>
	      </clause>
             </multiclause>
             <multiclause>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
          <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>?
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

      <p>In the case of unary operators, if the type of the operand is
      empty, the resulting type is empty.</p>

	<infergr>
	  <infer>
	    <prejudge>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> = empty
		</expression>
	      </clause>
             </multiclause>
	    </prejudge>
	    <postjudge>
	      <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
		<expression>
		  <emph><a href="#id-expanded-qnames"><emph>expanded-QName</emph></a></emph>(<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> empty
		</expression>
	      </clause>
	    </postjudge>
	  </infer>
	</infergr>

      <p>Finally, the resulting type is obtained by performing type
      promotion and accessing the operators mapping table (using the
      <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> judgment defined below).</p>

      <infergr>
        <infer>
          <prejudge>
              <multiclause>
                <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>'</expression></clause>
              </multiclause>
              <multiclause>
                <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>'</expression></clause>
              </multiclause>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression>
	      </clause>
             </multiclause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>,<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>
      </infergr>

      <infergr>
        <infer>
          <prejudge>
              <multiclause>
                <clause><environment> <a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                        <expression><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_can_be_promoted_to" class="judgment"><term>can be promoted to</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>'</expression></clause>
              </multiclause>
             <multiclause>
	      <clause>
		<expression>
		  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
		</expression>
	      </clause>
             </multiclause>
          </prejudge>
          <postjudge>
            <multiclause>
              <clause><environment><a href="#xq_stat_env_def" class="env">statEnv</a> </environment>
                <expression>
                  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>(<a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript>) <a href="#jd_has_type" class="judgment"><term>:</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
                </expression>
              </clause>
            </multiclause>
          </postjudge>
        </infer>
      </infergr>

<!--
            Type1 is not a union of atomic types
            Type2 is not a union of atomic types
            statEnv |- Type1 can be promoted to Type1'
            statEnv |- Type2 can be promoted to Type2'
            operator type for Type1' and Type2' is Type3'

            statEnv |- expanded-QName(Type1, Type2) : Type3'

            [expanded-Qname is that of a unary pseudo-function]
            Type1 is not a union of atomic types
            statEnv |- Type1 can be promoted to Type1'
            operator type for Type1' is Type3'

            statEnv |- expanded-QName(Type1) : Type3'
-->

    </smtype>

    <smeval>
      <p>Each <code>fs:</code> overloaded operator maps to the
      corresponding equivalent overloaded <code>op:</code> operator,
      as defined in <bibref ref="xpath-functions"/>, and deals with the case where one
      of the operands is the empty sequence.</p>

      <p>The dynamic semantics of the <code>fs:</code> operator is
      similar to using the following user-defined function.</p>

      <table>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1"><code>declare function</code> <emph>fs:opname</emph><code>($x1 as
            xs:anyAtomicType?, $x2 as xs:anyAtomicType?) as
            xs:anyAtomicType? {</code></td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">  <code>if (fn:empty($x1) or fn:empty($x2)) then () else</code>
            <map><emph>fs:opname($x1,$x2)</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a></td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"><code>};</code></td>
          </tr>
        </tbody>
      </table>

      <p>Where
      <map><emph>fs:opname()</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a> maps
      to the corresponding op: operator in <bibref ref="xpath-functions"/>, as defined
      in the table below.</p>
    </smeval>

    <smnotation>
      <p>The operators mapping table is given below. The table is used
      to define the following auxiliary mapping rules and
      judgments.</p>

      <p id="jd_map_overloaded_op">The mapping rule for binary and
      unary operators</p>

      <display>
        <clause>
        <expression><map><emph>fs:opname1(<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>)</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a>
        == <emph>op:opname2(<emph>Expr</emph><subscript>1</subscript>,<emph>Expr</emph><subscript>2</subscript>)</emph></expression>
        </clause>
      </display>
    
      <p>and</p>

      <display>
        <clause>
        <expression><map><emph>fs:opname1(<emph>Expr</emph><subscript>1</subscript>)</emph></map><a href="#jd_map_overloaded_op" class="judgment"><subscript>OverloadedOp</subscript></a>
        == <emph>op:opname2(<emph>Expr</emph><subscript>1</subscript>)</emph></expression>
        </clause>
      </display>

      <p>where the operator depends on the type of each value returned
      by <emph>Expr</emph><subscript>1</subscript> and <emph>Expr</emph><subscript>2</subscript>.</p>

      <p id="jd_operator_type_for">The judgments for binary and unary
      operators</p>

      <display>
        <clause>
	 <expression>
	  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>and</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
	 </expression>
        </clause>
      </display>

      <p>and</p>

      <display>
        <clause>
	 <expression>
	  <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> <a href="#jd_operator_type_for" class="judgment"><term>operator type for</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> <a href="#jd_operator_type_for" class="judgment"><term>is</term></a> <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript>
	 </expression>
        </clause>
      </display>

      <p>hold when the operator table indicates that the operator
      <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a> has the output type <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript> for the input
      types <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript> and <a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript>.</p>

    </smnotation>

    <p>Note that in the following table, all numeric functions are
    applied to operands with the same type.  Values are promoted to
    compatible types using the function call semantics given in
    <specref ref="id-function-calls"/>.</p>

    <p><term>Gregorian</term> refers to the types <code>xs:gYearMonth</code>,
    <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and <code>xs:gMonth</code>.  For
    binary operators that accept two Gregorian-type operands, both
    operands must have the same type (for example, if one operand is
    of type <code>xs:gDay</code>, the other operand must be of type
    <code>xs:gDay</code>.)</p>

    <table border="1">
    <caption>Binary Operators</caption>
    <tbody><tr>
    <th rowspan="1" colspan="1"><small>Internal Function</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript></small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>2</subscript></small></th><th rowspan="1" colspan="1"><small>Denotes</small></th><th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></small></th>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-add(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-date(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-date(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-time(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-time(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDuration-to-dateTime(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDuration-to-dateTime(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:add-yearMonthDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>plus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:add-dayTimeDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-subtract(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>fn:subtract-dates(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDuration-from-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-date(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>fn:subtract-times(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-time(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>fn:get-dayTimeDuration-from-dateTimes(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDuration-from-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDuration-from-dateTime(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:subtract-yearMonthDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>minus</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:subtract-dayTimeDurations(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-multiply(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:multiply-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:multiply-yearMonthDuration(B, A)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:multiply-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>times</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:multiply-dayTimeDuration(B, A)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>idiv</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:integer-div(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-divide(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:divide-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:divide-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:divide-yearMonthDuration-by-yearMonthDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>div</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:divide-dayTimeDuration-by-dayTimeDuration(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>mod</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-mod(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-equal(fn:compare(A, B), 1)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:datetime-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>op:gYear-equal(A, B) etc.</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small>op:hex-binary-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small>op:base64-binary-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small>op:anyURI-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small>op:QName-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>eq</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small>op:NOTATION-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:boolean-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:numeric-equal(fn:compare(A, B), 1))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:date-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:time-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:datetime-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:yearMonthDuration-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:dayTimeDuration-equal(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small>Gregorian</small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:gYear-equal(A, B)) etc.</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:hexBinary</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:hex-binary-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>xs:base64Binary</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:base64-binary-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>xs:anyURI</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:anyURI-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>xs:QName</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:QName-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ne</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>xs:NOTATION</code></small></td><td rowspan="1" colspan="1"><small><code>fn:not</code>(op:NOTATION-equal(A, B))</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), 0)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:datetime-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>gt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-greater-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:boolean-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 0)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:datetime-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>lt</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-less-than(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), -1)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:datetime-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>ge</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-less-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small><code>xs:string</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 1)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small><code>xs:date</code></small></td><td rowspan="1" colspan="1"><small>op:date-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small><code>xs:time</code></small></td><td rowspan="1" colspan="1"><small>op:time-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small><code>xs:dateTime</code></small></td><td rowspan="1" colspan="1"><small>op:datetime-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>
    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:yearMonthDuration</code></a></small></td><td rowspan="1" colspan="1"><small>op:yearMonthDuration-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>le</code>(A, B)</small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small><a href="#dt-xs_durations"><code>xs:dayTimeDuration</code></a>      </small></td><td rowspan="1" colspan="1"><small>op:dayTimeDuration-greater-than(B, A)</small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>


    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>is-same-node</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:is-same-node</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>node-before</code>(A, B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:node-before</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    <tr>
    <td rowspan="1" colspan="1"><small><emph>fs:</emph><code>node-after</code>(A,
    B)</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small>node()</small></td><td rowspan="1" colspan="1"><small><code>op:node-after</code></small></td><td rowspan="1" colspan="1"><small><code>xs:boolean</code></small></td>
    </tr>

    </tbody></table>

<table border="1" summary="Unary operators">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1"><small>Internal Function</small></th>
<th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>1</subscript></small></th>
<th rowspan="1" colspan="1"><small>Denotes</small></th>
<th rowspan="1" colspan="1"><small><a href="#doc-core-AtomicType"><emph>AtomicType</emph></a><subscript>3</subscript></small></th>
</tr>

<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-plus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-plus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr>

<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:integer</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:decimal</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:float</code></small></td></tr>
<tr><td rowspan="1" colspan="1"><small><emph>fs:</emph><code>unary-minus</code>(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td><td rowspan="1" colspan="1"><small>op:numeric-unary-minus(A)</small></td><td rowspan="1" colspan="1"><small><code>xs:double</code></small></td></tr>

</tbody>
</table>
  </div2>
</div1>

     <div1 id="sec_importing_schema">
  <head>Importing Schemas</head>

  <p>This section describes how XML Schema declarations, as specified
  by XML Schema are imported into the [XPath/XQuery] type system.</p>

  <div2 id="sec_import_intro">
    <head>Introduction</head>

    <p>During schema import processing, the [XPath/XQuery] environment
    imports XML Schema declarations and loads them as declarations in
    the [XPath/XQuery] type system. The semantics of that loading process
    is defined by normalization rules that map XML Schema descriptions
    into the [XPath/XQuery] type system.</p>

    <div3 id="sec_import_features">
      <head>Features</head>

      <p>Here is summarized the XML Schema features which are covered
      by the formal semantics, and handled by the import mapping
      described in this section. For each feature, the following
      indications are used.</p>

      <ulist>
        <item>
          <p><term>Handled</term> indicates features that are relevant for
          [XPath/XQuery], are modeled in the [XPath/XQuery] type system,
          and are supported by the mapping.</p>
        </item>
        <item>
          <p><term>Not in v1.0</term> indicates features that  are relevant to
          [XPath/XQuery], but are not yet modeled in the [XPath/XQuery]
          type system or are not handled by the mapping in XQuery
          V1.0. In case the [XPath/XQuery]
          type system provides appropriate support for those features,
          but the mapping is incomplete, the additional annotation
          <term>mapping only</term> is used.</p>
        </item>
        <item>
          <p><term>Not handled</term> indicates features that are relevant
          for [XPath/XQuery], but are not modeled in the [XPath/XQuery]
          type system, and are not handled by the mapping. Such
          features are typically only related to validation, for which
          the formal semantics defines a partial model.</p>
        </item>
        <item>
          <p><term>Ignored</term> Indicates features that are not relevant
          for [XPath/XQuery], are not modeled in the [XPath/XQuery] type
          system, and are not relevant for the mapping. Such features
          might have to do with documentation of the schema, or might
          affect which Schemas are legal, but do not affect which
          documents match which Schemas.</p>
        </item>
      </ulist>

      <p>Here is the exhaustive list of XML Schema features and their
      status in this document.</p>

        <table summary="" role="figure">
          <col align="left" span="1"/>
          <col align="center" span="1"/>
          <col align="left" span="1"/>
          <tbody>
             <tr><td rowspan="1" colspan="1"><term>Feature:</term></td>
          	 <td rowspan="1" colspan="1"><term>Supported</term></td>
             </tr>
             <tr><td rowspan="1" colspan="1">Primitive Simple types</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Simple type derivation by restriction</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Derivation by list and union</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Facets on simple types</td>
          	 <td rowspan="1" colspan="1">Not handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">ID and IDREF constraints</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Attribute Declarations</td>
          	 <td rowspan="1" colspan="1"/>
             </tr>
             <tr><td rowspan="1" colspan="1">    default,fixed,use</td>
          	 <td rowspan="1" colspan="1">Not in v1.0</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Element Declarations</td>
          	 <td rowspan="1" colspan="1"/>
             </tr>
             <tr><td rowspan="1" colspan="1">    default, fixed (value constraint)</td>
          	 <td rowspan="1" colspan="1">Not in v1.0</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    nillable</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    substitution group affiliation</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    substitution group exclusions</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    disallowed substitutions</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    abstract</td>
          	 <td rowspan="1" colspan="1">Not in v1.0</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Complex Type Definitions</td>
          	 <td rowspan="1" colspan="1"/>
             </tr>
             <tr><td rowspan="1" colspan="1">    derivation by restriction</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    derivation by extension</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    final</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    abstract</td>
          	 <td rowspan="1" colspan="1">Not in v1.0</td>
             </tr>
             <tr><td rowspan="1" colspan="1">AttributeUses</td>
          	 <td rowspan="1" colspan="1"/>
             </tr>
             <tr><td rowspan="1" colspan="1">    required</td>
          	 <td rowspan="1" colspan="1">Not in v1.0, mapping only</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    default, fixed (value constraint)</td>
          	 <td rowspan="1" colspan="1">Not in v1.0</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Attribute Group Definitions</td>
          	 <td rowspan="1" colspan="1">Not in v1.0, mapping only</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Model Group Definitions</td>
          	 <td rowspan="1" colspan="1">Not in v1.0, mapping only</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Model Groups</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Particles</td>
          	 <td rowspan="1" colspan="1">Handled</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Wildcards</td>
          	 <td rowspan="1" colspan="1"/>
             </tr>
             <tr><td rowspan="1" colspan="1">    process contents strict, skip, lax</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">    namespace wild cards.</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Identity-constraint Definitions</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Notation Declarations</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
             <tr><td rowspan="1" colspan="1">Annotations</td>
          	 <td rowspan="1" colspan="1">Ignored</td>
             </tr>
          </tbody>
        </table>

        <p>Note that the schema import feature specified here assumes
        it is given a legal schema as input. As a result, it is not
        necessary to check for 'block' or 'abstract' attributes.</p>

    </div3>

    <div3 id="sec_import_organization">
      <head>Organization</head>

      <p>The presentation of the schema mapping is done according to
      the following organization.</p>

      <smschema>
  
    	<p>First each schema component is summarized using the same
    	notation used in the XML Representation Summary sections in
    	XML Schema. For instance, here is the XML Representation
    	Summary for complex types.</p>
  
    	<schemaRepresentationEg>
    	  <schemaRepresentation>
    	    <name>complexType</name>
    	    <schemaAttribute role="ignored">
    	       abstract = boolean : false
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       block = (#all | List of (extension | restriction))
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       final = (#all | List of (extension | restriction))
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       mixed = boolean : false
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       name = NCName
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       {any schemaAttributes with non-schema namespace ...}
    	    </schemaAttribute>
    	    <content>
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((schemaAttribute |
    	      schemaAttributeGroup)*, anySchemaAttribute?))))
    	    </content>
    	  </schemaRepresentation>
    	</schemaRepresentationEg>
  
    	<p>Attributes indicated as <term>[ ignored ]</term> are not mapped
    	into the [XPath/XQuery] type system.</p>
  
    	<p>Attributes indicated as <term>[ not handled ]</term> are not
    	currently handled by the mapping.</p>
  
    	<p>Note that in order to simplify the mapping, it is assumed
    	that the default values for all attributes in the XML
    	Representation of Schema are filled in. For instance in the
    	above complex type, if the <code>mixed</code> attribute is not
    	present, it will be treated as being present and having the
    	value <code>"false"</code>.</p>
  
      </smschema>
  
      <smschemanorm>
  
    	<p>XML Schema import is specified by means of mapping
    	rules. All mapping rules have the structure below.</p>
  
    	<mapping>
    	  <xquery>
    	    <expression>
    	      <map><emph>SchemaComponent</emph></map><subscript>Subscript</subscript>
    	    </expression>
    	  </xquery>
    	  <core>
    	    <expression>
    	      <emph>TypeComponent</emph>
    	    </expression>
    	  </core>
    	</mapping>
  
    	<p>The <emph>SchemaComponent</emph> above the horizontal rule
    	denotes an XML Schema component before translation and the
    	<emph>TypeComponent</emph> beneath the horizontal rule denotes
    	an equivalent type component in the [XPath/XQuery] type system.</p>
  
      </smschemanorm>
  
      <smnotation>
  
    	<p>Whenever necessary for the mapping rules, specific grammar
    	productions which describe fragments of XML Schema may be
    	introduced. For instance, here are grammar productions used to
    	describes fragments of the XML Representation Summary for the
    	complexType Element Information Item.</p>
  
    	<scrap headstyle="show">
    	  <head>Complex type content</head>
  	
    	  <prod num="57 (Formal)" id="noid_N27ED1.doc-fs-ComplexTypeContent"><lhs>ComplexTypeContent</lhs><rhs>"annotation"?  ("simpleContent"  |  "complexContent"  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ChildrenContent" xlink:type="simple">ChildrenContent</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeContent" xlink:type="simple">AttributeContent</nt>))</rhs></prod>
    	  <prod num="60 (Formal)" id="noid_N27ED7.doc-fs-AttributeContent"><lhs>AttributeContent</lhs><rhs>("attribute"  |  "attributeGroup")*  "anyAttribute"?</rhs></prod>
    	  <prod num="58 (Formal)" id="noid_N27EDD.doc-fs-ChildrenContent"><lhs>ChildrenContent</lhs><rhs>("group"  |  "all"  |  "choice"  |  "sequence")?</rhs></prod>
    	</scrap>
   
    	<p>As in the rest of this document, some mapping rules may use
    	fragments of the XML Representation corresponding to the
    	syntactic categories defined by those grammar productions. For
    	instance, the following complex type fragment uses the
    	syntactic categories: <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>, <emph>ComplexTypeContent</emph>,
    	and <emph>AttributeContent</emph>, <emph>ChildrenContent</emph>, and
    	<emph>MixedAttribute</emph>.</p>
  
    	<schemaRepresentation>
    	  <name>complexType</name>
    	  <schemaAttribute>
    	     name = <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
    	  </schemaAttribute>
    	  <schemaAttribute>
    	     <emph>MixedAttribute</emph>
    	  </schemaAttribute>
    	  <content><emph>ChildrenContent</emph> <emph>AttributeContent</emph></content>
    	</schemaRepresentation>
  
      </smnotation>
    </div3>

    <div3 id="sec_import_mapping">
      <head>Main mapping rules</head>
    
      <smnotation>
        <p id="jd_map_schema">The normalization rule</p>

        <display>
  	  <mapping>
  	    <xquery>
              <expression>
  	         <map><emph>Schema</emph></map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
              </expression>
  	    </xquery>
  	    <core>
  	      <expression>
  	        <emph>Definitions</emph>
              </expression>
  	    </core>
  	  </mapping>
        </display>

        <p>maps a complete schema into a set of <emph>Definitions</emph> in
        the [XPath/XQuery] type system.</p>

  	<p id="jd_map_definition">The normalization rule</p>

  	<display>
  	  <mapping>
  	    <xquery>
              <expression>
  	         <map><emph>SchemaComponent</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression>
  	    </xquery>
  	    <core>
  	      <expression>
  	        <a href="#sec_top_level_definitions"><emph>Definition</emph></a>
              </expression>
  	    </core>
  	  </mapping>
  	</display>

        <p>maps a top level schema component into a <a href="#sec_top_level_definitions"><emph>Definition</emph></a> in
        the [XPath/XQuery] type system, given the target namespace
        <emph>target</emph><emph>AnyURI</emph>.</p>

  	<p id="jd_map_content">The normalization rule</p>
      	
  	<display>
  	  <mapping>
  	    <xquery>
              <expression>
  	         <map><emph>SchemaComponent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression>
  	    </xquery>
  	    <core>
  	      <expression>
  	        <emph>TypeComponent</emph>
              </expression>
  	    </core>
  	  </mapping>
  	</display>

        <p>maps a schema component not directly under the schema
        element, into a <emph>TypeComponent</emph> in the [XPath/XQuery]
        type system, given the target namespace <emph>target</emph><emph>AnyURI</emph>.</p>
      </smnotation>
    </div3>    

    <div3 id="sec_use">
      <head>Special attributes</head>
    
      <p>The XML Schema attributes: use, default, fixed, minOccurs,
      maxOccurs, mixed, nillable, and substitutionGroup, require
      specific mapping rules.</p>
    
      <div4 id="sec_import_attributes">
  	<head>use, default, and fixed</head>
      
  	<p>The <quote>use</quote>, <quote>default</quote>, and
        <quote>fixed</quote> attributes are used to describe the
        occurrence and default behavior of a given attribute.</p>
  
  	<smnotation>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the <quote>use</quote>, <quote>default</quote>, and
  	  <quote>fixed</quote> attributes.</p>
      
  	  <scrap headstyle="show">
  	    <head>Use, default, and fixed attributes</head>
  	  
  	    <prod num="61 (Formal)" id="doc-fs-UseAttribute"><lhs>UseAttribute</lhs><rhs>"use"  "="  ("optional"  |  "prohibited"  |  "required")</rhs></prod>
  	    <prod num="62 (Formal)" id="doc-fs-DefaultAttribute"><lhs>DefaultAttribute</lhs><rhs>"default"  "="  String</rhs></prod>
  	    <prod num="63 (Formal)" id="doc-fs-FixedAttribute"><lhs>FixedAttribute</lhs><rhs>"fixed"  "="  String</rhs></prod>
  	  </scrap>

  	  <p id="jd_map_use">The normalization rule</p>
      
  	  <display>
  	    <mapping>
  	      <xquery>
  		<expression>
  		  <map><emph>UseAttribute</emph> <emph>DefaultAttribute</emph>? <emph>FixedAttribute</emph>? </map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a>
  		</expression>
  	      </xquery>
  	      <core>
  		<expression>
  		  <emph>OccurrenceIndicator</emph>
  		</expression>
  	      </core>
  	    </mapping>
  	  </display>
  
  	  <p>maps a combination of a use attribute <emph>UseAttribute</emph>,
  	  along with an optional default or fixed attribute in Schema
  	  into the occurrence indicator <emph>OccurrenceIndicator</emph> in the
  	  [XPath/XQuery] type system.</p>
  	</smnotation>
  	  
  	<smschemanorm>
  	  <p>Use attributes are mapped to the type system in the
  	  following way. In case there is a default or fixed
  	  attribute, the attribute is always present in the PSVI and
  	  the use attribute is ignored.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><emph>UseAttribute</emph> <emph>DefaultAttribute</emph><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>1</expression>
  	    </core>
  	  </mapping>
  	
  	  <mapping>
  	    <xquery>
  	      <expression><emph>UseAttribute</emph> <emph>FixedAttribute</emph><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>1</expression>
  	    </core>
  	  </mapping>
  	
  	  <mapping>
  	    <xquery>
  	      <expression>use = <quote>optional</quote><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>?</expression>
  	    </core>
  	  </mapping>
  	
  	  <mapping>
  	    <xquery>
  	      <expression>use = <quote>required</quote><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>1</expression>
  	    </core>
  	  </mapping>
  	
  	  <ednote>
  	    <edtext>Issue: how derivation of attribute declaration and
  	    the <quote>prohibited</quote> use attributes are mapped in
  	    the [XPath/XQuery] type system is still an open
  	    issue.</edtext>
  	  </ednote>
  
  	</smschemanorm>
      </div4>

      <div4 id="prod-formal-OccursAttributes"> 
  	<head>minOccurs, maxOccurs, minLength, maxLength, and length</head>
    
  	<smnotation>
  	  <p>The following auxiliary grammar productions are used to
  	  describe occurrence attributes and the length facets.</p>
  	  
  	  <scrap headstyle="show">
  	    <head>Occurrence attributes</head>
  	  
  	    <prod num="56 (Formal)" id="doc-fs-OccursAttributes"><lhs>OccursAttributes</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-maxOccurs" xlink:type="simple">maxOccurs</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-minOccurs" xlink:type="simple">minOccurs</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-maxLength" xlink:type="simple">maxLength</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-minLength" xlink:type="simple">minLength</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-length" xlink:type="simple">length</nt></rhs></prod>
  	    <prod num="54 (Formal)" id="doc-fs-maxOccurs"><lhs>maxOccurs</lhs><rhs>"maxOccurs"  "="  ("nonNegativeInteger"  |  "unbounded")</rhs></prod>
  	    <prod num="55 (Formal)" id="doc-fs-minOccurs"><lhs>minOccurs</lhs><rhs>"minOccurs"  "="  "nonNegativeInteger"</rhs></prod>
  	    <prod num="51 (Formal)" id="doc-fs-maxLength"><lhs>maxLength</lhs><rhs>"maxLength"  "="  "nonNegativeInteger"</rhs></prod>
  	    <prod num="52 (Formal)" id="doc-fs-minLength"><lhs>minLength</lhs><rhs>"minLength"  "="  "nonNegativeInteger"</rhs></prod>
  	    <prod num="53 (Formal)" id="doc-fs-length"><lhs>length</lhs><rhs>"length"  "="  "nonNegativeInteger"</rhs></prod>
  	  </scrap>
  
  	  <p id="jd_map_occurs">The normalization rule</p>
      
  	  <display>
  	    <mapping>
  	      <xquery>
  		<expression>
  		  <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a>
  		</expression>
  	      </xquery>
  	      <core>
  		<expression>
  		  <emph>OccurrenceIndicator</emph>
  		</expression>
  	      </core>
  	    </mapping>
  	  </display>
  
  	  <p>maps the occurrence attributes and facets <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a> in
  	  Schema into the occurrence indicator <emph>OccurrenceIndicator</emph> in the
  	  [XPath/XQuery] type system.</p>
  	</smnotation>
  	  
  	<smschemanorm>
  	  
  	  <p>Occurrence attributes are mapped to the type system in
  	  the following way.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minOccurs="0" maxOccurs="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>?</expression>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minOccurs="1" maxOccurs="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression/>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minOccurs="0" maxOccurs="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>*</expression>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minOccurs="1" maxOccurs="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>+</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>where <expression>n &gt; 1</expression>.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minOccurs="n" maxOccurs="m"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>+</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>where <expression>m &gt;= n &gt; 1</expression></p>

  	  <mapping>
  	    <xquery>
  	      <expression><map>minLength="0" maxLength="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>?</expression>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minLength="1" maxLength="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression/>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minLength="0" maxLength="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>*</expression>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minLength="1" maxLength="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>+</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>where <expression>n &gt; 1</expression>.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>minLength="n" maxLength="m"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>+</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>where <expression>m &gt;= n &gt; 1</expression></p>

  	  <mapping>
  	    <xquery>
  	      <expression><map>length="1"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression/>
  	    </core>
  	  </mapping>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression><map>length="n"</map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
  	    </xquery>
  	    <core>
  	      <expression>+</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>where <expression>n &gt; 1</expression></p>
  	</smschemanorm>
      </div4>
  
      <div4 id="sec_import_mixed">
  	<head>mixed</head>
    
  	<smnotation>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the <quote>mixed</quote> attribute.</p>
    
  	  <scrap headstyle="show">
  	    <head>Mixed attribute</head>
  	  
  	    <prod num="48 (Formal)" id="doc-fs-MixedAttribute"><lhs>MixedAttribute</lhs><rhs>"mixed"  "="  Boolean</rhs></prod>
  	  </scrap>
  
  	  <p id="jd_map_mixed">The normalization rule</p>
      
  	  <display>
  	    <mapping>
  	      <xquery>
  		<expression>
  		  <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  		</expression>
  	      </xquery>
  	      <core>
  		<expression>
  		  <a href="#doc-fs-Mixed"><emph>Mixed</emph></a>
  		</expression>
  	      </core>
  	    </mapping>
  	  </display>
  
  	  <p>maps the mixed attribute <emph>MixedAttribute</emph> in Schema into
  	  a <a href="#doc-fs-Mixed"><emph>Mixed</emph></a> notation in the [XPath/XQuery] type system.</p>
  	</smnotation>
  	  
  	<smschemanorm>
  	  <p>If the mixed attribute is true it is mapped to a mixed
  	  notation in the [XPath/XQuery] type system.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression>
  		<map>
  		  mixed = <quote>true</quote>
  	      </map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  	    </expression>
  	    </xquery>
  	    <core>
  	      <expression>mixed</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>If the mixed attribute is false it is mapped to empty in
  	  the [XPath/XQuery] type system.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression>
  		<map>
  		  mixed = <quote>false</quote>
  		</map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a>
  	    </expression>
  	    </xquery>
  	    <core>
  	      <expression/>
  	    </core>
  	  </mapping>
  	
  	</smschemanorm>
      </div4>
    
      <div4 id="sec_import_nillable">
  	<head>nillable</head>
    
  	<smnotation>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the <quote>nillable</quote> attribute.</p>
    
  	  <scrap headstyle="show">
  	    <head>Nillable attribute</head>
  	  
  	    <prod num="49 (Formal)" id="doc-fs-NillableAttribute"><lhs>NillableAttribute</lhs><rhs>"nillable"  "="  Boolean</rhs></prod>
  	  </scrap>
  
  	  <p id="jd_map_nillable">The normalization rule</p>
      
  	  <display>
  	    <mapping>
  	      <xquery>
  		<expression>
  		  <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  		</expression>
  	      </xquery>
  	      <core>
  		<expression>
  		  <a href="#doc-fs-Nillable"><emph>Nillable</emph></a>
  		</expression>
  	      </core>
  	    </mapping>
  	  </display>
  
  	  <p>maps the nillable attribute <emph>NillableAttribute</emph> in
  	  Schema into a <a href="#doc-fs-Nillable"><emph>Nillable</emph></a> notation in the [XPath/XQuery] type
  	  system.</p>
  	</smnotation>
  	  
  	<smschemanorm>
  	  <p>If the nillable attribute is true it is mapped to a
  	  nillable notation in the [XPath/XQuery] type system.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression>
  		<map>
  		  nillable = <quote>true</quote>
  	      </map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  	    </expression>
  	    </xquery>
  	    <core>
  	      <expression>nillable</expression>
  	    </core>
  	  </mapping>
  	  
  	  <p>If the nillable attribute is false it is mapped to empty
  	  in the [XPath/XQuery] type system.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression>
  		<map>
  		  nillable = <quote>false</quote>
  		</map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
  	    </expression>
  	    </xquery>
  	    <core>
  	      <expression/>
  	    </core>
  	  </mapping>
  	
  	</smschemanorm>
      </div4>
    
      <div4 id="sec_import_substitution">
  	<head>substitutionGroup</head>
    
  	<smnotation>
  	  <p>The substitution group declaration indicates the element
  	  that a given element can be substituted for. The following
  	  auxiliary grammar productions are used to describe the
  	  <quote>substitutionGroup</quote> attribute.</p>
    
  	  <scrap headstyle="show">
  	    <head>substitutionGroup attribute</head>
  	  
  	    <prod num="50 (Formal)" id="doc-fs-substitutionGroupAttribute"><lhs>substitutionGroupAttribute</lhs><rhs>"substitutionGroup"  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-core-QName" xlink:type="simple">QName</nt></rhs></prod>
  	  </scrap>
  
  	  <p id="jd_map_substitution">The normalization rule</p>
      
  	  <display>
  	    <mapping>
  	      <xquery>
  		<expression>
  		  <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
  		</expression>
  	      </xquery>
  	      <core>
  		<expression>
  		  <emph>Substitution</emph>
  		</expression>
  	      </core>
  	    </mapping>
  	  </display>
  
  	  <p>maps the substitutionGroup attribute
  	  <emph>substitutionGroupAttribute</emph> in Schema into a
  	  <emph>Substitution</emph> notation in the [XPath/XQuery] type
  	  system.</p>
  	</smnotation>
  	  
  	<smschemanorm>
  	  <p>If the substitutionGroup attribute is present, it is
  	  mapped to a substitutionGroup notation in the [XPath/XQuery]
  	  type system.</p>
  	  
  	  <mapping>
  	    <xquery>
  	      <expression>
  		<map>
  		  substitutionGroup = <emph>QName</emph>
  	      </map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
  	    </expression>
  	    </xquery>
  	    <core>
  	      <expression>substitutes for <emph>QName</emph></expression>
  	    </core>
  	  </mapping>

  	  <p>Otherwise, it is mapped to empty.</p>
  	</smschemanorm>
      </div4>
    
    </div3>

    <div3 id="sec_import_anonymous">
      <head>Anonymous type names</head>

      <smnotation>
        <p>As explained in <specref ref="sec_types"/>, the [XPath/XQuery]
        type uses system-generated type names for anonymous types. For
        the purpose of this document those type names are generated at
        XML Schema import time.</p>
      </smnotation>
    </div3>
  </div2>

  <div2 id="sec_schema_as_a_whole">
    <head>Schemas as a whole</head>

    <div3 id="sec_import_whole">
      <head>Schema</head>

      <smschema>
        <p>A schema is represented in XML by the following
        structure.</p>
  
        <schemaRepresentationEg>
        <schemaRepresentation>
          <name>schema</name>
          <schemaAttribute role="nothandled">
             attributeFormDefault = (qualified | unqualified) : unqualified
          </schemaAttribute>
          <schemaAttribute role="ignored">
             blockDefault = (#all | List of (extension | restriction | substitution))  : ' '
          </schemaAttribute>
          <schemaAttribute role="nothandled">
             elementFormDefault = (qualified | unqualified) : unqualified
          </schemaAttribute>
          <schemaAttribute role="ignored">
             finalDefault = (#all | List of (extension | restriction)) :  ' '
          </schemaAttribute>
          <schemaAttribute role="ignored">
             id = ID
          </schemaAttribute>
          <schemaAttribute>
             targetNamespace = anyURI
          </schemaAttribute>
          <schemaAttribute role="ignored">
             version = token
          </schemaAttribute>
          <schemaAttribute role="ignored">
             xml:lang = language
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
            Content: ((include | import | redefine | annotation)*,
            (((simpleType | complexType | group | attributeGroup) |
            element | attribute | notation), annotation*)*)
          </content>
        </schemaRepresentation>
        </schemaRepresentationEg>
  
      </smschema>
  
      <smnotation>
        <p>The following auxiliary grammar productions are used.</p>
  
        <scrap headstyle="show">
          <head>XML Schema Pragma and Content</head>
        
          <prod num="46 (Formal)" id="doc-fs-SPragma"><lhs>SPragma</lhs><rhs>("include"  |  "import"  |  "redefine"  |  "annotation")*</rhs></prod>
          <prod num="47 (Formal)" id="doc-fs-Content"><lhs>Content</lhs><rhs>(("simpleType"  |  "complexType"  |  "element"  |  "attribute"  |  "attributeGroup"  |  "group"  |  "notation")  "annotation"*)*</rhs></prod>
        </scrap>
   
        <p id="jd_map_pragma">The auxiliary normalization rule</p>
    
        <display>
          <mapping>
            <xquery>
              <expression>
                <map><emph>Pragma</emph></map><a href="#jd_map_pragma" class="judgment"><subscript>pragma(<emph>target</emph><emph>AnyURI</emph>)</subscript></a>
              </expression>
            </xquery>
            <core>
              <expression>
                <emph>Definitions</emph>
              </expression>
            </core>
          </mapping>
        </display>
    
        <p>maps the a schema pragma into a set of definitions in the
        [XPath/XQuery] type system.</p>
      </smnotation>

      <smschemanorm>
        <p>Schemas are imported by the <quote>schema</quote>
        declaration in the preamble of a query. To import a schema,
        the document referred to by the given URI is opened and the
        schema declarations contained in the document are translated
        into the corresponding in-line type definitions.  The
        mechanism for finding a schema document, possibly using the
        optional schema location hint, is not specified formally. </p>
  
        <mapping>
          <xquery>
            <expression>
              <map>schema <emph>StringLiteral</emph> (at <emph>StringLiteral</emph>)?</map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>
              <map>open-schema-document(<emph>StringLiteral</emph> (at <emph>StringLiteral</emph>)?)</map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
            </expression>
          </core>
        </mapping>
  
        <mapping>
          <xquery>
            <expression>
             <map>
                 <schemaRepresentation>
                   <name>schema</name>
                   <schemaAttribute>
                      targetNamespace = <emph>target</emph><emph>AnyURI</emph>
                   </schemaAttribute>
                   <content>
                     <emph>Pragma</emph> <emph>Content</emph>
                   </content>
                 </schemaRepresentation>
             </map><a href="#jd_map_schema" class="judgment"><subscript>Schema</subscript></a>
           </expression>
          </xquery>
          <core>
            <expression>
                <map><emph>Pragma</emph></map><a href="#jd_map_pragma" class="judgment"><subscript>pragma(<emph>target</emph><emph>AnyURI</emph>)</subscript></a>
                <map><emph>Content</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </core>
        </mapping>
      </smschemanorm>

    </div3>

    <div3 id="sec_import_include">
      <head>Include</head>

        <smschema>
          <p>A schema include is represented in XML by the following
          structure.</p>
  
          <schemaRepresentationEg>
            <schemaRepresentation>
              <name>include</name>
              <schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute>
              <schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute>
              <schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute>
              <content>
                Content: (annotation?)
              </content>
            </schemaRepresentation>
          </schemaRepresentationEg>

        </smschema>

        <smschemanorm>

          <p>A schema include is not specified here, and is assumed
          to be handled by the XML Schema processor.</p>
        </smschemanorm>
      </div3>

      <div3 id="sec_import_redefine">
        <head>Redefine</head>

        <smschema>
          <p>A schema redefinition is represented in XML by the
          following structure.</p>

          <schemaRepresentationEg>
            <schemaRepresentation>
              <name>redefine</name>
              <schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute>
              <schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute>
              <schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute>
              <content>
                Content: (annotation | (simpleType | complexType | group | attributeGroup))*
              </content>
            </schemaRepresentation>
          </schemaRepresentationEg>

        </smschema>

        <smschemanorm>

          <p>A schema redefine is not specified here, and is assumed
          to be handled by the XML Schema processor.</p>

        </smschemanorm>

      </div3>

      <div3 id="sec_import_import">
        <head>Import</head>

        <smschema>
          <p>A schema import is represented in XML by the following
          structure.</p>

          <schemaRepresentationEg>
            <schemaRepresentation>
              <name>import</name>
              <schemaAttribute role="ignored">
                 id = ID
              </schemaAttribute>
              <schemaAttribute>
                 namespace = anyURI
              </schemaAttribute>
              <schemaAttribute>
                 schemaLocation = anyURI
              </schemaAttribute>
              <schemaAttribute role="ignored">
                 {any attributes with non-schema namespace ...}
              </schemaAttribute>
              <content>
                Content: (annotation?)
              </content>
            </schemaRepresentation>
          </schemaRepresentationEg>

        </smschema>

        <smschemanorm>
          <p>A schema import is not specified here, and is assumed to
          be handled by the XML Schema processor.</p>
        </smschemanorm>
      </div3>
    </div2>

  <div2 id="sec_import_attribute_decl">
    <head>Attribute Declarations</head>

    <smschema>
      <p>The following structure describes attribute declarations in
      XML Schema.</p>
  
    	<schemaRepresentationEg>
    	  <schemaRepresentation>
    	    <name>attribute</name>
    	    <schemaAttribute role="nothandled">
    	       default = string
    	    </schemaAttribute>
    	    <schemaAttribute role="nothandled">
    	       fixed = string
    	    </schemaAttribute>
    	    <schemaAttribute role="nothandled">
    	       form = (qualified | unqualified)
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       name = NCName
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       ref = QName
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       type = QName
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       use = (optional | prohibited | required) : optional
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       {any attributes with non-schema namespace ...}
    	    </schemaAttribute>
    	    <content>
    	      Content: (annotation?, (simpleType?))
    	    </content>
    	  </schemaRepresentation>
    	</schemaRepresentationEg>
    </smschema>
  
    <div3 id="sec_import_global_attributes">
      <head>Global attributes declarations</head>
  
      <p>Schema import distinguishes between global attribute
      declarations and local attribute declarations.</p>
  
      <smschemanorm>
        <p>Global attribute declarations are mapped like local
        attribute declarations, but are prefixed by a
        <quote>define</quote> keyword in the [XPath/XQuery] type
        system.</p>
  
        <mapping>
          <xquery>
            <expression><map><emph>AttributeDecl</emph></map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
          </xquery>
          <core>
            <expression>define <map><emph>AttributeDecl</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
          </core>
        </mapping>
      </smschemanorm>
    </div3>
  
    <div3 id="sec_import_local_attributes">
      <head>Local attribute declarations</head>
  
      <smschemanorm>
        <p>Local attributes whose type is given by a reference to a
        global type name are mapped in the type system as
        follows.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	  	  <schemaRepresentationNoContent>
    	  	    <name>attribute</name>
    	  	    <schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute>
    	  	    <schemaAttribute>
    	  	       type = <emph>QName</emph>
    	  	    </schemaAttribute>
    	  	    <schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute>
    	  	  </schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( attribute <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph> {
            of type <emph>QName</emph> }
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
          </core>
        </mapping>
    
        <p>References to a global attribute are mapped in the type
        system as follows.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	  	  <schemaRepresentationNoContent>
    	  	    <name>attribute</name>
    	  	    <schemaAttribute>
    	  	       ref = <emph>QName</emph>
    	  	    </schemaAttribute>
    	  	    <schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute>
    	  	  </schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( attribute <emph>QName</emph>
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression>
          </core>
        </mapping>
    
        <p>A local attribute with a local content is mapped to the
        [XPath/XQuery] type system as follows. Let <emph>fs:</emph>anon<subscript>k</subscript> be a newly
        generated anonymous name.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	  	  <schemaRepresentation>
    	  	    <name>attribute</name>
    	  	    <schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute>
    	  	    <schemaAttribute>
    	  	       <emph>UseAttribute</emph>
    	  	    </schemaAttribute>
    	    	    <content>
    	    	      <emph>simpleType</emph>
    	    	    </content>
    	  	  </schemaRepresentation>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>
            <table><tbody>
            <tr><td rowspan="1" colspan="1"><expression>( attribute <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph> of
            type <emph>fs:</emph>anon<subscript>k</subscript>
            )<map><emph>UseAttribute</emph></map><a href="#jd_map_use" class="judgment"><subscript>use</subscript></a></expression></td></tr>
            <tr><td rowspan="1" colspan="1">  with</td></tr>
            <tr><td rowspan="1" colspan="1"><expression>define type <emph>fs:</emph>anon<subscript>k</subscript> of type
            xs:anySimpleType {
            <map><emph>simpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a> }</expression></td></tr> 
            </tbody>
            </table>
            </expression>
          </core>
        </mapping>

    
      </smschemanorm>
    </div3>
  </div2>

  <div2 id="sec_import_element">
    <head>Element Declarations</head>
  
    <smschema>
      <p>The following structure describes attribute declarations in
      XML Schema.</p>
  
      <schemaRepresentationEg>
        <schemaRepresentation>
          <name>element</name>
          <schemaAttribute role="ignored">
            abstract = boolean : false
          </schemaAttribute>
    	  <schemaAttribute role="ignored">
    	    block = (#all | List of (extension | restriction))
    	  </schemaAttribute>
          <schemaAttribute role="nothandled">
            default = string
          </schemaAttribute>
    	  <schemaAttribute role="ignored">
    	    final = (#all | List of (extension | restriction))
    	  </schemaAttribute>
          <schemaAttribute role="nothandled">
            fixed = string
          </schemaAttribute>
          <schemaAttribute role="nothandled">
            form = (qualified | unqualified)
          </schemaAttribute>
          <schemaAttribute role="ignored">
            id = ID
          </schemaAttribute>
    	  <schemaAttribute>
    	    maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	  </schemaAttribute>
    	  <schemaAttribute>
    	    minOccurs = nonNegativeInteger : 1
    	  </schemaAttribute>
          <schemaAttribute>
            name = NCName
          </schemaAttribute>
          <schemaAttribute>
            nillable = boolean : false
          </schemaAttribute>
          <schemaAttribute>
            ref = QName
          </schemaAttribute>
          <schemaAttribute>
            substitutionGroup = QName
          </schemaAttribute>
          <schemaAttribute>
             type = QName
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
            Content: (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
          </content>
        </schemaRepresentation>
      </schemaRepresentationEg>
    </smschema>

    <div3 id="sec_import_global_element">
      <head>Global element declarations</head>
  
      <p>Schema import distinguishes between global element
      declarations and local element declarations.</p>
  
      <smschemanorm>
        <p>Global element declarations are mapped like local element
        declarations, but are prefixed by a <quote>define</quote>
        keyword in the [XPath/XQuery] type system.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
        	<schemaRepresentationNoContent>
        	  <name>element</name>
        	  <schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>substitutionGroupAttribute</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    type = <emph>QName</emph>
        	  </schemaAttribute>
        	</schemaRepresentationNoContent>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>define element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>QName</emph></expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression>
              <map>
        	<schemaRepresentation>
        	  <name>element</name>
        	  <schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>substitutionGroupAttribute</emph>
        	  </schemaAttribute>
        	  <content>
        	    <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>
        	  </content>
        	</schemaRepresentation>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>define element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>substitutionGroupAttribute</emph></map><a href="#jd_map_substitution" class="judgment"><subscript>substitution</subscript></a>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a>
            <map><a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
          </core>
        </mapping>

      </smschemanorm>
    </div3>

    <div3 id="sec_import_local_element">
      <head>Local element declarations</head>
  
      <smschemanorm>
        <p>Local element declarations, but mapped into corresponding
        notations in the [XPath/XQuery] type system. Note that
        substitution group cannot be declared on local elements.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
        	<schemaRepresentationNoContent>
        	  <name>element</name>
    	    	  <schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute>
        	  <schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    type = <emph>QName</emph>
        	  </schemaAttribute>
        	</schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( element <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>QName</emph> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression>
              <map>
        	<schemaRepresentationNoContent>
        	  <name>element</name>
    	    	  <schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute>
        	  <schemaAttribute>
        	    ref = <emph>QName</emph>
        	  </schemaAttribute>
        	</schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( element <emph>QName</emph> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>

        <p>Let <emph>fs:</emph>anon<subscript>k</subscript> be a newly generated anonymous name.</p>

        <mapping>
          <xquery>
            <expression>
              <map>
        	<schemaRepresentation>
        	  <name>element</name>
    	    	  <schemaAttribute>
          	    <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	  </schemaAttribute>
        	  <schemaAttribute>
        	    name = <emph>NCName</emph>
        	  </schemaAttribute>
        	  <schemaAttribute>
        	    <emph>NillableAttribute</emph>
        	  </schemaAttribute>
        	  <content>
        	    <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>
        	  </content>
        	</schemaRepresentation>
              </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>
            <table><tbody>
            <tr><td rowspan="1" colspan="1"><expression>( element
            <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>NillableAttribute</emph></map><a href="#jd_map_nillable" class="judgment"><subscript>nillable</subscript></a> of type
            <emph>fs:</emph>anon<subscript>k</subscript> )
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression></td></tr>
            <tr><td rowspan="1" colspan="1">  with</td></tr>
            <tr><td rowspan="1" colspan="1"><expression>define type <emph>fs:</emph>anon<subscript>k</subscript>
            <map><a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression></td></tr>
            </tbody>
            </table>
            </expression>
          </core>
        </mapping>
      </smschemanorm>
    </div3>
  </div2>

  <div2 id="sec_complex_type">
    <head>Complex Type Definitions</head>
  
    <smschema>
      <p>A complex type definition is represented in XML by the
      following structure.</p>
  
    	<schemaRepresentationEg>
    	  <schemaRepresentation>
    	    <name>complexType</name>
    	    <schemaAttribute role="ignored">
    	       abstract = boolean : false
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       block = (#all | List of (extension | restriction))
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       final = (#all | List of (extension | restriction))
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       id = ID
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       mixed = boolean : false
    	    </schemaAttribute>
    	    <schemaAttribute>
    	       name = NCName
    	    </schemaAttribute>
    	    <schemaAttribute role="ignored">
    	       {any attributes with non-schema namespace ...}
    	    </schemaAttribute>
    	    <content>
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((attribute |
    	      attributeGroup)*, anyAttribute?))))
    	    </content>
    	  </schemaRepresentation>
    	</schemaRepresentationEg>
    </smschema>
  
    <smnotation>
      <p>The following auxiliary grammar productions are used to
      describe the content of a complex type definition.</p>
  
      <scrap headstyle="show">
        <head>Complex type content</head>
  
        <prod num="57 (Formal)" id="doc-fs-ComplexTypeContent"><lhs>ComplexTypeContent</lhs><rhs>"annotation"?  ("simpleContent"  |  "complexContent"  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-ChildrenContent" xlink:type="simple">ChildrenContent</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-fs-AttributeContent" xlink:type="simple">AttributeContent</nt>))</rhs></prod>
    	<prod num="60 (Formal)" id="doc-fs-AttributeContent"><lhs>AttributeContent</lhs><rhs>("attribute"  |  "attributeGroup")*  "anyAttribute"?</rhs></prod>
    	<prod num="58 (Formal)" id="doc-fs-ChildrenContent"><lhs>ChildrenContent</lhs><rhs>("group"  |  "all"  |  "choice"  |  "sequence")?</rhs></prod>
      </scrap>
  
    </smnotation>
  
    <div3 id="sec_import_global_complex_type">
      <head>Global complex type</head>
  
      <p>Schema import distinguishes between global complex types
      (which are mapped to sort declarations) and local complex types
      (which are mapped to type definitions).</p>
  
      <smschemanorm>
        <p>In the case of global complex types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	  	  <schemaRepresentation>
    	  	    <name>complexType</name>
    	  	    <schemaAttribute>
    	  	       <emph>MixedAttribute</emph>
    	  	    </schemaAttribute>
    	  	    <schemaAttribute>
    	  	       name = <emph>NCName</emph>
    	  	    </schemaAttribute>
    	  	    <content>
    	  	       <emph>ComplexTypeContent</emph>
    	  	    </content>
    	  	  </schemaRepresentation>
            </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression>define type <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
            <map><emph>MixedAttribute</emph>
            <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
          </core>
        </mapping>
  
        <p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p>
      </smschemanorm>
  
    </div3>
  
    <div3 id="sec_import_local_complex_type">
      <head>Local complex type</head>
  
      <smschemanorm>
        <p>In the case of a local complex types, there must not be a
        name attribute and the mapping rule which applies is denoted
        by <map/><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	  	  <schemaRepresentation>
    	  	    <name>complexType</name>
    	  	    <schemaAttribute>
    	  	       <emph>MixedAttribute</emph>
    	  	    </schemaAttribute>
    	  	    <content>
    	  	       <emph>ComplexTypeContent</emph>
    	  	    </content>
    	  	  </schemaRepresentation>
            </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression><map><emph>MixedAttribute</emph>
            <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
          </core>
        </mapping>
  
        <p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p>
      </smschemanorm>
  
    </div3>
  
    <div3 id="sec_import_ct_simple">
      <head>Complex type with simple content</head>
  
    	<smschema>
    	  <p>A complex type can be of simple content. A simple content
    	  is represented in XML by the following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>simpleContent</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, (restriction | extension))
    	      </content>
    	    </schemaRepresentation>
        </schemaRepresentationEg>
  
        <p>Derivation by restriction inside a simple content is
        represented in XML by the following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>restriction</name>
    	      <schemaAttribute>
    		 base = QName
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, (simpleType?, (minExclusive |
    		minInclusive | maxExclusive | maxInclusive |
    		totalDigits | fractionDigits | length | minLength |
    		maxLength | enumeration | whiteSpace | pattern)*)?,
    		((attribute | attributeGroup)*, anyAttribute?))
    	      </content>
    	    </schemaRepresentation>
        </schemaRepresentationEg>
  
        <p>Derivation by extension inside a simple content is
        represented in XML by the following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>extension</name>
    	      <schemaAttribute>
    		 <term>base</term> = QName
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
              Content: (annotation?, ((attribute | attributeGroup)*,
              anyAttribute?))
    	      </content>
    	    </schemaRepresentation>
        </schemaRepresentationEg>
      </smschema>

      <smnotation>
        <p id="jd_map_mixed_content">The normalization rule</p>
      
        <display>
          <mapping>
            <xquery>
              <expression>
                <map><emph>MixedAttribute</emph> <emph>ComplexTypeContent</emph></map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              </expression>
            </xquery>
            <core>
              <expression>
                <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
              </expression>
            </core>
          </mapping>
        </display>
      
        <p>maps a pair of mixed attribute and complex type content to
        a type derivation.</p>
      </smnotation>
  
      <smschemanorm>
        <p>A complex types with simple content must not have a
        <code>mixed</code> attribute set to <quote>true</quote>.</p>
  
        <p>If the simple content is derived by restriction, it is
        mapped into a simple type restriction in the [XPath/XQuery] type
        system. Only the name of the base atomic type and attributes
        are mapped, while the actual simple type restriction is
        ignored. (Remember that facets are not captured in the
        [XPath/XQuery] type system.)</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
                <table summary="">
                <tbody>
                <tr>
                <td rowspan="1" colspan="1">mixed = <quote>false</quote></td>
                <td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute>
    	  	    <name>simpleContent</name>
    	  	    <content>
    	    	      <schemaRepresentation>
    	    		<name>restriction</name>
    	    		<schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute>
    	    		<content>
    	 		  <emph>simpleContentRestriction</emph> <emph>AttributeContent</emph>
    	    		</content>
    	    	      </schemaRepresentation>
    	  	    </content>
    	  	  </schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression>restricts <emph>QName</emph> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <emph>QName</emph> }</expression>
          </core>
        </mapping>
  
        <p>If the simple type is derived by extension, it is mapped
        into an extended type specifier into the [XPath/XQuery] type
        system.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
                <table summary="">
                <tbody>
                <tr>
                <td rowspan="1" colspan="1">mixed = <quote>false</quote></td>
                <td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute>
    	  	    <name>simpleContent</name>
    	  	    <content>
    	    	      <schemaRepresentation>
    	    		<name>extension</name>
    	    		<schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute>
    	    		<content>
    	 		  <emph>AttributeContent</emph>
    	    		</content>
    	    	      </schemaRepresentation>
    	  	    </content>
    	  	  </schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression>extends <emph>QName</emph> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression>
          </core>
        </mapping>
  
      </smschemanorm>
  
    </div3>
  
    <div3 id="sec_import_ct_complex">
      <head>Complex type with complex content</head>
  
    	<smschema>
    	  <p>A complex type can be of complex content. A complex
    	  content is represented in XML by the following
    	  structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>complexContent</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
            <schemaAttribute>
        	 mixed = boolean : false
            </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
               Content: (annotation?, (restriction | extension))
    	      </content>
    	    </schemaRepresentation>
        </schemaRepresentationEg>
  
        <p>Derivation by restriction inside a complex content is
        represented in XML by the following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>restriction</name>
    	      <schemaAttribute>
    		 base = QName
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
               Content: (annotation?, (group | all | choice |
               sequence)?, ((attribute | attributeGroup)*,
               anyAttribute?))
            </content>
    	    </schemaRepresentation>
        </schemaRepresentationEg>
  
        <p>Derivation by extension inside a complex content is
        represented in XML by the following structure.</p>
  
        <schemaRepresentationEg>
          <schemaRepresentation>
            <name>extension</name>
            <schemaAttribute>
               <term>base</term> = QName
            </schemaAttribute>
            <schemaAttribute role="ignored">
               id = ID
            </schemaAttribute>
            <schemaAttribute role="ignored">
               {any attributes with non-schema namespace ...}
            </schemaAttribute>
            <content>
            Content: (annotation?, ((group | all | choice |
            sequence)?, ((attribute | attributeGroup)*,
            anyAttribute?)))
            </content>
          </schemaRepresentation>
        </schemaRepresentationEg>
      </smschema>
  
      <smschemanorm>
        <p>If the complex content is derived by restriction, it is
        mapped into a type restriction in the [XPath/XQuery] type
        system, and the </p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
                <table summary="">
                <tbody>
                <tr>
                <td rowspan="1" colspan="1"><emph>MixedAttribute</emph></td>
                <td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute>
    	  	    <name>complexContent</name>
    	  	    <content>
    	    	      <schemaRepresentation>
    	    		<name>restriction</name>
    	    		<schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute>
    	    		<content>
    	 		  <emph>annotation</emph>? <emph>ChildrenContent</emph> <emph>AttributeContent</emph>
    	    		</content>
    	    	      </schemaRepresentation>
    	  	    </content>
    	  	  </schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression>restricts <emph>QName</emph>
            <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <map><emph>ChildrenContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression>
          </core>
        </mapping>
  
        <p>If the complex content is derived by extension, it is
        mapped into an extended type specifier into the [XPath/XQuery]
        type system.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
                <table summary="">
                <tbody>
                <tr>
                <td rowspan="1" colspan="1"><emph>MixedAttribute</emph></td>
                <td rowspan="1" colspan="1">
   	  	  <schemaRepresentationNoAttribute>
    	  	    <name>complexContent</name>
    	  	    <content>
    	    	      <schemaRepresentation>
    	    		<name>extension</name>
    	    		<schemaAttribute>
    	 		   base = <emph>QName</emph>
    	    		</schemaAttribute>
    	    		<content>
    	 		  <emph>annotation</emph>? <emph>ChildrenContent</emph> <emph>AttributeContent</emph>
    	    		</content>
    	    	      </schemaRepresentation>
    	  	    </content>
    	  	  </schemaRepresentationNoAttribute>
               </td></tr></tbody></table>
            </map><a href="#jd_map_mixed_content" class="judgment"><subscript>mixed_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
          </expression>
          </xquery>
          <core>
            <expression>extends <emph>QName</emph>
            <map><emph>MixedAttribute</emph></map><a href="#jd_map_mixed" class="judgment"><subscript>mixed</subscript></a> {
            <map><emph>AttributeContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            <map><emph>ChildrenContent</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            }</expression>
          </core>
        </mapping>
  
      </smschemanorm>
  
    </div3>
  
  </div2>

  <div2 id="sec_attribute_use">
    <head>Attribute Uses</head>
  
    <p>Mapping for attribute uses is given in <specref ref="sec_use"/>.</p>
  </div2>
  
  <div2 id="sec_attribute_group">
    <head>Attribute Group Definitions</head>
  
    <div3 id="sec_attribute_group_def">
      <head>Attribute group definitions</head>
  
    	<smschema>
    	  <p>Model group definitions are represented in XML by the
    	  following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>attributeGroup</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   name = NCame
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   ref = QName
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, ((attribute | attributeGroup)*,
    		anyAttribute?))
    	      </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
    	<smschemanorm>
    	  <p>Attribute group definitions are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p>
    	</smschemanorm>
    </div3>
  
    <div3 id="sec_import_attribute_group_ref">
      <head>Attribute group reference</head>
  
    	<smschemanorm>
    	  <p>Attribute group references are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p>
    	</smschemanorm>
    </div3>
  </div2>
  
  <div2 id="sec_import_model">
    <head>Model Group Definitions</head>
  
    <smschema>
      <p>Model group definitions are represented in XML by the
      following structure.</p>
  
    	<schemaRepresentationEg>
    	  <schemaRepresentation>
    	    <name>group</name>
    	    <schemaAttribute>
    		 <term>name</term> = NCame
    	    </schemaAttribute>
    	    <content>
            Content: (annotation?, (all | choice | sequence))
    	    </content>
    	  </schemaRepresentation>
      </schemaRepresentationEg>
    </smschema>
  
    <smschemanorm>
      <p>Model group definitions are not currently handled by the
      mapping. See Issue 501 (FS-Issue-0158).</p>
    </smschemanorm>
  </div2>

  <div2 id="sec_import_model_groups">
    <head>Model Groups</head>
  
    <p>Model groups are either <quote>all</quote>,
    <quote>sequence</quote> or <quote>choice</quote>. One can also
    refer to a model group definition.</p>
  
    <div3 id="sec_import_all_groups">
      <head>All groups</head>
  	
    	<smschema>
    	  <p>All groups are represented in XML by the following
    	  structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>all</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 maxOccurs = 1 : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 minOccurs = (0 | 1) : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, element*)
    	      </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
         <p>All groups are mapped into the <quote>&amp;</quote>
         operation in the [XPath/XQuery] type system.</p>
        <mapping>
          <xquery>
            <expression>
              <map>
    	    	  <schemaRepresentation>
    	    	    <name>all</name>
    	    	    <schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute>
    	    	    <content>
    	 	      <emph>Element</emph><subscript>1</subscript> ... <emph>Element</emph><subscript>n</subscript>
    	    	    </content>
    	    	  </schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>(<map><emph>Element</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            &amp; ... &amp;
            <map><emph>Element</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
  
      </smschemanorm>
    </div3>
  	
    <div3 id="sec_import_choice_groups">
      <head>Choice groups</head>
  	
    	<smschema>
    	  <p>Choice groups are represented in XML by the following
    	  structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>choice</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smnotation>
        <p>The following auxiliary grammar productions are used to
        describe group components.</p>
  	  
        <scrap headstyle="show">
          <head>Group Component </head>
  	  
          <prod num="59 (Formal)" id="doc-fs-GroupComponent"><lhs>GroupComponent</lhs><rhs>"element"  |  "group"  |  "choice"  |  "sequence"  |  "any"</rhs></prod>
        </scrap>
      </smnotation>
  
      <smschemanorm>
        <p>Choice groups are mapped into the <quote>|</quote>
        operation in the [XPath/XQuery] type system.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	    	  <schemaRepresentation>
    	    	    <name>choice</name>
    	    	    <schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute>
    	    	    <content>
    	 	      <emph>GroupComponent</emph><subscript>1</subscript> ... <emph>GroupComponent</emph><subscript>n</subscript>
    	    	    </content>
    	    	  </schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>(<map><emph>GroupComponent</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            | ... |
            <map><emph>GroupComponent</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
  
      </smschemanorm>
    </div3>
  	
    <div3 id="sec_import_sequence_groups">
      <head>Sequence groups</head>
  	
    	<smschema>
    	  <p>Sequence groups are represented in XML by the following
    	  structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>sequence</name>
    	      <schemaAttribute role="ignored">
    		 id = ID
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	      <content>
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
        <p>Sequence groups are mapped into the <quote>,</quote>
        operation in the [XPath/XQuery] type system.</p>
  
        <mapping>
          <xquery>
            <expression>
              <map>
    	    	  <schemaRepresentation>
    	    	    <name>sequence</name>
    	    	    <schemaAttribute>
          	      <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	    	    </schemaAttribute>
    	    	    <content>
    	 	      <emph>GroupComponent</emph><subscript>1</subscript> ... <emph>GroupComponent</emph><subscript>n</subscript>
    	    	    </content>
    	    	  </schemaRepresentation>
             </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>(<map><emph>GroupComponent</emph><subscript>1</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            , ... ,
            <map><emph>GroupComponent</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>)
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
      </smschemanorm>
    </div3>
  </div2>
  
  <div2 id="sec_import_particles">
    <head>Particles</head>
  
    <p>Particles contribute to the definition of content models.</p>
  
    <p>A particle can be either an element reference, a group
    reference or a wildcard.</p>
  
    <div3 id="sec_import_element_ref">
      <head>Element reference</head>
  
    	<smschema>
    	  <p>Element reference particles are represented in XML by the
    	  following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentationNoContent>
    	      <name>element</name>
    	      <schemaAttribute>
    		 ref = QName
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	    </schemaRepresentationNoContent>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
        <p>Element references are mapped into element references in
        the [XPath/XQuery] type system.</p>
  
        <mapping>
          <xquery>
            <expression>
      	<map>
    	      	  <schemaRepresentationNoContent>
    	     	    <name>element</name>
    	     	    <schemaAttribute>
    	  	       ref = <emph>QName</emph>
    	     	    </schemaAttribute>
    	     	    <schemaAttribute>
    	  	       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    	     	    </schemaAttribute>
    	      	  </schemaRepresentationNoContent>
              </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>element <emph>QName</emph>
            <map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
      </smschemanorm>
    </div3>
  
    <div3 id="sec_group_ref">
      <head>Group reference</head>
  
    	<smschema>
    	  <p>Group reference particles are represented in XML by the
    	  following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentationNoContent>
    	      <name>group</name>
    	      <schemaAttribute>
    		 ref = QName
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		   minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
    	    </schemaRepresentationNoContent>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
        <p>Model group references are not currently handled by the
        mapping.</p>
      </smschemanorm>
    </div3>
  </div2>

  <div2 id="sec_import_wildcards">
    <head>Wildcards</head>
  
    <div3 id="sec_import_attribute_wildcards">
      <head>Attribute wildcards</head>
  
    	<smschema>
    	  <p>Attribute wildcards are represented in XML by the
    	  following structure.</p>
  
    	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>anyAttribute</name>
            <schemaAttribute role="ignored">
        	 id = ID
            </schemaAttribute>
    	      <schemaAttribute role="nothandled">
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 processContents = (lax | skip | strict) : strict
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
            <content>
               Content: (annotation?)
            </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
        <p>An attribute wildcard with a <quote>skip</quote> process
        content is mapped as an attribute wildcard in the [XPath/XQuery]
        type system.</p>
  
        <mapping>
          <xquery>
            <expression>
        	<map>
    		  <schemaRepresentation>
    		    <name>anyAttribute</name>
    		    <schemaAttribute>
    		       processContents = <quote>skip</quote>
    		    </schemaAttribute>
      	    <content>
      	       <emph>annotation</emph>?
      	    </content>
    		  </schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>(attribute (*, <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>))*</expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression>
        	<map>
    		  <schemaRepresentation>
    		    <name>anyAttribute</name>
    		    <schemaAttribute>
    		       processContents = <quote>lax</quote>
    		    </schemaAttribute>
      	    <content>
      	       <emph>annotation</emph>?
      	    </content>
    		  </schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>attribute *</expression>
          </core>
        </mapping>

        <mapping>
          <xquery>
            <expression>
        	<map>
    		  <schemaRepresentation>
    		    <name>anyAttribute</name>
    		    <schemaAttribute>
    		       processContents = <quote>strict</quote>
    		    </schemaAttribute>
      	    <content>
      	       <emph>annotation</emph>?
      	    </content>
    		  </schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>attribute *</expression>
          </core>
        </mapping>

<!--
  	<ednote>
  	  <edtext>Attribute wildcards with a
          <quote>strict</quote> process content
          are not handled by the mapping. </edtext>
  	</ednote>
-->

  	<ednote>
  	  <edtext>Namespace wildcards are not
  	  handled by the mapping.</edtext>
  	</ednote>
      </smschemanorm>
    </div3>
  
    <div3 id="sec_import_element_wildcards">
      <head>Element wildcards</head>
  
    	<smschema>
    	  <p>Element wildcards are represented in XML by the following
    	  structure.</p>
  
   	  <schemaRepresentationEg>
    	    <schemaRepresentation>
    	      <name>any</name>
            <schemaAttribute role="ignored">
        	 id = ID
            </schemaAttribute>
    	      <schemaAttribute>
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 minOccurs = nonNegativeInteger : 1
    	      </schemaAttribute>
    	      <schemaAttribute role="nothandled">
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </schemaAttribute>
    	      <schemaAttribute>
    		 processContents = (lax | skip | strict) : strict
    	      </schemaAttribute>
    	      <schemaAttribute role="ignored">
    		 {any attributes with non-schema namespace ...}
    	      </schemaAttribute>
            <content>
               Content: (annotation?)
            </content>
    	    </schemaRepresentation>
    	  </schemaRepresentationEg>
    	</smschema>
  
      <smschemanorm>
        <p>An element wildcard with a <quote>skip</quote> process
        content is mapped as an element wildcard in the [XPath/XQuery]
        type system.</p>
  
        <mapping>
          <xquery>
            <expression>
      	<map>
    		  <schemaRepresentation>
    		    <name>any</name>
                  <schemaAttribute>
    		       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    		    </schemaAttribute>
    		    <schemaAttribute>
    		       processContents = <quote>skip</quote>
    		    </schemaAttribute>
      	    <content>
      	       <emph>annotation</emph>?
      	    </content>
    		  </schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( element (*, <a href="#dt-xs_untyped"><code>xs:untyped</code></a>)
            )<map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
  
        <mapping>
          <xquery>
            <expression>
      	<map>
    		  <schemaRepresentation>
    		    <name>any</name>
                  <schemaAttribute>
    		       <a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a>
    		    </schemaAttribute>
    		    <schemaAttribute>
    		       processContents = <quote>lax</quote>
    		    </schemaAttribute>
      	    <content>
      	       <emph>annotation</emph>?
      	    </content>
    		  </schemaRepresentation>
      	 </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            </expression>
          </xquery>
          <core>
            <expression>( element (*, <code>xs:anyType</code>)
            )<map><a href="#prod-formal-OccursAttributes"><emph>OccursAttributes</emph></a></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
          </core>
        </mapping>
  
  	<ednote>
  	  <edtext>Element wildcards with a
          <quote>lax</quote> or <quote>strict</quote> process content
          are not handled by the mapping. </edtext>
  	</ednote>

  	<ednote>
  	  <edtext>Namespace wildcards are not
  	  handled by the mapping.</edtext>
  	</ednote>
      </smschemanorm>
    </div3>
  </div2>
  
  <div2 id="sec_import_identity">
    <head>Identity-constraint Definitions</head>
  
    <p>All identity-constraints definitions are ignored when mapping
    into the [XPath/XQuery] type system.</p>
  </div2>
  
  <div2 id="sec_import_notation">
    <head>Notation Declarations</head>
  
    <p>All notation declarations are ignored when mapping into the
    [XPath/XQuery] type system.</p>
  </div2>
  
  <div2 id="sec_import_annotation">
    <head>Annotation</head>
  
    <p>All annotation are ignored when mapping into the [XPath/XQuery]
    type system.</p>
  </div2>

  <div2 id="sec_import_simple_type">
    <head>Simple Type Definitions</head>
    
    <smschema>
      <p>A simple type is represented in XML by the following
      structure.</p>

      <schemaRepresentationEg>
        <schemaRepresentation>
          <name>simpleType</name>
          <schemaAttribute role="ignored">
             final = (#all | (list | union | restriction))
          </schemaAttribute>
          <schemaAttribute role="ignored">
             id = ID
          </schemaAttribute>
          <schemaAttribute>
             name = NCName
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
            name = NCName
          </content>
        </schemaRepresentation>
      </schemaRepresentationEg>

      <p>Derivation by restriction inside a simple type is represented
      in XML by the following structure.</p>
  
      <schemaRepresentationEg>
        <schemaRepresentation>
          <name>restriction</name>
          <schemaAttribute>
             base = QName
          </schemaAttribute>
          <schemaAttribute role="ignored">
             id = ID
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
            Content: (annotation?, (simpleType?, (minExclusive |
            minInclusive | maxExclusive | maxInclusive |
            totalDigits | fractionDigits | length | minLength |
            maxLength | enumeration | whiteSpace | pattern)*)?)
          </content>
        </schemaRepresentation>
      </schemaRepresentationEg>
  
      <p>Derivation by list inside a simple type is represented in XML
      by the following structure.</p>
  
      <schemaRepresentationEg>
        <schemaRepresentation>
          <name>list</name>
          <schemaAttribute role="ignored">
             id = ID
          </schemaAttribute>
          <schemaAttribute>
             itemType = QName
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
             Content: (annotation?, (simpleType?))
          </content>
        </schemaRepresentation>
      </schemaRepresentationEg>

      <p>Derivation by union inside a simple type is represented in
      XML by the following structure.</p>
  
      <schemaRepresentationEg>
        <schemaRepresentation>
          <name>union</name>
          <schemaAttribute role="ignored">
             id = ID
          </schemaAttribute>
          <schemaAttribute>
             memberTypes = List of QName
          </schemaAttribute>
          <schemaAttribute role="ignored">
             {any attributes with non-schema namespace ...}
          </schemaAttribute>
          <content>
             Content: (annotation?, (simpleType*))
          </content>
        </schemaRepresentation>
      </schemaRepresentationEg>
    </smschema>

    <div3 id="sec_import_global_simple_type">
      <head>Global simple type definition</head>

      <p>Schema import distinguishes between global simple types
      (which are mapped to sort declarations) and local simple types
      (which are mapped to type definitions).</p>
  
      <smschemanorm>
        <p>In the case of global simple types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p>
  
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
      		<schemaRepresentation>
      		  <name>simpleType</name>
      		  <schemaAttribute>
      		     name = <emph>NCName</emph>
      		  </schemaAttribute>
      		  <content>
      		     <emph>SimpleTypeContent</emph>
      		  </content>
      		</schemaRepresentation>
      	    </map><a href="#jd_map_definition" class="judgment"><subscript>definition(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression>
      	  </xquery>
      	  <core>
      	    <expression>define type <emph>target</emph><emph>NCName</emph>:<emph>NCName</emph>
      	    <map><emph>SimpleTypeContent</emph></map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
      	  </core>
      	</mapping>
      </smschemanorm>
    </div3>

    <div3 id="sec_import_local_simple_type">
      <head>Local simple type definition</head>

      <smschemanorm>
        <p>In the case of global simple types, the mapping rule which
        applies is denoted by <map/><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>.</p>
  
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
      		<schemaRepresentationNoAttribute>
      		  <name>simpleType</name>
      		  <content>
      		     <emph>SimpleTypeContent</emph>
      		  </content>
      		</schemaRepresentationNoAttribute>
      	    </map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression>
      	  </xquery>
      	  <core>
      	    <expression><map><emph>SimpleTypeContent</emph></map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a></expression>
      	  </core>
      	</mapping>
      </smschemanorm>
    </div3>

    <div3 id="sec_import_simple_type_content">
      <head>Simple type content</head>

      <smnotation>
        <p id="jd_map_simple_content">The normalization rule
        <map/><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a> maps a simple type content
        to a type specifier and an optional occurrence indicator.</p>
      </smnotation>

      <smschemanorm>
        <p>If the simple type is derived by restriction, it is mapped
        into a simple type restriction in the [XPath/XQuery] type
        system.   The name of the base atomic type and attributes
        are mapped.  Only the minLength, maxLength, and length facets in the simple type
        restriction are handled.  All other properties of the simple-type restriction are ignored.</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
      		<schemaRepresentation>
      		  <name>restriction</name>
      		  <schemaAttribute>
      		     base = <emph>QName</emph>
      		  </schemaAttribute>
      		  <content>
      		     <emph>simpleContentRestriction</emph>
      		  </content>
      		</schemaRepresentation>
      	    </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	  </expression>
      	  </xquery>
      	  <core>
      	    <expression>restricts <emph>QName</emph> { <emph>QName</emph> } <map><emph>simpleContentRestriction</emph></map><a href="#jd_map_occurs" class="judgment"><subscript>occurs</subscript></a></expression>
      	  </core>
      	</mapping>
      
        <p>If the simple type is derived by list, and its content type
        does not constrain the length of the list, 
        it is mapped into a zero-or-more repetition type into the [XPath/XQuery] type system.</p>
      
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
                <schemaRepresentationNoAttribute>
                  <name>list</name>
                  <content>
                    <emph>SimpleType</emph>
                  </content>
                </schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a> = <map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>{ <a href="#doc-fs-Type"><emph>Type</emph></a> * }</expression>
      	  </core>
      	</mapping>

        <p>If the simple type is derived by list, and its content type
        does constrain the length of the list, then it is mapped into
        a zero-or-more repetition type into the [XPath/XQuery] type
        system.</p>

      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
                <schemaRepresentationNoAttribute>
                  <name>list</name>
                  <content>
                    <emph>SimpleType</emph>
                  </content>
                </schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
              <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> <emph>OccurrenceIndicator</emph> = <map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>{ <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_quantifier" class="judgment">·</a> <emph>OccurrenceIndicator</emph> }</expression>
      	  </core>
      	</mapping>
  
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
                <schemaRepresentationNoContent>
                  <name>list</name>
                  <schemaAttribute>
                     itemType = <emph>QName</emph>
                  </schemaAttribute>
                </schemaRepresentationNoContent>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>{ <emph>QName</emph>* }</expression>
      	  </core>
      	</mapping>

        <p>If the simple type is derived by union, it is mapped into a
        union type into the [XPath/XQuery] type system.</p>
      
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
                <schemaRepresentationNoAttribute>
                  <name>union</name>
                  <content>
                    <emph>SimpleType</emph><subscript>1</subscript> ... <emph>SimpleType</emph><subscript>n</subscript>
                  </content>
                </schemaRepresentationNoAttribute>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>{ (<map><emph>SimpleType</emph></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
            | ... | <map><emph>SimpleType</emph><subscript>n</subscript></map><a href="#jd_map_content" class="judgment"><subscript>content(<emph>target</emph><emph>NCName</emph>)</subscript></a>) }</expression>
      	  </core>
      	</mapping>
  
      	<mapping>
      	  <xquery>
      	    <expression>
      	      <map>
                <schemaRepresentationNoContent>
                  <name>union</name>
                  <schemaAttribute>
                     memberTypes = <emph>QName</emph><subscript>1</subscript> ... <emph>QName</emph><subscript>n</subscript>
                  </schemaAttribute>
                </schemaRepresentationNoContent>
      	      </map><a href="#jd_map_simple_content" class="judgment"><subscript>simple_content(<emph>target</emph><emph>NCName</emph>)</subscript></a>
      	    </expression>
      	  </xquery>
      	  <core>
      	    <expression>{ <emph>QName</emph><subscript>1</subscript> | ... | <emph>QName</emph><subscript>n</subscript> }</expression>
      	  </core>
      	</mapping>

      </smschemanorm>
    </div3>
  </div2>
</div1>


     <!-- *************************** References           **************** -->

<div1 id="appendix_references">
  <head>References</head>

  <div2 id="id-normative-references">
    <head>Normative References</head>
<blist>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" key="XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<!-- not referenced so far?
<bibl id="XMLNAMES" key="XML Names">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc
href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</loc></bibl>
-->

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C
Recommendation. See <loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="Schema Part 1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="Schema Part 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel" key="Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization" key="Data Model Serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery" key="XQuery 1.0: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath20" key="XML Path Language (XPath) 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions" key="Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

</blist>
</div2>

  <div2 id="id-non-normative-references">
    <head>Non-normative References</head>

    <blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-0" key="XML Schema Part 0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>


<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-requirements" key="XML Query 1.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>

    </blist>

  </div2>

  <div2 id="id-background-references">
    <head>Background References</head>

    <blist>
<!--
     <bibl key="BFS00" id="BFS00">
       P. Buneman, M. Fernandez, D. Suciu.  UnQL: A query language and
       algebra for semistructured data based on structural recursion.
       <emph>VLDB Journal</emph>, April, 2000, Vol 9, Number 1.
     </bibl>
     <bibl key="BKD90" id="BKD90">     
       Francois Bancilhon, Paris Kanellakis, Claude Delobel.
       <emph>Building an Object-Oriented Database System</emph>.
       Morgan Kaufmann, 1990.
     </bibl>
     <bibl key="BNTW95" id="BNTW95">   
       Peter Buneman, Shamim Naqvi, Val Tannen, Limsoon Wong.
       Principles of programming with complex object and collection
       types.  <emph>Theoretical Computer Science</emph> 149(1):3&mdash;48,
       1995.
     </bibl>
     <bibl key="Quilt" id="Quilt">
       Don Chamberlin, Jonathan Robie, and Daniela Florescu.  Quilt: An
       XML Query Language for Heterogeneous Data Sources.
       <emph>International Workshop on the Web and Databases
       (WebDB'2000)</emph>, Dallas, Texas, May 2000.
     </bibl>
-->
<!--
     <bibl key="CM93" id="CM93">        
       S. Cluet and G. Moerkotte. Nested queries in object bases.
       <emph>Workshop on Database Programming Languages</emph>, pages
       226-242, New York, August 1993.
     </bibl>
     <bibl key="YAT99" id="YAT99">
       S.&nbsp;Cluet, and J.&nbsp;Sim&eacute;on.  YATL: A Functional
       and Declarative Language for XML.  See <loc
       href="http://db.bell-labs.com/user/simeon/icfp.ps">http://db.bell-labs.com/user/simeon/icfp.ps</loc>
     </bibl>
     <bibl key="Col90" id="Col90">      
       L. S. Colby.  A recursive algebra for nested relations.
       <emph>Information Systems</emph> 15(5):567-582, 1990.
     </bibl>
     <bibl key="XMLQL99" id="XMLQL99">
       A.&nbsp;Deutsch, M.&nbsp;Fernandez, D.&nbsp;Florescu,
       A.&nbsp;Levy, and D.&nbsp;Suciu.  <emph>A query language for
       XML.</emph> In <emph>International World Wide Web
       Conference</emph>, 1999.
     </bibl>
     <bibl key="Graefe93" id="Graefe93">
       Goetz Graefe, <emph>Query Evaluation Techniques for Large
       Databases</emph>. In <emph>ACM Computing Surveys</emph>,
       25(2):73-170, 1993.
     </bibl>
     <bibl key="LW97" id="LW97">        
       Leonid Libkin and Limsoon Wong.  Query languages for bags and
       aggregate functions.  <emph>Journal of Computer and Systems
       Sciences</emph>, 55(2):241-272, October 1997.
     </bibl>
     <bibl key="HP2000" id="HP2000">    
       Haruio Hosoya, Benjamin Pierce, XDuce : A Typed XML Processing
       Language (Preliminary Report) <emph>WebDB Workshop</emph> 2000.
     </bibl>
     <bibl key="LMW96" id="LMW96">      
       Leonid Libkin, Rona Machlin, and Limsoon Wong.  A query language
       for multi-dimensional arrays: Design, implementation, and
       optimization techniques.  <emph>SIGMOD</emph> 1996.
     </bibl>
     <bibl key="Milner" id="Milner">
       R. Milner, M. Tofte, R. Harper, D. MacQueen <emph>The Definition
       of Standard ML (Revise)</emph>.  MIT Press, 1997.
     </bibl>
     <bibl key="Mitchell" id="Mitchell">
       John C. Mitchell <emph>Foundations for Programming
       Languages</emph>.  MIT Press, 1998.
     </bibl>
     <bibl key="Mog89" id="Mog89">  
       E. Moggi, Computational lambda-calculus and monads.  In
       <emph>Symposium on Logic in Computer Science</emph> Asilomar,
       California, IEEE, June 1989.
     </bibl>
     <bibl key="Mog91" id="Mog91">
       E. Moggi, Notions of computation and monads.  <emph>Information
       and Computation</emph>, 93(1), 1991.
     </bibl>
     <bibl key="SQL" id="SQL">
       International Organization for Standardization (ISO).
       <emph>Information Technology-Database Language
       SQL</emph>. Standard No. ISO/IEC 9075:1999.  (Available from
       American National Standards Institute, New York, NY 10036,
       (212) 642-4900.)
     </bibl>
     <bibl key="ODMG" id="ODMG">
       Rick Cattell et al. <emph>The Object Database Standard:
       ODMG-93, Release 1.2</emph>. Morgan Kaufmann Publishers, San
       Francisco, 1996.
     </bibl>
     <bibl key="XQL99" id="XQL99">
       J.&nbsp;Robie, editor.  XQL '99 Proposal, 1999.  See <loc
       href="http://www.ibiblio.org/xql/xql-proposal.html">http://www.ibiblio.org/xql/xql-proposal.html</loc>.
     </bibl>
-->
     <bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="Languages" id="Languages" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
       Handbook of Formal Languages. G. Rozenberg and A. Salomaa,
       editors. <emph>Springer-Verlag</emph>. 1997.
     </bibl>
     <bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="TATA" id="TATA" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
       Tree Automata Techniques and Applications. H. Comon and
       M. Dauchet and R. Gilleron and F. Jacquemard and D. Lugiez and
       S. Tison and M. Tommasi. See <loc href="http://www.grappa.univ-lille3.fr/tata/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.grappa.univ-lille3.fr/tata/</loc>. 1997.
     </bibl>
<!--
     <bibl key="Wad93" id="Wad93">     
       P. Wadler, Monads for functional programming.  In M. Broy,
       editor, <emph>Program Design Calculi</emph>, NATO ASI Series,
       Springer Verlag, 1993.  Also in J. Jeuring and E. Meijer,
       editors, <emph>Advanced Functional Programming</emph>, LNCS 925,
       Springer Verlag, 1995.
     </bibl>
     <bibl key="Wad95" id="Wad95">
       P. Wadler, How to declare an imperative.  <emph>ACM Computing
       Surveys</emph>, 29(3):240-263, September 1997.
     </bibl>
     <bibl key="Won00" id="Won00">
       Limsoon Wong.  An introduction to the Kleisli query system and a
       commentary on the influence of functional programming on its
       implementation.  <emph>Journal of Functional Programming</emph>,
       to appear.
     </bibl>
--> 
    </blist>
  </div2>
</div1>


     <inform-div1 id="sec_validation_judgments">
  <head>Auxiliary Judgments for Validation</head>

  <div2 id="sec_validate">
    <head>Judgments for the validate expression</head>

    <p>XQuery supports XML Schema validation using the validate
    expression. This section gives a non-normative formal semantics of XML Schema
    validation, solely for the purpose of specifying its usage in XQuery.</p>

    <p>Specifying XML Schema validation requires a fairly large number
    of auxiliary judgments. There are two main judgments used to
    describe the semantics of validation.</p>

    <ulist>
      <item>
        <p>The <quote>erase</quote> judgment takes a value and removes
        all type information from it. This operation is necessary
        since, in XQuery, validation can occur both on well-formed or
        already validated documents.</p>
      </item>
      <item>
        <p>The <quote>annotate</quote> operation takes an untyped
        value and a type and either fails or succeeds by returning a
        new -validated- value.</p>
      </item>
    </ulist>

    <p>Before defining thes two judgments, we first introduce the
    auxiliary judgments used to describe specific parts of XML
    Schema's semantics.</p>

    <div3 id="sec_type_resolution">
      <head>Type resolution</head>

      <smnotation>
        <p id="jd_resolves_to">The judgments</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
          </clause>
        </display>

        <p>and</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
          <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
          </clause>
        </display>

        <p>hold when a type reference (resp. a type derivation)
        resolves to the given type name and type content.</p>
      </smnotation>

      <smrules>     
        <p>Those judgments are specified by the following rules.</p>

	<p>If the type is omitted, it is resolved as the empty
	sequence type.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Derivation"><emph>Derivation</emph></a>? <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { empty } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Derivation"><emph>Derivation</emph></a>? <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In case of a type reference, then the type name is the name
        of that type, and the type is taken by resolving the type
        declaration of the global type.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
            </multiclause>
            <multiclause>

             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
                <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a>
              </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeDerivation"><emph>TypeDerivation</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>In the above inference rule, note that <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a> is
        the base type of the type referred to. So this is indeed the
        original type name, <a href="#doc-fs-TypeName"><emph>TypeName</emph></a>, which must be returned, and
        eventually used to annotated the corresponding element or
        attribute. However, the type needs to be obtained through a
        second application of the <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> judgment.</p>

        <p>If the type derivation is a restriction, then the type name
        is the name of the base type, and the type is taken from the
        type derivation.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>restricts <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> {
             <a href="#doc-fs-Type"><emph>Type</emph></a> } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> {
             <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the type derivation is an extension, then the type name
        is the name of the base type, and the type is the base type
        extended by the type in the type derivation.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
          <clause>
           <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
           <expression>
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#jd_elem_qname_expands_to" class="judgment"><term>of elem/type expands to</term></a> <a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>
           </expression>
          </clause>
            </multiclause>
            <multiclause>

             <clause>
              <expression>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><emph>expanded-QName</emph></a>) = define type
                <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-Derivation"><emph>Derivation</emph></a>? <a href="#doc-fs-OptMixed"><emph>BaseOptMixed</emph></a> {
                <emph>Base</emph><a href="#doc-fs-Type"><emph>Type</emph></a>? }
              </expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><emph>Base</emph><a href="#doc-fs-Type"><emph>Type</emph></a>? <a href="#jd_extended_by" class="judgment"><term>extended by</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>
              <a href="#jd_extended_by" class="judgment"><term>is</term></a> <emph>Extended</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> <emph>Extended</emph><a href="#doc-fs-Type"><emph>Type</emph></a>
              <a href="#jd_adjusts_to" class="judgment"><term>adjusts to</term></a> <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>extends <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> <a href="#doc-fs-OptMixed"><emph>OptMixed</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a>
             } <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <emph>Adjusted</emph><a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
  
      </smrules>
    </div3>

    <div3 id="sec_interleaving">
      <head>Interleaving</head>

      <smnotation>
        <p id="jd_interleave">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
          <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
          </clause>
        </display>

        <p>holds if some interleaving of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
        yields <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript>.  Interleaving is non-deterministic; it is
        used for processing all groups.</p>
      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>Interleaving two empty sequences yields the empty
        sequence.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression>() <a href="#jd_interleave" class="judgment"><term>interleave</term></a> () <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             ()</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Otherwise, pick an item from the head of one of the
        sequences, and recursively interleave the remainder.</p>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
            </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_interleave" class="judgment"><term>yields</term></a>
             <a href="#doc-fs-Item"><emph>Item</emph></a>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

    </div3>

    <div3 id="sec_jd_filter">
      <head>Attribute filtering</head>

      <smintro>
        <p>Finally, we introduce an auxiliary judgment which extracts
        the value of a given attribute if it exists. This judgment is
        not used in the semantics of step expressions, but in <specref ref="sec_type_matching"/>, and is based on the other filter
        judgments.</p>
      </smintro>

      <smnotation>
        <p id="jd_filter">The judgment</p>

        <display>
          <clause>
          <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression>
          </clause>
        </display>

        <p>holds if there are no occurrences of the attribute
        <emph>QName</emph> in <a href="#doc-fs-Value"><emph>Value</emph></a>. The judgment</p>

        <display>
          <clause>
          <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph> <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression>
          </clause>
        </display>

        <p>holds if there is one occurrence of the attribute
        <emph>QName</emph> in <a href="#doc-fs-Value"><emph>Value</emph></a>, and the value of that attribute is
        <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>.</p>

      </smnotation>

      <smrules>
        <p>The <a href="#jd_filter" class="judgment"><term>filter</term></a> judgments are defined as follows.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression><a href="#jd_axis" class="judgment"><term>axis</term></a> attribute:: <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>QName</emph> <a href="#jd_test" class="judgment"><term>with</term></a> attribute
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              ()</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph>
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression><a href="#jd_axis" class="judgment"><term>axis</term></a> attribute:: <a href="#jd_axis" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> 
              <a href="#jd_axis" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_dyn_env_def" class="env">dynEnv</a></environment>
              <expression><a href="#jd_test" class="judgment"><term>test</term></a> <emph>QName</emph> <a href="#jd_test" class="judgment"><term>with</term></a> attribute
              <a href="#jd_test" class="judgment"><term>of</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_test" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>3</subscript> = attribute <emph>QName</emph> {
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> }</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @<emph>QName</emph>
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
    </div3>
  <div3 id="sec_erasure">
    <head>Erasure</head>

    <div4 id="sec_simply_erases">
      <head>Simply erases</head>

      <smnotation>
        <p id="jd_simply_erases_to">To define erasure, an auxiliary
        judgment is needed.  The judgment</p>

        <display>
          <clause>
          <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
          <emph>String</emph></expression>
          </clause>
        </display>

        <p>holds when <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> erases to the string
        <emph>String</emph>.</p>

      </smnotation>

      <smrules>

        <p>This judgment is specified by the following rules.</p>

        <p>The empty sequence erases to the empty string.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression>() <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a> ""</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The concatenation of two non-empty sequences of values
        erases to the concatenation of their erasures with a
        separating space.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph><subscript>1</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> != ()</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph><subscript>2</subscript></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript> != ()</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>
             <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a> <code>fn:concat</code>(<emph>String</emph><subscript>1</subscript>,"
             ",<emph>String</emph><subscript>2</subscript>)</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>An atomic value erases to its string representation as an
        instance of <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression><a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a> of type <a href="#doc-fs-AtomicTypeName"><emph>AtomicTypeName</emph></a>
             <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
             <emph>dm:</emph><code>string-value</code>(<a href="#doc-fs-AtomicValueContent"><emph>AtomicValueContent</emph></a>)</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>
    </div4>

    <div4 id="sec_erases">
      <head>Erases</head>

      <smnotation>
        <p id="jd_erases_to">The <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> judgment is used in
        the definition of the dynamic semantics of validation.  The
        normative dynamic semantics of validation is specified in
        <xspecref spec="XQ" ref="id-validate"/>.

        The effect of the validate expression is equivalent to:
        <ulist>
          <item><p>serialization of the data model, as described in
          <bibref ref="xslt-xquery-serialization"/>, followed by </p></item>
          <item><p>validation of the serialized value into a
          Post-Schema Validated Infoset, as described in
          <bibref ref="xmlschema-1"/>, followed by</p></item>
          <item><p>construction of a new data model value, as
          described in <bibref ref="xpath-datamodel"/>.</p></item>
        </ulist>

        Erasure is the formal equivalent of serialization followed by
        construction of a new data model value in which all element
        nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute nodes
        with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

        <p>The judgment</p>

        <display>
          <clause>
          <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>

        <p>holds when the erasure of <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> is <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p>

      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>The empty sequence erases to itself.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression>() <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> ()</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of the concatenation of two values is the
        concatenation of their erasure, so long as neither of the two
        original values is simple.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression>
             </clause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> not a simple value</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
             </clause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> not a simple value</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of an element is an element that has the same
        name and the type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and the erasure of the original
        content.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression>element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <a href="#dt-xs_untyped"><code>xs:untyped</code></a> { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
             }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of an attribute is an attribute that has the
        same name and the type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> and the simple erasure
        of the original content labeled with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression>attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> attribute
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> { <emph>String</emph>
             of type <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of a document is a document with the erasure of
        the original content.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression>document { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a>
             document { <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of a text or comment or processing-instruction node is itself.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression>text
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> text { <emph>String</emph>
             }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression>comment
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> comment { <emph>String</emph>
             }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <expression>processing-instruction <emph>NCName</emph>
             { <emph>String</emph> } <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> processing-instruction <emph>NCName</emph> { <emph>String</emph>
             }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The erasure of a simple value is the corresponding text
        node.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_simply_erases_to" class="judgment"><term>simply erases to</term></a>
              <emph>String</emph></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_erases_to" class="judgment"><term>erases to</term></a> text {
             <emph>String</emph> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

    </div4>

  </div3>

  <div3 id="sec_jd_annotate">
    <head>Annotate</head>

<p>The <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<xspecref spec="XQ" ref="id-validate"/>.
The effect of the validate expression is equivalent to:
<ulist>
<item><p>serialization of the data model, as described in
<bibref ref="xslt-xquery-serialization"/>, followed by</p> </item>
<item><p>parsing of the serialized value into the Infoset</p></item>
<item><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item>
<item><p>construction of a new data model value, as described in
<bibref ref="xpath-datamodel"/>.</p></item>
</ulist>
Annotation is the formal equivalent of schema validation of an Infoset
value into the PSVI followed by construction of a new data model
value.   Because the Formal Semantics is defined on data model values,
not the Infoset, annotation is applied to data model values in which
all element nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute
nodes with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a> -- that is, the result of erasure. 
</p>

    <div4 id="sec_simply_annotate">
      <head>Simply annotate</head>
  
        <smnotation>
          <p id="jd_cast_as">The judgment</p>
  
          <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
            <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>
            ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
          </clause>
          </display>
  
          <p>holds if the result of casting the <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> to
          <emph>SimpleType</emph> is <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>.</p>
<!--  
          <ednote>
            <edtext>Issue: The <term>simply annotate</term> judgment
            is used to describe the behavior of validation of simple
            values. This operation is similar to casting
            from string to an atomic value. It is not clear if this
            actually aligns to the behavior of casting as specified by
            the &xq_functions;. See Issue 499
            (FS-Issue-0156).</edtext>
          </ednote>
-->
  
        </smnotation>
  
        <smrules>
          <p>This judgment is specified by the following rules.</p>
  
          <p>Simply annotating a simple value to a union type yields the
          result of simply annotating the simple value to either the
          first or second type in the union. Note that simply annotating
          to the second type is attempted only if simply annotating to
          the first type <emph>fails</emph>.</p>
  
          <infergr>
            <infer>
             <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>1</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
               </clause>
              </multiclause>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a>
               <emph>SimpleType</emph><subscript>1</subscript>|<emph>SimpleType</emph><subscript>2</subscript> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <infergr>
            <infer>
             <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression>not(<a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>1</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>)</expression>
               </clause>
              </multiclause>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph><subscript>2</subscript>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
               </clause>
              </multiclause>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a>
               <emph>SimpleType</emph><subscript>1</subscript>|<emph>SimpleType</emph><subscript>2</subscript> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <p>The simple annotation rules for ?, +, * are similar.</p>
  
          <infergr>
            <infer>
             <prejudge>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>? ( () )
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> ()</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <infergr>
            <infer>
             <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
               </clause>
              </multiclause>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>?
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <infergr>
            <infer>
             <prejudge>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>* ( () )
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a> ()</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <infergr>
            <infer>
             <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>'</expression>
               </clause>
</multiclause>
<multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression>
               </clause>
              </multiclause>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>',<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <infergr>
            <infer>
             <prejudge>
              <multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>'</expression>
               </clause>
</multiclause>
<multiclause>
               <clause>
                <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
                <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>*
                (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
                <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression>
               </clause>
              </multiclause>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph>+
               (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>,<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>',<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>'</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <p>Simply annotating an atomic value to <code>xs:string</code> yields its
          string representation.</p>
  
          <infergr>
            <infer>
             <prejudge>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <code>xs:string</code> (<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <emph>dm:</emph>string-value(<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <p>Simply annotating an atomic value to <code>xs:decimal</code> yields
          the decimal that results from parsing its string
          representation.</p>
  
          <infergr>
            <infer>
             <prejudge>
             </prejudge>
             <postjudge>
              <clause>
               <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
               <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <code>xs:decimal</code> (<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>)
               <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
               <code>xs:decimal</code>(<emph>dm:</emph><code>string-value</code>(<a href="#doc-fs-AtomicValue"><emph>AtomicValue</emph></a>))</expression>
              </clause>
             </postjudge>
            </infer>
          </infergr>
  
          <p>Similar rules are assumed for the rest of the 19 XML Schema
          primitive types.</p>
  
      </smrules>
    </div4>

    <div4 id="sec_nil_annotate">
      <head>Nil-annotate</head>

      <smnotation>
        <p id="jd_nil_annotate_as">The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
          <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>

        <p>holds if it is possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had the nillable type <a href="#doc-fs-Type"><emph>Type</emph></a> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is the
        corresponding annotated value.</p>

      </smnotation>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is not nillable, then the xsi:nil attribute
        must not appear in the value, and it must be possible to
        annotate value <a href="#doc-fs-Value"><emph>Value</emph></a> as if it had the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#jd_filter" class="judgment"><term>absent</term></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
             <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the type is nillable, and the xsi:nil attribute does not
        appear or is false, then it must be possible to annotate value
        <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if it had the type <a href="#doc-fs-Type"><emph>Type</emph></a>.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> <a href="#jd_isin" class="judgment"><term>in</term></a> { (), false }</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> nillable <a href="#doc-fs-Type"><emph>Type</emph></a> (
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>If the type is nillable, and the xsi:nil attribute is true,
        then it must be possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had a type where the attributes in the type are kept and
        the element content of the type is ignored.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> true</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a> (
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a> nillable
             (<a href="#doc-fs-AttributeModel"><emph>AttributeModel</emph></a>, <a href="#doc-fs-ElementModel"><emph>ElementModel</emph></a>) ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
             <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

      </smrules>

    </div4>

    <div4 id="sec_annotate">
      <head>Annotate</head>


        <p id="jd_annotate_as">
The <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<xspecref spec="XQ" ref="id-validate"/>.
The effect of the validate expression is equivalent to:
<ulist>
<item><p>serialization of the data model, as described in
<bibref ref="xslt-xquery-serialization"/>, followed by</p> </item>
<item><p>parsing of the serialized value into the Infoset</p></item>
<item><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <bibref ref="xmlschema-1"/>, followed by</p></item>
<item><p>construction of a new data model value, as described in
<bibref ref="xpath-datamodel"/>.</p></item>
</ulist>
Erasure is the formal equivalent of serialization followed by
construction of a new data model value in which all element nodes are labeled with <a href="#dt-xs_untyped"><code>xs:untyped</code></a> and all attribute nodes with <a href="#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.
</p>

      <smnotation>
        <p>The judgment</p>

        <display>
          <clause>
          <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
          <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
          <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
          </clause>
        </display>

        <p>holds if it is possible to annotate value <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> as if
        it had type <a href="#doc-fs-Type"><emph>Type</emph></a> and <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> is the corresponding
        annotated value.</p>

      </smnotation>

      <smnote>
        <p>Assume an XML Infoset instance X1 is validated against an
        XML Schema S, yielding PSVI instance X2. Then if X1
        corresponds to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> and S corresponds to <a href="#doc-fs-Type"><emph>Type</emph></a> and
        X2 corresponds to <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>, the following should hold:
        <a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
        <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>.</p>
      </smnote>

      <smrules>
        <p>This judgment is specified by the following rules.</p>

        <p>Annotating the empty sequence as the empty type yields the
        empty sequence.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> empty (())
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> ()</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a concatenation of values as a concatenation of
        types yields the concatenation of the annotated values.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>,<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a value as a choice type yields the result of
        annotating the value as either the first or second type in the
        choice.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript>|<a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a value as an all group uses interleaving to
        decompose the original value and recompose the annotated
        value.</p>

        <ednote>
          <edtext>Jerome and Phil: Note that this may reorder the
          original sequence.  Perhaps we should disallow such
          reordering. Specifying that formally is not as easy as we
          would like.</edtext>
        </ednote>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript> ( <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript> )
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript> <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>' <a href="#jd_interleave" class="judgment"><term>interleave</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'
              <a href="#jd_interleave" class="judgment"><term>yields</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>1</subscript> &amp; <a href="#doc-fs-Type"><emph>Type</emph></a><subscript>2</subscript>
             ( <a href="#doc-fs-Value"><emph>Value</emph></a> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>The annotation rules for ?, +, * are similar.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> (<a href="#doc-fs-Type"><emph>Type</emph></a> |
              empty)(<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>? (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript></expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression>
             </clause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>+
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>')</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* ( () )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> ()</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>'</expression>
             </clause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>* (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>'</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a>*
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>,<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             (<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>1</subscript>',<a href="#doc-fs-Value"><emph>Value</emph></a><subscript>2</subscript>')</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>To annotate an element with no xsi:type attribute, first
        look up the element type, next resolve the resulting type
        reference, then annotate the value against the resolved type,
        and finally return a new element with the name of the original
        element, the resolved type name, and the annotated value.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:type
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> ()</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
              <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> ( element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><emph>Value</emph></a> } )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>To annotate an element with an xsi:type attribute, define a
        type reference corresponding to the xsi:type.  Look up the
        element type, yielding a type reference, and check that the
        xsi:type reference derives from this type reference.  Resolve
        the xsi:type reference, then annotate the value against the
        resolved type, and finally return a new element with the name
        of the original element, the resolved type name, and the
        annotated value.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <expression><a href="#doc-fs-Value"><emph>Value</emph></a> <a href="#jd_filter" class="judgment"><term>filter</term></a> @xsi:type
              <a href="#jd_filter" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <expression><emph>Xsi</emph><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> = of type
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-ElementName"><emph>ElementName</emph></a> <a href="#jd_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> <a href="#jd_lookup" class="judgment"><term>yields</term></a> <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a>
              of type <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeName"><emph>TypeName</emph></a>
              <a href="#jd_derives_from" class="judgment"><term>derives from</term></a>
              <a href="#doc-fs-TypeName"><emph>BaseTypeName</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><emph>Xsi</emph><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-ElementType"><emph>ElementType</emph></a> ( element
             <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><emph>Value</emph></a> } )
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> element <a href="#doc-fs-ElementName"><emph>ElementName</emph></a> of type
             <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
<!--
        <ednote>
          <edtext>Issue: the treatment of xsi:type in the
          &xq_xquerydoc; document and in the formal semantics document
          still differ. See Issue 485 (FS-Issue-0142).</edtext>
        </ednote>
-->
        <p>The rule for attributes is similar to the first rule for
        elements.</p>

        <infergr>
          <infer>
           <prejudge>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>name lookup</term></a>
              <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> <a href="#jd_attribute_lookup" class="judgment"><term>yields</term></a>
              <a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a></expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#doc-fs-TypeReference"><emph>TypeReference</emph></a> <a href="#jd_resolves_to" class="judgment"><term>resolves to</term></a>
              <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-Type"><emph>Type</emph></a> }</expression>
             </clause>
            </multiclause>
            <multiclause>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_nil_annotate_as" class="judgment"><term>nil-annotate as</term></a>
              <a href="#doc-fs-OptNillable"><emph>OptNillable</emph></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript>) <a href="#jd_nil_annotate_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript></expression>
             </clause>
            </multiclause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-AttributeType"><emph>AttributeType</emph></a> (
             attribute <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <code>xs:anySimpleType</code> {
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>1</subscript> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> attribute
             <a href="#doc-fs-AttributeName"><emph>AttributeName</emph></a> of type <a href="#doc-fs-TypeName"><emph>TypeName</emph></a> { <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a><subscript>2</subscript>
             }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a document node yields a document with the
        annotation of its contents.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <a href="#doc-fs-Type"><emph>Type</emph></a> (<a href="#doc-fs-Value"><emph>Value</emph></a>)
              <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> <a href="#doc-fs-Value"><emph>Value</emph></a>'</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> document { <a href="#doc-fs-Type"><emph>Type</emph></a> } (
             document { <a href="#doc-fs-Value"><emph>Value</emph></a> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> document
             { <a href="#doc-fs-Value"><emph>Value</emph></a>' }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a text node as text yields itself.</p>

        <infergr>
          <infer>
           <prejudge>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> text (text { <emph>String</emph> })
             <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a> text { <emph>String</emph> }</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a text nodes as a simple type is identical to
        casting.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> ( <emph>String</emph> ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <emph>SimpleType</emph> ( text {
             <emph>String</emph> } ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>

        <p>Annotating a simple value as a simple type is identical to
        casting.</p>

        <infergr>
          <infer>
           <prejudge>
             <clause>
              <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
              <expression><a href="#jd_cast_as" class="judgment"><term>simply annotate as</term></a> <emph>SimpleType</emph> (
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> ) <a href="#jd_cast_as" class="judgment"><term>=&gt;</term></a>
              <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression>
             </clause>
           </prejudge>
           <postjudge>
            <clause>
             <environment><a href="#xq_stat_env_def" class="env">statEnv</a></environment>
             <expression><a href="#jd_annotate_as" class="judgment"><term>annotate as</term></a> <emph>SimpleType</emph> (
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a> ) <a href="#jd_annotate_as" class="judgment"><term>=&gt;</term></a>
             <a href="#doc-fs-SimpleValue"><emph>SimpleValue</emph></a>'</expression>
            </clause>
           </postjudge>
          </infer>
        </infergr>
      </smrules>
     </div4>
   </div3>
  </div2>
</inform-div1>

     <inform-div1 id="id-fs-revisions-log"><head>Revision Log</head>

  <p>This log records the changes that have been made to this document
  since the Working Draft of September 3 June 2005 Last Call Working Draft.</p>

  <div2 id="sec_changes_09152005">
    <head>15 September 2005</head>

    <olist>
      <item><p>Completely removed the formal specification of error
      propagation, and which kind of dynamic errors are
      raised.</p></item>
      <item><p>Fixed static typing rules for fn:subsequence</p></item>
      <item><p>Numerous fixes to static typing rules for function
      calls, including overloaded functions in Appendix B.2.</p></item>
      <item><p>Fixed bugs in auxiliary functions dealing with type
      promotion and atomization in the semantics of function
      calls.</p></item>
      <item><p>Fixed handling of namespace "unbinding" under the
      namespaces rules for XML 1.1.</p></item>
      <item><p>Fixed dynamic evaluation rules for literals.</p></item>
      <item><p>Fixed static typing rules for document constructors.</p></item>
      <item><p>Fixed a bug in the rule implementing the 'union
      interpretation' for derivation by extension.</p></item>
      <item><p>Fixed bugs in the rules for module import, now dealing
      with multiple modules with the same namespace properly.</p></item>
      <item><p>Fixed terminology for some aspects of the type system,
      and added clarification pointers in a number of
      places.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing last call comments.</p></item>
      <item><p>A few minor fixes to the core grammar (e.g.,
      Constructor production was missing).</p></item>
    </olist>
  </div2>

  <div2 id="sec_changes_11032005">
    <head>03 November 2005 (CR Draft)</head>

    <olist>
      <item><p>Numerous improvements and clarifications in the
      preliminary section which introduces the formal semantics
      notations.</p></item>
      <item><p>Complete refactoring of the formal semantics of
      function calls.</p></item>
      <item><p>Always provide the normalization rule even for the
      trivial cases.</p></item>
      <item><p>Default values in formal notations are only used in
      examples, not in inference rules anymore.</p></item>
      <item><p>Removed the use of the confusing notation
      <emph>NonTerminal</emph>?  in inference rules.</p></item>
      <item><p>Fixes to the formal semantics of
      constructors.</p></item>
      <item><p>Fixes to the semantics of global variables and function
      declarations.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing last call comments.</p></item>
      <item><p>Grammar productions now have a marker indicating when
      they correspond to the XQuery or the XPath grammar.</p></item>
    </olist>
  </div2>

  <div2 id="sec_changes_06092006">
    <head>09 June 2006</head>

    <olist>
      <item><p>Replaced the xdt: namespace with the xs: namespace
      throughout the specification.</p></item>
      <item><p>Fixed a bug with precedence in the normalization of
      path expressions.</p></item>
      <item><p>Fixed a bug in the normalization of
      fs:eq().</p></item>
      <item><p>Added some clarifications in the section on Notations,
      notably for judgments using ellipses, and the definition of
      formal atomic values.</p></item>
      <item><p>Removed unused productions from the XQuery Core
      (Module, MainModule, LibraryModule, Prolog, Setter, Import,
      VersionDecl).</p></item>
      <item><p>Fixed inappropriate use of QNames in inference rules
      where an expanded-QName is expected (notably when handling
      variables and function signatures in the static
      context).</p></item>
      <item><p>Simplified the normalization of FLWOR expressions.</p></item>
      <item><p>An index of the judgments used in this specification
      has been added in <specref ref="sec_indexes"/>.</p></item>
      <item><p>Fixed numerous bugs and typos, as a result of
      processing the remaining last call comments.</p></item>
    </olist>
  </div2>

</inform-div1>


  </back>
</spec><!--
Local Variables:
indent-tabs-mode:nil
End:
-->
