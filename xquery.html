<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="JA">
<head>
<meta name="generator" content=
"HTML Tidy for Mac OS X (vers 1 September 2005), see www.w3.org" />
<title>XQuery 1.0: XML問合せ言語</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-CR.css" />
</head>
<body>
<p>訳注: この文書は<a href=
"http://www.w3.org/TR/2006/CR-xquery-20060608/">http://www.w3.org/TR/2006/CR-xquery-20060608/</a>を国島丈生(<a href="mailto:kunishi@acm.org">kunishi@acm.org</a>)が訳したものです。この日本語訳はあくまで参考であり、また翻訳には誤りが含まれる可能性があります。ご利用は自己責任でお願いします。一部に翻訳未完成の部分が含まれている場合があります。</p>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XQuery 1.0: XML問合せ言語</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C勧告候補 8 June
2006</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2006/CR-xquery-20060608/">http://www.w3.org/TR/2006/CR-xquery-20060608/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a></dd>
<dt>Previous versions:</dt>
<dd><a href=
"http://www.w3.org/TR/2005/CR-xquery-20051103/">http://www.w3.org/TR/2005/CR-xquery-20051103/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xquery-20050915/">http://www.w3.org/TR/2005/WD-xquery-20050915/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xquery-20050404/">http://www.w3.org/TR/2005/WD-xquery-20050404/</a>
<a href=
"http://www.w3.org/TR/2005/WD-xquery-20050211/">http://www.w3.org/TR/2005/WD-xquery-20050211/</a>
<a href=
"http://www.w3.org/TR/2004/WD-xquery-20040723/">http://www.w3.org/TR/2004/WD-xquery-20040723/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xquery-20031112/">http://www.w3.org/TR/2003/WD-xquery-20031112/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xquery-20030822/">http://www.w3.org/TR/2003/WD-xquery-20030822/</a>
<a href=
"http://www.w3.org/TR/2003/WD-xquery-20030502/">http://www.w3.org/TR/2003/WD-xquery-20030502/</a></dd>
<dt>Editors:</dt>
<dd>Scott Boag (XSL WG), IBM Research <a href=
"mailto:scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>
<dd>Don Chamberlin (XML Query WG), IBM Almaden Research Center
<a href=
"mailto:chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd>
<dd>Mary F. Fernández (XML Query WG), AT&amp;T Labs <a href=
"mailto:mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>
<dd>Daniela Florescu (XML Query WG), Oracle <a href=
"mailto:dana.florescu@oracle.com">&lt;dana.florescu@oracle.com&gt;</a></dd>
<dd>Jonathan Robie (XML Query WG), DataDirect Technologies <a href=
"mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd>
<dd>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center
<a href=
"mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd>
</dl>
<p>This document is also available in these non-normative formats:
<a href=
"http://www.w3.org/TR/2006/CR-xquery-20060608/xquery.xml">XML</a>
and&nbsp;<a href=
"http://www.w3.org/TR/2006/CR-xquery-20060608/diff-from-20051103.html">Recent
revisions</a>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2006&nbsp;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.org/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p class="xquery">XMLはさまざまな目的に利用できるマークアップ言語であり、
種々のデータ源の情報内容をラベル付けする能力を持つ。ここでデータ源には
構造文書や半構造文書、関係データベース、オブジェクトレポジトリなどが
含まれる。XMLの構造を利用する問合せ言語は、これらの種類のデータすべてに
またがる問合せをうまく表現することができる。データが物理的にXMLとして
格納されているか、ミドルウェアを通してXMLのビューとして見えているかには
よらない。この仕様書は、XQueryと呼ばれる問合せ言語について記述する。
これは、多くの型のXMLデータ源にまたがって広く適用可能であるように 設計されている。</p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>On 3 November 2005, this specification <span class=
"xquery"><a href=
"http://www.w3.org/TR/2005/CR-xquery-20051103/">was
published</a></span> as a <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR">Candidate
Recommendation</a>, and a Call for Implementations was announced.
This revision is published in order to give visibility to the
technical decisions that have been made so far during this phase of
the process and to allow review by W3C Members and other interested
parties. The maturity level of the specification remains unchanged,
and the work is on track to move forward to the <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
Recommendation</a> stage when the exit criteria for the current
phase have been met.</p>
<p>Publication as a Candidate Recommendation does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress. This specification will remain a Candidate Recommendation
until at least 28 February 2006.</p>
<p>The <a href="http://www.w3.org/XML/Query/test-suite/">XPath and
XML Query Test Suite</a> is under development. Implementors are
encouraged to run this test suite and report their results.
<span class="xquery">A <a href=
"http://www.w3.org/XML/Query/test-suite/XQTSReport.html">preliminary
XQuery Test Suite Result Summary</a> has been prepared that
contains information submitted for several
implementations.</span></p>
<p><span class="xquery">This document has been produced by the
<a href="http://www.w3.org/XML/Query">XML Query Working Group</a>
(WG), which is part of the <a href=
"http://www.w3.org/XML/Activity">XML Activity</a>.</span></p>
<p>This draft includes corrections and changes based on <a href=
"http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=XPath&amp;component=XQuery&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">
public comments</a> recorded in the W3C public Bugzilla repository
(<a href=
"http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</a>)
used for Last Call issues tracking. A list of substantive changes
since the publication of the <a href=
"http://www.w3.org/TR/2005/CR-xquery-20051103/">Candidate
Recommendation</a> of 03 November 2005 can be found in <a href=
"#id-revisions-log"><b>J Revision Log</b></a>.</p>
<p>Comments on this document are invited and should be made in
W3C's <a href="http://www.w3.org/Bugs/Public/">public Bugzilla
system</a> (instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery mailing list, <a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string <span class=
"xquery">[XQuery]</span> in the subject line of your comment,
whether made in Bugzilla or in email. Each Bugzilla entry and email
message should contain only one comment. Archives of the comments
and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>
.</p>
<p>This document was produced by operating under the <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2002/08/xmlquery-IPR-statements">public list of
any patent disclosures</a> made in connection with the deliverables
of the XML Query Working Group instructions for disclosing a
patent. An individual who has actual knowledge of a patent which
the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> with respect to this specification should
disclose the information in accordance with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">まえがき</a><br />
2 <a href="#id-basics">基本事項</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#context">式文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 <a href=
"#static_context">静的文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 <a href=
"#eval_context">動的文脈</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href=
"#id-processing-model">処理モデル</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 <a href=
"#id-data-model-generation">データモデルの生成</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 <a href=
"#id-schema-import-processing">スキーマの輸入処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 <a href=
"#id-expression-processing">式の処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1
<a href="#id-static-analysis">静的解析相</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2
<a href="#id-dynamic-evaluation">動的評価相</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 <a href=
"#id-serialization">直列化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.5 <a href=
"#id-consistency-constraints">無矛盾性制約</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#errors">エラー処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href=
"#id-kinds-of-errors">エラーの種類</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <a href=
"#id-identifying-errors">エラーの識別と報告</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <a href=
"#id-handling-dynamic">動的エラーの処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.4 <a href=
"#id-errors-and-opt">エラーと最適化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href=
"#id-important-concepts">概念</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href=
"#id-document-order">文書順</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <a href=
"#id-atomization">原子化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 <a href=
"#id-ebv">有効ブール値</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.4 <a href=
"#id-input-sources">入力源</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.5 <a href=
"#id-uri-literals">URIリテラル</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#id-types">型</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 <a href=
"#id-predefined-types">既定義スキーマ型</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.2 <a href=
"#id-typed-value">型付けされた値と文字列値</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.3 <a href=
"#id-sequencetype-syntax">SequenceTypeの文法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4 <a href=
"#id-sequencetype-matching">SequenceTypeの照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.1
<a href="#id-matching-value">SequenceTypeと値の照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.2
<a href="#id-matching-item">ItemTypeと項目の照合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.3
<a href="#id-element-test">要素テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.4
<a href="#id-schema-element-test">スキーマ要素テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.5
<a href="#id-attribute-test">属性テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.6
<a href="#id-schema-attribute-test">スキーマ属性テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#comments">コメント</a><br />
3 <a href="#id-expressions">式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href=
"#id-primary-expressions">基本式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <a href=
"#id-literals">リテラル</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 <a href=
"#id-variables">変数参照</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <a href=
"#id-paren-expressions">括弧式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <a href=
"#id-context-item-expression">文脈項目式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <a href=
"#id-function-calls">関数呼び出し</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href=
"#id-path-expressions">経路式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <a href=
"#id-steps">ステップ</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.1
<a href="#axes">軸</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.2
<a href="#node-tests">節点テスト</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <a href=
"#id-predicates">述語</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 <a href=
"#unabbrev">非省略構文</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.4 <a href=
"#abbrev">省略構文</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href=
"#id-sequence-expressions">列式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <a href=
"#construct_seq">列の構成</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <a href=
"#id-filter-expr">選別式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <a href=
"#combining_seq">節点列の結合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#id-arithmetic">算術式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#id-comparisons">比較式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.1 <a href=
"#id-value-comparisons">値比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.2 <a href=
"#id-general-comparisons">汎用比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.3 <a href=
"#id-node-comparisons">節点比較</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.6 <a href=
"#id-logical-expressions">論理式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.7 <a href=
"#id-constructors">構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1 <a href=
"#id-element-constructor">直接要素構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.1
<a href="#id-attributes">属性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.2
<a href="#id-namespaces">名前空間宣言属性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.3
<a href="#id-content">内容</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.4
<a href="#id-whitespace">境界空白</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.2 <a href=
"#id-otherConstructors">その他の直接構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3 <a href=
"#id-computedConstructors">被計算構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.1
<a href="#id-computedElements">被計算要素構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.2
<a href="#id-computedAttributes">被計算属性構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.3
<a href="#id-documentConstructors">文書節点構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.4
<a href="#id-textConstructors">テキスト節点構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.5
<a href="#id-computed-pis">被計算処理命令構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.6
<a href="#id-computed-comments">被計算コメント構成子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.4 <a href=
"#id-ns-nodes-on-elements">構成された要素の有効範囲内名前空間</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.8 <a href="#id-flwor-expressions">FLWOR
式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.1 <a href=
"#id-for-let">For 節と Let 節</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.2 <a href=
"#id-where">Where 節</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.3 <a href=
"#id-orderby-return">Order By 節と Return 節</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.4 <a href=
"#id-flwor-example">例</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.9 <a href=
"#id-unordered-expressions">順序化式と非順序化式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.10 <a href=
"#id-conditionals">条件式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.11 <a href=
"#id-quantified-expressions">限量式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.12 <a href=
"#id-expressions-on-datatypes">SequenceTypes上の式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.1 <a href=
"#id-instance-of">Instance Of</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.2 <a href=
"#id-typeswitch">Typeswitch</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.3 <a href=
"#id-cast">Cast</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.4 <a href=
"#id-castable">Castable</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.5 <a href=
"#id-constructor-functions">構成子関数</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.6 <a href=
"#id-treat">Treat</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.13 <a href="#id-validate">検証式</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;3.14 <a href=
"#id-extension-expressions">拡張式</a><br />
4 <a href="#id-query-prolog">モジュールと前書き</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href=
"#id-version-declaration">バージョン宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href=
"#id-module-declaration">モジュール宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href=
"#id-boundary-space-decls">境界空白宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href=
"#id-default-collation-declaration">デフォルト照合順序宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href="#id-base-uri-decl">基礎 URI
宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.6 <a href=
"#id-construction-declaration">構成宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.7 <a href=
"#id-default-ordering-decl">順序付けモード宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.8 <a href=
"#id-empty-order-decl">空順序宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.9 <a href=
"#id-copy-namespaces-decl">名前空間複製宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.10 <a href=
"#id-schema-imports">スキーマ輸入</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.11 <a href=
"#id-module-imports">モジュール輸入</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.12 <a href=
"#id-namespace-decls">名前空間宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.13 <a href=
"#id-default-namespace">デフォルト名前空間宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.14 <a href=
"#id-variable-declarations">変数宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.15 <a href=
"#FunctionDeclns">関数宣言</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;4.16 <a href=
"#id-option-declaration">オプション宣言</a><br />
5 <a href="#id-xquery-conformance">適合性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href=
"#id-minimal-conformance">最小適合性</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href=
"#id-conform-optional-features">省略可能な機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href=
"#id-schema-import-feature">スキーマ輸入機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a href=
"#id-schema-validation-feature">スキーマ検証機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a href=
"#id-static-typing-feature">静的型付け機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3.1
<a href="#id-static-extensions">静的型付け拡張</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 <a href=
"#id-full-axis-feature">全軸機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.5 <a href=
"#id-module-feature">モジュール機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.6 <a href=
"#id-serialization-feature">直列化機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.7 <a href=
"#id-trivial-xml-embedding-feature">自明な XML 埋め込み機能</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href=
"#id-data-model-conformance">データモデル適合</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XQueryの文法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#id-grammar">EBNF</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.1 <a href=
"#EBNFNotation">記法</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.2 <a href=
"#extra-grammatical-constraints">特別な文法上の制約</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.3 <a href=
"#notes-on-parsing">文法に関する備考</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href=
"#lexical-structure">字句構造</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.1 <a href=
"#terminal-symbols">終端記号</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.2 <a href=
"#id-terminal-delimitation">終端記号の区切り</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3 <a href=
"#id-eol-handling">行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.1
<a href="#id-xml10-eol-handling">XML 1.0の行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.2
<a href="#id-xml11-eol-handling">XML 1.1の行末処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4 <a href=
"#whitespace-rules">空白規則</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.1
<a href="#DefaultWhitespaceHandling">デフォルト空白処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.2
<a href="#ExplicitWhitespaceHandling">明示的空白処理</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.3 <a href=
"#id-reserved-fn-names">予約済関数名</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;A.4 <a href=
"#id-precedence-order">優先順位</a><br />
B <a href=
"#id-type-promotion-and-operator-mapping">型の昇格と演算子の写像</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.1 <a href="#promotion">型の昇格</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;B.2 <a href="#mapping">演算子の写像</a><br />
C <a href="#id-xq-context-components">文脈の構成要素</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href=
"#id-xq-static-context-components">静的文脈の構成要素</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href=
"#id-xq-evaluation-context-components">動的文脈の構成要素</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;C.3 <a href=
"#id-xq-serialization-parameters">直列化パラメータ</a><br />
D <a href="#id-impl-defined-items">実装定義の項目</a><br />
E <a href="#id-references">参考文献</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.1 <a href=
"#id-normative-references">規格</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.2 <a href=
"#id-non-normative-references">参考</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;E.3 <a href=
"#id-background-material">背景資料</a><br />
F <a href="#id-errors">エラー条件</a><br />
G <a href="#id-mime-type">application/xquery メディア型</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.1 <a href=
"#id-mime-type-intro">はじめに</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.2 <a href=
"#id-registration-of-mime-type">MIME メディア型 application/xquery
の登録</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.1 <a href=
"#id-interoperability-considerations">相互運用性に関する考慮</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.2 <a href=
"#id-applications-of-media-type">このメディア型を用いている応用</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.3 <a href=
"#id-file-extensions">ファイルの拡張子</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.4 <a href=
"#id-intended-usage">意図する用い方</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.5 <a href=
"#id-author-change-controller">著者/変更の管理者</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.3 <a href=
"#xquery-mime-encoding">符号化に関する考慮</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.4 <a href=
"#xquery-mime-recognizing">XQuery ファイルの認識</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.5 <a href=
"#id-charset-default-rules">文字集合デフォルトルール</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;G.6 <a href=
"#id-security-considerations">セキュリティに関する考慮</a><br />
H <a href="#id-glossary">用語集</a> (Non-Normative)<br />
I <a href="#id-example-applications">応用例</a> (Non-Normative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;I.1 <a href="#id-joins">結合</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.2 <a href="#id-grouping">グループ化</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.3 <a href=
"#id-queries-on-sequence">列への問合せ</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.4 <a href=
"#id-recursive-transformations">再帰的変換</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;I.5 <a href=
"#id-select-distinct">区別可能な組み合わせの選択</a><br />
J <a href="#id-revisions-log">Revision Log</a>
(Non-Normative)<br />
&nbsp;&nbsp;&nbsp;&nbsp;J.1 <a href="#id-log-050707">10 May
2006</a><br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="id-introduction" id="id-introduction"></a>1 まえがき</h2>
<p class="xquery">XMLを用いて蓄積されたり、交換されたり、表現
されている情報の量が増えており、XMLデータ源に対してうまく問合せを
行う機能がますます重要になっている。XMLの素晴らしい利点の一つは、 種々のデータ源から得られる多くの異なる種類の情報を表現する際の
柔軟性である。この柔軟性を活用するため、XML問合せ言語は、これらの 種々のデータ源から情報を検索したり、その情報を解釈する機能を
用意しなければならない。</p>
<p class="xquery">XQueryは、W3C XML Queryワーキンググループ <a href=
"#Requirements">[XML Query 1.0 Requirements]</a>によって認識された要求や
<a href="#UseCases">[XML Query Use Cases]</a>にある利用例に応えるように設計されている。
この言語は、問合せが簡潔で、容易に理解できるように設計されている。 また、広範囲のXML情報源に問合せが行えるよう、充分な柔軟性も
持っている。W3C XML Queryワーキンググループでは、非XML形式の
問合せ構文とXMLによる問合せ構文の両方についての要求を認識して いる。XQueryはこれらの要求のうち、最初の2つに応えるように設計
されている。XQueryは、Quilt<a href="#Quilt">[Quilt]</a>と呼ばれる
XML問合せ言語に由来している。この言語はさらに、他の多くの言語から 機能を借用している。XPath 1.0 <a href=
"#XPath">[XPath 1.0]</a>, XQL <a href="#XQL">[XQL]</a>, XML-QL
<a href="#XML-QL">[XML-QL]</a>, SQL <a href="#SQL">[SQL]</a>, OQL
<a href="#ODMG">[ODMG]</a> などである。</p>
<p>[<a name="dt-datamodel" id="dt-datamodel" title=
"data model">Definition</a>: XQueryは、XML文書の抽象
的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<b>データモデル</b>と呼ばれ、<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>で定義されている。]</p>
<p>XQueryバージョン1.0はXPathバージョン2.0の拡張である。XPath2.0でもXQuery
1.0でも構文的に正しく、かつ正常に実行される式はすべて、いずれの言語でも同じ結果を返す。これらの言語は非常に密接に関連しているため、これらの言語の文法や言語記述は、一貫性を保つために共通のソースから生成されており、これらの仕様書の編者は密に協力して作業を進めている。</p>
<p>またXQueryは、以下の仕様書に依存しており、密接に関連している。</p>
<ul>
<li>
<p><a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>では、すべてのXQuery式の基礎となるデータモデルを定義する。</p>
</li>
<li>
<p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal
Semantics]</a>では、XQueryの静的な意味を定義する。また動的な意味に関して、形式的ではあるが規範ではない記述を含んでいる。これは、実装を行う人や形式的定義を必要とする人に有用である。</p>
</li>
<li>
<p>XQueryの型システムは<a href="#XMLSchema">[XML Schema]</a>に基づいている。</p>
</li>
<li>
<p>XQueryで支援されている組み込み関数ライブラリや演算子は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義される。</p>
</li>
<li>
<p><a href="#Requirements">[XML Query 1.0
Requirements]</a>にある要求の一つに、XML問合せ 言語は人間に読みやすい構文とXMLに基づく構文の両方を持つ、と
いうものがある。XMLに基づくXQueryについては、 <a href="#XQueryX">[XQueryX
1.0]</a>で記述されている。</p>
</li>
</ul>
<p>この文書は<a href="#XML">[XML
1.0]</a>で用いられているのと同じ基本的なEBNF記法を用いて、XQueryの文法を規定する。特に注釈を加えない限り(<a href="#lexical-structure"><b>A.2
字句構造</b></a>)、空白は<span class=
"xquery">問合せ</span>中では意味を持たない。文法の生成規則は、それが記述している特徴とともに紹介される。また、完全な文法は付録
[<a href="#nt-bnf"><b>A XQueryの文法</b></a>]で示される。この付録は規定版である。</p>
<p>
この文書中の文法の生成規則では、名前を持つ記号には下線を引き、リテラルテキストは二重引用符で囲む。例えば、次の生成規則は関数呼び出しの構文を記述している:</p>
<h5><a name="d2e277" id="d2e277"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="fakeid_doc-xquery-FunctionCall" id=
"fakeid_doc-xquery-FunctionCall"></a>[93]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a> "(" (<a href=
"#doc-xquery-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>この生成規則は次のように読むべきである:
関数呼び出しは、一つの開き括弧が続く一つのQNameからなる。その開き括弧の次には、省略可能な引数リストが続く。引数リストは(もし存在するならば)1つ以上の式からなり、それらはコンマで区切られる。省略可能な引数リストの次には、1つの閉じ括弧が続く。</p>
<p>
この仕様書では、言語処理のいくつかの面について、<b>実装定義</b>または<b>実装依存</b>という言葉で記述している。</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>実装定義</b>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>実装依存</b>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。]</p>
</li>
</ul>
<p>この文書はXQueryの動的な意味を規定として定義する。XQueryの静的な意味は<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>において規定として定義されている。この文書では、例、および「Note:」というラベルの付けられた資料は説明の目的で用意されたものであり、参考(not
normative)である。</p>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>2 基本事項</h2>
<p>XQueryの基本的な構成ブロックは<b>式</b>である。これは<a href=
"#Unicode">[Unicode]</a>文字(使用されるUnicodeの版は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。)の列である。この言語には、キーワード、記号、演算数などから構成される様々な種類の式が用意されている。一般的に、式の演算数は別の式である。XQueryでは、式は完全に一般的な入れ子であってもよい。<span class="xquery">(しかし、純粋な関数型言語とは異なり、変数の定義が新しい節点の構成からなっているならば、その変数への代入は許されない。)</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>この仕様書では、<a href=
"#Unicode">[Unicode]</a>文字の文字列の文字符号化方式に関して、何も仮定しないし、何も要求しない。</p>
</div>
<p>
XMLと同様に、XQueryは大文字小文字を区別する言語である。XQueryのキーワードは小文字を用い、かつ予約されていない。すなわち、XQuery式に出現する名前はXQuery言語のキーワードと同じであってもよい。ただし<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>に挙げられている接頭語なし関数名を除く。</p>
<p>[<a name="dt-value" id="dt-value" title="value">Definition</a>:
<a title="data model" href=
"#dt-datamodel">データモデル</a>では、<b>値</b>は常に<a title="sequence" href=
"#dt-sequence">列</a>である。] [<a name="dt-sequence" id="dt-sequence"
title="sequence">Definition</a>: <b>列</b>は0個以上の<a title="item"
href="#dt-item">項目</a>の順序付きコレクションである。] [<a name="dt-item" id=
"dt-item" title="item">Definition</a>: <b>項目</b>は<a title=
"atomic value" href="#dt-atomic-value">原子値</a>か<a title="node"
href="#dt-node">節点</a>である。] [<a name="dt-atomic-value" id=
"dt-atomic-value" title="atomic value">Definition</a>:
<b>原子値</b>は<a href="#XMLSchema">[XML
Schema]</a>で定義される<b>原子型</b>の値空間に含まれる値である。] [<a name="dt-node" id=
"dt-node" title="node">Definition</a>: <b>節点</b>は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>で定義されている<b>節点の種類</b>のいずれかのインスタンスである。]
各節点は唯一の<b>節点識別性</b>、1つの<b>型付けされた値</b>、そして1つの<b>文字列値</b>を持つ。これに加え、いくつかの節点は<b>名前</b>を持つ。節点の<b>型付けされた値</b>は0個以上の原子値からなる列である。節点の<b>文字列値</b>は<code>xs:string</code>型の値である。節点の<b>名前</b>は<code>xs:QName</code>型の値である。</p>
<p>[<a name="dt-singleton" id="dt-singleton" title=
"singleton">Definition</a>:
ただ一つの項目しか含まない列を<b>単一値列</b>という。]項目は、その項目を含む単一値列と同一である。列が入れ子になることは決してない。例えば1,
(2, 3), () という値を一つの列に結合した結果は (1, 2, 3)になる。[<a name=
"dt-empty-sequence" id="dt-empty-sequence" title=
"empty sequence">Definition</a>: 0個の項目を含む列を<b>空列</b>という。]</p>
<p>[<a name="dt-data-model-instance" id="dt-data-model-instance"
title="XDM instance">Definition</a>:
<b>XDMインスタンス</b>という用語は<b>値</b>という用語と同義であり、<a title="data model"
href="#dt-datamodel">データモデル</a>中の<a title="node" href=
"#dt-node">節点</a>や<a title="atomic value" href=
"#dt-atomic-value">原子値</a>からなる制約なしの列を表す。]</p>
<p>XQueryにおける名前は<b>QName</b>と呼ばれ、<a href="#XMLNAMES">[XML
Names]</a>中の文法に従う。[<a name="dt-qname" id="dt-qname" title=
"QName">Definition</a>:
字句としては、<b>QName</b>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。]
字句としてのQNameは、<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>[<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]を用いて名前空間接頭辞を名前空間URIに解決することにより、<b>展開済QName</b>に変換することができる。
[<a name="dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName">Definition</a>:
<b>展開済QName</b>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。]名前空間URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>のためのルールに従って、空白に関して正規化される。2つの展開済QNameが等しいとは、それらの名前空間URIが等しく、かつそれらの局所名が等しいときである(それらの名前空間接頭辞が等しくなくてもよい)。名前空間URIと局所名はコード位置に基づいて比較され、それ以上の正規化は行われない。</p>
<p class="xquery">ある名前空間接頭辞は XQuery
であらかじめ宣言されており、固定された名前空間URIに束縛されている。これらの名前空間接頭辞は以下の通りである。</p>
<ul>
<li>
<p><code>xml = http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>local =
http://www.w3.org/2005/xquery-local-functions</code> (<a href=
"#FunctionDeclns"><b>4.15 関数宣言</b></a>を見よ。)</p>
</li>
</ul>
<p class="xquery">
上のリスト中の接頭辞に加え、この文書では接頭辞<code>err</code>を名前空間URI<code>http://www.w3.org/2005/xqt-errors</code>を表すものとして用いる
(<a href="#id-identifying-errors"><b>2.3.2
エラーの識別と報告</b></a>を見よ)。この名前空間接頭辞はあらかじめ宣言されてはおらず、この文書中での使用は参考である。</p>
<p>要素節点は<b>有効範囲内名前空間</b>と呼ばれる性質を持つ。[<a name=
"dt-in-scope-namespaces" id="dt-in-scope-namespaces" title=
"in-scope namespaces">Definition</a>:
要素節点の<b>有効範囲内名前空間</b>性質は、<b>名前空間束縛</b>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a href="#XPath">[XPath
1.0]</a>では、ある要素節点の有効範囲内名前空間は<b>名前空間軸</b>上に置かれた<b>名前空間節点</b>のコレクションとして表現される。<a href="#XPath20">[XPath
2.0]</a>では、これは省略可能であり、推奨されない。XQueryは名前空間軸を支援せず、名前空間の束縛を節点の形式で表現することはない。しかし、<a href="#serialization">[XSLT
2.0 and XQuery 1.0
Serialization]</a>のように別の仕様書が名前空間節点を参照している場合には、これらの節点が要素節点の有効範囲内名前空間から合成される。これは、それぞれの名前空間束縛を名前空間節点と解釈することで行われる。</p>
</div>
<p>[<a name="dt-URI" id="dt-URI" title="URI">Definition</a>:
この仕様書では、<b>URI</b>という用語は、<a href=
"#RFC3986">[RFC3986]</a>で定義され<a href=
"#RFC3987">[RFC3987]</a>で新しい名前<b>IRI</b>として拡張されたUniversal Resource
Identifierを表す。] ただし、IRIよりもURIという用語を好んで残している。"Base
URI"のように、すべてのXML関連の仕様書で定義され、また参照されてきた概念に新しい名前を与えることを避けるためである。</p>
<div class="div2">
<h3><a name="context" id="context"></a>2.1 式文脈</h3>
<p>[<a name="dt-expression-context" id="dt-expression-context"
title="expression context">Definition</a>:
ある式に対する<b>式文脈</b>は、その式の結果に影響を与えうるすべての情報からなる。] この情報は<a title=
"static context" href="#dt-static-context">静的文脈</a>と<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>という2種類に分けられる。</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>2.1.1
静的文脈</h4>
<p>[<a name="dt-static-context" id="dt-static-context" title=
"static context">Definition</a>:
式の<b>静的文脈</b>は、その式の評価よりも静的解析において有効である情報である。] この情報は、式が<a title=
"static error" href=
"#dt-static-error">静的エラー</a>を含むかどうか決定するのに用いることができる。もし式の解析が、<a title="static context"
href=
"#dt-static-context">静的文脈</a>中の値を割り当てられていない構成要素に依存するならば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する [<a title=
"err:XPST0001" href="#ERRXPST0001">err:XPST0001</a>]。</p>
<p><a title="static context" href=
"#dt-static-context">静的文脈</a>の構成要素を以下にまとめる。<span class=
"xquery">有効範囲を管理したり、これらの構成要素を初期化するルールは、<a href=
"#id-xq-static-context-components"><b>C.1
静的文脈の構成要素</b></a>にある。</span></p>
<ul>
<li>
<p>[<a name="dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode">Definition</a>: <b>XPath
1.0互換モード</b>。<span class="xquery">この構成要素は、XPath 2.0
を部分集合として含むようなすべてのホスト言語で設定されなければならない。この構成要素により、XPath 1.0
との互換性のためのルールが有効であるかどうかを示す。XQuery
では、この構成要素の値を<code>false</code>に設定している。</span>]</p>
</li>
<li>
<p>[<a name="dt-static-namespaces" id="dt-static-namespaces" title=
"statically known namespaces">Definition</a>:
<b>静的既知名前空間</b>。これは、組(接頭辞,
URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。] URIの値は<a href=
"#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">有効範囲内名前空間</a>と<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の違いに注意せよ。前者は要素節点の動的性質であり、後者は式の静的性質である。</p>
<p class="xquery">
いくつかの名前空間はあらかじめ定義されている。付加的な名前空間を静的既知名前空間に加えることができる。これは、<a title=
"Prolog" href="#dt-prolog">前書き</a>中の<a title=
"namespace declaration" href=
"#dt-namespace-declaration">名前空間宣言</a>による方法や、<a title=
"direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>中の<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間定義属性</a>による方法がある。</p>
</li>
<li>
<p>[<a name="dt-def-elemtype-ns" id="dt-def-elemtype-ns" title=
"default element/type namespace">Definition</a>:
<b>デフォルト要素/型名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。]
URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-def-fn-ns" id="dt-def-fn-ns" title=
"default function namespace">Definition</a>:
<b>デフォルト関数名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。]
URIの値は、<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-issd" id="dt-issd" title=
"in-scope schema definitions">Definition</a>:
<b>有効範囲内スキーマ定義</b>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。]
次の3つの部分を含む。</p>
<ul>
<li>
<p>[<a name="dt-is-types" id="dt-is-types" title=
"in-scope schema type">Definition</a>: <b>有効範囲内スキーマ型</b>。各スキーマ型定義は、
<a title="expanded QName" href="#dt-expanded-qname">展開済QName</a>
(<b>名前付けされた型</b>に対して) か<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の型識別子
(<b>無名型</b>に対して)のいずれかで識別される。有効範囲内スキーマ型は<a href=
"#id-predefined-types"><b>2.5.1 既定義スキーマ型</b></a>で述べられる既定義スキーマ型を含む。
<span class="xquery">もし<a title="schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内スキーマ型には、輸入されたスキーマ中にある型定義がすべて含まれる。</span>
]</p>
</li>
<li>
<p>[<a name="dt-is-elems" id="dt-is-elems" title=
"in-scope element declarations">Definition</a>:
<b>有効範囲内要素定義</b>。各要素定義は、<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位要素定義に対して)か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の要素識別子
(局所要素定義に対して)のいずれかで識別される。<span class="xquery">もし<a title=
"schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内要素定義には、輸入されたスキーマ定義中にある要素定義がすべて含まれる。</span>]
要素定義は、その要素の<a title="substitution group" href=
"#dt-substitution-group">置換グループ</a>の加入に関する情報を含む。</p>
<p>[<a name="dt-substitution-group" id="dt-substitution-group"
title="substitution group">Definition</a>: <b>置換グループ</b>は<a href=
"#XMLSchema">[XML Schema]</a>第1部,
2.2.2.2節で定義されている。直観的には、与えられた要素(<b>先導要素</b>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。]</p>
</li>
<li>
<p>[<a name="dt-is-attrs" id="dt-is-attrs" title=
"in-scope attribute declarations">Definition</a>: <b>有効範囲内属性定義</b>
各属性定義は<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位属性定義に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の属性識別子
(局所属性定義に対して)のいずれかで識別される。<span class="xquery">もし<a title=
"schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内属性定義には、輸入されたスキーマ中にある属性定義がすべて含まれる。</span>]</p>
</li>
</ul>
</li>
<li>
<p>[<a name="dt-in-scope-variables" id="dt-in-scope-variables"
title="in-scope variables">Definition</a>: <b>有効範囲内変数</b>。これは組
(展開済QName, 型) の集合であり、式中で参照可能な変数の集合を定義する。<a title="expanded QName"
href="#dt-expanded-qname">展開済QName</a>は変数名、型はその変数の<a title=
"static type" href="#dt-static-type">静的型</a>である。]</p>
<p><span class="xquery"><a title="Prolog" href=
"#dt-prolog">前書き</a>中の変数定義は<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>に加えられる。</span> 変数を束縛する式
(<span class="xquery"><code>let</code>式,</span> <code>for</code>式,
<code>some</code>式, <code>every</code>式など)は、その式の部分式の<a title=
"in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>を新しく束縛された変数とその型によって拡張する。<span class="xquery"><b>関数定義</b>中では、<a title="in-scope variables"
href=
"#dt-in-scope-variables">有効範囲内変数</a>は<b>関数の引数</b>の名前と型によって拡張される。</span></p>
<p class="xquery">変数の静的型は、問合せ内で宣言されていてもよいし、(<a title=
"static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が有効になっているなら) <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で記述されている静的型推論ルールによって推論されてもよい。</p>
</li>
<li>
<p>[<a name="dt-context-item-static-type" id=
"dt-context-item-static-type" title=
"context item static type">Definition</a>:
<b>文脈項目の静的型</b>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<a title=
"static type" href="#dt-static-type">静的型</a>を定義する。]</p>
</li>
<li>
<p>[<a name="dt-function-signature" id="dt-function-signature"
title="function signature">Definition</a>:
<b>関数のシグネチャ</b>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<a title=
"expanded QName" href="#dt-expanded-qname">展開済QName</a>と次数 (引数の数)
によって一意に識別される。] 名前と次数に加え、関数のシグネチャはそれぞれ、その関数の引数と結果の<a title=
"static type" href="#dt-static-type">静的型</a>を指定する。</p>
<p><a title="function signature" href=
"#dt-function-signature">関数のシグネチャ</a>は、<a title=
"constructor function" href=
"#dt-constructor-function">構成子関数</a>のシグネチャを含む。これについては<a href=
"#id-constructor-functions"><b>3.12.5 構成子関数</b></a>で議論する。</p>
</li>
<li>
<p>[<a name="dt-static-collations" id="dt-static-collations" title=
"statically known collations">Definition</a>: <b>静的既知照合順序</b>。これは組
(URI, 照合順序)の<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の集合である。<span class=
"xquery">問合せや</span>式の処理に用いることのできる照合順序の名前を定義する。] [<a name=
"dt-collation" id="dt-collation" title="collation">Definition</a>:
<b>照合順序</b>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>を見よ。]</p>
</li>
<li>
<p>[<a name="dt-def-collation" id="dt-def-collation" title=
"default collation">Definition</a>:
<b>デフォルト照合順序</b>。これは、明示的に照合順序が指定されていないときに、<a title=
"statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型
(およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。]</p>
</li>
<li>
<p>[<a name="dt-construction-mode" id="dt-construction-mode" title=
"construction mode">Definition</a>: <b>構成モード</b>。
構成モードは、要素や文書節点の構成子の振舞いを決定する。構成モードが<code>preserve</code>であれば、構成された要素節点の型は<code>xs:anyType</code>であり、節点構成において複製された属性節点や要素節点はすべて、元の型を保存する。構成モードが<code>strip</code>であれば、構成された要素節点の型は<code>xs:untyped</code>であり、節点構成において複製された要素節点はすべて型<code>xs:untyped</code>を受け取り、節点構成において複製された属性節点はすべて型<code>xs:untypedAtomic</code>を受け取る。]</p>
</li>
<li>
<p>[<a name="dt-ordering-mode" id="dt-ordering-mode" title=
"ordering mode">Definition</a>: <b>順序付けモード</b>。
順序付けモードは<code>ordered</code>か<code>unordered</code>という値を取り、ある種の<a title="path expression"
href="#dt-path-expression">経路式</a>, <code>union</code>式,
<code>intersect</code>式, <code>except</code>式, <code>order
by</code>節を持たないFLWOR式などによって生成される結果列の順序付けに影響を与える。]
詳細は、これらの式の記述の中で与える。</p>
</li>
<li>
<p>[<a name="dt-default-empty-order" id="dt-default-empty-order"
title="default order for empty sequences">Definition</a>:
<b>空列のデフォルト順序</b>。 この構成要素は、FLWOR式中の<code>order
by</code>節中の順序付けキーとしての空列や値<code>NaN</code>の処理を制御する。これについての記述は<a href="#id-orderby-return"><b>3.8.3
Order By 節と Return 節</b></a>にある。]
この値は<code>greatest</code>または<code>least</code>であってもよい。</p>
</li>
<li>
<p>[<a name="dt-boundary-space-policy" id=
"dt-boundary-space-policy" title=
"boundary-space policy">Definition</a>:
<b>境界空白ポリシー</b>。この構成要素は、<a title="direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>による<a title=
"boundary whitespace" href=
"#dt-boundary-whitespace">境界空白</a>の処理を制御する。これについての記述は<a href=
"#id-whitespace"><b>3.7.1.4 境界空白</b></a>にある。]
この値は<code>preserve</code>または<code>strip</code>であってもよい。</p>
</li>
<li>
<p>[<a name="dt-copy-namespaces-mode" id="dt-copy-namespaces-mode"
title="copy-namespaces mode">Definition</a>:
<b>名前空間複製モード</b>。この構成要素は、すでにある要素節点が要素構成子によって複製されるときに割り当てられる名前空間束縛を制御する。これについての記述は<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>にある。この値は2つの部分からなる:
<code>preserve</code>または<code>no-preserve</code>、そして<code>inherit</code>または<code>no-inherit</code>である。]</p>
</li>
<li>
<p>[<a name="dt-base-uri" id="dt-base-uri" title=
"base URI">Definition</a>: <b>基底URI</b>。 これは絶対URIであり、
(例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。]
URIの値は<a href="#XMLSchema">[XML
Schema]</a>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p>
</li>
<li>
<p>[<a name="dt-known-docs" id="dt-known-docs" title=
"statically known documents">Definition</a>: <b>静的既知文書</b>。
これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<a title="static type"
href="#dt-static-type">静的型</a>である。]
<code>fn:doc</code>の引数が<b>静的既知文書</b>にはない文字列リテラルであるとき、<code>fn:doc</code>の<a title="static type"
href=
"#dt-static-type">静的型</a>は<code>document-node()?</code>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<b>静的既知文書</b>の目的は静的型情報を提供することであり、どの文書が利用可能かを決定することではない。URIが<b>静的既知文書</b>中になくても、<code>fn:doc</code>を用いてアクセスできる。</p>
</div>
</li>
<li>
<p>[<a name="dt-known-collections" id="dt-known-collections" title=
"statically known collections">Definition</a>:
<b>静的既知コレクション</b>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。]
<code>fn:collection</code>の引数が<b>静的既知コレクション</b>にない文字列リテラルであるとき、<code>fn:collection</code>の<a title="static type"
href="#dt-static-type">静的型</a>は<code>node()*</code>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<b>静的既知コレクション</b>の目的は静的型情報を提供することで、どのコレクションが利用可能かを決定することではない。URIが<b>静的既知コレクション</b>になくても、<code>fn:collection</code>を用いてアクセスできる。</p>
</div>
</li>
<li>
<p>[<a name="dt-known-default-collection" id=
"dt-known-default-collection" title=
"statically known default collection type">Definition</a>:
<b>静的既知デフォルトコレクション型</b>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。]
実装によって他の値に初期化されない限り、<b>静的既知デフォルトコレクション型</b>の値は<code>node()*</code>である。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>2.1.2 動的文脈</h4>
<p>[<a name="dt-dynamic-context" id="dt-dynamic-context" title=
"dynamic context">Definition</a>:
式の<b>動的文脈</b>は、その式が評価されているときに利用可能な情報として定義される。] 式の評価が<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>のうち値が割り当てられていない部分に依存するとき、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する [<a title=
"err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
<p><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の個々の構成要素を以下にまとめる。これらの構成要素の意味を支配する詳細なルールは<a href="#id-xq-evaluation-context-components"><b>C.2
動的文脈の構成要素</b></a>にある。</p>
<p><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>は<a title="static context" href=
"#dt-static-context">静的文脈</a>の部分要素すべて、および以下に列挙する追加構成要素を含む。</p>
<p>[<a name="dt-focus" id="dt-focus" title="focus">Definition</a>:
<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の最初の3つの構成要素
(文脈項目、文脈位置、文脈サイズ)を、式の<b>焦点</b>という。]
焦点を用いると、処理器はどの項目が式によって処理されているかを追跡することができる。</p>
<p>ある種の言語の構成要素、すなわち<a title="path expression" href=
"#dt-path-expression">経路式</a> <code>E1/E2</code>と<a title=
"predicate" href="#dt-predicate">述語</a>
<code>E1[E2]</code>は、部分式の評価の際に新しい焦点を作成する。これらの構成要素では、<code>E1</code>を評価した結果の列中の項目それぞれに対し、<code>E2</code>が1回評価される。
<code>E2</code>が評価されるたびに、異なる焦点で評価が行われる。<code>E2</code>を評価する焦点を<b>内部焦点</b>、<code>E1</code>を評価する焦点を<b>外部焦点</b>という。内部焦点は、<code>E2</code>が評価されている間のみ存在する。この評価が終了するとき、含むほうの式の評価が元の焦点のまま行われる。</p>
<ul>
<li>
<p>[<a name="dt-context-item" id="dt-context-item" title=
"context item">Definition</a>:
<b>文脈項目</b>は現在処理している項目である。項目は原子値か節点である。][<a name="dt-context-node"
id="dt-context-node" title="context node">Definition</a>:
文脈項目が節点であるとき、<b>文脈節点</b>と呼ぶこともできる。]
文脈項目は1つのドット(<code>.</code>)からなる式によって得られる。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E1</code>を評価して得られる列中の項目それぞれが、<code>E2</code>の評価に対する内部焦点の文脈項目となる。</p>
</li>
<li>
<p>[<a name="dt-context-position" id="dt-context-position" title=
"context position">Definition</a>:
<b>文脈位置</b>は、現在処理されている項目列中での文脈項目の位置である。]文脈項目が変化するたび、文脈位置も変化する。焦点が定義されているとき、文脈位置の値は0より大きい整数である。式<code>fn:position()</code>によって文脈位置が返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点での文脈位置は、<code>E1</code>を評価して得られる列中の文脈項目の位置である。列の最初の項目の位置は常に1である。文脈位置は常に、文脈サイズより小さいか等しい。</p>
</li>
<li>
<p>[<a name="dt-context-size" id="dt-context-size" title=
"context size">Definition</a>:
<b>文脈サイズ</b>は、現在処理されている項目列に含まれる項目数である。]
文脈サイズの値は常に0より大きい整数である。式<code>fn:last()</code>によって文脈サイズが返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点の文脈サイズは、<code>E1</code>の評価で得られる列に含まれる項目数である。</p>
</li>
<li>
<p>[<a name="dt-variable-values" id="dt-variable-values" title=
"variable values">Definition</a>: <b>変数の値</b>。これは、組 (展開済QName,
値)の集合である。式の<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>と同じ<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が含まれる。]</p>
</li>
<li>
<p>[<a name="dt-function-implementation" id=
"dt-function-implementation" title=
"function implementation">Definition</a>: <b>関数の実装</b>。<a title=
"function signature" href=
"#dt-function-signature">関数のシグネチャ</a>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。<span class="xquery"><a title="user-defined function"
href="#dt-udf">利用者定義関数</a>については、関数の実装はXQuery式である。<a title=
"built-in function" href=
"#dt-built-in-function">組み込み関数</a>や<a title="external function"
href="#dt-external-function">外部関数</a>については、関数の実装は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</span>]</p>
</li>
<li>
<p>[<a name="dt-date-time" id="dt-date-time" title=
"current dateTime">Definition</a>:
<b>現在のdateTime</b>。この情報は<span class=
"xquery">問合せ</span>の処理の間のある<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<span class="xquery">問合せ</span>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。]</p>
</li>
<li>
<p>[<a name="dt-timezone" id="dt-timezone" title=
"implicit timezone">Definition</a>: <b>暗黙タイムゾーン</b>。これは、タイムゾーンを持たない
data, time,
dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<a title="implementation defined"
href=
"#dt-implementation-defined">実装定義</a>の値である。タイムゾーンの正しい値の範囲については<a href="#XMLSchema">[XML
Schema]</a>を見よ。]</p>
</li>
<li>
<p>[<a name="dt-available-docs" id="dt-available-docs" title=
"available documents">Definition</a>:
<b>利用可能文書</b>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<a title=
"data model" href=
"#dt-datamodel">データモデル</a>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。]
利用可能文書の集合は<a title="statically known documents" href=
"#dt-known-docs">静的既知文書</a>の集合に限定されず、また空集合でもよい。</p>
</li>
<li>
<p>[<a name="dt-available-collections" id=
"dt-available-collections" title=
"available collections">Definition</a>:
<b>利用可能コレクション</b>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。]
利用可能コレクションの集合は<a title="statically known collections" href=
"#dt-known-collections">静的既知コレクション</a>の集合に限定されず、また空集合でもよい。</p>
</li>
<li>
<p>[<a name="dt-default-collection" id="dt-default-collection"
title="default collection">Definition</a>:
<b>デフォルトコレクション</b>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。]
<b>デフォルトコレクション</b>の値は実装によって初期化されてもよい。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>2.2
処理モデル</h3>
<p>XQueryは<a title="data model" href=
"#dt-datamodel">データモデル</a>と<a title="expression context" href=
"#dt-expression-context">式文脈</a>に基づいて定義される。</p>
<img src="ProcMod-XQuery.gif" alt="Processing Model Overview" />
<p>図1: 処理モデルの概要</p>
<p>
図1は、この後詳細を述べる処理段階の概要を図で示したものである。このうちいくつかの段階は完全にXQueryの範疇外である。図1では、これらの段階は言語の境界を表す実線の外側、<b>外部処理</b>とラベル付けされた領域に描かれている。外部処理域には、問合せが行われるデータを表現する<a title="XDM instance"
href="#dt-data-model-instance">XDMインスタンス</a>の生成(<a href=
"#id-data-model-generation"><b>2.2.1
データモデルの生成</b></a>を見よ)、スキーマの輸入処理(<a href=
"#id-schema-import-processing"><b>2.2.2
スキーマの輸入処理</b></a>を見よ)、直列化(<a href="#id-serialization"><b>2.2.4
直列化</b></a>を見よ)などが含まれる。言語の境界の内側は<span class=
"xquery"><b>問合せ処理域</b></span>と呼ばれ、静的解析段階と動的評価段階(<a href=
"#id-expression-processing"><b>2.2.3 式の処理</b></a>を見よ)が含まれる。
<span class="xquery">問合せ</span>処理域上の無矛盾性制約は<a href=
"#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>で定義される。</p>
<div class="div3">
<h4><a name="id-data-model-generation" id=
"id-data-model-generation"></a>2.2.1 データモデルの生成</h4>
<p><span class="xquery">問合せ</span>が処理できるようになる前に、式の入力データが<a title=
"XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>として表現されなければならない。この処理はXQueryの範囲外で発生し、そのため図1ではこの処理を外部処理域に置いている。以下にXML文書を<a title="XDM instance"
href="#dt-data-model-instance">XDMインスタンス</a>に変換する段階を示す。</p>
<ol class="enumar">
<li>
<p>文書が、<b>XML情報集合</b>(<a href="#XINFO">[XML
Infoset]</a>を見よ)を生成するXMLパーザによって解析される。解析された文書は1つ以上のスキーマに対して妥当性検証されてもよい。この処理は<a href="#XMLSchema">[XML
Schema]</a>に記述されているが、この結果、<b>検証後情報集合</b>(Post-Schema Validation
Infoset,
PSVI)と呼ばれる抽象情報構造が得られる。もし文書に関連するスキーマがなければ、文書の情報集合が保存される。(図1のDM1を見よ。)</p>
</li>
<li>
<p>情報集合もしくはPSVIが、<a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>に書かれている処理によって<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>に変換される。(図1のDM2を見よ。)</p>
</li>
</ol>
<p>上に述べた段階は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>がどのように構築されるかという一例を提供している。XDMインスタンスは関係データベースから直接合成されるかもしれないし、他の方法(図1のDM3を見よ)で構築されるかもしれない。XQueryは<a title="data model"
href=
"#dt-datamodel">データモデル</a>に基づいて定義されるが、XDMインスタンスがどのように構築されるかについては、制約を何も置かない。</p>
<p>[<a name="dt-type-annotation" id="dt-type-annotation" title=
"type annotation">Definition</a>: <a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の要素節点や属性節点はそれぞれ<b>型注釈</b>(<a href="#datamodel">[XQuery/XPath
Data Model
(XDM)]</a>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<a title=
"schema type" href="#dt-schema-type">スキーマ型</a>であり、節点の<a title=
"string value" href="#dt-string-value">文字列値</a>と<a title=
"typed value" href="#dt-typed-value">型付けされた値</a>の関連を記述する。]
<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>が<a href=
"http://www.w3.org/TR/xpath-datamodel/#const-psvi">3.3 Construction
from a PSVI</a><sup xmlns=
""><small>DM</small></sup>に述べられているように妥当なXML文書から導出されたならば、要素節点や属性節点の型注釈はスキーマ妥当性検証から導出される。
XQueryは要素節点や属性節点の型注釈に直接アクセスする方法は用意しない。</p>
<p>属性の値は属性節点によって直接表される。型が不明な属性節点(スキーマのない文書に出現する場合など)には<a title=
"type annotation" href="#dt-type-annotation">型注釈</a>
<code>xs:untypedAtomic</code>が与えられる。</p>
<p>要素の値はその要素の子たちによって表される。子にはテキスト節点やほかの要素節点が含まれてもよい。要素節点の<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>は、その子テキスト節点の値がどのように解釈されるかを示す。妥当性検証されていない要素(スキーマのない文書中に出現する場合など)には、<code>xs:untyped</code>というスキーマ型が注釈付けされる。妥当性検証されて部分的に妥当だとされた要素には<code>xs:anyType</code>というスキーマ型が注釈付けされる。もし要素が<code>xs:untyped</code>と注釈付けされているなら、そのすべての子孫要素節点もまた<code>xs:untyped</code>と注釈付けされる。しかし、もし要素が<code>xs:anyType</code>と注釈付けされているなら、その子孫要素節点のいくつかには、より詳細な<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が付けられるかもしれない。</p>
</div>
<div class="div3">
<h4><a name="id-schema-import-processing" id=
"id-schema-import-processing"></a>2.2.2 スキーマの輸入処理</h4>
<p class="xquery"><a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>は、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で記述されているように実際のXMLスキーマから展開されてもよい
(図1の段階SI1を見よ)し、他の何らかの機構によって生成されてもよい
(図1の段階SI2を見よ)。いずれの場合も、結果は、<a href=
"#id-consistency-constraints"><b>2.2.5
無矛盾性制約</b></a>で定義されている無矛盾性制約を満たさなければならない。</p>
</div>
<div class="div3">
<h4><a name="id-expression-processing" id=
"id-expression-processing"></a>2.2.3 式の処理</h4>
<p>XQueryは、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>と<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>という2つの処理相を定義する(図1を参照)。静的解析相では、<a title="static error"
href="#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、または<a title="type error" href=
"#dt-type-error">型エラー</a>が発生することがある。動的評価相では、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>と<a title=
"type error" href=
"#dt-type-error">型エラー</a>のみ発生することがある。これらの種類のエラーは<a href=
"#id-kinds-of-errors"><b>2.3.1 エラーの種類</b></a>で定義される。</p>
<p>それぞれの相について、実装はこの文書の仕様に従う結果を得る戦略やアルゴリズムを自由に使ってよい。</p>
<div class="div4">
<h5><a name="id-static-analysis" id=
"id-static-analysis"></a>2.2.3.1 静的解析相</h5>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: <b>静的解析相</b>は式自身と<a title=
"static context" href=
"#dt-static-context">静的文脈</a>に依存する。<b>静的解析相</b>は入力データ(スキーマを除く)には依存しない。]</p>
<p>静的解析相では、<span class=
"xquery">問合せ</span>は構文解析され、<b>演算木</b>と呼ばれる内部表現となる(図1の段階SQ1)。構文解析エラーは<a title="static error"
href="#dt-static-error">静的エラー</a>として発生する [<a title="err:XPST0003"
href="#ERRXPST0003">err:XPST0003</a>]。次に<a title="static context"
href="#dt-static-context">静的文脈</a>が実装によって初期化される(段階SQ2)。<span class=
"xquery">次に<a title="static context" href=
"#dt-static-context">静的文脈</a>は、<b>prolog</b>中の情報に基づいて変更されたり拡大されたりする
(段階SQ3)。もし<a title="schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されているならば、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に輸入されたスキーマからの情報が加えられる。<a title=
"module feature" href=
"#dt-module-feature">モジュール機能</a>が支援されているならば、輸入されたモジュールからの関数定義や変数定義により、静的文脈が拡張される。</span><a title="static context"
href=
"#dt-static-context">静的文脈</a>はスキーマ型名、関数名、名前空間接頭辞、変数名などを解決するのに用いられる(段階SQ4)。もし、<b>演算木</b>中のこれらの種類のいずれかの名前が<a title="static context"
href="#dt-static-context">静的文脈</a>になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>([<a title="err:XPST0008" href=
"#ERRXPST0008">err:XPST0008</a>]もしくは[<a title="err:XPST0017" href=
"#ERRXPST0017">err:XPST0017</a>])が発生する(ただし、<a href=
"#id-element-test"><b>2.5.4.3 要素テスト</b></a>および<a href=
"#id-attribute-test"><b>2.5.4.5 属性テスト</b></a>にあるこのルールの例外を見よ)。</p>
<p>次に、<b>演算木</b>は、<a title="atomization" href=
"#dt-atomization">原子化</a>、あるいは<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>の展開といった暗黙的演算を明示化することで、<b>正規化</b>される。正規化処理については<a href="#XQueryFormalSemantics">[XQuery
1.0 and XPath 2.0 Formal Semantics]</a>で記述されている。</p>
<p>次に、各式に<a title="static type" href=
"#dt-static-type">静的型</a>が付与される(段階SQ6)。[<a name="dt-static-type"
id="dt-static-type" title="static type">Definition</a>:
式の<b>静的型</b>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。] もし<a title=
"static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が支援されているなら、<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>に書かれているルールに従って、さまざまな式の<a title="static type" href=
"#dt-static-type">静的型</a>が推論される。もし<a title="static typing feature"
href=
"#dt-static-typing-feature">静的型付け機能</a>が支援されていないなら、割り当てられる静的型は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>では、もし<a title=
"static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が機能しており、かつ式の演算数が、その演算数に適切でない<a title="static type"
href="#dt-static-type">静的型</a>を持つと分かったならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。静的型検査でエラーが発生せず<a title=
"static type" href=
"#dt-static-type">静的型</a>Tが式に割り当てられたならば、正当な入力データに対しその式を実行すると、型Tの値が生成されるか<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>となることが保証される。</p>
<p><a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>の目的は、<a title="type error"
href=
"#dt-type-error">型エラー</a>の早期検出を提供し、式評価の最適化に役立つ型情報を推論することである。</p>
</div>
<div class="div4">
<h5><a name="id-dynamic-evaluation" id=
"id-dynamic-evaluation"></a>2.2.3.2 動的評価相</h5>
<p>[<a name="dt-dynamic-evaluation" id="dt-dynamic-evaluation"
title="dynamic evaluation phase">Definition</a>:
<b>動的評価相</b>は式の値を計算する相である。] 動的評価相は<a title="static analysis phase"
href="#dt-static-analysis">静的解析相</a>が完了した後に行われる。</p>
<p>動的評価相は、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>でエラーが検出されなかった場合に限り行うことができる。もし<a title="static typing feature"
href=
"#dt-static-typing-feature">静的型付け機能</a>が機能しているなら、静的解析の間にすべての<a title="type error"
href="#dt-type-error">型エラー</a>が検出され、動的評価相の実行を妨げるのに役立つ。</p>
<p>動的評価相は、評価している式の<b>演算木</b>(段階DQ1)、入力データ(段階DQ4)、<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>(段階DQ5)に依存し、さらに外部環境(段階DQ3)や<a title=
"dynamic context" href=
"#dt-dynamic-context">静的文脈</a>(段階DQ2)から情報を引き出す。動的評価相は新しいデータモデル値を生成したり(段階DQ4)、値を変数に束縛するなどによりそれを<a title="dynamic context"
href="#dt-dynamic-context">動的文脈</a>に展開してもよい(段階DQ5)。</p>
<p>[<a name="dt-dynamic-type" id="dt-dynamic-type" title=
"dynamic type">Definition</a>:
<b>動的型</b>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<a title=
"static type" href=
"#dt-static-type">静的型</a>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。]</p>
<p>もし式の演算数が、その演算数に適切でない<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>を持っていると分かったならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>式が評価される前に静的型付けで多くの<a title="type error" href=
"#dt-type-error">型エラー</a>がとらえられるとしても、静的解析では検出されなかったエラーが評価時に発生することはあり得る。例えば、式に文字列から整数への型変換が含まれているかもしれない。これは静的には正しい。しかし、もし実行時の実際の文字列の値が整数に変換できないならば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する。同様に、式中で<a title=
"static type" href=
"#dt-static-type">静的型</a>が<code>xs:untypedAtomic</code>であるような値に算術演算子を適用しているかもしれない。これは<a title="static error"
href="#dt-static-error">静的エラー</a>ではない。しかし実行時では、もしその値が<a title=
"numeric" href="#dt-numeric">数</a>型にうまく変換できなければ、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する。</p>
<p><a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が有効であるとき、式の静的解析において<a title=
"type error" href=
"#dt-type-error">型エラー</a>を発生させることは、たとえある入力に対してその式が正常に実行されるとしても、可能である。例えば、引数として要素を要求する関数が式に含まれており、静的解析相でその関数の引数の<a title="static type"
href=
"#dt-static-type">静的型</a>が省略可能な要素であると推論されたとする。この場合は、たとえ省略可能な要素が存在するような入力データに対してこの関数呼び出しが正常に行われるとしても、<a title="type error"
href="#dt-type-error">型エラー</a>として扱われ、評価が妨げられる。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization" id="id-serialization"></a>2.2.4
直列化</h4>
<p>[<a name="dt-serialization" id="dt-serialization" title=
"serialization">Definition</a>: <b>直列化</b>は<a title="XDM instance"
href=
"#dt-data-model-instance">XDMインスタンス</a>をオクテット列に変換する処理である(図1の段階DM4)。]
直列化の一般的な枠組は<a href="#serialization">[XSLT 2.0 and XQuery 1.0
Serialization]</a>に記述されている。</p>
<p class="xquery">
XQueryの実装は、直列化インタフェースを提供する必要はない。例えば、実装は単にDOMインタフェース (<a href=
"#DOM">[Document Object
Model]</a>を見よ)やイベント系列に基づくインタフェースを用意するだけでもよい。これらの場合、直列化はこの仕様書の範囲外である。</p>
<p class="xquery"><a href="#serialization">[XSLT 2.0 and XQuery 1.0
Serialization]</a>では、直列化のプロセスを決定する<b>直列化特性</b>の集合を定義している。XQueryの実装が直列化インタフェースを用意しているならば、<a href="#id-xq-serialization-parameters"><b>C.3
直列化パラメータ</b></a>で(デフォルト値とともに)列挙されている任意の直列化特性を支援し(また利用者に見せ)てもよい。直列化インタフェースを用意しているXQueryの実装は、<code>method
= "xml"</code>かつ<code>version =
"1.0"</code>であるような直列化特性の組み合わせを支援しなければならない。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="data model" href=
"#dt-datamodel">データモデル</a>では、要素節点の持つ<a title="in-scope namespaces"
href=
"#dt-in-scope-namespaces">有効範囲内名前空間</a>がその親よりも少ないことを許している。このような要素節点に対して正しく直列化を行うには、名前空間の
"定義解除" が必要である。これは<a href="#XMLNAMES11">[XML Names
1.1]</a>の機能である。<a href="#XMLNAMES11">[XML Names
1.1]</a>を支援しない実装では、名前空間の "定義解除"
を行うことなくこのような要素を直列化することが許される。結果として、その要素は、親の有効範囲内名前空間を事実上継承することになる。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-consistency-constraints" id=
"id-consistency-constraints"></a>2.2.5 無矛盾性制約</h4>
<p>XQueryが明確に定義されるためには、入力となる<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>、<a title="static context"
href="#dt-static-context">静的文脈</a>、<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>が互いに無矛盾でなければならない。以下に列挙する無矛盾性制約はXQueryの実装が正しく動作するための前提条件である。これらの無矛盾性制約をどのように強制させるかはこの仕様書の範囲外である。この仕様書は、これらの制約が1つ以上満たされない条件の下での<span class="xquery">問合せ</span>の結果を定義しない。</p>
<p>無矛盾性制約のいくつかでは<b>データモデルスキーマ</b>という用語を用いる。[<a name=
"dt-data-model-schema" id="dt-data-model-schema" title=
"data model schema">Definition</a>: <a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中のある節点に対して、<b>データモデルスキーマ</b>は、その節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が導出されたスキーマとして定義される。]
スキーマ妥当性検証以外の処理によって構成された節点に対しては、<b>データモデルスキーマ</b>は、単に、その節点の<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>によって表現されるスキーマ型定義から成る。</p>
<ul>
<li>
<p>型注釈を持つ各節点について、その型注釈が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>(ISSD)中にあるなら、ISSD中の定義は<a title=
"data model schema" href=
"#dt-data-model-schema">データモデルスキーマ</a>中の定義と等価でなければならない。さらに、<a title="data model schema"
href=
"#dt-data-model-schema">データモデルスキーマ</a>中のある型から拡張によって導出されるすべての型は、それと等価な定義がISSD中にもなければならない。</p>
</li>
<li>
<p><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中と<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>(ISSD)中の両方にある要素名<em>EN</em>のそれぞれについて、<em>EN</em>を先頭とする<a title="substitution group"
href="#dt-substitution-group">置換グループ</a>中にあると分かっている<a title=
"data model schema" href=
"#dt-data-model-schema">データモデルスキーマ</a>中のすべての要素は、また<em>EN</em>を先頭とする<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあると分かっているISSD中の要素でなければならない。</p>
</li>
<li>
<p>要素名、属性名、<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>や<a title="function signature"
href=
"#dt-function-signature">関数のシグネチャ</a>から参照されているスキーマ型名は、いずれも<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中になければならない。ただし、<a href=
"#doc-xquery-ElementTest">ElementTest</a>の部分から参照されている要素名、<a href=
"#doc-xquery-AttributeTest">AttributeTest</a>の部分から参照されている属性名は除く。</p>
</li>
<li>
<p><a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中に、大域的要素、属性、型名に対する参照がある場合は、対応する要素、属性、型の定義を<a title="in-scope schema definitions"
href="#dt-issd">有効範囲内スキーマ定義</a>中に持っていなければならない。</p>
</li>
<li>
<p>文字列から<a title="available documents" href=
"#dt-available-docs">利用可能な文書</a>中の文書節点への写像それぞれについて、もし同じ文字列から<a title="statically known documents"
href="#dt-known-docs">静的既知文書</a>中の文書型への写像が存在するなら、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、文書節点はその文書型に照合されなければならない。</p>
</li>
<li>
<p>文字列から<a title="available collections" href=
"#dt-available-collections">利用可能コレクション</a>中の節点列への写像それぞれについて、もし同じ文字列から<a title="statically known collections"
href="#dt-known-collections">静的既知コレクション</a>中の型への写像が存在するなら、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、節点列はその型に照合されなければならない。</p>
</li>
<li>
<p><a title="default collection" href=
"#dt-default-collection">デフォルトコレクション</a>中の節点列は、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、<a title=
"statically known default collection type" href=
"#dt-known-default-collection">静的既知デフォルトコレクション</a>に照合されなければならない。</p>
</li>
<li>
<p><a title="context item" href=
"#dt-context-item">文脈項目</a>の値は、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、<a title=
"context item static type" href=
"#dt-context-item-static-type">文脈項目静的型</a>に照合されなければならない。</p>
</li>
<li>
<p><a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>中の2つ組 (変数, 型)のそれぞれと、<a title=
"variable values" href="#dt-variable-values">変数の値</a>中で対応する2つ組 (変数,
値)のうち変数名が等しいものについて、<a href="#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールを用いて、値と型が照合されなければならない。</p>
</li>
<li>
<p><code>external</code>と宣言されている変数それぞれについて:
変数の宣言に宣言済の型が含まれているならば、外部環境は、その変数に対する値として宣言済の型に照合されるものを用意しなければならない。このとき<a href="#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある照合ルールが用いられる。変数の宣言に宣言済の型が含まれていないならば、外部環境は、型とそれに照合される値を用意しなければならない。このときも同じ照合ルールが用いられる。</p>
</li>
<li>
<p>外部と宣言されている関数それぞれについて: <a title="function implementation" href=
"#dt-function-implementation">関数の実装</a>は、<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>中の照合ルールを用いて、宣言されている結果の型と照合される値を返すか、<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>のエラーを発生させるか、いずれかでなければならない。</p>
</li>
<li>
<p>与えられた問合せに対し、<b>関与中ISSD</b>を、その問合せを評価するのに用いられるモジュールの<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>として定義する。2つの関与中ISSDが同じスキーマ型、要素名、属性名に対する定義を含むならば、その定義はいずれのISSDでも等価でなければならない。さらに、2つの関与中ISSDのそれぞれにスキーマ型<em>T</em>の定義が含まれているならば、<em>T</em>から拡張によって導出される型の集合もまた、いずれのISSDでも等価でなければならない。また、2つの関与中ISSDのそれぞれに要素名<em>E</em>の定義が含まれているならば、<em>E</em>を先頭とする置換グループもまたいずれのISSDでも等価でなければならない。</p>
</li>
<li>
<p><a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の中で、接頭辞<code>xml</code>は<code>http://www.w3.org/XML/1998/namespace</code>以外の名前空間URIに束縛されてはならず、またこの名前空間URIには<code>xml</code>以外の接頭辞が束縛されてはならない。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.3 エラー処理</h3>
<div class="div3">
<h4><a name="id-kinds-of-errors" id="id-kinds-of-errors"></a>2.3.1
エラーの種類</h4>
<p><a href="#id-expression-processing"><b>2.2.3
式の処理</b></a>で述べたように、XQueryは入力データに依存しない<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>と入力データに依存する<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>を定義する。エラーはいずれの相でも発生してよい。</p>
<p>[<a name="dt-static-error" id="dt-static-error" title=
"static error">Definition</a>:
<b>静的エラー</b>は静的解析相で検出されなければならないエラーである。構文エラーは<a title="static error"
href="#dt-static-error">静的エラー</a>の例である。]</p>
<p>[<a name="dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error">Definition</a>:
<b>動的エラー</b>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。]</p>
<p>[<a name="dt-type-error" id="dt-type-error" title=
"type error">Definition</a>:
<b>型エラー</b>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<a title=
"static type" href=
"#dt-static-type">静的型</a>とその式の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href=
"#dt-type-error">型エラー</a>が発生する。動的評価相では、値の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>とその値の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する。]</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>の結果は、成功か、1つ以上の<a title="type error"
href="#dt-type-error">型エラー</a>、<a title="static error" href=
"#dt-static-error">静的エラー</a>、静的に検出される<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>のいずれかである。<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>の結果は、結果の値か、1つの<a title=
"type error" href="#dt-type-error">型エラー</a>か、1つの<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>のいずれかである。</p>
<p>
1つ以上のエラーが現れたり、エラー条件がこの仕様で定義される1つ以上のエラーの範囲内に入ったりすると、これらのエラーの空でない集合が報告されてもよい。</p>
<p><a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>では、<a title="static typing feature"
href=
"#dt-static-typing-feature">静的型付け機能</a>が機能しており、かつ<code>()</code>もしくは<code>data(())</code>以外の式に割り当てられる<a title="static type"
href=
"#dt-static-type">静的型</a>が<code>empty-sequence()</code>であるならば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0005"
href="#ERRXPST0005">err:XPST0005</a>]。これにより、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に存在しない要素や属性を問合せが参照している場合がとらえられる。これは綴りの誤りの可能性があるためである。</p>
<p><a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が機能しているかどうかに関わらず、もし<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>で、ある式が評価されると<a title="type error"
href="#dt-type-error">型エラー</a>や<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する必要がある、ということを実装が決定できるならば、実装は<a title="static analysis phase"
href=
"#dt-static-analysis">静的解析相</a>でエラーを通知してもよい(しかし通知することを要求されるわけではない)。しかし、<code>fn:error()</code>関数は<a title="static analysis phase"
href="#dt-static-analysis">静的解析相</a>では評価されてはならない。</p>
<p>[<a name="dt-warning" id="dt-warning" title=
"warning">Definition</a>: <a title="static error" href=
"#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、<a title="type error" href=
"#dt-type-error">型エラー</a>に加えて、XQueryの実装は、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>、<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>のいずれかで<b>警告</b>を発生してもよい。警告が発生する状況や、警告を処理する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。]</p>
<p>この仕様書で定義されるエラーに加えて、実装は、この仕様書の範囲外の理由により<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。例えば、さまざまなオブジェクトの最大数や最大サイズに制限があってもよい。このような制限や、これらを越えることによる結果は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
</div>
<div class="div3">
<h4><a name="id-identifying-errors" id=
"id-identifying-errors"></a>2.3.2 エラーの識別と報告</h4>
<p>
この仕様書で定義されるエラーは、<code>err:XXYYnnnn</code>という形式を持つQNameで識別される。ここで:</p>
<ul>
<li>
<p>
<code>err</code>はXPathおよびXQueryのエラーのための名前空間、<code>http://www.w3.org/2005/xqt-errors</code>を表す。この名前空間接頭辞<code>err</code>の束縛はこの文書内の便宜上用いており、参考である。</p>
</li>
<li>
<p><code>XX</code>は、そのエラーが定義されている言語を表しており、次の符号を用いる。</p>
<ul>
<li>
<p>
<code>XP</code>はXPathで定義されるエラーを表す。このようなエラーはXQueryでも発生する。なぜならXQueryはXPathを部分集合として含むからである。</p>
</li>
<li>
<p><code>XQ</code>はXQueryで定義されるエラーを表す。</p>
</li>
</ul>
</li>
<li>
<p><code>YY</code>はエラーの分類を示し、次のような符号化を用いる:</p>
<ul>
<li>
<p><code>ST</code>は静的エラーを表す。</p>
</li>
<li>
<p><code>DY</code>は動的エラーを表す。</p>
</li>
<li>
<p><code>TY</code>は型エラーを表す。</p>
</li>
</ul>
</li>
<li>
<p><code>nnnn</code>は一意に決まる数字コードである。</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
XQueryのバージョンが変わっても、XPathとXQueryのエラーのための名前空間URIが変わることは期待されない。しかし、この名前空間の内容は、エラー定義が追加されることによって拡張されてよい。</p>
</div>
<p>XQuery処理器がエラー情報を外部環境に報告する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</p>
<p>
エラーは、エラーQNameから導出されるURI参照によって次のように表すことができる。名前空間URI<em><code>NS</code></em>と局所名<em><code>LP</code></em>を持つエラーは、URI参照<em><code>NS</code></em><code>#</code><em><code>LP</code></em>で表すことができる。例えば、QNameが<code>err:XPST0017</code>であるエラーは<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>で表せる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
エラーを識別するコードとともに、実装は、エラーの場所やエラーが検出された処理相などの付加的な情報を返してもよい。実装が付加的な情報を返すことを選択する場合は、この情報を返すのに用いられる機構は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-handling-dynamic" id=
"id-handling-dynamic"></a>2.3.3 動的エラーの処理</h4>
<p>この文書で示した以外に、もし式の演算数が<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生するならば、その式もまた<a title=
"dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。もし式が正常に値を返すことも動的エラーを発生することもできるのであれば、実装は、値を返すか動的エラーを発生するか選択してよい。例えば、論理式<code>expr1
and
expr2</code>は、いずれかの演算数が<code>false</code>を返すならば値<code>false</code>を返してもよい。またいずれかの演算数が動的エラーを発生すれば動的エラーを発生してもよい。</p>
<p>
もし式中の1つ以上の演算数がエラーを発生するならば、実装は、どのエラーがその式によって発生するかを選択してよい。例えば、次の式を考える:</p>
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
<p>部分式<code>($x div
$y)</code>と<code>xs:decimal($z)</code>はともにエラーを発生するかもしれない。実装は式"<code>+</code>"によってどちらのエラーが発生するか選択してよい。いったん1つの演算数がエラーを発生すれば、実装が他の演算数を評価することは要求されないが、評価してもよい。</p>
<p>[<a name="dt-error-value" id="dt-error-value" title=
"error value">Definition</a>:
識別可能なQNameに加え、動的エラーは、説明的な文字列や、<b>エラー値</b>と呼ばれる1つ以上の付加的な値を伴ってもよい。]
実装は、アプリケーションで定義されるエラー処理器がエラー値を処理し診断メッセージを生成する機構を提供してもよい。</p>
<p>動的エラーは<a title="built-in function" href=
"#dt-built-in-function">組み込み関数</a>や演算子によって発生してもよい。例えば<code>div</code>演算子は、その演算数が<code>xs:decimal</code>値でかつ第2演算数が0に等しいならば、例外を発生する。組み込み関数や演算子によって発生するエラーは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。</p>
<p>
動的エラーは明示的に<code>fn:error</code>関数を呼び出すことによっても発生する。この関数はエラーを1つ発生させるだけで、値は返さない。この関数は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている。例えば、次に示す関数呼び出しは動的エラーを発生する。発生する動的エラーは、エラーを識別するQName、説明的な文字列、診断値からなる(接頭辞<code>app</code>が、アプリケーションで定義されるエラーコードを含む名前空間に束縛されていると仮定している)。</p>
<div class="exampleInner">
<pre>
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</pre></div>
</div>
<div class="div3">
<h4><a name="id-errors-and-opt" id="id-errors-and-opt"></a>2.3.4
エラーと最適化</h4>
<p>
実装が異なると、式を評価したり最適化したりする方法として異なるものを選ぶかもしれないので、この節で述べるように、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>の検出や報告についてのある側面は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<p>実装は常に、演算子の演算数をどのような順序で評価しても自由である。</p>
<p>
場合によっては、処理器は、形式的な式の意味によって内含されるすべてのデータにアクセスすることなく、式の結果を決定することができる。例えば、<a title="filter expression"
href=
"#dt-filter-expression">選別式</a>の形式的記述では、<code>$s[1]</code>は列<code>$s</code>のすべての項目を検査し、述語<code>position()=1</code>を満たす項目をすべて選ぶことによって評価されるべきであると推奨している。実際は、多くの実装は、列の最初の項目を取ってきて終了してもこの式を評価することができる、と認識している。もし<code>$s</code>が<code>//book[author
eq
'Berners-Lee']</code>と言った式で定義されるならば、この戦略は大きな文書全体の走査を避け、性能を大幅に改善するかもしれない。しかし、この戦略の結果として、式の評価が早く終了してしまうと、式の意味に厳密に従っていれば検出できたであろう動的エラーや型エラーが全く検出できないかもしれない。この例では、もし1個以上の<code>author</code>部分要素を持つ<code>book</code>要素が入力中にあると、このようなエラーが発生するかもしれない。</p>
<p>エラーを検出しないコストに関して、処理器がデータへのアクセスを最適化するかもしれない外延は、次のルールで定義される。</p>
<p>
演算数(部分式)に<em>E</em>を持つ式<em>Q</em>を考えよう。一般には<em>E</em>の値は列である。列の評価の中間段階では、その項目のいくつかは分かっているが、残りは未知である。もし、評価の中間段階で、処理器が<em>Q</em>を評価した結果として2つの可能性しかない、すなわち値<em>V</em>かエラーの可能性しかないと証明できるならば、処理器は、演算数<em>E</em>の残りの項目を評価することなく結果<em>V</em>を出してもよい。この目的のために、2つの項目の節点と値がともに同一であるならば、2つの値は同じ結果を表現していると考えられる。ここで、節点が同じ識別子を持っているならば、それらの節点は同一である。また、2つの値が等値でかつ全く同じ型を持っているならば、それらの値は同一である。</p>
<p>このルールには例外がある。もし処理器が演算数 <em>E</em> を (その全体であれ部分的にであれ)
評価するならば、処理器は、<em>E</em>の演算数の実際の値が濃度に関するどんな制約にも反しないことを証明する必要がある。例えば、式<code>$e
eq
0</code>は、<code>$e</code>の値が2個以上の項目を含んでいれば、型エラーという結果になる。処理器は、<code>$e</code>の値の最初の項目を評価した後、可能な結果は、値<code>true</code>か、濃度の違反による型エラーだけである、と決定することは許されない。<code>$e</code>の値が1個以下の項目しか含まないことを証明しなければならない。</p>
<p>
このルールは、式の演算数として考えられるすべての組み合わせに適用される。したがって、式が2つの演算数<em>E1</em>と<em>E2</em>を持っているならば、上のルールを満たすそれぞれの列のどんな例を用いて評価されてもよい。</p>
<p>
このルールは連鎖する。<em>A</em>が<em>B</em>の演算数で、<em>B</em>が<em>C</em>の演算数であるならば、処理器は<em>C</em>の値を決めるために充分な数の<em>B</em>の例だけを評価すればよく、さらに<em>B</em>の例を決めるために充分な数の<em>A</em>の例だけを評価すればよい。</p>
<p>
これらのルールの効果として、処理器は、列中のあるところより先の項目が、エラーを発生させるかもしれないということ以外に結果に影響を及ぼさないと証明できれば、直ちにその先の項目の検査を止めても構わない。例えば、処理器は、2つの列から等しい値の2つ組を見つければ、直ちに<code>S1
= S2</code>の結果として<code>true</code>を返してもよい。</p>
<p>
これらのルールのもう一つの結果として、列中のどの項目も式の結果に貢献しないとき、処理器はその列のどの部分も評価する義務を負わない。しかし、繰り返すが、処理器は要求される濃度の検査は、せずに済ますことができない。対象とする文脈で空列が許されなければ、処理器は、演算数が空列でないことを保証しなければならない。</p>
<p>例:</p>
<ul>
<li>
<p>
下の例において、実装が<code>$expr1</code>によって返される項目のうち少なくとも1つが<code>47</code>という値を持つと知ることができる(例えば索引を用いて)ならば、<code>some</code>式の結果として<code>true</code>を返すことが許される。このとき、<code>$expr1</code>によって返される他の項目に、評価するとエラーを発生させるものがあるか探す必要はない。</p>
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</li>
<li>
<p>
以下の例において、実装が、値が<code>47</code>であるような子節点<code>id</code>を持つ<code>product</code>要素節点を見つけられれば(例えば索引を用いて)、<a title="path expression"
href=
"#dt-path-expression">経路式</a>の結果としてこれらの節点を返すことが許される。このとき、他の<code>product</code>節点に、整数を値としない<code>id</code>子節点があるためにエラーを発生させるものがあるか探す必要はない。</p>
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</li>
</ul>
<p>
最適化など、さまざまな理由により、実装は式を等価な式に書き換えることは自由である。エラーを発生させるか発生させないかという点を除いて、等価な式を評価した結果は、元の式を評価した結果と等しくなければならない。式の書換えを以下の例で説明する。</p>
<ul>
<li>
<p>式<code>//part[color eq
"Red"]</code>を考えよう。実装はこの式を<code>//part[color = "Red"][color eq
"Red"]</code>と書き換えることを選択するかもしれない。この実装では、この式を次のように処理するかもしれない。まず part
に関する索引を color によって引き、color が Red であるような part
すべてを素早く見つけ、"<code>=</code>" 述語を処理する。次にこれらの part それぞれについて
"<code>eq</code>" 述語を処理し、確かに一つの color
しか持っていないか検査する。結果は以下のようになる。</p>
<ul>
<li>
<p>Redという1つの color しか持っていない part が返される。</p>
</li>
<li>
<p>ある part が Red という color と他の color を共に持っていれば、エラーが発生する。</p>
</li>
<li>
<p>Red という color を持たず Red でない color を複数持つ part
が存在してもエラーは引き起こさない。</p>
</li>
</ul>
</li>
<li>
<p>
以下の例の式は、書かれている順に(すなわち左から右へ)正確に評価されれば、型変換エラーを起こすことはできない。どちらの述語も文脈位置に依存しているので、実装は、(例えば索引を利用することで)よりよい性能を得るために、述語を並び替えることを選択するかもしれない。述語を並べ替えることで、式がエラーを引き起こすかもしれない。</p>
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
<p>
式の書き換えによって引き起こされる想定外のエラーを避けるために、動的エラーを防ぐために設計されたテストを、条件<span class=
"xquery">式または<code>typeswitch</code></span>式を用いて表現するべきである。条件<span class="xquery">式や<code>typeswitch</code></span>式は、実際に選択された分岐中で発生する動的エラーのみ引き起こす。したがって、前の例とは異なり、以下の例では<code>@x</code>が<code>xs:date</code>に型変換されなくても動的エラーは起こらない。</p>
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>2.4 概念</h3>
<p>この節では、XQuery式の処理で重要な概念をいくつか説明する。</p>
<div class="div3">
<h4><a name="id-document-order" id="id-document-order"></a>2.4.1
文書順</h4>
<p><b>文書順</b>と呼ばれる順序は、ある<span class=
"xquery">問合せ</span>の処理中にアクセス可能なすべての節点の間で定義され、1つ以上の<b>木</b>(文書もしくはその一部)から構成されていてもよい。文書順は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>で定義されているが、便宜上その定義をここでも繰り返す。[<a name=
"dt-reverse-document-order" id="dt-reverse-document-order" title=
"reverse document order">Definition</a>:
文書順の逆順であるような節点の順序を<b>逆文書順</b>という。]</p>
<p>文書順は全順序である。ただし、節点間の相対順序は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。[<a name=
"dt-document-order" id="dt-document-order" title=
"document order">Definition</a>:
直観的には、<b>文書順</b>は直列化されたXML文書中で節点が出現する順序である。] [<a name="stable" id=
"stable" title="stable">Definition</a>:
文書順は<b>安定</b>である。ここで安定とは、ある<span class=
"xquery">問合せ</span>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であっても)ことを意味する。]</p>
<p>木では、文書順は次の制約を満たす。</p>
<ol class="enumar">
<li>
<p>根節点は最初の節点である。</p>
</li>
<li>
<p>いずれの節点も、その子および子孫のどれよりも前に出現する。</p>
</li>
<li>
<p>属性節点は、それが関連づけられている要素節点のの直後に出現する。属性節点の相対順序は安定であるが<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
</li>
<li>
<p>兄弟間の相対順序は、親節点の性質<code>children</code>中で出現する順序である。</p>
</li>
<li>
<p>子および子孫は、弟よりも先に出現する。</p>
</li>
</ol>
<p>異なる木の節点間の相対順序は安定であるが<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であり、次の制約に従う。与えられた木T1中のある節点が、別の木T2中のすべての節点より前に出現するならば、木T1中のすべての節点が木T2のすべての節点より前に出現する。</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>2.4.2 原子化</h4>
<p>いくつかのXQuery演算子の意味は<a title="atomization" href=
"#dt-atomization">原子化</a>という処理に依存している。原子化がある値に対して適用されるのは、原子値の列が必要となる文脈でその値が用いられるときである。原子化の結果は、原子値の列か<a title="type error"
href="#dt-type-error">型エラー</a> [err:FOTY0012] のいずれかである。[<a name=
"dt-atomization" id="dt-atomization" title=
"atomization">Definition</a>: 列の<b>原子化</b>は、<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。]</p>
<p>
便宜上、<code>fn:data</code>の意味を繰り返す。<code>fn:data</code>の結果は、入力列中の各項目に以下のルールを適用して生成される原子値の列である。</p>
<ul>
<li>
<p>その項目が原子値であれば、その項目を返す。</p>
</li>
<li>
<p>その項目が節点であれば、その<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>を返す。(もしその節点が型付けされた値を持たないならば、err:FOTY0012が発生する。)</p>
</li>
</ul>
<p>原子化は以下の式の型を処理するのに用いられる。</p>
<ul>
<li>
<p>算術式</p>
</li>
<li>
<p>比較式</p>
</li>
<li>
<p>関数呼び出しと関数からの戻り</p>
</li>
<li>
<p>型変換式</p>
</li>
<li>
<p>さまざまな種類の節点に対する構成子式</p>
</li>
<li>
<p>FLWOR式の<code>order by</code>節</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>2.4.3 有効ブール値</h4>
<p>ある状況の下では(以下に列挙する)、値の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を得る必要がある。[<a name="dt-ebv" id="dt-ebv" title=
"effective boolean value">Definition</a>:
ある値の<b>有効ブール値</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and
Operators]</a>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。]</p>
<p>便宜上、<code>fn:boolean</code>の動的意味を繰り返す。</p>
<ol class="enumar">
<li>
<p>演算数が空列であれば、<code>fn:boolean</code>は<code>false</code>を返す。</p>
</li>
<li>
<p>
演算数が、最初の項目が節点であるような列であれば、<code>fn:boolean</code>は<code>true</code>を返す。</p>
</li>
<li>
<p>
演算数が<code>xs:boolean</code>型もしくは<code>xs:boolean</code>から導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は演算数の値を変化せずに返す。</p>
</li>
<li>
<p>
演算数が<code>xs:string</code>型、<code>xs:untypedAtomic</code>型、もしくはこれらのいずれかから導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は、演算数の値の長さが0の場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</li>
<li>
<p>演算数が<a title="numeric" href=
"#dt-numeric">数</a>型、もしくは数型から導出される型の<a title="singleton" href=
"#dt-singleton">単一値列</a>であれば、<code>fn:boolean</code>は、演算数の値が<code>NaN</code>もしくは数として0に等しい場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</li>
<li>
<p>これ以外のすべての場合について、<code>fn:boolean</code>は型エラー
[err:FORG0006]を引き起こす。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>fn:boolean</code>の静的意味は<a href=
"http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">7.2.4 The
fn:boolean function</a><sup xmlns=
""><small>FS</small></sup>で定義されている。</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>unordered</code>であるような問合せに対しては、節点と原子値をそれぞれ1つ以上含む列の<a title="effective boolean value"
href="#dt-ebv">有効ブール値</a>は非決定的であってもよい。</p>
</div>
<p>列の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>は、以下のような式の型の処理で暗黙的に計算される。</p>
<ul>
<li>
<p>論理式(<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p><code>fn:not</code>関数</p>
</li>
<li>
<p>FLWOR式の<code>where</code>節</p>
</li>
<li>
<p>ある形式の<a title="predicate" href=
"#dt-predicate">述語</a>。例えば<code>a[b]</code></p>
</li>
<li>
<p>条件式(<code>if</code>)</p>
</li>
<li>
<p>限量式(<code>some</code>, <code>every</code>)</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>の定義は、例えば<code>cast</code>式のような<code>xs:boolean</code>型への型変換、あるいは引数として<code>xs:boolean</code>型を期待する関数に値を渡すときには、<em>使わない</em>。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>2.4.4
入力源</h4>
<p>
XQueryは、入力データへのアクセスを提供する関数集合を持っている。これらの関数は、式が文書や文書の集まりを参照できる方法を用意しているため、特に重要である。ここでは、入力関数について直観的に記述する。これらは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。</p>
<p>式が入力データにアクセスするには、入力関数の一つを呼び出すか、外部環境によって初期化される<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の一部、例えば<a title="variable values"
href="#dt-variable-values">変数</a>や<a title="context item" href=
"#dt-context-item">文脈項目</a>を参照するか、いずれかによる。</p>
<p>XQueryで支援されている入力関数は以下の通りである:</p>
<ul>
<li>
<p><code>fn:doc</code>関数はURIを含む文字列を受け取る。そのURIが<a title=
"available documents" href=
"#dt-available-docs">有効文書</a>中の文書と関連づけられていれば、<code>fn:doc</code>はその文書の<a title="data model"
href="#dt-datamodel">データモデル</a>表現を内容とするような文書節点を返す。それ以外の場合、<a title=
"" href="#">動的エラー</a>を引き起こす(詳細は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>を見よ)。</p>
</li>
<li>
<p>1引数の<code>fn:collection</code>関数は、URIを含む文字列を受け取る。そのURIが<a title=
"available collections" href=
"#dt-available-collections">有効コレクション</a>中のコレクションと関連づけられていれば、<code>fn:collection</code>はそのコレクションのデータモデル表現を返す。それ以外の場合、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>を引き起こす(詳細は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>を見よ)。コレクションは任意の節点列であってもよい。例えば、式<code>fn:collection("http://example.org")//customer</code>は、URIが<code>http://example.org</code>であるようなコレクション中の節点の子孫である<code>customer</code>要素すべてを指し示す。</p>
</li>
<li>
<p>引数を持たない<code>fn:collection</code>関数は、<a title=
"default collection" href=
"#dt-default-collection">デフォルトコレクション</a>を返す。これは<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の節点列である。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-uri-literals" id="id-uri-literals"></a>2.4.5
URIリテラル</h4>
<p>XQueryの文法のいくつかの箇所で、正当な静的既知絶対URIが要求される。このような箇所は、文法記号<a href=
"#doc-xquery-URILiteral">URILiteral</a>によって記述される。例えば、URILiteral
は名前空間や照合順序を指定するのに用いられる。これらはいずれも静的に既知でなければならない。</p>
<h5><a name="d2e3011" id="d2e3011"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-URILiteral" id=
"doc-xquery-URILiteral"></a>[140]&nbsp;&nbsp;&nbsp;</td>
<td><code>URILiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p>構文的には、URILiteralは<a href=
"#doc-xquery-StringLiteral">StringLiteral</a>に等しい:
すなわち、0個以上の文字の並びであり、一重引用符または二重引用符によって囲まれたものである。しかし、実装は、URILiteralの値の長さが0以外であり、かつ<code>xs:anyURI</code>の字句領域に含まれないか、<a href="#RFC3986">[RFC3986]</a>で定義されている
"相対参照" を表す文字列であるならば、<a title="static error" href=
"#dt-static-error">静的エラー</a> [<a title="err:XQST0046" href=
"#ERRXQST0046">err:XQST0046</a>]を発生<a title="may" href=
"#may">させてもよい</a>。</p>
<p>文字列リテラル中のように、<a title="predefined entity reference" href=
"#dt-predefined-entity-reference">既定義実体参照</a> (例えば
<code>&amp;amp;</code>), <a title="character reference" href=
"#dt-character-reference">文字参照</a> (例えば <code>&amp;#x2022;</code>),
あるいは <a href="#doc-xquery-EscapeQuot">EscapeQuot</a> や <a href=
"#doc-xquery-EscapeApos">EscapeApos</a> (例えば <code>""</code>)
はすべて、適切な展開を行うことによって置き換えられる。ある種の文字、特にアンパサンドは、<a title=
"predefined entity reference" href=
"#dt-predefined-entity-reference">既定義実体参照</a>あるいは<a title=
"character reference" href=
"#dt-character-reference">文字参照</a>を用いてしか表現することができない。</p>
<p>URILiteral は、<a href="#XMLSchema">[XML Schema]</a>中で
<code>xs:anyURI</code> 型に対して定義される空白の正規化に従っている:
この意味するところは、先頭と末尾の空白は除去され、それ以外の空白文字の列はいずれも、空白 (#x20)
文字1つに置き換えられる、ということである。空白の正規化は<a title="character reference" href=
"#dt-character-reference">文字参照</a>の展開の後で行われる。したがって (例えば)
<code>$#xA;</code> として表現されている改行は、空白文字に正規化されることを妨げない。</p>
<p>URILiteral は、<a href="#RFC3986">[RFC3986]</a>
に定義されているようなパーセント符号化やパーセント復号化に自動的に従うことはない。しかし、基礎 URI に従って URI を解決したり
URI を逆参照したりしようと試みる処理はいずれも、関連する RFC
中で定義されているパーセント符号化や復号化を適用してもよい。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyURI</code>型は、<a href="#RFC3987">[RFC3987]</a>で定義される
Internationalized Resource Identifier (IRI)
の導入を予想して設計されている。<a href="#RFC3987">[RFC3987]</a></p>
</div>
<p>以下に示すのは、正当な URILiteral の例である。</p>
<div class="exampleInner">
<pre>
"http://www.w3.org/2005/xpath-functions/collation/codepoint"
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-types" id="id-types"></a>2.5 型</h3>
<p>XQueryの型システムは<a href="#XMLSchema">[XML
Schema]</a>に基づいており、<a href="#XQueryFormalSemantics">[XQuery 1.0 and
XPath 2.0 Formal Semantics]</a>で形式的に定義されている。</p>
<p>[<a name="dt-sequence-type" id="dt-sequence-type" title=
"sequence type">Definition</a>: <b>列型</b>(sequence type)は<a href=
"#doc-xquery-SequenceType">SequenceType</a>の構文を用いて表現することのできる型である。列型は、XQuery式で型を参照する必要があるときにはいつでも用いられる。<b>列型</b>という用語は、この構文がXQueryの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。]</p>
<p>[<a name="dt-schema-type" id="dt-schema-type" title=
"schema type">Definition</a>: <b>スキーマ型</b>(schema type)は<a href=
"#XMLSchema">[XML Schema]</a>の機能(<a href="#XMLSchema">[XML
Schema]</a>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<b>複合型</b>か<b>単純型</b>のいずれかである。単純型はさらに<b>リスト型</b>、<b>共用体型</b>、<b>原子型</b>に分けられる(これらの用語の定義と説明は<a href="#XMLSchema">[XML
Schema]</a>を見よ)。]</p>
<p>原子型は<a title="sequence type" href=
"#dt-sequence-type">列型</a>と<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>という種類の間の集合積を表現している。原子型、例えば<code>xs:integer</code>や<code>my:hatsize</code>は<a title="sequence type"
href="#dt-sequence-type">列型</a>でもあり<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>でもある。</p>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>2.5.1 既定義スキーマ型</h4>
<p class="xquery"><a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>は、あらかじめ定義されているあるスキーマ型によって初期化される。このスキーマ型には、<a href="#XMLSchema">[XML
Schema]</a>の組み込みスキーマ型が含まれる。これらの組み込みスキーマ型は、名前空間<code>http://www.w3.org/2001/XMLSchema</code>に属する。この名前空間は既定義名前空間接頭辞<code>xs</code>を持つ。組み込みスキーマ型の例には、<code>xs:integer</code>,
<code>xs:string</code>,
<code>xs:date</code>などがある。<code>xs</code>名前空間中の要素や属性の定義は、静的文脈に明示的には含まれていない。</p>
<p class="xquery">
加えて、XQueryの既定義スキーマ型には、名前空間<code>http://www.w3.org/2005/xpath-datatypes</code>で定義されているスキーマ型が含まれる。この名前空間は既定義名前空間接頭辞<code>xdt</code>を持つ。この名前空間中のスキーマ型は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>で定義されている。以下にその概要を示す。</p>
<ol class="enumar">
<li>
<p>[<a name="dt-untyped" id="dt-untyped" title=
"xs:untyped">Definition</a>:
<code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>として用いられる。]
<code>xs:untyped</code>からは既定義スキーマ型は何も導出されない。</p>
</li>
<li>
<p>[<a name="dt-untypedAtomic" id="dt-untypedAtomic" title=
"xs:untypedAtomic">Definition</a>:
<code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。]
<code>skip</code>モードで妥当性検証された属性は、<a title="data model" href=
"#dt-datamodel">データモデル</a>中では<code>xs:untypedAtomic</code>という<a title="type annotation"
href=
"#dt-type-annotation">型注釈</a>のついた属性節点として表現される。<code>xs:untypedAtomic</code>からは、既定義スキーマ型は何も導出されない。</p>
</li>
<li>
<p>[<a name="dt-dayTimeDuration" id="dt-dayTimeDuration" title=
"xs:dayTimeDuration">Definition</a>:
<code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。]</p>
</li>
<li>
<p>[<a name="dt-yearMonthDuration" id="dt-yearMonthDuration" title=
"xs:yearMonthDuration">Definition</a>:
<code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。]</p>
</li>
<li>
<p>[<a name="dt-anyAtomicType" id="dt-anyAtomicType" title=
"xs:anyAtomicType">Definition</a>:
<code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>,
<code>xs:string</code>,
<code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyAtomicType</code>は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の実際の値の型には出現しない。</p>
</div>
</li>
</ol>
<p>
<code>xs</code>名前空間中のスキーマ型の間の関連を図2に示す。XQueryの型階層のより完全な記述は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>にある。</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>図2: XQueryで用いられるスキーマ型の階層</p>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>2.5.2
型付けされた値と文字列値</h4>
<p>すべての節点は<b>型付けされた値</b>と<b>文字列値</b>とを持っている。[<a name=
"dt-typed-value" id="dt-typed-value" title=
"typed value">Definition</a>:
節点の<b>型付けされた値</b>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。]
[<a name="dt-string-value" id="dt-string-value" title=
"string value">Definition</a>:
節点の<b>文字列値</b>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。]
<code>fn:data</code>と<code>fn:string</code>の定義は<a href=
"#">[FunctionsAndOprators]</a>にある。</p>
<p>実装は、節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>と<a title="string value" href=
"#dt-string-value">文字列値</a>をともに格納してもよいし、これらの一方だけを格納して、必要なときにもう一方を導出してもよい。節点の文字列値は、その節点の型付けされた値の正しい字句表現でなければならないが、その節点は元のソース文書から文字列表現を保存している必要はない。例えば、ある節点の型付けされた値が<code>xs:integer</code>の値<code>30</code>であったとすると、その文字列値は
"<code>30</code>" でも "<code>0030</code>" でもよい。</p>
<p class="xquery">節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>, <a title="string value" href=
"#dt-string-value">文字列値</a>, <a title="type annotation" href=
"#dt-type-annotation">型注釈</a>は密接に関連しており、以下の場所にあるルールによって定義される:</p>
<ul>
<li>
<p>節点が情報集合またはPSVIからの写像によって生成されたのであれば、<a href=
"#datamodel">[XQuery/XPath Data Model (XDM)]</a>のルールを見よ。</p>
</li>
<li>
<p>節点が XQuery の節点構成子によって生成されたのであれば、<a href=
"#id-element-constructor"><b>3.7.1 直接要素構成子</b></a>, <a href=
"#id-computedElements"><b>3.7.3.1 被計算要素構成子</b></a>, あるいは<a href=
"#id-computedAttributes"><b>3.7.3.2 被計算属性構成子</b></a>のルールを見よ。</p>
</li>
<li>
<p>節点が<code>validate</code>式によって生成されたのであれば、<a href=
"#id-validate"><b>3.13 検証式</b></a>のルールを見よ。</p>
</li>
</ul>
<p>読者の便宜のため、さまざまな種類の節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>と<a title="string value" href=
"#dt-string-value">文字列値</a>の関連について以下にまとめ、例を用いて説明する。</p>
<ol class="enumar">
<li>
<p>
テキスト節点と文書節点では、型付けされた値と文字列値は等しく、<code>xs:untypedAtomic</code>型のインスタンスである。文書節点の文字列値は、そのすべての子孫のテキスト節点の文字列値を<a title="document order"
href="#dt-document-order">文書順</a>に連接して得られる。</p>
</li>
<li>
<p>
コメント、、処理命令節点について、型付けされた値は文字列値に等しい。<code>xs:string</code>型のインスタンスである。</p>
</li>
<li>
<p><a title="type annotation" href=
"#dt-type-annotation">型注釈</a><code>xs:anySimpleType</code>または<code>xs:untypedAtomic</code>のついた属性節点の型付けされた値は、文字列値に等しく、<code>xs:untypedAtomic</code>型のインスタンスである。その他の型注釈のついた属性節点の型付けされた値は、対応する型に関して<a href="#XMLSchema">[XML
Schema]</a>第2部で定義される字句から値空間への写像を用いて、文字列値や型注釈から導出される。</p>
<p>例: A1
は文字列値<code>"3.14E-2"</code>と型注釈<code>xs:double</code>を持つ属性である。A1の型付けされた値は、字句表現として<code>3.14E-2</code>を持つ<code>xs:double</code>の値である。</p>
<p>例: A2
は型注釈<code>xs:IDREFS</code>を持つ属性であり、各項目の型が原子データ型<code>xs:IDREF</code>であるようなリストデータ型である。A2の文字列値は"<code>bar
baz
faz</code>"である。A2の型付けされた値は、それぞれ<code>xs:IDREF</code>型である3つの原子値("<code>bar</code>",
"<code>baz</code>",
"<code>faz</code>")の列である。節点の型付けされた値は、名前付けされたリスト型のインスタンスとは決して扱われない。そのかわり、節点の型注釈がリスト型(<code>xs:IDREFS</code>など)であれば、型付けされた値は、それが導出される原子型(<code>xs:IDREF</code>など)の列として扱われる。</p>
</li>
<li>
<p>要素節点については、型付けされた値と文字列値の関連はその要素の<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>に依存する。以下の通り:</p>
<ol class="enumla">
<li>
<p>
型注釈が<code>xs:untyped</code>、<code>xs:anySimpleType</code>、もしくは混在内容を伴う複合型(<code>xs:anyType</code>を含む)を表していれば、その節点の型付けされた値は文字列値に等しく、<code>xs:untypedAtomic</code>のインスタンスである。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列である。</p>
<p>例: E1
は型注釈<code>xs:untyped</code>と文字列値"<code>1999-05-31</code>"を持つ要素節点である。E1の型付けされた値は"<code>1999-05-31</code>"であり、<code>xs:untypedAtomic</code>のインスタンスである。</p>
<p>例:
E2は、型注釈<code>formula</code>を持つ要素節点である。この型注釈は混在内容を伴う複合型である。E2の内容は文字"<code>H</code>"、<code>subscript</code>と名付けられ文字列値"<code>2</code>"を持つ子要素、文字"<code>O</code>"からなる。E2の型付けされた値は"<code>H2O</code>であり、<code>xs:untypedAtomic</code>の印寸タンスである。</p>
</li>
<li>
<p>
型注釈が単純型、もしくは単純内容を伴う複合型を表していれば、その節点の型付けされた値は、スキーマ妥当性検証と同じ方法で、文字列値と型注釈から導出される。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列になる。</p>
<p>例:
E3は型注釈<code>cost</code>を持つ要素節点である。この型はいろいろな属性を持ち、かつ<code>xs:decimal</code>型の単純内容を持つ複合型である。E3の文字列値は"<code>74.95</code>"である。E3の型付けされた値は<code>74.95</code>であり、<code>xs:decimal</code>のインスタンスである。</p>
<p>例:
E4は型注釈<code>hatsizelist</code>を持つ要素節点である。この型は原子型<code>hatsize</code>から導出された単純型であり、<code>hatsize</code>はさらに<code>xs:integer</code>から導出されている。E4の文字列値は"<code>7
8 9</code>"である。E4の型付けされた値は3つの値(<code>7</code>, <code>8</code>,
<code>9</code>)からなる列であり、3つの値はいずれも<code>hatsize</code>型である。</p>
<p>例:
E5は、メンバの型が<code>xs:integer</code>と<code>xs:string</code>の共用体型<code>my:integer-or-string</code>という型注釈を持つ要素節点である。E5の文字列値は"<code>47</code>"である。E5の型付けされた値は、<code>xs:integer</code>としての<code>47</code>である。なぜならば、E5の内容を妥当性検証したメンバ型が<code>xs:integer</code>であるからである。一般的に、節点の型注釈が共用体型であるときは、その節点の型付けされた値は、共用体のいずれかのメンバ型のインスタンスである。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
実装が節点の文字列値しか格納しておらず、その節点の型注釈が共用体型であるならば、実装はその節点の型付けされた値を適切なメンバ型のインスタンスとして配布しなければならない。</p>
</div>
</li>
<li>
<p>型注釈が空内容を伴う複合型を表していれば、その節点の型付けされた値は空列であり、文字列値は長さ0の文字列である。</p>
</li>
<li>
<p>
型注釈が要素だけからなる内容を伴う複合型を表していれば、その節点の型付けされた値は未定義である。<code>fn:data</code>関数は、このような節点に対して適用されると<a title=""
href="#">型エラー</a>
[err:FOTY0012]を引き起こす。このような節点の文字列値は、すべての子孫テキスト節点の文字列値を文書順に連接した文字列値と等しい。</p>
<p>例:
E6は型注釈が<code>weather</code>である要素節点である。この型は、内容型が<code>element-only</code>と指定されている複合型である。E6は<code>temperature</code>および<code>precipitation</code>と名付けられた2つの子節点を持つ。E6の型付けされた値は未定義であり、<code>fn:data</code>関数をE6に適用するとエラーを引き起こす。</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-sequencetype-syntax" id=
"id-sequencetype-syntax"></a>2.5.3 SequenceTypeの文法</h4>
<p>XQuery式中の型を参照する必要があるときはいつでも、<a href=
"#doc-xquery-SequenceType">SequenceType</a>の文法が用いられる。</p>
<h5><a name="d2e3664" id="d2e3664"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SequenceType" id=
"doc-xquery-SequenceType"></a>[119]&nbsp;&nbsp;&nbsp;</td>
<td><code>SequenceType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xquery-ItemType">ItemType</a> <a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ItemType" id=
"doc-xquery-ItemType"></a>[121]&nbsp;&nbsp;&nbsp;</td>
<td><code>ItemType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-KindTest">KindTest</a> | ("item" "("
")") | <a href="#doc-xquery-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OccurrenceIndicator" id=
"doc-xquery-OccurrenceIndicator"></a>[120]&nbsp;&nbsp;&nbsp;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AtomicType" id=
"doc-xquery-AtomicType"></a>[122]&nbsp;&nbsp;&nbsp;</td>
<td><code>AtomicType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-KindTest" id=
"doc-xquery-KindTest"></a>[123]&nbsp;&nbsp;&nbsp;</td>
<td><code>KindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xquery-ElementTest">ElementTest</a><br />
| <a href="#doc-xquery-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xquery-PITest">PITest</a><br />
| <a href="#doc-xquery-CommentTest">CommentTest</a><br />
| <a href="#doc-xquery-TextTest">TextTest</a><br />
| <a href="#doc-xquery-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DocumentTest" id=
"doc-xquery-DocumentTest"></a>[125]&nbsp;&nbsp;&nbsp;</td>
<td><code>DocumentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xquery-ElementTest">ElementTest</a> | <a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ElementTest" id=
"doc-xquery-ElementTest"></a>[133]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" "(" (<a href=
"#doc-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xquery-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SchemaElementTest" id=
"doc-xquery-SchemaElementTest"></a>[135]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xquery-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ElementDeclaration" id=
"doc-xquery-ElementDeclaration"></a>[136]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AttributeTest" id=
"doc-xquery-AttributeTest"></a>[129]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xquery-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SchemaAttributeTest" id=
"doc-xquery-SchemaAttributeTest"></a>[131]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xquery-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AttributeDeclaration" id=
"doc-xquery-AttributeDeclaration"></a>[132]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ElementNameOrWildcard" id=
"doc-xquery-ElementNameOrWildcard"></a>[134]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ElementName" id=
"doc-xquery-ElementName"></a>[138]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AttribNameOrWildcard" id=
"doc-xquery-AttribNameOrWildcard"></a>[130]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AttributeName" id=
"doc-xquery-AttributeName"></a>[137]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TypeName" id=
"doc-xquery-TypeName"></a>[139]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PITest" id=
"doc-xquery-PITest"></a>[128]&nbsp;&nbsp;&nbsp;</td>
<td><code>PITest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery-NCName">NCName</a> | <a href=
"#doc-xquery-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CommentTest" id=
"doc-xquery-CommentTest"></a>[127]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TextTest" id=
"doc-xquery-TextTest"></a>[126]&nbsp;&nbsp;&nbsp;</td>
<td><code>TextTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AnyKindTest" id=
"doc-xquery-AnyKindTest"></a>[124]&nbsp;&nbsp;&nbsp;</td>
<td><code>AnyKindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p>特別な型<code>empty-sequence()</code>を除き、<a title="sequence type"
href=
"#dt-sequence-type">列型</a>は、列中の各項目の型に制約を加える<b>項目型</b>、および列の項目数に制約を加える<b>濃度</b>からなる。項目型<code>item()</code>は任意の種類の項目を許すが、これを除き、項目型は<b>節点型</b>(<code>element()</code>など)と<b>原子型</b>(<code>xs:integer</code>など)に分けられる。</p>
<p>要素節点や属性節点を表す項目型は、これらの節点の必要な<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>を、<a title="schema type" href=
"#dt-schema-type">スキーマ型</a>の形式で指定してもよい。したがって、項目型<code>element(*,
us:address)</code>は、<code>us:address</code>と名付けられたスキーマ型(あるいはこの型から導出される型)を型注釈とする要素節点を表す。</p>
<p>以下に、XQuery式で用いられる<a title="sequence type" href=
"#dt-sequence-type">列型</a>の例をいくつか示す。</p>
<ul>
<li>
<p>
<code>xs:date</code>は、<code>xs:date</code>と名付けられた組み込み原子スキーマ型を参照する。</p>
</li>
<li>
<p><code>attribute()?</code>は省略可能な属性節点を参照する。</p>
</li>
<li>
<p><code>element()</code>は任意の要素節点を参照する。</p>
</li>
<li>
<p><code>element(po:shipto,
po:address)</code>は、<code>po:shipto</code>という名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
</li>
<li>
<p><code>element(*,
po:address)</code>は、任意の名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
</li>
<li>
<p>
<code>element(customer)</code>は、<code>customer</code>と名付けられ、かつ任意の型注釈を持つ要素節点を参照する。</p>
</li>
<li>
<p>
<code>schema-element(customer)</code>は、名前が<code>customer</code>であり(もしくは<code>customer</code>を先頭とする置換グループの中にあり)、かつ型注釈が、<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中の<code>customer</code>要素のために定義されたスキーマ型に照合するような要素節点を参照する。</p>
</li>
<li>
<p><code>node()*</code>は、任意の種類の節点0個以上からなる列を参照する。</p>
</li>
<li>
<p><code>item()+</code>は、1個以上の節点もしくは原子値からなる列を参照する。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>2.5.4 SequenceTypeの照合</h4>
<p>[<a name="dt-sequencetype-matching" id=
"dt-sequencetype-matching" title=
"SequenceType matching">Definition</a>: 式の評価の間、既知の<a title=
"dynamic type" href="#dt-dynamic-type">動的型</a>が期待される<a title=
"sequence type" href=
"#dt-sequence-type">列型</a>に「照合」されるか決定する必要があることがある。この処理を<b>SequenceTypeの照合</b>という。]
例えば、式<code>instance of</code>は、与えられた値の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が与えられた<a title="sequence type" href=
"#dt-sequence-type">列型</a>に照合されれば<code>true</code>を返し、照合されなければ<code>false</code>を返す。</p>
<p><a title="sequence type" href=
"#dt-sequence-type">列型</a>中に出現するQNameは、<a title="" href=
"#">静的既知名前空間</a>と(もし適用可能であれば)<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を用いて名前空間URIに展開される接頭辞を持つ。接頭辞のない属性
QName はどの名前空間にも属さない。QName の等価性は <code>eq</code> 演算子によって定義される。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールは、値の<a title=
"dynamic type" href="#dt-dynamic-type">動的型</a>を、期待される<a title=
"sequence type" href=
"#dt-sequence-type">列型</a>と比較する。これらのルールは<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で定義される、値と期待される型との照合を行う形式的ルールの部分集合である。なぜなら、Formal
Semanticsは、<a href=
"#doc-xquery-SequenceType">SequenceType</a>の文法を用いて表現できない型に対して値を照合することができなければならないからである。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールのいくつかでは、与えられたスキーマ型が期待されるスキーマ型と同じかまたは導出されるかを決定する必要がある。与えられたスキーマ型は"既知"(<a title="in-scope schema definitions"
href="#dt-issd">有効範囲内スキーマ定義</a>で定義されている)か、または"未定義"(<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>で定義されていない)のいずれかであってもよい。未定義スキーマ型は、例えば、ソース文書が<a title="static context"
href=
"#dt-static-context">静的文脈</a>に輸入されていないスキーマを用いて妥当性検証されている場合などに現れるかもしれない。この場合、実装は、未定義のスキーマ型が期待されるスキーマ型から導出されるか決定する<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>の機構を用意することが許される(しかし用意しておく必要はない)。
例えば、実装は型階層に関する情報を含むデータ辞書を管理していてもよい。</p>
<p>[<a name="dt-subtype-substitution" id="dt-subtype-substitution"
title="subtype substitution">Definition</a>: <a title=
"dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される型から導出されるような値を用いることを<b>部分型置換</b>という。]
部分型置換は、値の実際の型は変更しない。例えば、<code>xs:integer</code>の値を<code>xs:decimal</code>の値が期待される場所で用いても、その値の型は<code>xs:integer</code>のまま保たれる。</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>の定義は、<code>derives-from(</code><em>AT,
ET</em><code>)</code>という名前の擬似関数に頼っている。この関数は、実際の単純スキーマ型もしくは複合スキーマ型<em>AT</em>と、期待される単純スキーマ型もしくは複合スキーマ型<em>ET</em>をとり、ブール値を返すか、<a title="type error"
href="#dt-type-error">型エラー</a> [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]を発生する。
擬似関数<code>derives-from</code>は以下で定義され、また<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>で形式的に定義されている。</p>
<ul>
<li>
<p>
<em>ET</em>が既知の型で、以下の3つの条件のいずれかが真であるとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<code>true</code>を返す。</p>
<ol class="enumar">
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中にあるスキーマ型で、<em>ET</em>と同じか、<em>ET</em>から制限もしくは拡張によって導出される。</p>
</li>
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>には含まれないスキーマ型で、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構により<em>AT</em>が<em>ET</em>から制限により導出されると決定できる。</p>
</li>
<li>
<p><code>derives-from(</code><em>IT,
ET</em><code>)</code>と<code>derives-from(</code><em>AT,
IT</em><code>)</code>が真であるようなスキーマ型<em>IT</em>が存在する。</p>
</li>
</ol>
</li>
<li>
<p>
<em>ET</em>が既知の型で、以下の条件のうち1番目と3番目、もしくは2番目と3番目が真であるとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<code>false</code>を返す。</p>
<ol class="enumar">
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>中にあるスキーマ型で、<em>ET</em>と等しくなく、<em>ET</em>から制限または拡張によって導出されない。</p>
</li>
<li>
<p><em>AT</em>が<a title="in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>にないスキーマ型で、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構により<em>AT</em>が制限によって<em>ET</em>から導出されない。</p>
</li>
<li>
<p><code>derives-from(</code><em>IT,
ET</em><code>)</code>と<code>derives-from(</code><em>AT,
IT</em><code>)</code>がともに真であるようなスキーマ型<em>IT</em>が存在しない。</p>
</li>
</ol>
</li>
<li>
<p>以下のとき、<code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code>は<a title="type error" href=
"#dt-type-error">型エラー</a> [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]を発生する。</p>
<ol class="enumar">
<li>
<p><em>ET</em>が未定義の型である。もしくは</p>
</li>
<li>
<p>
<em>AT</em>が未定義の型で、実装は、<em>AT</em>が制限によって<em>ET</em>から導出されるか決定できない。</p>
</li>
</ol>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>derives-from</code>擬似関数は実際の XQuery
関数としては書くことができない。なぜなら型は関数の引数としては正当でないからである。</p>
</div>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールを以下に述べ、例を示す(例は説明が目的であり、可能な場合をすべて網羅しているわけではない)。</p>
<div class="div4">
<h5><a name="id-matching-value" id="id-matching-value"></a>2.5.4.1
SequenceTypeと値の照合</h5>
<ul>
<li>
<p><a title="sequence type" href="#dt-sequence-type">列型</a>
<code>empty-sequence()</code>は、空列である値と照合される。</p>
</li>
<li>
<p><a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>のない<a href="#doc-xquery-ItemType">ItemType</a>がただ1つの項目を含む任意の値と照合されるのは、その<a href="#doc-xquery-ItemType">ItemType</a>がその項目と照合されるときである(<a href="#id-matching-item"><b>2.5.4.2
ItemTypeと項目の照合</b></a>を見よ)。</p>
</li>
<li>
<p><a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>のある<a href="#doc-xquery-ItemType">ItemType</a>が値と照合されるのは、その値の項目の数が<a href="#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>と照合され、<a href="#doc-xquery-ItemType">ItemType</a>がその値の各項目と照合されるときである。</p>
</li>
</ul>
<p><a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>は列中の項目数を以下のように指定する。</p>
<ul>
<li>
<p><code>?</code>は0個もしくは1個の項目と照合される</p>
</li>
<li>
<p><code>*</code>は0個以上の項目と照合される</p>
</li>
<li>
<p><code>+</code>は1個以上の項目と照合される</p>
</li>
</ul>
<p>これらのルールの結果として、<a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>が<code>*</code>もしくは<code>?</code>であるような任意の<a title="sequence type"
href="#dt-sequence-type">列型</a>は、空列である値と照合される。</p>
</div>
<div class="div4">
<h5><a name="id-matching-item" id="id-matching-item"></a>2.5.4.2
ItemTypeと項目の照合</h5>
<ul>
<li>
<p>QNameのみからなる<a href="#doc-xquery-ItemType">ItemType</a>は<a href=
"#doc-xquery-AtomicType">AtomicType</a>と解釈される。AtomicType
<em>AtomicType</em>が実際の型が<em>AT</em>である原子値と照合されるのは、<code>derives-from(</code><em>AT,
AtomicType</em><code>)</code>が<code>true</code>の場合である。もし<a href=
"#doc-xquery-AtomicType">AtomicType</a>として用いられているQNameが<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ定義</a>中の原子型として定義されていないならば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する [<a title=
"err:XPST0051" href="#ERRXPST0051">err:XPST0051</a>]。</p>
<p>例: <a href="#doc-xquery-AtomicType">AtomicType</a>
<code>xs:decimal</code>は値<code>12.34</code>
(実数リテラル)と照合される。もし<code>shoesize</code>が<code>xs:decimal</code>から制限によって導出される原子型であれば、<code>xs:decimal</code>はまた、型が<code>shoesize</code>であるような値とも照合される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<code>xs:IDREFS</code>のように原子型でない型の名前は、この文脈では認められないが、しばしば、<code>xs:IDREF+</code>のように出現標識を伴った原子型によって置き換えることができる。</p>
</div>
</li>
<li>
<p><code>item()</code>は任意の単一項目と照合される。</p>
<p>例:
<code>item()</code>は、原子値<code>1</code>や要素<code>&lt;a/&gt;</code>と照合される。</p>
</li>
<li>
<p><code>node()</code>は任意の節点と照合される。</p>
</li>
<li>
<p><code>text()</code>は任意のテキスト節点と照合される。</p>
</li>
<li>
<p><code>processing-instruction()</code>は任意の処理命令節点と照合される。</p>
</li>
<li>
<p>
<code>processing-instruction(</code><em>N</em><code>)</code>は、処理命令節点のうち名前(XMLでは処理命令の"PITarget"という)が<em>N</em>に等しいものに照合される。ここで<em>N</em>はNCNameである。</p>
<p>例:
<code>processing-instruction(xml-stylesheet)</code>は、処理命令のうちPITargetが<code>xml-stylesheet</code>であるものに照合される。</p>
<p>XPath1.0との後方互換性のため、処理命令のPITargetは文字列リテラルとしても表されてもよい。例えばこの例の通り:
<code>processing-instruction("xml-stylesheet")</code></p>
</li>
<li>
<p><code>comment()</code>は任意のコメント節点に照合される。</p>
</li>
<li>
<p><code>document-node()</code>は任意の文書節点に照合される。</p>
</li>
<li>
<p>
<code>document-node(</code><em>E</em><code>)</code>は、文書節点のうちただ1つの要素節点を含むものに照合される。1つ以上のコメント節点や処理命令節点が含まれていてもよい。ここで<em>E</em>は、その要素節点に照合される<a href="#doc-xquery-ElementTest">ElementTest</a>または<a href="#doc-xquery-SchemaElementTest">SchemaElementTest</a>である(<a href="#id-element-test"><b>2.5.4.3
要素テスト</b></a>および<a href="#id-schema-element-test"><b>2.5.4.4
スキーマ要素テスト</b></a>を見よ)。</p>
<p>例:
<code>document-node(element(book))</code>は、文書節点のうち、ElementTest
<code>element(book)</code>によって照合されるようなただ1つの文書節点を含むものに照合される。</p>
</li>
<li>
<p><a href="#doc-xquery-ElementTest">ElementTest</a>、<a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a>、<a href=
"#doc-xquery-AttributeTest">AttributeTest</a>、または<a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a>であるような<a href="#doc-xquery-ItemType">ItemType</a>は、以下の節で述べる要素節点または属性節点に照合される。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-element-test" id="id-element-test"></a>2.5.4.3
要素テスト</h5>
<p><a href=
"#doc-xquery-ElementTest">ElementTest</a>は、要素節点をその名前や<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>と照合するのに用いられる。<a href=
"#doc-xquery-ElementTest">ElementTest</a>は以下の形式のどれをとってもよい。これらの形式では、<a href="#doc-xquery-ElementName">ElementName</a>は<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>中にある必要はないが、<a href=
"#doc-xquery-TypeName">TypeName</a>は<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>中になければならない。なお、<a title=
"substitution group" href=
"#dt-substitution-group">置換グループ</a>は、<a href=
"#doc-xquery-ElementTest">ElementTest</a>の意味には影響を及ぼさない。</p>
<ol class="enumar">
<li>
<p>
<code>element()</code>と<code>element(*)</code>は任意の単一要素節点に照合され、その名前や型注釈とは関係しない。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xquery-ElementName">ElementName</a><code>)</code>は、要素節点のうち名前が<a href="#doc-xquery-ElementName">ElementName</a>であるようなものに照合され、その型注釈や<code>nilled</code>性質とは関係しない。</p>
<p>例:
<code>element(person)</code>は、要素節点のうち名前が<code>person</code>のものと照合される。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xquery-ElementName">ElementName</a><code>,</code> <a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>は、要素節点のうち名前が<a href="#doc-xquery-ElementName">ElementName</a>のものに照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xquery-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。</p>
<p>例: <code>element(person,
surgeon)</code>は、nilledでない要素節点のうち名前が<code>person</code>であり、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xquery-ElementName">ElementName</a>, <a href=
"#doc-xquery-TypeName">TypeName</a><code>?)</code>は、要素節点のうち名前が<a href="#doc-xquery-ElementName">ElementName</a>のものに照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>が<code>true</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(person,
surgeon?)</code>は、nilledもしくはnilledでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xquery-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。</p>
<p>例: <code>element(*,
surgeon)</code>は、nilledでない要素節点のうち、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xquery-TypeName">TypeName</a>
<code>?)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><em>AT</em>,
<a href="#doc-xquery-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であるときである。ここで<em>AT</em>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(*,
surgeon?)</code>は、nilledであるかnilledでない要素節点のうち、型注釈が<code>surgeon</code>である
(もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-element-test" id=
"id-schema-element-test"></a>2.5.4.4 スキーマ要素テスト</h5>
<p><a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a>は、要素節点のうち、<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中にある対応する要素定義に対して照合される。これは次のような形式をとる。</p>
<p><code>schema-element(</code><a href=
"#doc-xquery-ElementName">ElementName</a><code>)</code></p>
<p>もし<a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a>中で指定されている<a href="#doc-xquery-ElementName">ElementName</a>が<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>にないならば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0008"
href="#ERRXPST0008">err:XPST0008</a>]。</p>
<p><a href=
"#doc-xquery-SchemaElementTest">SchemaElementTest</a>は、以下の3つの条件がすべて満たされるとき、候補要素節点に照合される。</p>
<ol class="enumar">
<li>
<p>候補節点の名前が、指定された<a href=
"#doc-xquery-ElementName">ElementName</a>に照合されるか、<a href=
"#doc-xquery-ElementName">ElementName</a>と名付けられた要素を先頭とする<a title=
"substitution group" href=
"#dt-substitution-group">置換グループ</a>中の要素名に照合される。</p>
</li>
<li>
<p><code>derives-from(</code><em>AT,
ET</em><code>)</code>が<code>true</code>である。ここで<em>AT</em>はその候補節点の型注釈、<em>ET</em>は<a title="in-scope element declarations"
href="#dt-is-elems">有効範囲内要素定義</a>中で要素<a href=
"#doc-xquery-ElementName">ElementName</a>のために定義されたスキーマ型である。</p>
</li>
<li>
<p><a title="in-scope element declarations" href=
"#dt-is-elems">有効範囲内要素定義</a>中の<a href=
"#doc-xquery-ElementName">ElementName</a>のための要素定義が<code>nillable</code>でないならば、その候補節点の<code>nilled</code>性質は<code>false</code>である。</p>
</li>
</ol>
<p>例: <a href="#doc-xquery-SchemaElementTest">SchemaElementTest</a>
<code>schema-element(customer)</code>は候補要素節点に照合される。ただし照合されるのは<code>customer</code>が<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中の最上位要素定義であり、候補節点の名前が<code>customer</code>であるか<code>customer</code>を先頭とする<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあり、候補節点の型注釈が<code>customer</code>要素のために定義されたスキーマ型と同じか導出されており、候補節点が<code>nilled</code>であるか<code>customer</code>が<code>nillable</code>と定義されているときである。</p>
</div>
<div class="div4">
<h5><a name="id-attribute-test" id="id-attribute-test"></a>2.5.4.5
属性テスト</h5>
<p><a href=
"#doc-xquery-AttributeTest">AttributeTest</a>は、属性節点をその名前や<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>と照合するのに用いられる。<a href=
"#doc-xquery-AttributeTest">AttributeTest</a>は以下の形式のどれをとってもよい。これらの形式で、<a href="#doc-xquery-AttributeName">AttributeName</a>は<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>中にある必要はないが、<a href=
"#doc-xquery-TypeName">TypeName</a>は<a title="in-scope schema type"
href="#dt-is-types">有効範囲内スキーマ型</a>中にはなければならない。</p>
<ol class="enumar">
<li>
<p>
<code>attribute()</code>と<code>attribute(*)</code>は任意の単一属性節点に照合され、その名前や型注釈とは関係しない。</p>
</li>
<li>
<p><code>attribute(</code><a href=
"#doc-xquery-AttributeName">AttributeName</a><code>)</code>は、属性節点のうち名前が<a href="#doc-xquery-AttributeName">AttributeName</a>のものに照合され、その型注釈とは関係しない。</p>
<p>例:
<code>attribute(price)</code>は、名前が<code>price</code>である任意の属性節点に照合される。</p>
</li>
<li>
<p><code>attribute(</code><a href=
"#doc-xquery-AttributeName">AttributeName</a>, <a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>は、属性節点のうち名前が<a href="#doc-xquery-AttributeName">AttributeName</a>であり、<code>derives-from(</code><em>AT</em>,
<a href="#doc-xquery-TypeName">TypeName</a>
<code>)</code>が<code>true</code>であるようなものに照合される。ここで<em>AT</em>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(price,
currency)</code>は、属性節点のうち名前が<code>price</code>で型注釈が<code>currency</code>である
(もしくは<code>currency</code>から導出される)ものに照合される。</p>
</li>
<li>
<p><code>attribute(*,</code> <a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>は、名前に関係なく属性節点のうち<code>derives-from(</code><em>AT</em>,
<a href=
"#doc-xquery-TypeName">TypeName</a><code>)</code>が<code>true</code>であるようなものに照合される。ここで<em>AT</em>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(*,
currency)</code>は、属性節点のうち型注釈が<code>currency</code>である
(もしくは<code>currency</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-attribute-test" id=
"id-schema-attribute-test"></a>2.5.4.6 スキーマ属性テスト</h5>
<p><a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a>は、属性節点のうち、<a title="in-scope attribute declarations"
href=
"#dt-is-attrs">有効範囲内属性定義</a>中の対応する属性定義に対する属性節点に照合される。これは次のような形式をとる。</p>
<p><code>schema-attribute(</code><a href=
"#doc-xquery-AttributeName">AttributeName</a><code>)</code></p>
<p>もし<a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a>中で指定される<a href="#doc-xquery-AttributeName">AttributeName</a>が<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0008"
href="#ERRXPST0008">err:XPST0008</a>]。</p>
<p><a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a>は、以下の条件が2つとも満たされるとき、候補属性に照合される。</p>
<ol class="enumar">
<li>
<p>候補節点の名前が指定された<a href=
"#doc-xquery-AttributeName">AttributeName</a>に照合される。</p>
</li>
<li>
<p><code>derives-from(</code><em>AT,
ET</em><code>)</code>が<code>true</code>である。ここで<em>AT</em>は候補節点の型注釈、<em>ET</em>は<a title="in-scope attribute declarations"
href="#dt-is-attrs">有効範囲内属性定義</a>中の属性<a href=
"#doc-xquery-AttributeName">AttributeName</a>に対して定義されるスキーマ型である。</p>
</li>
</ol>
<p>例: <a href=
"#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a>
<code>schema-attribute(color)</code>は候補属性節点に照合される。ただし照合されるのは<code>color</code>が<a title="in-scope attribute declarations"
href=
"#dt-is-attrs">有効範囲内属性定義</a>中の最上位属性定義であり、候補節点の名前が<code>color</code>であり、候補節点の型注釈が<code>color</code>属性に対して定義されたスキーマ型と等しいか、それから導出されるときである。</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>2.6 コメント</h3>
<h5><a name="d2e5162" id="d2e5162"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Comment" id=
"doc-xquery-Comment"></a>[151]&nbsp;&nbsp;&nbsp;</td>
<td><code>Comment</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(:" (<a href=
"#doc-xquery-CommentContents">CommentContents</a> | <a href=
"#doc-xquery-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CommentContents" id=
"doc-xquery-CommentContents"></a>[159]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>コメントは<span class="xquery"><a title="Prolog" href=
"#dt-prolog">前書き</a>または<a title="query body" href=
"#dt-queryBody">問合せ本体</a>のいずれに出現してもよく、問合せ</span>のための参考的注釈を提供するのに用いてもよい。コメントは字句的な構成要素だけであり<span class="xquery">問合せ</span>の処理には影響を与えない。</p>
<p>
コメントは文字列であり、記号<code>(:</code>と<code>:)</code>によって区切られる。コメントは入れ子になってもよい。</p>
<p>コメントは<a title="ignorable whitespace" href=
"#IgnorableWhitespace">無視できる空白記号</a>が許されるところにはどこで用いてもよい(<a href=
"#DefaultWhitespaceHandling"><b>A.2.4.1 デフォルト空白処理</b></a>を見よ)。</p>
<p>以下がコメントの例である。</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>3 式</h2>
<p>
この章では、基本的な式の種類について一つ一つ議論する。それぞれの式の種類は<code>PathExpr</code>のような名前を持つ。この名前は、式を定義する文法生成規則の左辺に導入される。XQueryは構成可能な言語なので、それぞれの種類の式は、演算子がより高い優先度を持つような別の式を用いて定義される。このようにして、演算子の優先度は、文法中で明示的に表される。</p>
<p>
この文書中で式が議論される順番は、演算子の優先度の順番を反映していない。一般に、この文書では、最も単純な種類の式を最初に導入し、続いて、より複雑な式を導入する。完全な文法については、付録を見よ
[<a href="#nt-bnf"><b>A XQueryの文法</b></a>]。</p>
<p><span class="xquery">[<a name="dt-query" id="dt-query" title=
"query">Definition</a>: <b>問合せ</b>は1つ以上の<a title="module" href=
"#dt-module">モジュール</a>から構成される。]
もし問合せが実行可能であるならば、そのモジュールのうちいずれか1つが<a title="query body" href=
"#dt-queryBody">Query Body</a>を持つ。これに含まれる式の値が問合せの結果となる。式は XQuery
の文法中の記号<a href="#doc-xquery-Expr">Expr</a><a href=
"#doc-xquery-Expr">Expr</a>によって表現される。</span></p>
<h5><a name="d2e5247" id="d2e5247"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Expr" id=
"doc-xquery-Expr"></a>[31]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ExprSingle" id=
"doc-xquery-ExprSingle"></a>[32]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExprSingle</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-FLWORExpr">FLWORExpr</a><br />
| <a href="#doc-xquery-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xquery-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#doc-xquery-IfExpr">IfExpr</a><br />
| <a href="#doc-xquery-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p>最も優先度の低いXQuery演算子は<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>である。これは、2つの演算数をつないで1つの列を作るのに用いられる。文法に示す通り、一般の式(<a href="#doc-xquery-Expr">Expr</a>)は複数の<a href="#doc-xquery-ExprSingle">ExprSingle</a>演算数から構成することができる。このとき演算数はコンマで区切られる。名前<a href="#doc-xquery-ExprSingle">ExprSingle</a>は最上位の<a title="comma operator"
href="#dt-comma-operator">コンマ演算子</a>を含まない式を表す。(その名前に反して、<a href=
"#doc-xquery-ExprSingle">ExprSingle</a>は1つ以上の項目を含む列を評価してもよい。)</p>
<p>シンボル<a href=
"#doc-xquery-ExprSingle">ExprSingle</a>は、文法中で式の最上位にコンマを含むことが許されないようなあちこちの場所で使われている。例えば、関数呼び出しの各引数は<a href="#doc-xquery-ExprSingle">ExprSingle</a>でなければならない。なぜなら、関数呼び出しの引数を区切るのにコンマが使われているからである。</p>
<p>コンマの次に低い優先度を持つ式は<span class="xquery"><a href=
"#doc-xquery-FLWORExpr">FLWORExpr</a>,</span> <a href=
"#doc-xquery-QuantifiedExpr">QuantifiedExpr</a>, <span class=
"xquery"><a href=
"#doc-xquery-TypeswitchExpr">TypeswitchExpr</a>,</span> <a href=
"#doc-xquery-IfExpr">IfExpr</a>, そして<a href=
"#doc-xquery-OrExpr">OrExpr</a>である。これらの式は各々、この文書の別の節で述べる。</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>3.1 基本式</h3>
<p>[<a name="dt-primary-expression" id="dt-primary-expression"
title="primary expression">Definition</a>: <b>基本式</b>(primary
expression)はXQuery言語の基本原式である。これにはリテラル、変数参照、文脈項目式、<span class=
"xquery">構成子、</span>関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。]
<span class="xquery">構成子についての記述は<a href="#id-constructors"><b>3.7
構成子</b></a>にある。</span></p>
<h5><a name="d2e5345" id="d2e5345"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PrimaryExpr" id=
"doc-xquery-PrimaryExpr"></a>[84]&nbsp;&nbsp;&nbsp;</td>
<td><code>PrimaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Literal">Literal</a> | <a href=
"#doc-xquery-VarRef">VarRef</a> | <a href=
"#doc-xquery-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#doc-xquery-ContextItemExpr">ContextItemExpr</a> | <a href=
"#doc-xquery-FunctionCall">FunctionCall</a> | <a href=
"#doc-xquery-OrderedExpr">OrderedExpr</a> | <a href=
"#doc-xquery-UnorderedExpr">UnorderedExpr</a> | <a href=
"#doc-xquery-Constructor">Constructor</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>3.1.1 リテラル</h4>
<p>[<a name="dt-literal" id="dt-literal" title=
"literal">Definition</a>: <b>リテラル</b>は原子値の直接的構文表現である。]
XQueryは2種類のリテラルを支援する。数リテラルと文字列リテラルである。</p>
<h5><a name="d2e5383" id="d2e5383"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Literal" id=
"doc-xquery-Literal"></a>[85]&nbsp;&nbsp;&nbsp;</td>
<td><code>Literal</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-NumericLiteral">NumericLiteral</a> |
<a href="#doc-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-NumericLiteral" id=
"doc-xquery-NumericLiteral"></a>[86]&nbsp;&nbsp;&nbsp;</td>
<td><code>NumericLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-IntegerLiteral">IntegerLiteral</a> |
<a href="#doc-xquery-DecimalLiteral">DecimalLiteral</a> | <a href=
"#doc-xquery-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-IntegerLiteral" id=
"doc-xquery-IntegerLiteral"></a>[141]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntegerLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DecimalLiteral" id=
"doc-xquery-DecimalLiteral"></a>[142]&nbsp;&nbsp;&nbsp;</td>
<td><code>DecimalLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("." <a href="#doc-xquery-Digits">Digits</a>) | (<a href=
"#doc-xquery-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DoubleLiteral" id=
"doc-xquery-DoubleLiteral"></a>[143]&nbsp;&nbsp;&nbsp;</td>
<td><code>DoubleLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("." <a href="#doc-xquery-Digits">Digits</a>) |
(<a href="#doc-xquery-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]?
<a href="#doc-xquery-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-StringLiteral" id=
"doc-xquery-StringLiteral"></a>[144]&nbsp;&nbsp;&nbsp;</td>
<td><code>StringLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href=
"#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery-CharRef">CharRef</a> | <a href=
"#doc-xquery-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') | ("'"
(<a href="#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a>
| <a href="#prod-xquery-CharRef">CharRef</a> | <a href=
"#doc-xquery-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PredefinedEntityRef" id=
"doc-xquery-PredefinedEntityRef"></a>[145]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredefinedEntityRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Digits" id=
"doc-xquery-Digits"></a>[158]&nbsp;&nbsp;&nbsp;</td>
<td><code>Digits</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p><b>数リテラル</b>の値のうち"<code>.</code>"と文字<code>e</code>,
<code>E</code>を含まないものは<code>xs:integer</code>型の原子値である。数リテラルの値のうち、"<code>.</code>"を含むが文字<code>e</code>も<code>E</code>も含まないものは<code>xs:decimal</code>型の原子値である。数リテラルの値のうち、文字<code>e</code>か<code>E</code>を含むものは<code>xs:double</code>型の原子値である。これらの数リテラルの値は、<a href="http://www.w3.org/TR/xpath-functions/#casting-from-strings">17.1.1
Casting from xs:string and xs:untypedAtomic</a><sup xmlns=
""><small>FO</small></sup>で指定されているように、<code>xs:untypedAtomic</code>から数型へ型変換するためのルールにしたがって、適切な型へ変換することにより決定される。</p>
<p><b>文字列リテラル</b>の値は、
<code>xs:string</code>を型とし、区切りの一重引用符または二重引用符の間の文字によって表される文字列を値とするような原子値である。リテラルが一重引用符で区切られているとき、リテラル中で隣り合った2つの一重引用符は1つの一重引用符と解釈される。同様に、リテラルが二重引用符で区切られているとき、リテラル中で隣り合った2つの二重引用符は1つの二重引用符と解釈される。</p>
<p class="xquery">文字列リテラルには<b>既定義実体参照</b>が含まれていてもよい。[<a name=
"dt-predefined-entity-reference" id=
"dt-predefined-entity-reference" title=
"predefined entity reference">Definition</a>:
<b>既定義実体参照</b>は短い文字列であり、&amp;記号で始まる。これは単一の文字のうち、他の場合には構文上の目印となるものを表す。]
既定義実体参照はそれぞれ、文字列リテラルが生成されるときには、それが表現する文字に置き換えられる。XQuery
で認識される既定義実体参照は以下の通りである:</p>
<table width="60%" border="1" class="xquery" summary=
"Special characters">
<tbody>
<tr>
<td align="center">実体参照</td>
<td align="center">表現される文字</td>
</tr>
<tr>
<td align="center"><code>&amp;lt;</code></td>
<td align="center"><code>&lt;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;gt;</code></td>
<td align="center"><code>&gt;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;amp;</code></td>
<td align="center"><code>&amp;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;quot;</code></td>
<td align="center"><code>"</code></td>
</tr>
<tr>
<td align="center"><code>&amp;apos;</code></td>
<td align="center"><code>'</code></td>
</tr>
</tbody>
</table>
<p class="xquery">文字列リテラルは<b>文字参照</b>を含んでもよい。[<a name=
"dt-character-reference" id="dt-character-reference" title=
"character reference">Definition</a>: <b>文字参照</b>は<a href=
"#Unicode">[Unicode]</a>文字のXML形式の参照であり、10進または16進のコード位置で識別される。]
例えば、ユーロ記号 (€)
は文字参照<code>&amp;#8364;</code>によって表現することができる。文字参照はXMLの仕様の 4.1
節で規格として定義されている (<a href="#XML">[XML 1.0]</a>のルールを適用するか<a href=
"#XML1.1">[XML 1.1]</a>のルールを適用するかは<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である)。文字参照が、使用している XML
の版での正しい文字を識別しないならば、<a title="static error" href=
"#dt-static-error">静的エラー</a> [<a title="err:XQST0090" href=
"#ERRXQST0090">err:XQST0090</a>] が発生する。</p>
<p>リテラル式の例をいくつか示す。</p>
<ul>
<li>
<p><code>"12.5"</code>は、文字 '1', '2', '.', '5'からなる文字列を表す。</p>
</li>
<li>
<p><code>12</code>は<code>xs:integer</code>の値12を表す。</p>
</li>
<li>
<p><code>12.5</code>は<code>xs:decimal</code>の値12.5を表す。</p>
</li>
<li>
<p><code>125E2</code>は、<code>xs:double</code>の値12500を表す。</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code>は2つの二重引用符と1つの
一重引用符を含む文字列を表す。</p>
</li>
<li>
<p><code>"Ben &amp;amp;
Jerry&amp;apos;s"</code>は<code>xs:string</code>の値 "<code>Ben &amp;
Jerry's</code>" を表す。</p>
</li>
<li>
<p><code>"&amp;#8364;99.50"</code> は<code>xs:string</code>の値
"<code>€99.50</code>" を表す。</p>
</li>
</ul>
<p>
<code>xs:boolean</code>の値<code>true</code>と<code>false</code>は、それぞれ<a title="built-in function"
href="#dt-built-in-function">組み込み関数</a>
<code>fn:true()</code>と<code>fn:false()</code>の呼び出しによって表現することができる。</p>
<p>その他の原子型の値は、与えられた型に対する<a title="constructor function" href=
"#dt-constructor-function">構成子関数</a>を呼び出すことにより構成することができる。XML
Schemaの組み込み型に対する構成子関数は<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>で定義されている。一般的に、ある型の構成子関数の名前は、その型の名前(名前空間を含む)と等しい。例えば:</p>
<ul>
<li>
<p><code>xs:integer("12")</code>は整数値12を返す。</p>
</li>
<li>
<p>
<code>xs:date("2001-08-25")</code>は、型が<code>xs:date</code>で、値が2001年8月25日という日付を表す項目を返す。</p>
</li>
<li>
<p>
<code>xs:dayTimeDuration("PT5H")</code>は、型が<code>xs:dayTimeDuration</code>で、値が5時間という時間を表す項目を返す。</p>
</li>
</ul>
<p>また構成子関数は、以下の例のように、リテラル表現を持たない特別な値を生成することもできる。</p>
<ul>
<li>
<p><code>xs:float("NaN")</code>は、"数でない"(Not a
Number)という特別な浮動小数点数の値を返す。</p>
</li>
<li>
<p><code>xs:double("INF")</code>は"正の無限大"という特別な二倍長浮動小数点数の値を返す。</p>
</li>
</ul>
<p>また、<code>cast</code>式を用いてさまざまな型の値を構成することもできる。例えば以下の通り。</p>
<ul>
<li>
<p><code>9 cast as
hatsize</code>は、型が<code>hatsize</code>である原子値<code>9</code>を返す。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>3.1.2 変数参照</h4>
<h5><a name="d2e5737" id="d2e5737"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-VarRef" id=
"doc-xquery-VarRef"></a>[87]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href="#doc-xquery-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-VarName" id=
"doc-xquery-VarName"></a>[88]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-variable-reference" id="dt-variable-reference"
title="variable reference">Definition</a>:
<b>変数参照</b>は$記号にQNameを続けたものである。]
2つの変数参照が同値であるとは、それらの局所名が等しく、かつそれらの名前空間接頭辞が<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中の同じ名前空間URIに束縛されていることである。接頭辞のない変数参照はどの名前空間にも属さない。</p>
<p>変数参照はそれぞれ<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>内の名前に照合されなければならない。有効範囲内変数には以下の出所からの変数が含まれる。</p>
<ol class="enumar">
<li>
<p>変数は<a title="Prolog" href=
"#dt-prolog">前書き</a>で宣言されていてもよいし、現在の<a title="module" href=
"#dt-module">モジュール</a>や<b>輸入モジュール</b>中で宣言されていてもよい。モジュールや前書きに関する議論は<a href="#id-query-prolog"><b>4
モジュールと前書き</b></a>を見よ。</p>
</li>
<li>
<p><a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の変数によって拡大されてもよい。</p>
</li>
<li>
<p>変数はXQuery式によって束縛されてもよい。<span class="xquery">変数を束縛できる式の種類は、FLWOR式
(<a href="#id-flwor-expressions"><b>3.8 FLWOR 式</b></a>), 限量式
(<a href="#id-quantified-expressions"><b>3.11 限量式</b></a>),
<code>typeswitch</code>式 (<a href="#id-typeswitch"><b>3.12.2
Typeswitch</b></a>)
である。関数呼び出しもまた、関数の本体を実行する前に関数の仮引数に値を束縛する。</span></p>
</li>
</ol>
<p>
変数束縛はそれぞれ静的有効範囲を持つ。有効範囲は、変数への参照が正しく出現できる場所を定義する。有効範囲の中にない変数を参照すると、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0008" href=
"#ERRXPST0008">err:XPST0008</a>] である。ある式に対して、変数が<a title=
"static context" href=
"#dt-static-context">静的文脈</a>内で束縛されれば、その変数は式全体に対する有効範囲に含まれる。</p>
<p>
変数参照が有効範囲内の2つ以上の変数束縛に照合されたときは、その参照は、より内側の束縛、すなわち有効範囲がより小さいほうの束縛を参照すると解釈される。評価時には、変数参照の値は、対応する変数が束縛されている式の値である。変数束縛の有効範囲は、変数を束縛することのできる式それぞれについて個別に定義される。</p>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>3.1.3 括弧式</h4>
<h5><a name="d2e5818" id="d2e5818"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ParenthesizedExpr" id=
"doc-xquery-ParenthesizedExpr"></a>[89]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(" <a href="#doc-xquery-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>括弧は、複数の演算子を含む式の評価順序をある順に強制するのに用いてもよい。例えば、式<code>(2 + 4) *
5</code>を評価すると30になる。なぜなら括弧式<code>(2 +
4)</code>が最初に評価され、その結果に5が掛けられるからである。括弧をつけなければ、式<code>2 + 4 *
5</code>を評価すると22になる。なぜなら乗算演算子は加算演算子より優先度が高いからである。</p>
<p>空の括弧は、<a href="#construct_seq"><b>3.3.1
列の構成</b></a>にある通り、空列を表すのに用いられる。</p>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>3.1.4 文脈項目式</h4>
<h5><a name="d2e5846" id="d2e5846"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ContextItemExpr" id=
"doc-xquery-ContextItemExpr"></a>[90]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContextItemExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p><b>文脈項目式</b>を評価すると<a title="context item" href=
"#dt-context-item">文脈項目</a>が得られる。これは節点(式<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>中のように)か、原子値(式<code>(1
to 100)[. mod 5 eq 0]</code>中のように)のいずれかである。</p>
<p><a title="context item" href=
"#dt-context-item">文脈項目</a>が未定義であれば、文脈項目式は動的エラーを引き起こす[<a title=
"err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>3.1.5
関数呼び出し</h4>
<p>[<a name="dt-built-in-function" id="dt-built-in-function" title=
"built-in function">Definition</a>:
XQueryで支援されている<b>組み込み関数</b>は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている。] <span class="xquery">追加の関数が<a title=
"Prolog" href="#dt-prolog">前書き</a>で宣言されたり、<a title="library module"
href="#dt-library-module">ライブラリモジュール</a>から輸入されたり、<a title=
"static context" href=
"#dt-static-context">静的文脈</a>の一部として外部環境によって用意されたりしてもよい。</span></p>
<h5><a name="d2e5897" id="d2e5897"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-FunctionCall" id=
"doc-xquery-FunctionCall"></a>[93]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a> "(" (<a href=
"#doc-xquery-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>
<b>関数呼び出し</b>は、QNameの後ろに0個以上の式の括弧付きリストが続くような構成をしている。この括弧付きリストを<b>引数</b>という。関数呼び出しのQNameが名前空間接頭辞を持っていなければ、<a title="default function namespace"
href="#dt-def-fn-ns">デフォルト関数名前空間</a>に属するとみなす。</p>
<p>関数呼び出しの<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>や引数の数が<a title="static context"
href="#dt-static-context">静的文脈</a>中の<a title="function signature"
href="#dt-function-signature">関数シグネチャ</a>の名前や次数に照合されなければ、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する[<a title=
"err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>]。</p>
<p>関数呼び出しは次のように評価される。</p>
<ol class="enumar">
<li>
<p>引数の式が評価され、引数値を生成する。引数の評価順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>であり、ある引数を評価することなく関数の本体が評価できるならば、関数はその引数を評価する必要はない。</p>
</li>
<li>
<p>以下に挙げる関数変換ルールを適用して、引数値がそれぞれ変換される。</p>
</li>
<li>
<p>
関数が組み込み関数であれば、変換された引数値を用いて評価される。結果はその関数の宣言済戻り型のインスタンスであるか、動的エラーである。組み込み関数によって発生するエラーは<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で定義されている。</p>
</li>
<li>
<p>
関数が本体を持つ利用者定義関数であれば、変換された引数値が関数の仮引数に束縛され、関数の本体が評価される。次に、関数変換ルールを用いて、関数の本体によって返される値がその関数の宣言済戻り型に変換される。</p>
<p>変換された引数値が関数の引数に束縛されるとき、引数の値はその最も具体的な<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>を保つ。この型が仮引数の型から導出されてもよいとしても、このようになる。例えば、<code>xs:decimal</code>
型の引数 <code>$p</code> を持つ関数は <code>xs:integer</code>
型の引数とともに呼び出すことができる。<code>xs:integer</code> 型は
<code>xs:decimal</code> 型から導出される。この関数呼び出しの処理の間、関数の本体の内部では
<code>$p</code> の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>は <code>xs:integer</code>
だとみなされる。同様に、関数による戻り値はその最も具体的な型を保つ。その型は、関数の宣言済戻り型から導出されてもよい。例えば、<code>xs:decimal</code>
を宣言済戻り型として持つ関数は、実際には動的型 <code>xs:integer</code> の値を返してもよい。</p>
<p>関数本体の評価では、式評価の<a title="static context" href=
"#dt-static-context">静的文脈</a>や<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>は、その関数が宣言されている<a title="module" href=
"#dt-module">モジュール</a>によって定義される。このモジュールが関数の呼び出される<a title="module"
href=
"#dt-module">モジュール</a>と同じである必要はない。例えば、関数の本体を評価する間有効範囲中にある変数は、関数が呼び出されるモジュールではなく、関数を宣言するモジュールの有効範囲内変数によって定義される。関数本体を評価する間、<a title="focus"
href="#dt-focus">焦点</a>
(文脈項目、文脈位置、文脈サイズ)は定義されない。ただし関数本体の内部の式によって焦点が定義される場合を除く。</p>
</li>
<li>
<p>関数がユーザ定義の外部関数であれば、その<a title="function implementation" href=
"#dt-function-implementation">関数の実装</a>が、変換された引数の値を伴って呼び出される。結果は、宣言された型の値か、<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>のエラーである (<a href=
"#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>を見よ)。</p>
</li>
</ol>
<p><b>関数変換ルール</b>は、引数値<span class=
"xquery">もしくは戻り値</span>を、引数として期待される型に変換するのに用いられる。すなわち、関数の<span class="xquery">引数もしくは戻り値</span>の定義済型に変換するのに用いられる。期待される型は<a title="sequence type"
href=
"#dt-sequence-type">列型</a>として表現される。与えられた値に対して、関数変換ルールは以下のように適用される。</p>
<ul>
<li>
<p>期待される型が原子型の列 (出現標識<code>*</code>, <code>+</code>,
<code>?</code>を伴っていてもよい)であるならば、以下の変換が適用される。</p>
<ol class="enumar">
<li>
<p>与えられた値に<a title="atomization" href=
"#dt-atomization">原子化</a>が行われ、原子値の列が結果として得られる。</p>
</li>
<li>
<p>
原子列の項目のうち<code>xs:untypedAtomic</code>型のものそれぞれに対し、期待される原子型への型変換が行われる。<a title="built-in function"
href="#dt-built-in-function">組み込み関数</a>のうち期待される型が<a title="numeric"
href=
"#dt-numeric">数</a>と指定されているものについて、<code>xs:untypedAtomic</code>型の引数が<code>xs:double</code>に型変換される。</p>
</li>
<li>
<p>原子列中の<a title="numeric" href="#dt-numeric">数</a>項目のうち、<a href=
"#promotion"><b>B.1 型の昇格</b></a>に書かれている数昇格を用いて期待される原子型に<a title=
"type promotion" href=
"#dt-type-promotion">昇格</a>できるものについて、昇格が行われる。</p>
</li>
<li>
<p>原子列中の<code>xs:anyURI</code>型の項目のうち、<a href="#promotion"><b>B.1
型の昇格</b></a>に書かれているURI昇格を用いて期待される原子型に<a title="type promotion"
href="#dt-type-promotion">昇格</a>できるものについて、昇格が行われる。</p>
</li>
</ol>
</li>
<li>
<p>上記の変換を行った後、結果の値が、<a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールに従って期待される型に照合されないときは、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する[<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。 <span class=
"xquery">関数呼び出しが、その関数が定義されている<a title="module" href=
"#dt-module">モジュール</a>ではない<a title="module" href=
"#dt-module">モジュール</a>に置かれているならば、このルールは、関数が呼び出されるモジュール、関数が定義されているモジュールの両方で満たされなければならない。
(このためのテストは繰り返される。というのは、2つのモジュールは異なる<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>を持っていてもよいからである。)</span> <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のためのルールは、導出された型の値を基礎型の値として置換することを許していることに注意せよ。</p>
</li>
</ul>
<p>関数呼び出しの引数はコンマで区切られているので、最上位の<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>を含む引数式は、括弧で囲まなければならない。以下は、関数呼び出しの例とその説明である。</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2,
3)</code>は3つの引数を持つ関数呼び出しである。</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2),
3)</code>は2つの引数を持つ関数呼び出しであり、1つ目の引数は2つの値の列である。</p>
</li>
<li>
<p><code>my:two-argument-function(1,
())</code>は2つの引数を持つ関数呼び出しであり、2つ目の引数は空列である。</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2,
3))</code>は1つの引数を持つ関数呼び出しであり、その引数は3つの値の列である。</p>
</li>
<li>
<p><code>my:one-argument-function((
))</code>は1つの引数を持つ関数呼び出しであり、その引数は空列である。</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code>は引数のない関数呼び出しである。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>3.2
経路式</h3>
<h5><a name="d2e6165" id="d2e6165"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PathExpr" id=
"doc-xquery-PathExpr"></a>[68]&nbsp;&nbsp;&nbsp;</td>
<td><code>PathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("/" <a href=
"#doc-xquery-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xquery-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xquery-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-RelativePathExpr" id=
"doc-xquery-RelativePathExpr"></a>[69]&nbsp;&nbsp;&nbsp;</td>
<td><code>RelativePathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-StepExpr">StepExpr</a> (("/" | "//")
<a href="#doc-xquery-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-path-expression" id="dt-path-expression" title=
"path expression">Definition</a>:
<b>経路式</b>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の <a title="step" href=
"#dt-step">ステップ</a>の並びからなり、各ステップは "<code>/</code>" または
"<code>//</code>", で区切られている。また、経路式は "<code>/</code>" または
"<code>//</code>"で始まる場合もある。]先頭の "<code>/</code>" または
"<code>//</code>"
は、以下に述べるように、経路式の先頭に暗黙的に追加される1つ以上の初期ステップの省略形である。</p>
<p>単一のステップからなる経路式は<a href="#id-steps"><b>3.2.1
ステップ</b></a>に述べるように評価される。</p>
<p>経路式の先頭にある "<code>/</code>" は初期ステップ<code>fn:root(self::node())
treat as document-node()/</code>の省略形である (ただし、もし "<code>/</code>"
が経路式全体であるならば、末尾の "<code>/</code>"
は展開から省かれる)。この初期ステップの効果は、その経路が文脈節点を含む木の根節点から始まる、ということである。文脈項目が節点でない場合は、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。評価時に、文脈節点より上にある根節点が文書節点でなければ、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
<p>経路式の先頭にある "<code>//</code>" は初期ステップ<code>fn:root(self::node())
treat as document-node()/descendant-or-self::node()/</code>の省略形である
(ただし、"<code>//</code>" それ自身は正しい経路式ではない [<a title="err:XPST0003"
href=
"#ERRXPST0003">err:XPST0003</a>])。これらの初期ステップの効果は、文脈節点の存在する木の根を含み、この根の子孫にすべての節点があるような初期節点列を確立するということである。この節点列は、経路式中の次のステップの入力として用いられる。文脈項目が節点でなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。評価時に、文脈節点より上にある根節点が文書節点でなければ、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>節点の子孫には属性節点は含まれない。</p>
</div>
<p>経路式中の先頭ではない場所に出現する "<code>//</code>" は<a href="#abbrev"><b>3.2.4
省略構文</b></a>に述べるように展開され、 "<code>/</code>"
で区切られるステップの列になる。次に、このステップ列が左から右へ評価される。それぞれの演算
<code>E1/E2</code>は次のように評価される:
式<code>E1</code>が評価され、結果が(空かもしれない)節点列でなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0019" href=
"#ERRXPTY0019">err:XPTY0019</a>]。
次に、<code>E1</code>の評価の結果得られる節点それぞれが、<a href=
"#eval_context"><b>2.1.2
動的文脈</b></a>にあるように、さらに<code>E2</code>の評価のための<b>内部焦点</b>を提供する。
<code>E2</code>の評価すべてから得られた列が以下のように結合される:</p>
<ol class="enumar">
<li>
<p>
<code>E2</code>の評価それぞれが(空かもしれない)節点列を返すなら、これらの列が結合され、節点の識別性に基づき、重複する節点が除去される。<span class="xquery">もし<a title="ordering mode"
href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば、結果の節点列は<a title="document order"
href="#dt-document-order">文書順</a>で返される。そうでない場合は、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順序で返される。</span></p>
</li>
<li>
<p>
<code>E2</code>の評価それぞれが(空かもしれない)原子値列を返すなら、これらの列が連接され、返される。<span class="xquery">もし<a title="ordering mode"
href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば、結果の列は<code>E2</code>を評価した結果生成される部分列中および部分列間の順序を保存する。そうでない場合は、結果の列の順序は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</span></p>
</li>
<li>
<p>複数の<code>E2</code>の評価の結果、節点と原子値が少なくとも1つずつ返ってきたならば、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する [<a title=
"err:XPTY0018" href="#ERRXPTY0018">err:XPTY0018</a>]。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
経路の各ステップが次のステップのための文脈節点を用意するため、その結果、経路の最後のステップしか、原子値列を返すことは許されない。</p>
</div>
<p>
経路式の例として、<code>child::div1/child::para</code>は、文脈節点の子要素<code>div1</code>の子要素<code>para</code>を選択する。言い換えれば、文脈節点の孫要素<code>para</code>のうち<code>div1</code>を親として持つものが選択される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">文字 "<code>/</code>"
は、完全な経路式としても、"<code>/*</code>"
のようなさらに長い経路式の先頭としても用いることができる。また、"<code>*</code>"
は、乗算演算子であるとともに経路式のワイルドカードでもある。このことにより、"<code>/</code>" が
"<code>*</code>" の左側に出現するとき、構文解析が難しくなる。これは、<a href=
"#parse-note-leading-lone-slash">leading-lone-slash</a>
制約を用いることにより、解決できる。例えば、"<code>/*</code>" と "<code>/ *</code>"
はワイルドカードを含む正しい経路式であるが、"<code>/*5</code>" と "<code>/ * 5</code>"
は構文エラーを引き起こす。<code>/</code>" を演算子の左側で用いる時は、"<code>(/) * 5</code>"
のように、括弧をつけなければならない。同様に、"<code>4 + / * 5</code>"
は構文エラーを引き起こすが、"<code>4 + (/) * 5</code>" は正しい式である。式 "<code>4 +
/</code>" もまた正しい。なぜなら<code>/</code>が演算子の左側に出現していないからである。</p>
</div>
<div class="div3">
<h4><a name="id-steps" id="id-steps"></a>3.2.1 ステップ</h4>
<h5><a name="d2e6434" id="d2e6434"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-StepExpr" id=
"doc-xquery-StepExpr"></a>[70]&nbsp;&nbsp;&nbsp;</td>
<td><code>StepExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-FilterExpr">FilterExpr</a> |
<a href="#doc-xquery-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AxisStep" id=
"doc-xquery-AxisStep"></a>[71]&nbsp;&nbsp;&nbsp;</td>
<td><code>AxisStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xquery-ReverseStep">ReverseStep</a> |
<a href="#doc-xquery-ForwardStep">ForwardStep</a>) <a href=
"#doc-xquery-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ForwardStep" id=
"doc-xquery-ForwardStep"></a>[72]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xquery-ForwardAxis">ForwardAxis</a>
<a href="#doc-xquery-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ReverseStep" id=
"doc-xquery-ReverseStep"></a>[75]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xquery-ReverseAxis">ReverseAxis</a>
<a href="#doc-xquery-NodeTest">NodeTest</a>) | <a href=
"#doc-xquery-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PredicateList" id=
"doc-xquery-PredicateList"></a>[82]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-step" id="dt-step" title="step">Definition</a>:
<b>ステップ</b>は<a title="path expression" href=
"#dt-path-expression">経路式</a>の一部であり、項目の列を生成し、その列を0個以上の<a title=
"predicate" href=
"#dt-predicate">述語</a>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<a title="axis step"
href="#dt-axis-step">軸ステップ</a>または<a title="filter expression" href=
"#dt-filter-expression">選別式</a>のいずれかである。] 選別式の説明は<a href=
"#id-filter-expr"><b>3.3.2 選別式</b></a>にある。</p>
<p>[<a name="dt-axis-step" id="dt-axis-step" title=
"axis step">Definition</a>:
<b>軸ステップ</b>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<b>軸</b>はステップでの
"移動方向" を定義し、<a title="node test" href=
"#dt-node-test">節点テスト</a>は節点の種類、名前、<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>により節点を選択する。]
文脈項目が節点であれば、軸ステップは0個以上の節点からなる列を返す。それ以外の場合は、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0020" href=
"#ERRXPTY0020">err:XPTY0020</a>]。<span class="xquery">もし<a title=
"ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば、結果の節点列は<a title="document order"
href="#dt-document-order">文書順</a>で返される。そうでない場合は、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順序で返される。</span>
軸ステップは<b>前向きステップ</b>かまたは<b>逆向きステップ</b>のいずれかであり、0個以上の<a title=
"predicate" href="#dt-predicate">述語</a>がそれに続く。</p>
<p>ステップの<b>省略構文</b>では、軸は省略可能であり、また<a href="#abbrev"><b>3.2.4
省略構文</b></a>にあるように、その他の短縮記法も利用できる。</p>
<p>
軸ステップの非省略構文は軸名と節点テストからなり、これらは2つのコロンで区切られる。ステップの結果は、指定された軸を通して文脈節点から到達可能な節点のうち、節点テストで指定される節点の種類、名前、<a title="type annotation"
href=
"#dt-type-annotation">型注釈</a>を持つものからなる。例えば、ステップ<code>child::para</code>は、文脈節点の子要素<code>para</code>を選択する。ここで<code>child</code>が軸の名前であり、<code>para</code>がこの軸上で選択される要素節点の名前である。利用できる軸の説明は<a href="#axes"><b>3.2.1.1
軸</b></a>にある。利用できる節点テストの説明は<a href="#node-tests"><b>3.2.1.2
節点テスト</b></a>にある。ステップの例は<a href="#unabbrev"><b>3.2.3
非省略構文</b></a>や<a href="#abbrev"><b>3.2.4 省略構文</b></a>で示されている。</p>
<div class="div4">
<h5><a name="axes" id="axes"></a>3.2.1.1 軸</h5>
<h5><a name="d2e6590" id="d2e6590"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ForwardAxis" id=
"doc-xquery-ForwardAxis"></a>[73]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ReverseAxis" id=
"doc-xquery-ReverseAxis"></a>[76]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<p class="xquery">XQueryは次の軸を支援する (ただし、<a href=
"#id-full-axis-feature"><b>5.2.4 全軸機能</b></a>にある制限を仮定している):</p>
<ul>
<li>
<p><code>child</code>軸は文脈節点の子を含む。これらの節点は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>にある<code>dm:children</code>アクセサにより返される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
子を持つのは文書節点と要素節点だけである。文脈節点がこれ以外の種類の節点であるか、文脈節点が空の文書節点もしくは要素節点であったならば、child軸は空列である。文書節点や要素節点の子は、要素節点、処理命令節点、コメント節点、テキスト節点のいずれかである。属性節点、文書節点は決して子として出現することはない。</p>
</div>
</li>
<li>
<p><code>descendant</code>軸はchild軸の推移的閉包として定義される。この軸には文脈節点の子孫
(子、子の子、など) が含まれる。</p>
</li>
<li>
<p><code>parent</code>軸は<a href="#datamodel">[XQuery/XPath Data
Model
(XDM)]</a>にある<code>dm:parent</code>アクセサにより返される列を含む。このアクセサは文脈節点の親を返す。ただし、文脈節点が親を持たない場合は空列を返す。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>属性節点はその親として要素節点を持っていてもよい。ただしその場合も、その属性節点はその要素節点の子ではない。</p>
</div>
</li>
<li>
<p><code>ancestor</code>軸はparent軸の推移的閉包として定義される。この軸には文脈節点の先祖
(親、親の親、など) が含まれる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>ancestor軸には、文脈節点のある木の根節点が含まれる。ただし、文脈節点が根節点の場合は含まれない。</p>
</div>
</li>
<li>
<p>
<code>following-sibling</code>軸は文脈節点の後に続く兄弟を含む。すなわち文脈節点の親の子のうち、<a title="document order"
href=
"#dt-document-order">文書順</a>で文脈節点の後ろに出現する節点を含む。もし文脈節点が属性節点であれば、<code>following-sibling</code>軸は空である。</p>
</li>
<li>
<p>
<code>preceding-sibling</code>軸は文脈節点の前にある兄弟を含む。すなわち文脈節点の親の子のうち、<a title="document order"
href=
"#dt-document-order">文書順</a>で文脈節点より前に出現する節点を含む。もし文脈節点が属性節点であれば、<code>preceding-sibling</code>軸は空である。</p>
</li>
<li>
<p><code>following</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より後ろに出現するものすべてを含む。</p>
</li>
<li>
<p><code>preceding</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より前に出現するものすべてを含む。</p>
</li>
<li>
<p><code>attribute</code>軸は、文脈節点の属性を含む。これらは<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>にある<code>dm:attributes</code>アクセサによって返される節点である。文脈節点が要素でなければ、この軸は空である。</p>
</li>
<li>
<p><code>self</code>軸は文脈節点自身のみを含む。</p>
</li>
<li>
<p><code>descendant-or-self</code>軸は、文脈節点と、文脈節点の子孫を含む。</p>
</li>
<li>
<p>
<code>ancestor-or-self</code>軸は、文脈節点と、文脈節点の先祖を含む。したがって、ancestor-or-self軸は常に根節点を含む。</p>
</li>
</ul>
<p>軸は<b>前向き軸</b>と<b>逆向き軸</b>とに分類することができる。文脈節点または<a title=
"document order" href=
"#dt-document-order">文書順</a>で文脈節点より後ろの節点のみ含む軸は、前向き軸である。文脈節点または<a title="document order"
href="#dt-document-order">文書順</a>で文脈節点より前の節点のみ含む軸は、逆向き軸である。</p>
<p><code>parent</code>軸, <code>ancestor</code>軸,
<code>ancestor-or-self</code>軸, <code>preceding</code>軸,
<code>preceding-sibling</code>軸は逆向き軸である。それ以外の軸はすべて前向き軸である。<code>ancestor</code>軸,
<code>descendant</code>軸, <code>following</code>軸,
<code>preceding</code>軸, <code>self</code>軸は文書を分割する
(属性節点は無視する)。これらの軸は互いに重複がなく、すべてを合わせると文書中のすべての節点を含む。</p>
<p>[<a name="dt-principal-node-kind" id="dt-principal-node-kind"
title="principal node kind">Definition</a>:
軸はそれぞれ<b>主要節点種類</b>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。]
したがって:</p>
<ul>
<li>
<p>attribute軸に対しては、主要節点種類は属性である。</p>
</li>
<li>
<p>それ以外のすべての軸に対しては、主要節点種類は要素である。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>3.2.1.2 節点テスト</h5>
<p>[<a name="dt-node-test" id="dt-node-test" title=
"node test">Definition</a>: <b>節点テスト</b>は、<a title="step" href=
"#dt-step">ステップ</a>によって選択された節点それぞれについて真にならなければならない条件である。]
この条件は、節点の種類 (要素、属性、テキスト、文書、コメント、処理命令)、節点の名前、(要素節点、属性節点、文書節点の場合には)
節点の<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>に基づいていてもよい。</p>
<h5><a name="d2e6803" id="d2e6803"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-NodeTest" id=
"doc-xquery-NodeTest"></a>[78]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-KindTest">KindTest</a> | <a href=
"#doc-xquery-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-NameTest" id=
"doc-xquery-NameTest"></a>[79]&nbsp;&nbsp;&nbsp;</td>
<td><code>NameTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a> | <a href=
"#doc-xquery-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Wildcard" id=
"doc-xquery-Wildcard"></a>[80]&nbsp;&nbsp;&nbsp;</td>
<td><code>Wildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-name-test" id="dt-name-test" title=
"name test">Definition</a>:
QNameまたはワイルドカードのみからなる節点テストを<b>名前テスト</b>という。]
名前テストが真になるのは、節点の<b>種類</b>がそのステップの軸の<a title="principal node kind"
href="#dt-principal-node-kind">主要節点種類</a>であり、節点の<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>が節点テストで指定されている<a title=
"expanded QName" href="#dt-expanded-qname">展開済QName</a>と
(<code>eq</code> 演算子で定義されているように)
一致するとき、かつそのときに限る。例えば、<code>child::para</code>は、文脈節点の<code>para</code>子要素を選択する。文脈節点の子に<code>para</code>要素がなければ、節点の空集合を選択する。<code>attribute::abc:href</code>は、QName<code>abc:href</code>を持つ文脈節点の属性を選択する。文脈節点がそのような属性を持たなければ、節点の空集合を選択する。</p>
<p>節点テスト中のQNameは、式文脈の<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>に解決される。QNameの接頭辞が静的既知名前空間のどれにも一致しなければ、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]である。接頭辞のないQNameは、<a title=
"principal node kind" href=
"#dt-principal-node-kind">主要節点種類</a>が要素である軸上で名前テストとして用いられると、式文脈の<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>の名前空間URIを持つ。これ以外の用いられ方の場合、名前空間URIを持たない。</p>
<p>名前テストの<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>と名前が一致しないような要素節点に対しては、その名前テストは満たされない。たとえその名前がその名付けられた節点を先頭とするような<a title="substitution group"
href=
"#dt-substitution-group">置換グループ</a>中にあったとしても、その名前テストは満たされない。</p>
<p>節点テスト<code>*</code>は、そのステップの軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>であるような任意の節点に対して、真である。例えば、<code>child::*</code>は文脈節点のすべての子要素を選択する。また<code>attribute::*</code>は、文脈節点のすべての属性を選択する。</p>
<p>
節点テストは<code>NCName:*</code>という形式を持つことができる。この場合、接頭辞はQNameと同じ方法で展開される。このとき、<a title="static context"
href="#dt-static-context">静的文脈</a>中の<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いる。その接頭辞が静的既知名前空間中になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0081"
href=
"#ERRXPST0081">err:XPST0081</a>]。このような形式の節点テストが真になるのは、ステップの軸のうち<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>が接頭辞の束縛されている名前空間URIを持っているものについて、その軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>の任意の節点に対してである。その名前の局所部分には関係しない。</p>
<p>
節点テストは<code>*:NCName</code>という形式を持つこともできる。この場合、節点テストが真になるのは、そのステップの軸の<a title="principal node kind"
href=
"#dt-principal-node-kind">主要節点種類</a>の節点のうち、局所名が与えられたNCNameに一致するものに対してである。節点の名前空間や、節点の名前空間の有無には関係しない。</p>
<p>[<a name="dt-kind-test" id="dt-kind-test" title=
"kind test">Definition</a>:
節点テストのもう一つの形式は<b>種類テスト</b>と呼ばれる。これは、節点の種類、名前、<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>に基づき、節点を選択することができる。]
種類テストの構文と意味についての記述は<a href="#id-sequencetype-syntax"><b>2.5.3
SequenceTypeの文法</b></a>と<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>にある。種類テストが<a title="node test" href=
"#dt-node-test">節点テスト</a>内で用いられるとき、指定された軸上の節点のうち、その種類テストに照合されるものだけが選択される。以下に示すのは、経路式中で用いられている種類テストの例のいくつかである。</p>
<ul>
<li>
<p><code>node()</code>は任意の節点に照合される。</p>
</li>
<li>
<p><code>text()</code>は任意のテキスト節点に照合される。</p>
</li>
<li>
<p><code>comment()</code>は任意のコメント節点に照合される。</p>
</li>
<li>
<p><code>element()</code>は任意の要素節点に照合される。</p>
</li>
<li>
<p>
<code>schema-element(person)</code>は、要素節点のうち、名前が<code>person</code>
(または<code>person</code>を先頭とする<a title="substitution group" href=
"#dt-substitution-group">置換グループ</a>に含まれる)であり、型注釈が<a title=
"in-scope element declarations" href=
"#dt-is-elems">有効範囲内要素定義</a>中の<code>person</code>要素の定義型と同じ(もしくは導出される)であるようなものに照合される。</p>
</li>
<li>
<p>
<code>element(person)</code>は、要素節点のうち、名前が<code>person</code>であるようなものに照合される。その節点の型注釈には関係しない。</p>
</li>
<li>
<p><code>element(person,
surgeon)</code>は、nillでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>または<code>surgeon</code>から導出されるものに照合される。</p>
</li>
<li>
<p><code>element(*,
surgeon)</code>は、nillでない要素節点のうち、型注釈が<code>surgeon</code>
(または<code>surgeon</code>から導出される)であるようなものに照合される。その節点の名前には関係しない。</p>
</li>
<li>
<p><code>attribute()</code>は任意の属性節点に照合される。</p>
</li>
<li>
<p>
<code>attribute(price)</code>は、属性節点のうち名前が<code>price</code>であるものに照合される。その節点の型注釈には関係しない。</p>
</li>
<li>
<p><code>attribute(*,
xs:decimal)</code>は属性節点のうち型注釈が<code>xs:decimal</code>である
(または<code>xs:decimal</code>から導出される) ものに照合される。その節点の名前には関係しない。</p>
</li>
<li>
<p><code>document-node()</code>は任意の文書節点に照合される。</p>
</li>
<li>
<p><code>document-node(element(book))</code>は、文書節点のうち内容が<a title=
"kind test" href="#dt-kind-test">種類テスト</a>
<code>element(book)</code>を満たす単一要素節点と、0個以上のコメントや処理命令が交差しているようなものに照合される。</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-predicates" id="id-predicates"></a>3.2.2 述語</h4>
<h5><a name="d2e7080" id="d2e7080"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Predicate" id=
"doc-xquery-Predicate"></a>[83]&nbsp;&nbsp;&nbsp;</td>
<td><code>Predicate</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"[" <a href="#doc-xquery-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-predicate" id="dt-predicate" title=
"predicate">Definition</a>:
<b>述語</b>は式からなり、角括弧で囲まれる。この式のことを<b>述語式</b>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。]
複数の隣接する述語の場合は、述語が左から右に適用され、それぞれの述語を適用した結果が次に続く述語の入力列になる。</p>
<p>入力列のそれぞれの項目に対して、述語式は <b>内部焦点</b> を用いて以下のように評価される:
文脈項目は、その述語によって現在評価されている項目である。文脈サイズは入力列中の項目数である。文脈位置は、入力列中の文脈項目の位置である。述語中での文脈位置を評価する目的で、入力列は以下のように整列されているとみなす:
述語が前向き軸のステップ中にあるなら文書順、述語が後ろ向き軸のステップ中にあるなら逆文書順、述語がステップ内にないなら元の順である。</p>
<p>入力列の項目それぞれに対して、
述語式の結果は<code>xs:boolean</code>の値に強制される。この値を<b>述語真偽値</b>といい、以下の通りになる。述語真偽値が<code>true</code>であるような項目が残され、述語真偽値が<code>false</code>であるような項目が捨てられる。</p>
<p>述語真偽値は以下のルールを順に適用することで導出される。</p>
<ol class="enumar">
<li>
<p>述語式の値が<a title="numeric" href="#dt-numeric">数</a>型または<a title=
"numeric" href="#dt-numeric">数</a>型から導出される型の<a title="singleton"
href=
"#dt-singleton">単一値列</a>原子値であるなら、述語真偽値は次のようになる。述語式の値が(<code>eq</code>演算子によって)<b>文脈位置</b>と等しい場合は<code>true</code>、それ以外の場合は<code>false</code>になる。
[<a name="dt-numeric-predicate" id="dt-numeric-predicate" title=
"numeric predicate">Definition</a>: 述語式が数型を返す述語を<b>数述語</b>という。]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>問合せ中で<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>unordered</code>であるような領域では、<a href="#id-unordered-expressions"><b>3.9
順序化式と非順序化式</b></a>に説明がある通り、数述語の結果は非決定的である。</p>
</div>
</li>
<li>
<p>これ以外の場合は、述語真偽値は、その述語式の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>である。</p>
</li>
</ol>
<p>以下に、述語を含む<a title="axis step" href=
"#dt-axis-step">軸ステップ</a>の例をいくつか示す。</p>
<ul>
<li>
<p>この例は、文脈節点の子要素のうち、2番目の<code>chapter</code>要素を選択する。</p>
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</li>
<li>
<p>
この例は、文脈節点の子孫のうち、名前が<code>"toy"</code>であり、その<code>color</code>属性の値が<code>"red"</code>であるような要素を選択する。</p>
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</li>
<li>
<p>
この例は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>子要素と<code>assistant</code>子要素をともに持つものを選択する。</p>
<div class="exampleInner">
<pre>
child::employee[secretary][assistant]
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><b>逆向き軸</b>を用いて選択された節点列に<a title="predicate" href=
"#dt-predicate">述語</a>を用いる場合、このような列の文脈位置は<a title=
"reverse document order" href=
"#dt-reverse-document-order">逆文書順</a>に割り当てられることを覚えておくことが重要である。例えば、<code>preceding::foo[1]</code>は<a title="reverse document order"
href=
"#dt-reverse-document-order">逆文書順</a>に最初に限定される<code>foo</code>要素を返す。なぜなら、この述語は逆向き軸を用いた<a title="axis step"
href=
"#dt-axis-step">軸ステップ</a>の一部であるからである。一方、<code>(preceding::foo)[1]</code>は<a title="document order"
href=
"#dt-document-order">文書順</a>に最初に限定される<code>foo</code>要素を返す。なぜなら、括弧によって<code>(preceding::foo)</code>が<a title="primary expression"
href=
"#dt-primary-expression">優先式</a>と解釈され、この式の中で文脈位置が文書順に割り当てられるからである。同様に、<code>ancestor::*[1]</code>は最も近い先祖要素を返す。なぜなら<code>ancestor</code>軸は逆向き軸であるからである。一方<code>(ancestor::*)[1]</code>は根要素
(文書順で最初の先祖) を返す。</p>
<p>
後ろ向き軸のステップでは述語を評価する目的で文脈位置が逆文書順で割り当てられているという事実があっても、ステップの最終結果は常に文書順であるという事実は変わらない。</p>
</div>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>3.2.3 非省略構文</h4>
<p>この節では経路式の例をいくつか出すが、これらは、各<a title="step" href=
"#dt-step">ステップ</a>で軸が明示的に指定されている。これらの例で用いられている構文は<b>非省略構文</b>と呼ばれる。多くの場合に共通して、<b>省略構文</b>を用いて経路式をより簡潔に書くことが可能である。この構文については<a href="#abbrev"><b>3.2.4
省略構文</b></a>で説明する。</p>
<ul>
<li>
<p><code>child::para</code>は文脈節点の子である<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::*</code>は文脈節点の子である要素すべてを選択する。</p>
</li>
<li>
<p><code>child::text()</code>は文脈節点の子であるテキスト節点すべてを選択する。</p>
</li>
<li>
<p>
<code>child::node()</code>は、文脈節点の子すべてを選択する。属性節点は返されないことに注意すること。なぜなら属性は子ではないからである。</p>
</li>
<li>
<p><code>attribute::name</code>は文脈節点の<code>name</code>属性を選択する。</p>
</li>
<li>
<p><code>attribute::*</code>は、文脈節点の属性すべてを選択する。</p>
</li>
<li>
<p>
<code>parent::node()</code>は、文脈節点の親を選択する。文脈節点が属性節点であれば、この式はその属性が付けられている要素節点
(もしあれば) を返す。</p>
</li>
<li>
<p>
<code>descendant::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>ancestor::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>ancestor-or-self::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。さらに文脈節点が<code>div</code>要素であれば、文脈節点自身も選択する。</p>
</li>
<li>
<p>
<code>descendant-or-self::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。さらに文脈節点が<code>para</code>要素であれば、文脈節点自身も選択する。</p>
</li>
<li>
<p>
<code>self::para</code>は、文脈節点が<code>para</code>要素である場合は文脈節点自身を選択する。それ以外の場合には空列を返す。</p>
</li>
<li>
<p>
<code>child::chapter/descendant::para</code>は、文脈節点の<code>chapter</code>子要素の子孫の<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>child::*/child::para</code>は、文脈節点の孫の<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/</code>は、文脈節点の含まれる木の根を選択する。ただし、この根が文書節点でなければ動的エラーを発生する。</p>
</li>
<li>
<p>
<code>/descendant::para</code>は、文脈節点と同じ文書中にある<code>para</code>要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/descendant::list/child::member</code>は、<code>list</code>要素を親とする<code>member</code>要素で、文脈節点と同じ文書中にあるものすべてを選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
1]</code>は、文脈節点の子のうち最初の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
fn:last()]</code>は、文脈節点の子のうち最後の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() =
fn:last()-1]</code>は、文脈節点の子のうち最後から2番目の<code>para</code>要素を選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() &gt;
1]</code>は、文脈要素の子の<code>para</code>要素のうち、1番目以外のものをすべて選択する。</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() =
1]</code>は、文脈要素の弟の<code>chapter</code>のうち、最初に出現するものを選択する。</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() =
1]</code>は、文脈要素の兄の<code>chapter</code>のうち、直前に出現するものを選択する。</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() =
42]</code>は、文脈要素を含む文書中で42番目に出現する<code>figure</code>を選択する。</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() =
2]</code>は、文脈要素を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p>
</li>
<li>
<p><code>child::para[attribute::type eq
"warning"]</code>は、文脈要素の子の<code>para</code>のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p>
</li>
<li>
<p><code>child::para[attribute::type eq 'warning'][fn:position() =
5]</code>は、文脈節点の<code>para</code>子要素で、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの5番目のものを選択する。</p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type eq
"warning"]</code>は、文脈節点の子のうち5番目の<code>para</code>要素を選択する。ただし、その要素が<code>type</code>属性を持ち、その値が<code>warning</code>である場合に限られる。</p>
</li>
<li>
<p><code>child::chapter[child::title =
'Introduction']</code>は、文脈節点の子の<code>chapter</code>のうち、<a title=
"typed value" href=
"#dt-typed-value">型付けされた値</a>が文字列<code>Introduction</code>に等しいような<code>title</code>子要素を1つ以上持つようなものを選択する。</p>
</li>
<li>
<p>
<code>child::chapter[child::title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1つ以上の<code>title</code>子要素を持つものを選択する。</p>
</li>
<li>
<p><code>child::*[self::chapter or
self::appendix]</code>は、文脈節点の子の<code>chapter</code>と<code>appendix</code>を選択する。</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code>は、文脈節点の子の<code>chapter</code>または<code>appendix</code>のうち、最後のものを選択する。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>3.2.4 省略構文</h4>
<h5><a name="d2e7601" id="d2e7601"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AbbrevForwardStep" id=
"doc-xquery-AbbrevForwardStep"></a>[74]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"@"? <a href=
"#doc-xquery-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AbbrevReverseStep" id=
"doc-xquery-AbbrevReverseStep"></a>[77]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>省略構文では、次の省略記法が認められる。</p>
<ol class="enumar">
<li>
<p>
attribute軸<code>attribute::</code>は<code>@</code>と略記できる。例えば、経路式<code>para[@type="warning"]</code>は<code>child::para[attribute::type="warning"]</code>の短縮形であり、<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものを選択する。</p>
</li>
<li>
<p><a title="axis step" href=
"#dt-axis-step">軸ステップ</a>から軸名が省略されると、軸ステップが<a href=
"#doc-xquery-AttributeTest">AttributeTest</a>または
を含まない限り、デフォルトの軸は<code>child</code>になる。AttributeTestを含む場合は、デフォルトの軸は<code>attribute</code>になる。例えば、経路式<code>section/para</code>は<code>child::section/child::para</code>の省略形であり、経路式<code>section/@id</code>は<code>child::section/attribute::id</code>の省略形である。同様に、<code>section/attribute(id)</code>は<code>child::section/attribute::attribute(id)</code>の省略形である。後者の式は軸指定と<a title="node test"
href="#dt-node-test">節点テスト</a>をともに含んでいることに注意せよ。</p>
</li>
<li>
<p>
経路式の処理中、先頭以外に出現する<code>//</code>は<code>/descendant-or-self::node()/</code>に置き換えられる。例えば、<code>div1//para</code>は<code>child::div1/descendant-or-self::node()/child::para</code>の短縮形であり、<code>div1</code>子要素の<code>para</code>子孫要素を選択する。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
経路式<code>//para[1]</code>は、経路式<code>/descendant::para[1]</code>と同じであるということを意味<em>しない</em>。後者は、最初の<code>para</code>子孫要素を選択する。前者は<code>para</code>子孫要素のうち、その親の最初の<code>para</code>子要素であるものをすべて選択する。</p>
</div>
</li>
<li>
<p>
<code>..</code>からなるステップは<code>parent::node()</code>の短縮形である。例えば、<code>../title</code>は<code>parent::node()/child::title</code>の短縮形であり、文脈節点の親の<code>title</code>子要素を選択する。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>式<code>.</code>は、<b>文脈項目式</b>と呼ばれ、<a title="primary expression"
href="#dt-primary-expression">基本式</a>である。これについての説明は<a href=
"#id-context-item-expression"><b>3.1.4 文脈項目式</b></a>にある。</p>
</div>
</li>
</ol>
<p>以下に示すのは、省略構文を用いた経路の例である。</p>
<ul>
<li>
<p><code>para</code>は、文脈節点の<code>para</code>子要素を選択する。</p>
</li>
<li>
<p><code>*</code>は、文脈節点の子要素すべてを選択する。</p>
</li>
<li>
<p><code>text()</code>は、文脈節点の子であるテキスト節点すべてを選択する。</p>
</li>
<li>
<p><code>@name</code>は、文脈節点の<code>name</code>属性を選択する。</p>
</li>
<li>
<p><code>@*</code>は、文脈節点の属性すべてを選択する。</p>
</li>
<li>
<p>
<code>para[1]</code>は、文脈節点の<code>para</code>子要素のうち最初のものを選択する。</p>
</li>
<li>
<p>
<code>para[fn:last()]</code>は、文脈節点の<code>para</code>子要素のうち最後のものを選択する。</p>
</li>
<li>
<p><code>*/para</code>は、文脈節点の<code>para</code>孫要素すべてを選択する。</p>
</li>
<li>
<p>
<code>/book/chapter[5]/section[2]</code>は、文脈節点を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p>
</li>
<li>
<p>
<code>chapter//para</code>は、文脈節点の<code>chapter</code>子要素の子孫である<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>//para</code>は、根である文書節点の子孫の<code>para</code>をすべて選択する。すなわち、文脈節点と同じ文書内にあるすべての<code>para</code>要素を選択する。</p>
</li>
<li>
<p>
<code>//@version</code>は、文脈節点と同じ文書内にあるすべての<code>version</code>属性を選択する。</p>
</li>
<li>
<p>
<code>//list/member</code>は、文脈節点と同じ文書内にある<code>member</code>要素のうち、<code>list</code>を親に持つものをすべて選択する。</p>
</li>
<li>
<p><code>.//para</code>は、文脈節点の子孫の<code>para</code>要素をすべて選択する。</p>
</li>
<li>
<p><code>..</code>は文脈節点の親を選択する。</p>
</li>
<li>
<p><code>../@lang</code>は、文脈節点の親の<code>lang</code>属性を選択する。</p>
</li>
<li>
<p>
<code>para[@type="warning"]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p>
</li>
<li>
<p>
<code>para[@type="warning"][5]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの中から5番目を選択する。</p>
</li>
<li>
<p>
<code>para[5][@type="warning"]</code>は、文脈節点の5番目の<code>para</code>子要素が、<code>type</code>属性を持ち、その値が<code>warning</code>であるなら、それを選択する。</p>
</li>
<li>
<p>
<code>chapter[title="Introduction"]</code>は、文脈節点の<code>chapter</code>子要素のうち、<a title="typed value"
href=
"#dt-typed-value">型付けされた値</a>が文字列<code>Introduction</code>であるような<code>title</code>子要素を1つ以上持つものを選択する。</p>
</li>
<li>
<p>
<code>chapter[title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1個以上の<code>title</code>子要素を持つものを選択する。</p>
</li>
<li>
<p><code>employee[@secretary and
@assistant]</code>は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>属性と<code>assistant</code>属性をともに持つものをすべて選択する。</p>
</li>
<li>
<p>
<code>book/(chapter|appendix)/section</code>は、<code>section</code>要素のうち親が<code>chapter</code>要素か<code>appendix</code>要素のいずれかであり、さらにそれが文脈節点の子の<code>book</code>の子であるようなものを選択する。</p>
</li>
<li>
<p><code>E</code>が節点列を返す式であるとき、式<code>E/.</code>は同じ節点列を<a title=
"document order" href=
"#dt-document-order">文書順</a>で返す。ただし、節点の識別性に基づき重複が除去される。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>3.3 列式</h3>
<p>XQueryは<a title="item" href="#dt-item">項目</a>の<a title=
"sequence" href=
"#dt-sequence">列</a>を構成したり選別したり結合したりする演算を支援している。列は決して入れ子にならない。例えば、値<code>1</code>,
<code>(2, 3)</code>, <code>( )</code>を結合して1つの列にすると、結果は列<code>(1, 2,
3)</code>になる。</p>
<div class="div3">
<h4><a name="construct_seq" id="construct_seq"></a>3.3.1 列の構成</h4>
<h5><a name="d2e8044" id="d2e8044"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_N12B67.doc-xquery-Expr" id=
"noid_N12B67.doc-xquery-Expr"></a>[31]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a> (","
<a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-RangeExpr" id=
"doc-xquery-RangeExpr"></a>[49]&nbsp;&nbsp;&nbsp;</td>
<td><code>RangeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#doc-xquery-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-comma-operator" id="dt-comma-operator" title=
"comma operator">Definition</a>:
列を構成する1つの方法は、<b>コンマ演算子</b>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。]
空の括弧は空列を表すのに用いることができる。</p>
<p>
列は原子値や節点を重複して含んでいてもよいが、列が別の列の項目になることは決してない。2つ以上の入力列を連接して新たな列を生成する場合、新たな列は、入力列の項目すべてを含み、かつその長さは入力列の長さの総和になる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>関数呼び出しの引数など、文法中で<a href=
"#doc-xquery-ExprSingle">ExprSingle</a>が必要とされる場所では、最上位のコンマ演算子を含む式はすべて括弧で囲まなければならない。</p>
</div>
<p>列を構成する式の例をいくつか示す。</p>
<ul>
<li>
<p>この式の結果は、5つの整数の列である。</p>
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</li>
<li>
<p>この式はそれぞれ長さ1, 2, 0, 2である4つの列を結合し、長さ5の1つの列にする。この式の結果は列<code>10, 1,
2, 3, 4</code>になる。</p>
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</li>
<li>
<p>
この式の結果は、文脈節点のすべての<code>salary</code>子節点の後ろにすべての<code>bonus</code>子節点が続くような列である。</p>
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</li>
<li>
<p>
<code>$price</code>が値<code>10.50</code>に束縛されているとすると、この式の結果は列<code>10.50,
10.50</code>である。</p>
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</li>
</ul>
<p>
<b>範囲式</b>は連続した整数の列を構成するのに用いることができる。<code>to</code>演算子の演算数はそれぞれ、期待される引数の型が<code>xs:integer?</code>であるような関数の引数であるかのように、変換される。いずれかの演算数が空列であるか、第1演算数から導出される整数が第2演算数から導出される整数より大きければ、範囲式の結果は空列である。2つの演算数の変換結果が同じ整数になれば、範囲式の結果はその整数である。それ以外の場合は、結果は、2つの整数演算数、および2つの演算数の間の整数すべてからなる列であり、昇順に並べられる。</p>
<ul>
<li>
<p>この例では、列を構成する演算数の1つに範囲式を用いている。これを評価すると列<code>10, 1, 2, 3,
4</code>になる。</p>
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</li>
<li>
<p>この例では、1つの整数<code>10</code>を含む長さ1の列を構成している。</p>
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</li>
<li>
<p>この例の結果は長さ0の列である。</p>
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</li>
<li>
<p>
この例では、<code>fn:reverse</code>を用いて6つの整数の降順列を構成している。これを評価すると列<code>15,
14, 13, 12, 11, 10</code>となる。</p>
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-filter-expr" id="id-filter-expr"></a>3.3.2 選別式</h4>
<h5><a name="d2e8167" id="d2e8167"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-FilterExpr" id=
"doc-xquery-FilterExpr"></a>[81]&nbsp;&nbsp;&nbsp;</td>
<td><code>FilterExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-PrimaryExpr">PrimaryExpr</a>
<a href="#doc-xquery-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N12C0E.doc-xquery-PredicateList" id=
"noid_N12C0E.doc-xquery-PredicateList"></a>[82]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-filter-expression" id="dt-filter-expression" title=
"filter expression">Definition</a>:
<b>選別式</b>は、単に、1つの<b>基本式</b>の後ろに0個以上の<a title="predicate" href=
"#dt-predicate">述語</a>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。]
述語が全く指定されなければ、結果は単に基本式の結果である。選別式によって返される項目の順序は、基本式の結果の順序と同じである。項目に割り当てられる文脈位置は、結果の列中の順序位置に基づいて決められる。最初の文脈位置は1である。</p>
<p>選別式の例を以下に示す。</p>
<ul>
<li>
<p>productsの列が変数で与えられているとすると、これらのproductsのうちpriceが100以上のものを返す。</p>
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</li>
<li>
<p>
1から100までの整数のうち5で割り切れるものをすべて列挙する(<code>to</code>演算子についての説明は<a href=
"#construct_seq"><b>3.3.1 列の構成</b></a>を見よ)。</p>
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</li>
<li>
<p>以下の式の結果は整数25である。</p>
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</li>
<li>
<p>以下の例は、変数 <code>$orders</code> に束縛されている列の5番目から9番目までを返す。</p>
<div class="exampleInner">
<pre>
$orders[fn:position() = (5 to 9)]
</pre></div>
</li>
<li>
<p>次に示すのは、選別式を<a title="path expression" href=
"#dt-path-expression">経路式</a>の<a title="step" href=
"#dt-step">ステップ</a>として用いている例である。これは、変数<code>$book</code>に束縛されている本の中からchapterまたはappendixのうち最後のものを返す。</p>
<div class="exampleInner">
<pre>
$book/(chapter | appendix)[fn:last()]
</pre></div>
</li>
<li>
<p>次に示すのも、選別式を<a title="path expression" href=
"#dt-path-expression">経路式</a>の<a title="step" href=
"#dt-step">ステップ</a>として用いている例である。これは、指定された文書中の要素節点のうち、IDの値が<code>tiger</code>であるようなものを返す。</p>
<div class="exampleInner">
<pre>
fn:doc("zoo.xml")/fn:id('tiger')
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="combining_seq" id="combining_seq"></a>3.3.3
節点列の結合</h4>
<h5><a name="d2e8259" id="d2e8259"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-UnionExpr" id=
"doc-xquery-UnionExpr"></a>[52]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-IntersectExceptExpr" id=
"doc-xquery-IntersectExceptExpr"></a>[53]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-InstanceofExpr">InstanceofExpr</a> (
("intersect" | "except") <a href=
"#doc-xquery-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XQueryでは、節点列を結合する演算として次のようなものを用意している。</p>
<ul>
<li>
<p>
<code>union</code>演算子と<code>|</code>演算子は等価である。これらは2つの節点列を演算数として取り、いずれかの演算数中に出現するすべての節点を含む列を返す。</p>
</li>
<li>
<p>
<code>intersect</code>演算子は2つの節点列を演算数として取り、どちらの演算数にも出現するすべての節点を含む列を返す。</p>
</li>
<li>
<p>
<code>except</code>演算子は2つの節点列を演算数として取り、第1演算数には出現するが第2演算数には出現しない節点をすべて含む列を返す。</p>
</li>
</ul>
<p>これらの演算子はすべて、節点の識別性に基づき結果の列から重複した節点を取り除く。<span class=
"xquery">もし<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば、結果の列は<a title="document order"
href="#dt-document-order">文書順</a>で返される。そうでない場合は、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順序で返される。</span></p>
<p><code>union</code>, <code>intersect</code>,
<code>except</code>の演算数が節点でない項目を含んでいたならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>以下に、列を結合する式の例をいくつか示す。3つの要素節点が存在すると仮定しよう。これらをA, B,
Cという記号名で参照する。また、変数<code>$seq1</code>, <code>$seq2</code>,
<code>$seq3</code>が、先に挙げた節点からなる以下のような列に束縛されていると仮定する。</p>
<ul>
<li>
<p><code>$seq1</code>は (A, B) に束縛されている</p>
</li>
<li>
<p><code>$seq2</code>は (A, B) に束縛されている</p>
</li>
<li>
<p><code>$seq3</code>は (B, C)に束縛されている</p>
</li>
</ul>
<p>このとき:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code>を評価すると列 (A, B) になる。</p>
</li>
<li>
<p><code>$seq2 union $seq3</code>を評価すると列 (A, B, C) になる。</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code>を評価すると列 (A, B) になる。</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code>を評価すると B のみを含む列になる。</p>
</li>
<li>
<p><code>$seq1 except $seq2</code>を評価すると空列になる。</p>
</li>
<li>
<p><code>$seq2 except $seq3</code>を評価すると A のみを含む列になる。</p>
</li>
</ul>
<p>ここで述べた列に関する演算子に加えて、<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>には、添字を通して項目や列の部分列にアクセスするための関数、添字を通して列中から項目を削除したり列中に項目を挿入するための関数、列から重複した項目を削除するための関数がある。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-arithmetic" id="id-arithmetic"></a>3.4 算術式</h3>
<p>XQueryは、加算、減算、乗算、除算、法などの算術演算子を、通常の単項や二項の形で用意している。</p>
<h5><a name="d2e8408" id="d2e8408"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AdditiveExpr" id=
"doc-xquery-AdditiveExpr"></a>[50]&nbsp;&nbsp;&nbsp;</td>
<td><code>AdditiveExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-MultiplicativeExpr" id=
"doc-xquery-MultiplicativeExpr"></a>[51]&nbsp;&nbsp;&nbsp;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xquery-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-UnaryExpr" id=
"doc-xquery-UnaryExpr"></a>[58]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("-" | "+")* <a href=
"#doc-xquery-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ValueExpr" id=
"doc-xquery-ValueExpr"></a>[59]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ValidateExpr">ValidateExpr</a> |
<a href="#doc-xquery-PathExpr">PathExpr</a> | <a href=
"#doc-xquery-ExtensionExpr">ExtensionExpr</a></code></td>
</tr>
</tbody>
</table>
<p>
減算演算子の前には空白を置かなければならない。そうしなければ、直前の字句の一部と解釈されることがある。例えば、<code>a-b</code>は1つの名前と解釈されるが、<code>a
- b</code>や<code>a -b</code>は算術式と解釈される。(空白処理の詳細は<a href=
"#whitespace-rules"><b>A.2.4 空白規則</b></a>を見よ。)</p>
<p>算術式の評価は、まず演算数を評価することから始まる。演算数を評価する順番は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<p><span class="xquery">各</span>演算数は以下のステップを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が演算数に適用される。この操作の結果は<b>原子化済演算数</b>と呼ばれる。</p>
</li>
<li>
<p>
原子化済演算数が空列であれば、算術式の結果は空列であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p>
</li>
<li>
<p>原子化済演算数が長さ1より大きい列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:double</code>に型変換される。型変換に失敗すれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する。 [err:FORG0001]</p>
</li>
</ol>
<p>
演算数の評価の後、演算数の型が与えられた算術演算子について正しい組み合わせであれば、演算子が演算数に適用される。結果は、原子値または<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>となる。
(例えば、0で除算を行った結果はエラーになるかもしれない。)
さまざまな算術演算子に受け入れられる原子型の組み合わせ、算術演算子の結果として期待される型については<a href=
"#mapping"><b>B.2
演算子の写像</b></a>に列挙されている。ここには、それぞれの型の組み合わせに対して演算子の意味を定義する<a title=
"operator function" href=
"#dt-operator-function">演算子関数</a>についても記述がある。演算子関数の定義は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>にある。</p>
<p>演算数の型が、評価の後、与えられた演算子について正しい組み合わせでないならば、<a href="#mapping"><b>B.2
演算子の写像</b></a>のルールに従って、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>
XQueryは<code>div</code>と<code>idiv</code>という2種類の除算演算子を支援する。これらの演算子は、2つの演算数として任意の<a title="numeric"
href="#dt-numeric">数</a>型の値を許す。<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>の説明の通り、<code>$arg1 idiv $arg2</code>は<code>($arg1 div
$arg2) cast as xs:integer?</code>と等しい。ただしエラーの場合は除く。</p>
<p>以下に、算術式の例をいくつか示す。</p>
<ul>
<li>
<p>
以下の最初の式は<code>xs:decimal</code>の値<code>-1.5</code>を返し、2番目の式は<code>xs:integer</code>の値<code>-1</code>を返す。</p>
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</li>
<li>
<p>2つの日付値の差の結果は<code>xs:dayTimeDuration</code>型の値になる。</p>
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</li>
<li>
<p>この例は減算演算子とハイフンの違いを示している。</p>
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</li>
<li>
<p>単項演算子は二項演算子より優先度が高い。もちろんこれは、括弧の利用に左右される。従って、次の2つの例は異なる意味となる。</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops"><a href="#XPath">[XPath
1.0]</a>との互換性のため、XQueryでは複数の単項算術演算子が連続して出現することが許される。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-comparisons" id="id-comparisons"></a>3.5 比較式</h3>
<p>
比較式は、2つの値を比較することを許す。XQueryは、3種類の比較式を用意している。それぞれ、値比較、汎用比較、節点比較という。</p>
<h5><a name="d2e8590" id="d2e8590"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ComparisonExpr" id=
"doc-xquery-ComparisonExpr"></a>[48]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComparisonExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-RangeExpr">RangeExpr</a> ( (<a href=
"#doc-xquery-ValueComp">ValueComp</a><br />
| <a href="#doc-xquery-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xquery-NodeComp">NodeComp</a>) <a href=
"#doc-xquery-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ValueComp" id=
"doc-xquery-ValueComp"></a>[61]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-GeneralComp" id=
"doc-xquery-GeneralComp"></a>[60]&nbsp;&nbsp;&nbsp;</td>
<td><code>GeneralComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-NodeComp" id=
"doc-xquery-NodeComp"></a>[62]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-value-comparisons" id=
"id-value-comparisons"></a>3.5.1 値比較</h4>
<p>値比較演算子は<code>eq</code>, <code>ne</code>, <code>lt</code>,
<code>le</code>, <code>gt</code>,
<code>ge</code>である。値比較は単一値を比較するのに用いられる。</p>
<p>値比較の評価で最初に行われるのは演算数の評価である。演算数が評価される順番は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。各演算数は以下のステップを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が演算数に対して適用される。この操作の結果は<b>原子化済演算数</b>と呼ばれる。</p>
</li>
<li>
<p>
原子化済演算数が空列であれば、値比較の結果は空列であり、実装は、他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p>
</li>
<li>
<p>原子化済演算数が長さ1より大きい列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:string</code>に型変換される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
このルールの目的は、値比較を推移的にするためである。利用者は、汎用比較演算子は<code>xs:untypedAtomic</code>演算数に関する別の型変換ルールを持っていることに気づくべきである。また利用者は、型変換での正確さを犠牲にすることで、値比較の推移性が妥協されてもよいということにも気づくべきである
(例えば、ほんの少し異なる2つの<code>xs:integer</code>の値は、<code>xs:float</code>が<code>xs:interger</code>よりも正確さに欠けるために、同じ<code>xs:float</code>の値だとみなされてもよい)。</p>
</div>
</li>
</ol>
<p>次に、可能ならば、<a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>や<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>によって2つの演算数がそれらの最小共通型に変換される。例えば、演算数が
<code>hatsize</code> 型 (<code>xs:integer</code> から導出される) と
<code>shoesize</code> 型 (<code>xs:float</code> から導出される)
であれば、それらの最小共通型は <code>xs:float</code> である。</p>
<p>
最後に、演算数の型が与えられた演算子について正しい組み合わせであれば、演算子が演算数に対して適用される。さまざまな値比較演算子について、認められる原子型の組み合わせや、その演算子の結果として期待される型は<a href="#mapping"><b>B.2
演算子の写像</b></a>にある。ここではまた<a title="operator function" href=
"#dt-operator-function">演算子関数</a>についても記述されている。これは、型の組み合わせそれぞれに対して演算子の意味を定義するものである。演算子関数の定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>にある。</p>
<p>
直観的には、2つの原子化済演算数がともにまったく1つの原子値からなっているならば、比較の結果は次のようになる。もし第1演算数の値が第2演算数の値
(に等しい, に等しくない, より小さい, より小さいか等しい, より大きい, より大きいか等しい)
ならば、結果は<code>true</code>である。それ以外の場合には、比較の結果は<code>false</code>である。</p>
<p>演算数を評価した後、その演算数の型が与えられた演算数について正しくない組み合わせであれば、<a href=
"#mapping"><b>B.2 演算子の写像</b></a>のルールに従って、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>以下に、値比較の例をいくつか示す。</p>
<ul>
<li>
<p>
次の比較は、式<code>$book/author</code>によって返される節点を原子化する。比較が真になるのは、原子化の結果が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての値
"Kennedy"
である場合だけである。原子化の結果が空列であれば、比較の結果は空列になる。原子化の結果が2個以上の値を含む列であれば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</li>
<li>
<p>次の<a title="path expression" href=
"#dt-path-expression">経路式</a>は、重さが100以上の製品を選択する述語を含む。<code>weight</code>部分要素を持たない製品については、この述語の値は空列であり、その製品は選択されない。この例では、<code>weight</code>
は検証された要素であり、数型であると仮定している。</p>
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</li>
<li>
<p>以下の比較は true
である。なぜなら、それぞれの場合で、構成された2つの節点は、異なる識別性や名前を持つが、原子化すると同じ値を持つからである:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;
</pre></div>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;
</pre></div>
</li>
<li>
<p>
次の比較が真になるのは、<code>my:hatsize</code>と<code>my:shoesize</code>がともに、原子型<a title="numeric"
href="#dt-numeric">numeric</a>から制限によって導出されるユーザ定義型である場合である。</p>
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</li>
<li>
<p>以下の比較は true である。<code>eq</code> は2つの QName について、それらの名前空間 URI
と局所名をコード位置により比較を行うことにより、比較する。名前空間接頭辞は無視する。</p>
<div class="exampleInner">
<pre>
fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-general-comparisons" id=
"id-general-comparisons"></a>3.5.2 汎用比較</h4>
<p>汎用比較演算子は<code>=</code>, <code>!=</code>, <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>である。汎用比較は存在限量比較であり、任意の長さの列の演算数に適用してもよい。汎用比較の結果は、エラーが発生しないときは常に<code>true</code>か<code>false</code>である。</p>
<p>汎用比較は以下のルールを順に適用することで評価される。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が各演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p>
</li>
<li>
<p>
比較の結果が<code>true</code>になるのは、原子値の組が存在し、その1つは第1演算数の列、もう一方が第2演算数の列であり、それらが要求された<b>大小関係</b>を持っているとき、かつその時に限る。それ以外の場合には、比較の結果は<code>false</code>になる。2つの原子値間の<b>大小関係</b>は、以下のルールを順に適用することで決定される。これらのルールによって呼び出される<code>cast</code>演算子が成功しなければ、動的エラーが発生する。
[err:FORG0001]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>これらのルールの目的は、XPath 1.0 との互換性を保つためである。XPath 1.0 では (例えば) <code>x
&lt;
17</code>は、<code>x</code>が型付けされていない値であれば、数比較である。ユーザは、値比較演算子では<code>xs:untypedAtomic</code>の演算数を型変換するためのルールが異なることに注意すべきである。</p>
</div>
<ol class="enumla">
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<a title="numeric"
href=
"#dt-numeric">数</a>型のインスタンスであれば、<code>xs:untypedAtomic</code>の値が<code>xs:double</code>型に型変換される。</p>
</li>
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:untypedAtomic</code>または<code>xs:string</code>のインスタんであれば、<code>xs:untypedAtomic</code>の値
(または両方) が<code>xs:string</code>型に型変換される。</p>
</li>
<li>
<p>
原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>,
<code>xs:untypedAtomic</code>, または任意の<a title="numeric" href=
"#dt-numeric">数</a>型のどれでもなければ、<code>xs:untypedAtomic</code>の値がもう一方の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>に型変換される。</p>
</li>
<li>
<p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>,
<code>lt</code>, <code>le</code>, <code>gt</code>,
<code>ge</code>のいずれかを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>,
<code>&gt;=</code>のどれであったかに依存する。値が、要求される<b>大小関係</b>を持つのは、この値比較の結果が<code>true</code>である場合、かつその時に限る。</p>
</li>
</ol>
</li>
</ol>
<p>
いずれかの演算数が項目の列である汎用比較を評価するとき、実装は、第1演算数と第2演算数から、要求される<b>大小関係</b>を持つ項目を1つずつ見つけると直ちに<code>true</code>を返してもよい。同様に、汎用比較は、いずれかの演算数を評価しているときや2つの演算数から選んだ項目の組を比較するときにエラーが生じれば、直ちに<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。これらのルールの結果として、エラーが存在するときには、汎用比較の結果は決定的ではない。</p>
<p>以下に、汎用比較の例をいくつか示す。</p>
<ul>
<li>
<p>
以下の比較は、<code>$book1</code>の任意の部分要素<code>author</code>について、その<a title="typed value"
href=
"#dt-typed-value">型付けされた値</a>が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての
"Kennedy" であるとき、trueになる。</p>
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</li>
<li>
<p>
以下の例は3つの汎用比較を含む。初めの2つの比較の値は<code>true</code>であり、3つ目の比較の値は<code>false</code>である。この例は、汎用比較は推移的ではないという事実を示している。</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>
以下の例は2つの汎用比較を含む。これらはいずれも<code>true</code>である。この例は、<code>=</code>と<code>!=</code>は互いに逆ではないという事実を示している。</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p><code>$a</code>, <code>$b</code>,
<code>$c</code>がそれぞれ、型注釈<code>xs:untypedAtomic</code>を持ち、<a title=
"string value" href="#dt-string-value">文字列値</a> "<code>1</code>",
"<code>2</code>"、および"<code>2.0</code>" を持つ要素節点に束縛されているとする。このとき
<code>($a, $b) = ($c,
3.0)</code>は<code>false</code>を返す。なぜなら<code>$b</code>と<code>$c</code>は文字列として比較されるためである。しかし<code>($a,
$b) = ($c,
2.0)</code>は<code>true</code>を返す。なぜなら<code>$b</code>と<code>2.0</code>は数として比較されるためである。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-node-comparisons" id=
"id-node-comparisons"></a>3.5.3 節点比較</h4>
<p>節点比較は、2つの節点を識別性または<a title="document order" href=
"#dt-document-order">文書順</a>に基づいて比較するのに用いられる。節点比較の結果は以下のルールにより定義される。</p>
<ol class="enumar">
<li>
<p>節点比較の演算数が<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順で評価される。</p>
</li>
<li>
<p>各演算数は単一の節点か空列でなければならない。そうでない場合は<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>
いずれかの演算数が空列であれば、比較の結果は空列であり、実装は他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p>
</li>
<li>
<p>
<code>is</code>演算子による比較が<code>true</code>を返すのは、2つの演算数が同じ識別性を持っており、したがって同じ節点である場合である。そうでない場合は<code>false</code>を返す。節点の識別性の定義は<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>を見よ。</p>
</li>
<li>
<p>
<code>&lt;&lt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<a title="document order"
href=
"#dt-document-order">文書順</a>で前にある場合である。そうでない場合は<code>false</code>を返す。</p>
</li>
<li>
<p>
<code>&gt;&gt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<a title="document order"
href=
"#dt-document-order">文書順</a>で後ろにある場合である。そうでない場合は<code>false</code>を返す。</p>
</li>
</ol>
<p>以下に、節点比較の例をいくつか示す。</p>
<ul>
<li>
<p>次の比較が真になるのは、左辺と右辺を評価した結果がそれぞれ完全に同じ単一節点になる場合のみである。</p>
<div class="exampleInner">
<pre>
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</pre></div>
</li>
<li>
<p>以下の比較は false である。なぜなら構成された節点はそれぞれ固有の識別性を持っているからである。</p>
<div class="exampleInner">
<pre>
&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;
</pre></div>
</li>
<li>
<p>
次の比較が真になるのは、左辺によって識別される節点が、右辺によって識別される節点よりも文書順で前に出現する場合のみである。</p>
<div class="exampleInner">
<pre>
/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>3.6 論理式</h3>
<p>
<b>論理式</b>は<b>and式</b>か<b>or式</b>のいずれかである。ある論理式がエラーを発生しない場合、結果は常にブール値<code>true</code>か<code>false</code>のいずれかである。</p>
<h5><a name="d2e9198" id="d2e9198"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrExpr" id=
"doc-xquery-OrExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-AndExpr">AndExpr</a> ( "or" <a href=
"#doc-xquery-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AndExpr" id=
"doc-xquery-AndExpr"></a>[47]&nbsp;&nbsp;&nbsp;</td>
<td><code>AndExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ComparisonExpr">ComparisonExpr</a> (
"and" <a href="#doc-xquery-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p>論理式の評価は、まず各演算数の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を見つけることから始まる (<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>を見よ)。</p>
<p>and式の値は、演算数の有効ブール値 (EBV) により、次の表のように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>EBV<sub>2</sub>でエラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>エラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><span class="xquery"><code>false</code>かエラー</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub>でエラー</td>
<td>エラー</td>
<td><span class="xquery"><code>false</code>かエラー</span></td>
<td>エラー</td>
</tr>
</tbody>
</table>
<p>or式の値は、演算数の有効ブール値 (EBV) により、次の表にあるように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>EBV<sub>2</sub>でエラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><span class="xquery"><code>true</code>かエラー</span></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>エラー</td>
</tr>
<tr>
<td>EBV<sub>1</sub>でエラー</td>
<td><span class="xquery"><code>true</code>かエラー</span></td>
<td>エラー</td>
<td>エラー</td>
</tr>
</tbody>
</table>
<p><span class="xquery">論理式の演算数が評価される順序は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。上の表では、次のように定義されている。</span>or-式は、1番目の式を評価するとtrueになれば、<code>true</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。同様に、and式は、1番目の式を評価するとfalseになれば、<code>false</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。これらのルールの結果として、論理式は、エラーが存在する場合、非決定的である。その例を以下に示す。</p>
<p>以下に、論理式の例をいくつか示す。</p>
<ul>
<li>
<p>次の式は<code>true</code>を返す。</p>
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</li>
<li>
<p>次の式は<code>false</code>を返すか<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。</p>
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>次の式は<code>true</code>を返すか<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。</p>
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</li>
<li>
<p>次の式は<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生しなければならない。</p>
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</li>
</ul>
<p>
and式、or式に加え、XQueryは<code>fn:not</code>という関数を用意している。これは引数として一般の列をとり、ブール値を返す。<code>fn:not</code>関数の定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。<code>fn:not</code>関数は、引数を<a title=
"effective boolean value" href=
"#dt-ebv">有効ブール値</a>に縮退する。そして、引数の有効ブール値が<code>false</code>であれば<code>true</code>を返し、引数の有効ブール値が<code>true</code>であれば<code>false</code>を返す。引数の有効ブール値を求める際にエラーが起これば、<code>fn:not</code>は同じエラーを発生する。</p>
</div>
<div class="div2">
<h3><a name="id-constructors" id="id-constructors"></a>3.7 構成子</h3>
<p>XQueryは、XMLの構造を問合せ中で生成できる構成子を用意している。
構成子は、要素節点、属性節点、文書節点、テキスト節点、コメント節点、処理命令節点に対して用意されている。2種類の構成子が用意されている:
<b>直接構成子</b>と<b>被計算構成子</b>である。前者はXMLに似た記法を用い、後者は囲まれた式に基づいた記法を用いる。</p>
<h5><a name="d2e9477" id="d2e9477"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Constructor" id=
"doc-xquery-Constructor"></a>[94]&nbsp;&nbsp;&nbsp;</td>
<td><code>Constructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#doc-xquery-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirectConstructor" id=
"doc-xquery-DirectConstructor"></a>[95]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirectConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#doc-xquery-DirCommentConstructor">DirCommentConstructor</a><br />
| <a href=
"#doc-xquery-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirElemConstructor" id=
"doc-xquery-DirElemConstructor"></a>[96]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirElemConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;" <a href="#prod-xquery-QName">QName</a> <a href=
"#doc-xquery-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#doc-xquery-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-S">S</a>? "&gt;"))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirElemContent" id=
"doc-xquery-DirElemContent"></a>[101]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirElemContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-DirectConstructor">DirectConstructor</a><br />
| <a href="#doc-xquery-CDataSection">CDataSection</a><br />
| <a href="#doc-xquery-CommonContent">CommonContent</a><br />
| <a href=
"#doc-xquery-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ElementContentChar" id=
"doc-xquery-ElementContentChar"></a>[148]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
[{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CommonContent" id=
"doc-xquery-CommonContent"></a>[102]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommonContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery-CharRef">CharRef</a> | "{{" | "}}" | <a href=
"#doc-xquery-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CDataSection" id=
"doc-xquery-CDataSection"></a>[107]&nbsp;&nbsp;&nbsp;</td>
<td><code>CDataSection</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;![CDATA[" <a href=
"#doc-xquery-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CDataSectionContents" id=
"doc-xquery-CDataSectionContents"></a>[108]&nbsp;&nbsp;&nbsp;</td>
<td><code>CDataSectionContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* ']]&gt;'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirAttributeList" id=
"doc-xquery-DirAttributeList"></a>[97]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirAttributeList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-S">S</a> (<a href=
"#prod-xquery-QName">QName</a> <a href="#prod-xquery-S">S</a>? "="
<a href="#prod-xquery-S">S</a>? <a href=
"#doc-xquery-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirAttributeValue" id=
"doc-xquery-DirAttributeValue"></a>[98]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirAttributeValue</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href="#doc-xquery-EscapeQuot">EscapeQuot</a> |
<a href=
"#doc-xquery-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#doc-xquery-EscapeApos">EscapeApos</a> | <a href=
"#doc-xquery-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-QuotAttrValueContent" id=
"doc-xquery-QuotAttrValueContent"></a>[99]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuotAttrValueContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href="#doc-xquery-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AposAttrValueContent" id=
"doc-xquery-AposAttrValueContent"></a>[100]&nbsp;&nbsp;&nbsp;</td>
<td><code>AposAttrValueContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href="#doc-xquery-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-QuotAttrContentChar" id=
"doc-xquery-QuotAttrContentChar"></a>[149]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuotAttrContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
["{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-AposAttrContentChar" id=
"doc-xquery-AposAttrContentChar"></a>[150]&nbsp;&nbsp;&nbsp;</td>
<td><code>AposAttrContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
['{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-EscapeQuot" id=
"doc-xquery-EscapeQuot"></a>[146]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeQuot</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-EscapeApos" id=
"doc-xquery-EscapeApos"></a>[147]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeApos</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-EnclosedExpr" id=
"doc-xquery-EnclosedExpr"></a>[29]&nbsp;&nbsp;&nbsp;</td>
<td><code>EnclosedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"{" <a href="#doc-xquery-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
</table>
<p>この節は、さまざまな種類の構成子式の意味についての概念的説明を含む。XQuery
の実装は、この節で述べた処理ステップと同じ結果を生成する任意の実装技術を自由に用いてよい。</p>
<div class="div3">
<h4><a name="id-element-constructor" id=
"id-element-constructor"></a>3.7.1 直接要素構成子</h4>
<p><b>要素構成子</b>は要素節点を生成する。 [<a name="dt-direct-elem-const" id=
"dt-direct-elem-const" title=
"direct element constructor">Definition</a>:
<b>直接要素構成子</b>は、構成される要素の名前が定数であるような要素構成子の形式である。]
直接要素構成子は標準的なXMLの記法に基づいている。例えば、以下の式は直接要素構成子であり、属性一つおよび入れ子になった要素をいくつか含む<code>book</code>要素を生成する。</p>
<div class="exampleInner">
<pre>
&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</pre></div>
<p>直接要素構成子中の要素名が名前空間接頭辞を持っていれば、その名前空間接頭辞は<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて名前空間URIに解決される。もし要素名が名前空間接頭辞を持たないならば、<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>により暗黙的に修飾される。静的既知名前空間もデフォルト要素/型名前空間も、<a title="namespace declaration attribute"
href=
"#dt-namespace-decl-attr">名前空間定義属性</a>から影響を受けてもよいことに注意すること。要素名の名前空間接頭辞は、QNameを展開した後も保持される。これについては<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>に記述されている通りである。結果として得られる<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>が、構成された要素節点の<code>node-name</code>性質になる。</p>
<p>
直接要素構成子では、終了タグ中で用いられる名前は、対応する開始タグ中で用いられる名前と、接頭辞や接頭辞のあるなしを含めて、完全に一致しなければならない。</p>
<p>直接要素構成子では、波括弧 { }
は<b>囲まれた式</b>を区切り、リテラルテキストから区別する。囲まれた式は、評価された後その値と置き換えられる。以下の例の通りである:</p>
<div class="exampleInner">
<pre>
&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;
</pre></div>
<p>上の問合せは、次のような結果を生成するかもしれない
(読みやすくするために、この結果には空白を加えている。この文書中の他の例でも同様である):</p>
<div class="exampleInner">
<pre>
&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;
</pre></div>
<p>XQuery
では囲まれた式を表すのに波括弧を用いるため、通常の文字として用いられる波括弧を表すにはある種の約束が必要である。この目的のため、要素や属性の内容中に現れる二重の波括弧は、XQuery
では一重の波括弧として解釈される。 (すなわち、組 "<code>{{</code>" は文字 "<code>{</code>"
を、組 "<code>}}</code>" は文字 "<code>}</code>"を表す。) 代替案として<a title=
"character reference" href="#dt-character-reference">文字参照</a>
<code>&amp;#x7b;</code>と<code>&amp;#x7d;</code>も波括弧文字を表すのに用いることができる。一重の左波括弧
("<code>{</code>") は、囲まれた式の開始区切り記号と解釈される。一重の右波括弧 ("<code>}</code>")
は、左波括弧と対応しない場合<a title="static error" href=
"#dt-static-error">静的エラー</a> [<a title="err:XPST0003" href=
"#ERRXPST0003">err:XPST0003</a>]として扱われる。</p>
<p>
要素構成子の結果は新しい要素節点であり、固有の節点識別性を持つ。新たな要素節点の属性や子孫節点もまた新たな節点であり、固有の識別性を持つ。すでに存在する節点の複製であっても、このようになる。</p>
<div class="div4">
<h5><a name="id-attributes" id="id-attributes"></a>3.7.1.1 属性</h5>
<p>
直接要素構成子の開始タグには1つ以上の属性が含まれていてもよい。XMLと同様に、属性はそれぞれ名前と値によって指定される。直接要素構成子では、各属性の名前は定数のQNameで指定され、属性の値は一重引用符または二重引用符で囲まれた文字列によって指定される。要素構成子の主内容と同様に、属性の値には波括弧で囲まれた式が含まれていもよい。これは要素構成子の処理において、評価された後、その値によって置き換えられる。</p>
<p>
直接要素構成子中の各属性は新たな属性節点を生成する。生成された節点は固有の節点識別性を持ち、その親は構成された要素節点である。しかし、<a title="namespace declaration attribute"
href="#dt-namespace-decl-attr">名前空間宣言属性</a> (<a href=
"#id-namespaces"><b>3.7.1.2 名前空間宣言属性</b></a>を見よ)
は属性節点を生成しないことに注意せよ。</p>
<p>属性名が名前空間接頭辞を持つならば、その接頭辞は、<a title="statically known namespaces"
href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて名前空間URIに解決される。属性名が名前空間接頭辞を持たないならば、その属性はどの名前空間にも属さない。属性名を解決するのに用いられる静的既知名前空間は、その要素構成子中にある<a title="namespace declaration attribute"
href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>から影響を受けてもよいことに注意せよ。属性名の名前空間接頭辞は、QNameを展開した後も保持される。これについては<a href="#datamodel">[XQuery/XPath
Data Model (XDM)]</a>に記述されている通りである。結果として得られる<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>は、構成された属性節点の<code>node-name</code>性質となる。</p>
<p>直接要素構成子中の属性が、それぞれの<code>node-name</code>性質として、互いに区別される<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>を持たないならば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0040"
href="#ERRXQST0040">err:XQST0040</a>]。</p>
<p>概念的には、直接要素構成子中の属性 (名前空間宣言属性を除く) は以下のステップによって処理される。</p>
<ol class="enumar">
<li>
<p>
属性の内容中のリテラル文字の連続列それぞれが、それらの文字を含む文字列として扱われる。次に属性値の正規化が適用され、空白の正規化、および<a title="character reference"
href="#dt-character-reference">文字参照</a>や<a title=
"predefined entity reference" href=
"#dt-predefined-entity-reference">定義済実体参照</a>の展開が行われる。XML 1.0 を支援する
XQuery 処理器は、<a href="#XML">[XML 1.0]</a>の
3.3.3節にある属性値の正規化のルールを用いる。XML 1.1 を支援する XQuery 処理器は、<a href=
"#XML1.1">[XML 1.1]</a>の 3.3.3
節にある属性値の正規化のルールを用いる。いずれの場合も、正規化ルールは、その属性の型が CDATA
(先頭及び末尾の空白文字は取り除かれない。) であるかのように適用される。XML 1.0 のルールと XML 1.1
のルールのどちらを選択するかは<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。</p>
</li>
<li>
<p>以下のように、囲まれた式がそれぞれ文字列に変換される:</p>
<ol class="enumla">
<li>
<p>囲まれた式の値に対して<a title="atomization" href=
"#dt-atomization">原子化</a>が適用され、原子値列に変換される。</p>
</li>
<li>
<p>
原子化の結果が空列であれば、結果は長さ0の文字列である。そうでない場合、原子化された列中の原子値がそれぞれ文字列に型変換される。</p>
</li>
<li>
<p>前のステップから結果として得られる個々の文字列が、間に1つの空白文字を置きながら連接され、1つの文字列にまとめられる。</p>
</li>
</ol>
</li>
<li>
<p>
前のステップの結果得られる隣接する文字列が、間に空白を挟まずに連接される。結果の文字列は、属性節点の<code>string-value</code>性質となる。属性節点には<a title="type annotation"
href="#dt-type-annotation">型注釈</a> (<code>type-name</code>性質)
<code>xs:untypedAtomic</code> が与えられる
(この型注釈は、親要素が妥当性検証されれば変更されてもよい)。属性節点の<code>typed-value</code>性質は<code>string-value</code>と同じであり、<code>xs:untypedAtomic</code>のインスタンスである。</p>
</li>
<li>
<p>
属性節点の<code>parent</code>性質は、この属性を含み、直接要素構成子によって構成された要素節点に設定される。</p>
</li>
<li>
<p>
属性名が<code>xml:id</code>であるならば、その属性の文字列値と型付けされた値はさらに正規化される。すなわち、先頭と末尾の空白文字
(#x20) が削除され、空白文字 (#x20) の列が単一の空白文字 (#x20) に置き換えられる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>このステップで、<a href="#XMLID">[XML
ID]</a>で定義されている<code>xml:id</code>の処理が完結する。</p>
</div>
</li>
<li>
<p>
属性名が<code>xml:id</code>であるならば、結果として得られる属性節点の<code>is-id</code>性質が<code>true</code>に設定される。そうでない場合は、<code>is-id</code>性質は<code>false</code>に設定される。属性節点の<code>is-idrefs</code>性質は無条件に<code>false</code>に設定される。</p>
</li>
</ol>
<ul>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="7"/&gt;
</pre></div>
<p><code>size</code>属性の文字列値は "<code>7</code>" である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="{7}"/&gt;
</pre></div>
<p><code>size</code>属性の文字列値は "<code>7</code>" である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="{()}"/&gt;
</pre></div>
<p><code>size</code>属性の文字列値は長さ0の文字列である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;
</pre></div>
<p><code>ref</code>属性の文字列値は "<code>[1 5 6 7 9]</code>" である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;shoe size="As big as {$hat/@size}"/&gt;
</pre></div>
<p><code>size</code>属性の文字列値は "<code>As big as</code> "
と式<code>$hat/@size</code>で表される節点の文字列値を連接したものになる。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-namespaces" id="id-namespaces"></a>3.7.1.2
名前空間宣言属性</h5>
<p>構成された要素やその属性の名前は<b>名前空間接頭辞</b>を含む <a title="QName" href=
"#dt-qname">QNames</a> であってもよい。名前空間接頭辞は <a title="Prolog" href=
"#dt-prolog">前書き</a>
や<b>名前空間宣言属性</b>によって名前空間に束縛することができる。名前空間に束縛されていない名前空間接頭辞を用いると、<a title="static error"
href="#dt-static-error">静的エラー</a>である [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]。</p>
<p>[<a name="dt-namespace-decl-attr" id="dt-namespace-decl-attr"
title="namespace declaration attribute">Definition</a>:
<b>名前空間宣言属性</b>は、直接要素構成子の内部で用いられる。その目的は、構成された要素節点やその属性に対して、名前空間接頭辞を束縛したり、<a title="default element/type namespace"
href="#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を設定することである。]
構文的には、名前空間宣言属性は、名前空間接頭辞<code>xmlns</code>を持つ属性の形式をしているか、もしくは名前が<code>xmlns</code>で名前空間接頭辞を持たない属性の形式をしている。名前空間宣言属性の値は<a href="#doc-xquery-URILiteral">URILiteral</a>でなければならない。そうでない場合は<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0022"
href=
"#ERRXQST0022">err:XQST0022</a>]。与えられた要素の名前空間宣言属性はすべて、互いに区別される名前を持たなければならない
[<a title="err:XQST0071" href=
"#ERRXQST0071">err:XQST0071</a>]。それぞれの名前空間宣言属性は次のように処理される:</p>
<ul>
<li>
<p>
属性名の局所部分は名前空間宣言として解釈される。また、その属性の値は名前空間URIとして解釈される。この接頭辞とURIが構成子式の<a title="statically known namespaces"
href="#dt-static-namespaces">静的既知名前空間</a>に追加される
(与えられた接頭辞の束縛が存在する場合はそれを上書きする) 。また、構成された要素の<a title=
"in-scope namespaces" href=
"#dt-in-scope-namespaces">有効範囲内名前空間</a>にも名前空間束縛として追加される。名前空間URIが長さ0の文字列であり、実装が<a href="#XMLNAMES11">[XML
Names 1.1]</a>を支援しているならば、与えられた接頭辞に対する名前空間束縛が、構成された要素の<a title=
"in-scope namespaces" href=
"#dt-in-scope-namespaces">有効範囲内名前空間</a>、および構成子式の<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>から削除される。もし名前空間URIが長さ0の文字列で、実装が<a href="#XMLNAMES11">[XML
Names 1.1]</a>を支援しないならば、静的エラーが発生する [<a title="err:XQST0085" href=
"#ERRXQST0085">err:XQST0085</a>]。実装が<a href="#XMLNAMES">[XML
Names]</a>か<a href="#XMLNAMES11">[XML Names
1.1]</a>のいずれを支援するかは、<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。</p>
</li>
<li>
<p>
名前空間宣言属性の名前が<code>xmlns</code>で接頭辞を持たないならば、その属性の値が名前空間URIとして解釈される。このURIは、構成子式の<a title="default element/type namespace"
href="#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を指定する
(すでにデフォルトが存在する場合は上書きする)。また、構成された要素の<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">有効範囲内名前空間</a>にも(接頭辞なしで)加えられる
(接頭辞なしの名前空間束縛が存在するなら、それを上書きする)。もし名前空間URIが長さ0の文字列であれば、構成子式の<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>が "none"
に設定され、接頭辞なしの名前空間束縛が、構成された要素の<a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">有効範囲内名前空間</a>から削除される。</p>
</li>
<li>
<p>名前空間宣言属性が名前空間URIを既定義接頭辞 <code>xml</code> または <code>xmlns</code>
に束縛したり、<code>xml</code> 以外の接頭辞を名前空間URI
<code>http://www.w3.org/XML/1998/namespace</code> に束縛すると、<a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]。</p>
</li>
</ul>
<p>名前空間宣言属性は、生成される属性節点には影響を与えない。</p>
<p>以下に、名前空間宣言属性の例を示す:</p>
<ul>
<li>
<p>この要素構成子では、名前空間宣言属性を用いて<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を<code>http://example.org/animals</code>に設定している:</p>
<div class="exampleInner">
<pre>
&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;
</pre></div>
</li>
<li>
<p>この要素構成子では、名前空間宣言属性を用いて、名前空間接頭辞 <code>metric</code> と
<code>english</code> を束縛している:</p>
<div class="exampleInner">
<pre>
&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-content" id="id-content"></a>3.7.1.3 内容</h5>
<p>直接要素構成子のうち、開始タグと終了タグの間の部分を、その要素構成子の<b>内容</b>という。この内容は、テキスト文字
(<a href=
"#doc-xquery-ElementContentChar">ElementContentChar</a>と構文解析される),
入れ子になった直接構成子, <a href="#doc-xquery-CDataSection">CdataSections</a>,
文字参照および<a title="predefined entity reference" href=
"#dt-predefined-entity-reference">既定義実体参照</a>,
波括弧で囲まれた式から構成されてもよい。一般に、囲まれた式の値は節点や原子値の列であってもよい。囲まれた式は要素構成子の内容の中で用いることができ、構成された節点の内容や属性を計算するのに用いられる。</p>
<p>概念的には、要素構成子の内容は次のように処理される:</p>
<ol class="enumar">
<li>
<p>内容が評価され、節点列が以下のように生成される。この列を<b>内容列</b>という:</p>
<ol class="enumla">
<li>
<p>もし<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="boundary-space policy"
href=
"#dt-boundary-space-policy">境界空白ポリシー</a>が<code>strip</code>であれば、<a title="boundary whitespace"
href="#dt-boundary-whitespace">境界空白</a>が識別され、削除される
(境界空白の定義は<a href="#id-whitespace"><b>3.7.1.4 境界空白</b></a>を見よ)。</p>
</li>
<li>
<p><a title="predefined entity reference" href=
"#dt-predefined-entity-reference">既定義実体参照</a>と<a title=
"character reference" href=
"#dt-character-reference">文字参照</a>は、参照している文字列に展開される。これについては<a href=
"#id-literals"><b>3.1.1 リテラル</b></a>に記述されている通りである。<a href=
"#doc-xquery-CDataSection">CDataSection</a>内部の文字は、<code>&lt;</code>
や <code>&amp;</code> のような特殊文字も含め、マークアップ文字ではなくリテラル文字として扱われる (列
<code>]]&gt;</code> を除く。これは CDataSection を終了する)。</p>
</li>
<li>
<p>リテラル文字の連続列は、それらの文字を含む単一のテキスト節点として評価される。</p>
</li>
<li>
<p>入れ子の直接構成子はそれぞれ、<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>あるいは<a href="#id-otherConstructors"><b>3.7.2
その他の直接構成子</b></a>のルールに従って評価され、その結果は新たな要素節点、コメント節点、処理命令節点いずれか1つになる。次に、結果として得られる節点の
<code>parent</code> 性質が、新たに構成された要素節点に設定される。</p>
</li>
<li>
<p>囲まれた式は以下のように評価される:</p>
<ol class="enumlr">
<li>
<p>
囲まれた式によって返される1個以上の原子値からなる隣接列それぞれに対して、新たなテキスト節点が構成される。これには、それぞれの原子値を文字列に型変換した結果が含まれるが、隣接した値の間には1つの空白文字が挟まれる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>隣接した値の間への空白文字の挿入は、一方、もしくは両方の値が長さ0の文字列であっても適用される。</p>
</div>
</li>
<li>
<p>
囲まれた式によって返される節点それぞれに対して、与えられた節点、およびその節点を先祖として持つすべての節点の複製が新たに作られる。これらをまとめて<b>複製された節点</b>と呼ぶ。複製された節点の性質は以下のようになる:</p>
<ol class="enumua">
<li>
<p>複製された節点はそれぞれ新しい節点識別性を獲得する。</p>
</li>
<li>
<p>複製された節点の<code>parent</code>性質, <code>children</code>性質,
<code>attributes</code>性質は、節点間の関連を保存するように設定される。最上位の節点
(囲まれた式によって直接返される節点) に対して、<code>parent</code>
性質は、この構成子によって構成された節点に設定される。</p>
</li>
<li>
<p>もし<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="construction mode" href=
"#dt-construction-mode">構成モード</a>が<code>strip</code>であれば:</p>
<ol class="enumur">
<li>
<p>複製された節点が要素節点であれば、<code>type-name</code> 性質は
<code>xs:untyped</code> に設定される。<code>nilled</code>性質,
<code>is-id</code>性質, <code>is-idrefs</code>
性質は<code>false</code>に設定される。</p>
</li>
<li>
<p>複製された節点が属性節点であれば、<code>type-name</code> 性質は
<code>xs:untypedAtomic</code> に設定される。<code>is-idrefs</code> 性質は
<code>false</code> に設定される。<code>is-id</code> 性質は、その属性節点の修飾名が
<code>xml:id</code> であれば、<code>true</code> に設定され、そうでなければ
<code>false</code> に設定される。</p>
</li>
<li>
<p>複製された要素節点や属性節点それぞれについて、<code>string-value</code> はそのまま変更されない。また
<code>typed-value</code> は <code>xs:untypedAtomic</code>
のインスタンスとしての <code>string-value</code> に等しい。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>節点の<a title="typed value" href=
"#dt-typed-value">型付けされた値</a>のみを保存している実装では、この段階で型付けされた値を文字列形式に変換することが求められる。</p>
</div>
</li>
</ol>
<p>一方、もし<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="construction mode" href=
"#dt-construction-mode">構成モード</a>が<code>preserve</code>であれば、複製された節点の<code>type-name</code>,
<code>nilled</code>, <code>string-value</code>,
<code>typed-value</code>, <code>is-id</code>,
<code>is-idrefs</code> の各性質は保存される。</p>
</li>
<li>
<p>複製された要素節点の<code>in-scope-namespaces</code>
性質は以下のルールによって決定される。これらのルールを適用するとき、デフォルト名前空間や、デフォルト名前空間の欠如はほかの名前空間束縛と同様に扱われる:</p>
<ol class="enumur">
<li>
<p>もし<a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">名前空間複製モード</a> が
<code>preserve</code>と指定されていれば、元の要素の有効範囲内名前空間がすべて新しい複製中に保持される。もし<a title="copy-namespaces mode"
href="#dt-copy-namespaces-mode">名前空間複製モード</a> が
<code>no-preserve</code>と指定されていれば、新しい複製は、元の要素の有効範囲内名前空間のうち、その要素名や属性に用いられているものしか保持しない。この場合、もし複製された要素や任意の属性の<a title="typed value"
href="#dt-typed-value">型付けされた値</a>が<a title="namespace-sensitive"
href="#dt-namespace-sensitive">名前空間に対して敏感</a>であれば、<a title=
"type error" href="#dt-type-error">型エラー</a> [<a title=
"err:XQTY0086" href="#ERRXQTY0086">err:XQTY0086</a>] である。[<a name=
"dt-namespace-sensitive" id="dt-namespace-sensitive" title=
"namespace-sensitive">Definition</a>:
値が<b>名前空間に対して敏感</b>であるとは、その値に、<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が<code>xs:QName</code>または<code>xs:NOTATION</code>、または制限によって<code>xs:QName</code>か<code>xs:NOTATION</code>から導出されるかのいずれかであるような項目が含まれていることである。]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>エラー [<a title="err:XQTY0086" href=
"#ERRXQTY0086">err:XQTY0086</a>] の発生する可能性があるのは、<a title=
"construction mode" href=
"#dt-construction-mode">構成モード</a>が<code>preserve</code>の場合のみである。なぜならば、そうでない場合、複製された節点の型付けされた値は決して名前空間に対して敏感ではないからである。</p>
</div>
</li>
<li>
<p>もし<a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">名前空間複製モード</a> が
<code>inherit</code>と指定されていれば、複製された節点は構成された節点の有効範囲内名前空間をすべて継承し、元の要素の有効範囲内名前空間のうち先のルールで保存されたものによって、その拡張や上書きを行う。もし<a title="copy-namespaces mode"
href="#dt-copy-namespaces-mode">名前空間複製モード</a> が
<code>no-inherit</code>と指定されていれば、複製された節点は構成された節点からどの有効範囲内名前空間も継承しない。</p>
</li>
</ol>
</li>
<li>
<p>
要素または処理命令節点が複製されたとき、その<code>base-uri</code>性質は、新しい親節点と同じに設定される。ただし、以下の例外がある:
複製された要素節点が<code>xml:base</code>属性を持っていれば、その節点の<code>base-uri</code>性質は、その属性の値に設定される。このとき、この値は(もし相対値であれば)、新しい親節点の<code>base-uri</code>性質によって解決される。</p>
</li>
<li>
<p>複製された節点のその他の性質はすべて保存される。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>
内容列中の隣接したテキスト節点は、それらの内容を連接することによって、1つのテキスト節点に併合される。このとき、間に空白は挟まれない。連接の後、内容が長さ0の文字列であるテキスト節点は、内容列から取り除かれる。</p>
</li>
<li>
<p>内容列が文書節点を含むならば、その文書節点は、その子からなる内容列に置き換えられる。</p>
</li>
<li>
<p>内容列に含まれる属性節点について、それが属性節点でない節点の後ろに来るならば、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XQTY0024" href=
"#ERRXQTY0024">err:XQTY0024</a>]。</p>
</li>
<li>
<p>新しく構成された要素節点の性質は以下のように決定される:</p>
<ol class="enumla">
<li>
<p><code>node-name</code>は、開始タグ中の要素名を解決した結果として得られる<a title=
"expanded QName" href=
"#dt-expanded-qname">展開済QName</a>であり、元の名前空間接頭辞を (もしあるなら)
含む。これについては、<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>に記述されている通りである。</p>
</li>
<li>
<p><code>base-uri</code>は以下のソースのうち存在するものの最初から取ってこられる:</p>
<ol class="enumlr">
<li>
<p>構成された節点の <code>xml:base</code>属性の値。ただしこの属性が存在する場合;</p>
</li>
<li>
<p><a title="base URI" href="#dt-base-uri">静的文脈</a>中の<a title=
"base URI" href="#dt-base-uri">基礎URI</a></p>
</li>
</ol>
</li>
<li>
<p><code>parent</code>は空に設定される。</p>
</li>
<li>
<p><code>attributes</code>は、<a href="#id-attributes"><b>3.7.1.1
属性</b></a>に記述されている通り、開始タグ中に指定されるすべての属性と、内容列中のすべての属性節点からなる。その順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>である。これらのうち2つ以上の属性が同じ<code>node-name</code>を持っていれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0025"
href=
"#ERRXQDY0025">err:XQDY0025</a>]。これらの属性節点それぞれの<code>parent</code>性質は、新しく構成された要素節点に設定されていることに注意せよ。</p>
</li>
<li>
<p>
<code>children</code>は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点それぞれの<code>parent</code>性質は、新しく構成された要素節点に設定されていることに注意せよ。</p>
</li>
<li>
<p><code>in-scope-namespaces</code>は、<a href=
"#id-namespaces"><b>3.7.1.2
名前空間宣言属性</b></a>に記述されているように名前空間宣言属性から得られる名前空間束縛すべて、および<a href=
"#id-ns-nodes-on-elements"><b>3.7.4
構成された要素の有効範囲内名前空間</b></a>に記述されているように追加される可能性のある名前空間束縛からなる。</p>
</li>
<li>
<p><code>nilled</code> 性質は <code>false</code>である。</p>
</li>
<li>
<p><code>string-value</code>
性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。もし子孫にテキスト節点がなければ、<code>string-value</code>
性質は長さ0の文字列である。</p>
</li>
<li>
<p><code>typed-value</code> 性質は<code>xs:untypedAtomic</code>
のインスタンスとしての <code>string-value</code> 性質に等しい。</p>
</li>
<li>
<p>もし<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="construction mode" href=
"#dt-construction-mode">構成モード</a>が<code>strip</code>であれば、<code>type-name</code>
性質は
<code>xs:untyped</code>である。一方、構成モードが<code>preserve</code>であれば、<code>type-name</code>
性質は <code>xs:anyType</code>である。</p>
</li>
<li>
<p>
<code>is-id</code>性質と<code>is-idrefs</code>性質は<code>false</code>に設定される。</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{1}&lt;/a&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>1</code>" を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{1, 2, 3}&lt;/a&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>1 2 3</code>" を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;c&gt;{1}{2}{3}&lt;/c&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>123</code>" を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;b&gt;{1, "2", "3"}&lt;/b&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>1 2 3</code>" を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>I saw 8 cats.</code>"
を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;
</pre></div>
<p>構成された要素節点は子を1つ持っている。値 "<code>I saw 8 cats.</code>"
を含むテキスト節点である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;
</pre></div>
<p>構成された要素節点は子を3つ持っている: "<code>I saw</code> "
を含むテキスト節点、<code>howmany</code>と名付けられた子要素節点、それに "
<code>cats.</code>" を含むテキスト節点である。子要素節点はさらに、値 "<code>8</code>"
を含むテキスト節点を子として持つ。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-whitespace" id="id-whitespace"></a>3.7.1.4
境界空白</h5>
<p>
直接要素構成子では、構成される要素の内容中に空白文字が出現してもよい。場合によっては、囲まれる式や入れ子要素が空白文字によって飲み区切られてもよい。例えば、以下の式で、終了タグ
<code>&lt;/title&gt;</code> と開始タグ <code>&lt;author&gt;</code>
は改行文字1つとスペース文字4つで区切られている:</p>
<div class="exampleInner">
<pre>
&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</pre></div>
<p>[<a name="dt-boundary-whitespace" id="dt-boundary-whitespace"
title="boundary whitespace">Definition</a>: <b>境界空白</b>は<a title=
"direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>の文脈に現れる連続した空白文字の列であり、内容の始まりや終わり、<a href="#doc-xquery-DirectConstructor">DirectConstructor</a>、<a href="#doc-xquery-EnclosedExpr">EnclosedExpr</a>のいずれかによって両端を区切られている。この目的のために、<code>&amp;#x20;</code>といった<a title="character reference"
href="#dt-character-reference">文字参照</a>、あるいは<a href=
"#doc-xquery-CDataSection">CdataSections</a>によって生成される文字は空白文字とはみなされない。]</p>
<p><a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="boundary-space policy"
href=
"#dt-boundary-space-policy">空白境界ポリシー</a>は、境界空白が要素構成子によって保存されるかどうかを制御する。境界空白ポリシーが<code>strip</code>であれば、境界空白は重要だとは見なされず、捨てられる。一方、境界空白ポリシーが<code>preserve</code>であれば、境界空白は重要だと見なされ、保存される。</p>
<ul>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;cat&gt; 
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt; 
&lt;/cat&gt;
</pre></div>
<p>
構成された<code>cat</code>要素節点は、2つの子要素節点<code>breed</code>と<code>color</code>を持つ。境界空白ポリシーが<code>strip</code>であれば、子要素を囲む空白は要素構成子によってはぎ取られる。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;  {"abc"}  &lt;/a&gt;
</pre></div>
<p>
境界空白ポリシーが<code>strip</code>であれば、この例は<code>&lt;a&gt;abc&lt;/a&gt;</code>と等価である。しかし、境界空白ポリシーが<code>preserve</code>であれば、この例は<code>&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</code>と等価である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt; z {"abc"}&lt;/a&gt;
</pre></div>
<p>
<code>z</code>を取り囲む空白は境界空白ではないので、常に保存される。この例は<code>&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</code>と等価である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;
</pre></div>
<p>
この例は、境界空白ポリシーに関わらず<code>&lt;a&gt;&nbsp;abc&lt;/a&gt;</code>と等価である。なぜなら、<a title="character reference"
href=
"#dt-character-reference">文字参照</a>によって生成されるスペースは空白文字とは扱われないからである。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
&lt;a&gt;{"  "}&lt;/a&gt;
</pre></div>
<p>
この例は、境界空白ポリシーに関わらず、2つのスペース文字を含む要素を構成する。なぜならば、囲まれた式の内部の空白は決して境界空白とは見なされないからである。</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
要素構成子は、<code>xml:space</code>と名付けられた属性を通常の属性として扱う。<code>xml:space</code>属性は、要素構成子による空白処理に影響を与えない。</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="id-otherConstructors" id=
"id-otherConstructors"></a>3.7.2 その他の直接構成子</h4>
<p>
XQueryは、処理命令節点やコメント節点を生成する式を認めている。これらは<b>直接処理命令構成子</b>や<b>直接コメント構成子</b>を用いることで実現される。それぞれの場合について、構成子式の構文は、XMLの同じ構成要素の構文を基にしている。</p>
<h5><a name="d2e10797" id="d2e10797"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirPIConstructor" id=
"doc-xquery-DirPIConstructor"></a>[105]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirPIConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;?" <a href="#prod-xquery-PITarget">PITarget</a>
(<a href="#prod-xquery-S">S</a> <a href=
"#doc-xquery-DirPIContents">DirPIContents</a>)? "?&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirPIContents" id=
"doc-xquery-DirPIContents"></a>[106]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirPIContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirCommentConstructor" id=
"doc-xquery-DirCommentConstructor"></a>[103]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirCommentConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;!--" <a href=
"#doc-xquery-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DirCommentContents" id=
"doc-xquery-DirCommentContents"></a>[104]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirCommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>((<a href="#prod-xquery-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery-Char">Char</a> - '-')))*</code></td>
</tr>
</tbody>
</table>
<p>直接処理命令構成子は、<code>target</code>性質が<a href=
"#prod-xquery-PITarget">PITarget</a>で<code>content</code>性質が<a href="#doc-xquery-DirPIContents">DirPIContents</a>であるような処理命令節点を生成する。この節点の<code>base-uri</code>
性質は空である。この節点の<code>parent</code>性質は空である。</p>
<p>処理命令の<a href=
"#prod-xquery-PITarget">PITarget</a>には、大文字小文字の組み合わせ方の如何に関わらず、"XML"
という文字が含まれてはならない。処理命令の<a href=
"#doc-xquery-DirPIContents">DirPIContents</a>には、文字列
"<code>?&gt;</code>" が含まれてはならない。</p>
<p>以下は、直接処理命令構成子の例である:</p>
<div class="exampleInner">
<pre>
&lt;?format role="output" ?&gt;
</pre></div>
<p>直接コメント構成子は、<code>content</code>性質が<a href=
"#doc-xquery-DirCommentContents">DirCommentContents</a>であるようなコメント節点を生成する。この節点の<code>parent</code>性質は空である。</p>
<p>コメントの<a href=
"#doc-xquery-DirCommentContents">DirCommentContents</a>には、2つの連続したハイフンが含まれてはならず、またハイフンで終わってはならない。これらのルールは、上に示した文法によって構文的に強要されている。</p>
<p>以下は、直接コメント構成子の例である:</p>
<div class="exampleInner">
<pre>
&lt;!-- Tags are ignored in the following section --&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>直接コメント構成子は<a href=
"#doc-xquery-Comment">comment</a>とは異なる。なぜなら直接コメント構成子は実際にコメント節点を構成するが、一方<a href="#doc-xquery-Comment">comment</a>は単に問合せを文書化するときに用いられるだけで、評価されないからである。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-computedConstructors" id=
"id-computedConstructors"></a>3.7.3 被計算構成子</h4>
<h5><a name="d2e10908" id="d2e10908"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ComputedConstructor" id=
"doc-xquery-ComputedConstructor"></a>[109]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComputedConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#doc-xquery-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#doc-xquery-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#doc-xquery-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#doc-xquery-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#doc-xquery-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
</table>
<p>
節点を生成するもう一つの方法は<b>被計算構成子</b>を用いる、というものである。被計算構成子は、生成される節点の型を識別する以下のようなキーワードから始まる:
<code>element</code>, <code>attribute</code>,
<code>document</code>, <code>text</code>,
<code>processing-instruction</code>, または<code>comment</code>。</p>
<p>名前を持つ節点の種類 (要素節点、属性節点、処理命令節点)
に対して、節点の種類を表すキーワードの次に、生成される節点の名前が続く。この名前は QName
として指定されるか、括弧で囲まれた式として指定されるかのいずれであってもよい。[<a name=
"dt-name-expression" id="dt-name-expression" title=
"name expression">Definition</a>:
ある式が、構成された節点の名前を指定するのに用いられるとき、その式は、その構成子の<b>名前式</b>と呼ばれる。]</p>
<p>[<a name="dt-content-expression" id="dt-content-expression"
title="content expression">Definition</a>:
被計算構成子の最後の部分は括弧で囲まれた式であり、その節点の内容を生成する。これを、その構成子の<b>内容式</b>と呼ぶ。]</p>
<p>
以下に示すのは、被計算要素構成子および被計算属性構成子を用いた例であり、構成される節点の名前が定数であるような単純な場合である。この例では、<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>の最初の例と全く同じ結果が生成される:</p>
<div class="exampleInner">
<pre>
element book { 
   attribute isbn {"isbn-0060229357" }, 
   element title { "Harold and the Purple Crayon"},
   element author { 
      element first { "Crockett" }, 
      element last {"Johnson" }
   }
}
</pre></div>
<div class="div4">
<h5><a name="id-computedElements" id=
"id-computedElements"></a>3.7.3.1 被計算要素構成子</h5>
<h5><a name="d2e10981" id="d2e10981"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompElemConstructor" id=
"doc-xquery-CompElemConstructor"></a>[111]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompElemConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" (<a href="#prod-xquery-QName">QName</a> | ("{"
<a href="#doc-xquery-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ContentExpr" id=
"doc-xquery-ContentExpr"></a>[112]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContentExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-computed-elem-const" id="dt-computed-elem-const"
title="computed element constructor">Definition</a>:
<b>被計算要素構成子</b>は要素節点を1つ生成する。このとき、節点の名前も内容も計算して得ることができる。]</p>
<p>もしキーワード<code>element</code>の後ろに QName が続いていれば、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて展開され、結果として得られた<a title=
"expanded QName" href="#dt-expanded-qname">展開済
QName</a>が、構成された要素節点の<code>node-name</code>性質として用いられる。QName
の展開が成功しなければ、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]。</p>
<p>キーワード<code>element</code>の次に<a title="name expression" href=
"#dt-name-expression">名前式</a>がくれば、その名前式が以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="name expression" href=
"#dt-name-expression">名前式</a>の値に対して<a title="atomization" href=
"#dt-atomization">原子化</a>が適用される。原子化の結果が<code>xs:QName</code>型、<code>xs:string</code>型、<code>xs:untypedAtomic</code>型いずれかの原子値1つでなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p><a title="name expression" href=
"#dt-name-expression">名前式</a>の値を原子化した結果が<code>xs:QName</code>型であれば、その<a title="expanded QName"
href="#dt-expanded-qname">展開済
QName</a>が、構成された要素の<code>node-name</code>性質として用いられる。その際、QName
の接頭辞部分はそのまま保持される。</p>
</li>
<li>
<p><a title="name expression" href=
"#dt-name-expression">名前式</a>の値を原子化した結果が<code>xs:string</code>型か<code>xs:untypedAtomic</code>型であれば、その値が<a title="expanded QName"
href="#dt-expanded-qname">展開済
QName</a>に変換される。文字列値が名前空間接頭辞を含むならば、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて、その接頭辞を名前空間URIに解決する。文字列値が名前空間接頭辞を含まないならば、<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>にある局所名として扱われる。結果として得られる<a title="expanded QName"
href="#dt-expanded-qname">展開済
QName</a>が、構成された要素の<code>node-name</code>性質として用いられる。その際、QName
の接頭辞部分はそのまま保持される。原子化された<a title="name expression" href=
"#dt-name-expression">名前式</a>を展開済 QName に変換するのに成功しなければ、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する [<a title=
"err:XQDY0074" href="#ERRXQDY0074">err:XQDY0074</a>]。</p>
</li>
</ol>
<p>被計算要素構成子の<a title="content expression" href=
"#dt-content-expression">内容式</a> (もしあれば) は、<a title=
"direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>の内容中にある囲まれた式と全く同じ方法、すなわち<a href=
"#id-content"><b>3.7.1.3
内容</b></a>の段階1eで記述した方法で処理される。内容式を処理した結果は節点列になる。これを<b>内容列</b>という。<a title="content expression"
href="#dt-content-expression">内容式</a>がなければ、内容列は空列である。</p>
<p>被計算要素構成子の処理は以下のように行われる:</p>
<ol class="enumar">
<li>
<p>
内容列中の隣接したテキスト節点は、その内容を連接することによって1つのテキスト節点に併合される。このとき、間に空白は挟まれない。連接の後、内容が長さ0の文字列となるようなテキスト節点はいずれも内容列から消去される。</p>
</li>
<li>
<p>内容列が文書節点を含むならば、その文書節点は、その子によって内容列中で置き換えられる。</p>
</li>
<li>
<p>内容列に含まれる属性節点のうち、属性節点以外の節点に続くものがあれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XQTY0024" href=
"#ERRXQTY0024">err:XQTY0024</a>]。</p>
</li>
<li>
<p>新しく構成された要素節点の性質は以下のように決定される:</p>
<ol class="enumla">
<li>
<p><code>node-name</code>は、指定された QName または<a title=
"name expression" href=
"#dt-name-expression">名前式</a>を処理して得られた<a title="expanded QName"
href="#dt-expanded-qname">展開済 QName</a>である。これについては上で述べた通りである。</p>
</li>
<li>
<p><code>base-uri</code>は、以下のソースのうち存在する最初のものから取ってこられる:</p>
<ol class="enumlr">
<li>
<p>構成された節点の<code>xml:base</code>属性の値。ただしこの属性が存在する場合;</p>
</li>
<li>
<p><a title="base URI" href="#dt-base-uri">静的文脈</a>中の<a title=
"base URI" href="#dt-base-uri">基礎URI</a>。</p>
</li>
</ol>
</li>
<li>
<p><code>parent</code>は空である。</p>
</li>
<li>
<p><code>attributes</code>は、内容列中のすべての属性節点からなり、<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の順に並べられる。2つ以上の属性が同じ<code>node-name</code>を持っていれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0025"
href=
"#ERRXQDY0025">err:XQDY0025</a>]。これらの属性節点はそれぞれ、<code>parent</code>性質に新たに構成された要素節点が設定されていることに注意せよ。</p>
</li>
<li>
<p>
<code>children</code>は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点はそれぞれ、<code>parent</code>性質に新たに構成された要素節点が設定されていることに注意せよ。</p>
</li>
<li>
<p><code>in-scope-namespaces</code>は<a href=
"#id-ns-nodes-on-elements"><b>3.7.4
構成された要素の有効範囲内名前空間</b></a>に記述されているように計算される。</p>
</li>
<li>
<p><code>nilled</code>性質は<code>false</code>である。</p>
</li>
<li>
<p><code>string-value</code>性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。</p>
</li>
<li>
<p>
<code>typed-value</code>性質は、<code>xs:untypedAtomic</code>のインスタンスとしての<code>string-value</code>性質に等しい。</p>
</li>
<li>
<p><a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="construction mode" href=
"#dt-construction-mode">構成モード</a>が<code>strip</code>であれば、<code>type-name</code>性質は<code>xs:untyped</code>である。一方、構成モードが<code>preserve</code>であれば、<code>type-name</code>性質は<code>xs:anyType</code>である。</p>
</li>
<li>
<p>
<code>is-id</code>性質と<code>is-idrefs</code>性質は<code>false</code>に設定される。</p>
</li>
</ol>
</li>
</ol>
<p>被計算要素構成子は、存在する要素の複製を修正するのに用いられるかもしれない。例えば、変数 <code>$e</code>
が<a title="numeric" href=
"#dt-numeric">数</a>の内容を持つ要素に束縛されているならば、以下の構成子を用いることにより<code>$e</code>と同じ名前と属性を持ち、かつ<code>$e</code>の値の倍に等しい数の内容を持つ要素が新たに生成される:</p>
<div class="exampleInner">
<pre>
element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}
</pre></div>
<p>この例では、<code>$e</code>が式<code>let $e := &lt;length
units="inches"&gt;{5}&lt;/length&gt;</code>に束縛されているならば、例の式の結果は要素<code>&lt;length
units="inches"&gt;10&lt;/length&gt;</code>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>式<code>fn:node-name($e)</code>の<a title="static type" href=
"#dt-static-type">静的型</a>は<code>xs:QName?</code>であり、0個もしくは1個の QName
である。したがって、<a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が有効であるならば、上の例は静的型エラーを発生させる。なぜなら、被計算要素構成子中の名前式は正確に1個の文字列またはQNameを返すことが要求されるからである。静的型エラーを避けるためには、名前式<code>fn:node-name($e)</code>を<code>fn:exactly-one(fn:node-name($e))</code>と書き換えればよい。<a title="static typing feature"
href=
"#dt-static-typing-feature">静的型付け機能</a>が有効でないならば、上の例は、書かれているように正しく評価することができ、<code>$e</code>には、数の内容を持つ要素が正確に1個だけ束縛される。</p>
</div>
<p>
被計算構成子の重要な目的の一つに、節点の名前を計算することを許す、というものがある。この特徴を例で示そう。これは、要素の名前をある言語から別の言語に翻訳するというものである。変数
<code>$dict</code> は <code>dictionary</code> 要素に束縛されているとしよう。この要素は
<code>entry</code>
要素の列を含み、<code>entry</code>要素はそれぞれ指定された語の翻訳を符号化している。これは、語 "address"
のドイツ語およびイタリア語の変種を符号化した entry の例である:</p>
<div class="exampleInner">
<pre>
&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt; 
</pre></div>
<p>さらに、変数 <code>$e</code> は以下の要素に束縛されているとしよう:</p>
<div class="exampleInner">
<pre>
&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;
</pre></div>
<p>すると、以下の式は、<code>$e</code>の名前がイタリア語に翻訳され、かつ<code>$e</code>の内容
(属性があるならばそれも含め) が保存されているような新しい要素を生成する。キーワード <code>element</code>
の直後にある1つ目の囲まれた式は要素の名前を生成し、2つ目の囲まれた式は内容と属性を生成する:</p>
<div class="exampleInner">
<pre>
  element 
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}
</pre></div>
<p>この式の結果は、次のようになる:</p>
<div class="exampleInner">
<pre>
&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>前の例のように、<a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が有効であれば、静的型エラーを避けるために、上の被計算要素構成子中で要素名を計算する囲まれた式は<code>fn:exactly-one</code>関数の呼び出しによって囲まれなければならない。</p>
</div>
<p>被計算要素構成子の例はさらに<a href="#id-recursive-transformations"><b>I.4
再帰的変換</b></a>にもある。</p>
</div>
<div class="div4">
<h5><a name="id-computedAttributes" id=
"id-computedAttributes"></a>3.7.3.2 被計算属性構成子</h5>
<h5><a name="d2e11384" id="d2e11384"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompAttrConstructor" id=
"doc-xquery-CompAttrConstructor"></a>[113]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompAttrConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" (<a href="#prod-xquery-QName">QName</a> |
("{" <a href="#doc-xquery-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p>被計算属性構成子は新しい属性節点を1つ生成する。この節点は固有の節点識別性を持つ。</p>
<p>キーワード<code>attribute</code> の次に QName が続けば、その QName は<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて展開され、結果として得られる<a title=
"expanded QName" href="#dt-expanded-qname">展開済 QName</a> が
(その接頭辞も含め) 構成された属性節点の <code>node-name</code> 性質として用いられる。QName
の展開が成功しなければ、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]。</p>
<p>キーワード <code>attribute</code> の次に<a title="name expression" href=
"#dt-name-expression">名前式</a>が続けば、その名前式が以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="name expression" href=
"#dt-name-expression">名前式</a>の結果に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用される。<a title="atomization" href=
"#dt-atomization">原子化</a>の結果が<code>xs:QName</code>型,
<code>xs:string</code>型,
<code>xs:untypedAtomic</code>型のいずれかの原子値1つでなければ、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する [<a title=
"err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>原子化された<a title="name expression" href=
"#dt-name-expression">名前式</a>の値の型が<code>xs:QName</code>であれば、その<a title="expanded QName"
href="#dt-expanded-qname">展開済 QName</a>が (接頭辞も含め)
構成された属性節点の<code>node-name</code> 性質として用いられる。</p>
</li>
<li>
<p>原子化された<a title="name expression" href=
"#dt-name-expression">名前式</a>の値の型が<code>xs:string</code>もしくは<code>xs:untypedAtomic</code>であれば、その値が<a title="expanded QName"
href="#dt-expanded-qname">展開済
QName</a>に変換される。文字列値が名前空間接頭辞を含んでいれば、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いてその接頭辞が名前空間URIに解決される。文字列値に名前空間接頭辞が含まれなければ、どの名前空間にも属さない局所名と扱われる。結果として得られる<a title="expanded QName"
href="#dt-expanded-qname">展開済 QName</a>が (接頭辞も含め)
構成された属性の<code>node-name</code> 性質として用いられる。原子化された<a title=
"name expression" href="#dt-name-expression">名前式</a>を<a title=
"expanded QName" href="#dt-expanded-qname">展開済
QName</a>に変換することに成功しなければ、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0074" href=
"#ERRXQDY0074">err:XQDY0074</a>]。</p>
</li>
</ol>
<p>構成された属性の <code>node-name</code> 性質 (<a title="expanded QName"
href="#dt-expanded-qname">展開済 QName</a>) は以下のように検査される: その URI 部分が
<code>http://www.w3.org/2000/xmlns/</code> (名前空間接頭辞
<code>xmlns</code> に一致) であるか、またはその属性がどの名前空間にも属さず局所名が
<code>xmlns</code> であれば、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a> [<a title="err:XQDY0044" href=
"#ERRXQDY0044">err:XQDY0044</a>] が発生する。</p>
<p>被計算属性構成子の<a title="content expression" href=
"#dt-content-expression">内容式</a>は以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="content expression" href=
"#dt-content-expression">内容式</a>の結果に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用され、原子値の列に変換される。(<a title=
"content expression" href=
"#dt-content-expression">内容式</a>がなければ、このステップの結果は空列である。)</p>
</li>
<li>
<p>
原子化の結果が空列であれば、属性の値は長さ0の文字列である。そうでなければ、原子化された列中のそれぞれの原子値が文字列に型変換される。</p>
</li>
<li>
<p>
前のステップの結果得られる個々の文字列が、それぞれの間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果の文字列が、新しい属性節点の
<code>string-value</code> 性質となる。新しい属性節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a> (<code>type-name</code> 性質) は
<code>xs:untypedAtomic</code> である。この属性節点の <code>typed-value</code>
性質は <code>string-value</code>
と等しく、<code>xs:untypedAtomic</code>のインスタンスである。</p>
</li>
<li>
<p>この属性節点の <code>parent</code> 性質は空に設定される。</p>
</li>
<li>
<p>この属性の名前が
<code>xml:id</code>であれば、この属性の文字列値と型付けされた値がさらに正規化される。すなわち、前後の空白文字が取り除かれ,
空白文字の列がスペース文字 (#x20) 1つに置き換えられる。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>このステップは、<a href="#XMLID">[XML ID]</a>で定義されている
<code>xml:id</code> の処理を行う。</p>
</div>
</li>
<li>
<p>この属性の名前が
<code>xml:id</code>であれば、結果として得られる属性節点の<code>is-id</code>性質が<code>true</code>に設定される。そうでなければ、<code>is-id</code>性質は<code>false</code>に設定される。この属性の<code>is-idrefs</code>性質は無条件に<code>false</code>に設定される。</p>
</li>
</ol>
<ul>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
attribute size {4 + 3}
</pre></div>
<p><code>size</code>属性の<a title="string value" href=
"#dt-string-value">文字列値</a>は "<code>7</code>"
であり、その型は<code>xs:untypedAtomic</code>である。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
attribute
   { if ($sex = "M") then "husband" else "wife" }
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }
</pre></div>
<p>構成された属性の名前は<code>husband</code>か<code>wife</code>である。その<a title=
"string value" href="#dt-string-value">文字列値</a>は "<code>Hello 1 2 3
Goodbye</code>"である。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-documentConstructors" id=
"id-documentConstructors"></a>3.7.3.3 文書節点構成子</h5>
<h5><a name="d2e11656" id="d2e11656"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompDocConstructor" id=
"doc-xquery-CompDocConstructor"></a>[110]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompDocConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document" "{" <a href="#doc-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>文書節点構成子はすべて被計算構成子である。文書節点構成子の結果は新しい文書節点であり、固有の節点識別性を持つ。</p>
<p>
文書節点構成子は、問合せの結果をそれ自身だけで文書としたい場合に有用である。以下の例では、<code>author-list</code>という名前の根要素を含むXML文書を返す問合せを表している:</p>
<div class="exampleInner">
<pre>
document
   {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
   }
</pre></div>
<p>文書節点構成子の<a title="content expression" href=
"#dt-content-expression">内容式</a>は、<a title=
"direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>の内容中にある囲まれた式と全く同じように処理される。すなわち、<a href="#id-content"><b>3.7.1.3
内容</b></a>のステップ1eに記述されているように処理される。内容式を処理した結果は節点列になる。これを<b>内容列</b>という。文書節点構成子の処理は、次に以下のように行われる:</p>
<ol class="enumar">
<li>
<p>
内容列中の隣接するテキスト節点は、それらの内容を連接することによって1つのテキスト節点に併合される。このとき間に空白は挟まれない。連接の後、内容が長さ0の文字列であるようなテキスト節点はいずれも内容列から削除される。</p>
</li>
<li>
<p>内容列に文書節点が含まれれば、その文書節点は、内容列中においてその子に置き換えられる。</p>
</li>
<li>
<p>内容列に属性節点が含まれれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>新たに構成された文書節点の性質は以下のように決定される:</p>
<ol class="enumla">
<li>
<p><code>base-uri</code>は<a title="base URI" href=
"#dt-base-uri">静的文脈</a>中の<a title="base URI" href="#dt-base-uri">基礎
URI</a>から取ってこられる。静的文脈に基礎 URI が定義されていなければ、<code>base-uri</code>
性質は空である。</p>
</li>
<li>
<p><code>children</code>
性質は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点それぞれの<code>parent</code>性質は、新たに構成された文書節点に設定されていることに注意せよ。</p>
</li>
<li>
<p>
<code>unparsed-entities</code>性質と<code>document-uri</code>性質は空である。</p>
</li>
<li>
<p><code>string-value</code> 性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。</p>
</li>
<li>
<p><code>typed-value</code>
性質は、<code>string-value</code>性質に等しく、<code>xs:untypedAtomic</code>のインスタンスである。</p>
</li>
</ol>
</li>
</ol>
<p>構成された文書節点に対しては妥当性検証は行われない。<a href="#XML">[XML 1.0]</a>
にある、XML文書の構造を支配するルール (例えば、文書節点は子要素節点をただ1つ持たなければならない、など) は、XQeury
の文書節点構成子に対しては強制されない。</p>
</div>
<div class="div4">
<h5><a name="id-textConstructors" id=
"id-textConstructors"></a>3.7.3.4 テキスト節点構成子</h5>
<h5><a name="d2e11760" id="d2e11760"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompTextConstructor" id=
"doc-xquery-CompTextConstructor"></a>[114]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompTextConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "{" <a href="#doc-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>
テキスト節点構成子はすべて被計算構成子である。テキスト節点構成子の結果は新しいテキスト節点であり、固有の節点識別性を持つ。</p>
<p>テキスト節点の<a title="content expression" href=
"#dt-content-expression">内容式</a>は以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="content expression" href=
"#dt-content-expression">内容式</a>の値に対して<a title="atomization" href=
"#dt-atomization">原子化</a>が適用され、原子値の列に変換される。</p>
</li>
<li>
<p>
原子化の結果が空列であれば、テキスト節点は構成されない。そうでない場合は、原子化された列中の原子値それぞれが文字列に型変換される。</p>
</li>
<li>
<p>
前のステップの結果得られる個々の文字列が、間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果の文字列は、構成されたテキスト節点の
<code>content</code> 性質となる。</p>
</li>
</ol>
<p>構成されたテキスト節点の <code>parent</code> 性質は空に設定される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
テキスト節点構成子が長さ0の文字列を含むテキスト節点を構成することは可能である。しかし、構成された要素節点や文書節点の文脈で用いられると、このようなテキスト節点は削除されるか、ほかのテキスト節点に併合される。</p>
</div>
<p>以下に示すのは、テキスト節点構成子の例である:</p>
<div class="exampleInner">
<pre>
text {"Hello"}
</pre></div>
</div>
<div class="div4">
<h5><a name="id-computed-pis" id="id-computed-pis"></a>3.7.3.5
被計算処理命令構成子</h5>
<h5><a name="d2e11810" id="d2e11810"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompPIConstructor" id=
"doc-xquery-CompPIConstructor"></a>[116]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompPIConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery-NCName">NCName</a> | ("{" <a href=
"#doc-xquery-Expr">Expr</a> "}")) "{" <a href=
"#doc-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
</table>
<p>被計算処理命令構成子 (<a href=
"#doc-xquery-CompPIConstructor">CompPIConstructor</a>)
は新しい処理命令節点を構成する。この節点は固有の節点識別性を持つ。</p>
<p>キーワード <code>processing-instruction</code> の次に NCName が続けば、その
NCName が構成された節点の <code>target</code> 性質となる。キーワード
<code>processing-instruction</code> の次に<a title="name expression"
href="#dt-name-expression">名前式</a>が続けば、その名前式が以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="name expression" href=
"#dt-name-expression">名前式</a>の値に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用される。<a title="atomization" href=
"#dt-atomization">原子化</a>の結果が
<code>xs:NCName</code>、<code>xs:string</code>、<code>xs:untypedAtomic</code>いずれかの型の原子値1つでなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>原子化された<a title="name expression" href=
"#dt-name-expression">名前式</a>の値の型が<code>xs:string</code>もしくは<code>xs:untypedAtomic</code>であれば、その値が<code>xs:NCName</code>型に型変換される。その値が<code>xs:NCName</code>に型変換できなければ、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0041"
href="#ERRXQDY0041">err:XQDY0041</a>]。</p>
</li>
<li>
<p>次に、結果として得られる NCName が新たに構成される処理命令節点の <code>target</code>
性質として使われる。しかし、その NCName が "<code>XML</code>"
(大文字小文字の組み合わせに関わらず)に等しければ、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0064" href=
"#ERRXQDY0064">err:XQDY0064</a>]。</p>
</li>
</ol>
<p>被計算処理命令構成子の<a title="content expression" href=
"#dt-content-expression">内容式</a>は以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="content expression" href=
"#dt-content-expression">内容式</a>の値に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用され、原子値の列に変換される。(<a title=
"content expression" href=
"#dt-content-expression">内容式</a>がなければ、このステップの結果は空列である。)</p>
</li>
<li>
<p>
原子化の結果が空列であれば、長さ0の文字列に置き換えられる。そうでなければ、原子化された列中の原子値それぞれが文字列に型変換される。結果として得られる文字列のいずれかが
"<code>?&gt;</code>" を含むならば、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a> [<a title="err:XQDY0026" href=
"#ERRXQDY0026">err:XQDY0026</a>] が発生する。</p>
</li>
<li>
<p>
前のステップの結果得られる個々の文字列が、間に空白文字1つを挟みながら連接され、1つの文字列に併合される。先頭の空白文字は結果の文字列から削除される。結果として得られる文字列は、構成された処理命令節点の
<code>content</code> 性質となる。</p>
</li>
</ol>
<p>新しく構成された節点の残りの性質は以下のように決定される:</p>
<ol class="enumar">
<li>
<p><code>parent</code> 性質は空である。</p>
</li>
<li>
<p><code>base-uri</code> 性質は空である。</p>
</li>
</ol>
<p>以下に示すのは、被計算処理命令構成子の例である:</p>
<div class="exampleInner">
<pre>
let $target := "audio-output",
    $content := "beep" 
return processing-instruction {$target} {$content}
</pre></div>
<p>この例で構成される処理命令節点は以下のように直列化されるかもしれない:</p>
<div class="exampleInner">
<pre>
&lt;?audio-output beep?&gt;
</pre></div>
</div>
<div class="div4">
<h5><a name="id-computed-comments" id=
"id-computed-comments"></a>3.7.3.6 被計算コメント構成子</h5>
<h5><a name="d2e11966" id="d2e11966"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CompCommentConstructor" id=
"doc-xquery-CompCommentConstructor"></a>[115]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompCommentConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "{" <a href="#doc-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p>被計算コメント構成子 (<a href=
"#doc-xquery-CompCommentConstructor">CompCommentConstructor</a>)
は新しいコメント節点を構成する。この節点は固有の節点識別性を持つ。被計算コメント構成子の<a title=
"content expression" href=
"#dt-content-expression">内容式</a>は以下のように処理される:</p>
<ol class="enumar">
<li>
<p><a title="content expression" href=
"#dt-content-expression">内容式</a>の値に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用され、原子値の列に変換される。</p>
</li>
<li>
<p>
原子化の結果が空列であれば、長さ0の文字列に置き換えられる。そうでなければ、原子化された列中の原子値がそれぞれ文字列に型変換される。</p>
</li>
<li>
<p>
前のステップの結果得られた個々の文字列は、それぞれの間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果として得られる文字列は、新しく構成されたコメント節点の
<code>content</code> 性質となる。</p>
</li>
<li>
<p>被計算コメント構成子の<a title="content expression" href=
"#dt-content-expression">内容式</a>の結果が、2つの隣接したハイフン記号を含むか、ハイフン記号1つで終わっていれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>である [<a title="err:XQDY0072"
href="#ERRXQDY0072">err:XQDY0072</a>]。</p>
</li>
</ol>
<p>構成されたコメント節点の <code>parent</code> 性質は空に設定される。</p>
<p>以下に示すのは、被計算コメント構成子の例である:</p>
<div class="exampleInner">
<pre>
let $homebase := "Houston" 
return comment {fn:concat($homebase, ", we have a problem.")}
</pre></div>
<p>この例で構成されるコメント節点は以下のように直列化されるかもしれない:</p>
<div class="exampleInner">
<pre>
&lt;!--Houston, we have a problem.--&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-ns-nodes-on-elements" id=
"id-ns-nodes-on-elements"></a>3.7.4 構成された要素の有効範囲内名前空間</h4>
<p>直接要素構成子や被計算要素構成子によって構成された要素節点は、<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">名前空間束縛</a>の集合からなる <a title=
"in-scope namespaces" href="#dt-in-scope-namespaces">in-scope
namespaces</a> 性質を持つ。要素節点の有効範囲内名前空間は、その節点を直列化する方法に影響を与えるかもしれず
(<a href="#id-serialization"><b>2.2.4
直列化</b></a>を見よ)、また、<code>fn:name</code>など、節点上で動作するある種の関数の振舞いに影響を与えるかもしれない。<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">in-scope namespaces</a>と<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の違いに注意せよ。前者は要素節点の動的性質であり、一方後者は式の静的性質である。また、有効範囲内名前空間中の名前空間束縛のうち1つは接頭辞を持たないかもしれないことにも注意せよ
(その要素のデフォルト名前空間を表す)。構成された要素節点の有効範囲内名前空間は以下の名前空間束縛からなる:</p>
<ul>
<li>
<p>現在の要素構成子中で<a title="namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>によって定義されている名前空間それぞれから名前空間束縛が生成される。</p>
</li>
<li>
<p>その構成子を囲む<a title="direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>の名前空間宣言属性で定義され、現在の要素構成子もしくは途中の構成子で再定義されていない名前空間それぞれについて、名前空間束縛が生成される。</p>
</li>
<li>
<p>接頭辞 <code>xml</code> を名前空間 URI
<code>http://www.w3.org/XML/1998/namespace</code>
に束縛する名前空間束縛は常に生成される。</p>
</li>
<li>
<p>
構成された要素の名前もしくはその属性の名前に用いられている名前空間それぞれについて、名前空間束縛が1つ存在しなければならない。これらの名前空間に対する名前空間束縛がまだ存在しない場合は、その名前空間に対する新しい名前空間束縛が生成される。節点の名前が接頭辞を含んでいれば、その接頭辞が名前空間束縛に用いられる。名前が接頭辞を持たなければ、空の接頭辞に対する束縛が生成される。この結果、同じ接頭辞に対する2つの異なる束縛が必要になるなど、矛盾が生じれば、節点の名前に用いられている接頭辞は、矛盾を引き起こさない何らかの<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>の接頭辞に変更され、この新しい接頭辞に対する名前空間束縛が生成される。</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">名前空間複製モード</a>は新しく構成される要素節点の名前空間には影響を及ぼさない。このモードは、構成子式により複製された存在する節点に対してのみ適用される。</p>
</div>
<p>例として、以下の問合せを示す:</p>
<div class="exampleInner">
<pre>
declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</pre></div>
<p>結果として得られる <code>p:a</code> 要素の<a title="in-scope namespaces"
href="#dt-in-scope-namespaces">有効範囲内名前空間</a>は以下の<a title=
"in-scope namespaces" href=
"#dt-in-scope-namespaces">名前空間束縛</a>からなる:</p>
<ul>
<li>
<p><code>p = "http://example.com/ns/p"</code></p>
</li>
<li>
<p><code>q = "http://example.com/ns/q"</code></p>
</li>
<li>
<p><code>r = "http://example.com/ns/r"</code></p>
</li>
<li>
<p><code>xml = "http://www.w3.org/XML/1998/namespace"</code></p>
</li>
</ul>
<p><code>p</code> と <code>q</code>
に対する名前空間束縛は結果の要素に追加される。なぜなら、これらの名前空間はそれぞれ要素と属性に用いられているからである。名前空間束縛
<code>r="http://example.com/ns/r"</code>
は構成された要素の有効範囲内名前空間に追加される。なぜならこれは、名前には用いられていないが、<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>で定義されているからである。</p>
<p><code>f="http://example.com/ns/f"</code>
に対応する名前空間束縛は生成されない。なぜなら名前空間接頭辞 <code>f</code>
は問合せの前書きにのみ出現し、構成された節点の要素や属性には用いられていないからである。この名前空間束縛は、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中にはあり、この問合せの処理の間利用することができるが、問合せの結果には出現しない。</p>
<p>以下の構成された要素は、<code>validate</code>
式の内側に入れ子になっていれば、検証することができないことに注意せよ:</p>
<div class="exampleInner">
<pre>
&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;
</pre></div>
<p>この構成された要素は接頭辞 <code>xsi</code> (名前中で用いられているため) と
<code>xml</code> (どの構成された要素節点にも定義されるため)
に対する名前空間束縛は持っている。しかし、この構成された要素の検証中、検証器は名前空間接頭辞 <code>xs</code>
を解釈することができない。なぜならこれに対する名前空間束縛がないからである。この構成された要素の検証は、<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>を用意することで可能になる。例えば以下の通り:</p>
<div class="exampleInner">
<pre>
&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-flwor-expressions" id=
"id-flwor-expressions"></a>3.8 FLWOR 式</h3>
<p>XQuery は FLWOR
式と呼ばれる特徴を用意している。これは繰り返しや、中間結果を変数に束縛することを支援する。この種の式は2つ以上の文書の結合を計算したり、データを再構成するときにしばしば有用である。FLWOR
という名前は "flower" と発音し、キーワード<code>for</code>, <code>let</code>,
<code>where</code>, <code>order by</code>, および <code>return</code>
から示唆を受けた。</p>
<h5><a name="d2e12179" id="d2e12179"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-FLWORExpr" id=
"doc-xquery-FLWORExpr"></a>[33]&nbsp;&nbsp;&nbsp;</td>
<td><code>FLWORExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#doc-xquery-ForClause">ForClause</a> | <a href=
"#doc-xquery-LetClause">LetClause</a>)+ <a href=
"#doc-xquery-WhereClause">WhereClause</a>? <a href=
"#doc-xquery-OrderByClause">OrderByClause</a>? "return" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ForClause" id=
"doc-xquery-ForClause"></a>[34]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"for" "$" <a href="#doc-xquery-VarName">VarName</a>
<a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>? <a href=
"#doc-xquery-PositionalVar">PositionalVar</a>? "in" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xquery-VarName">VarName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>? <a href=
"#doc-xquery-PositionalVar">PositionalVar</a>? "in" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-LetClause" id=
"doc-xquery-LetClause"></a>[36]&nbsp;&nbsp;&nbsp;</td>
<td><code>LetClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"let" "$" <a href="#doc-xquery-VarName">VarName</a>
<a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>? ":="
<a href="#doc-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xquery-VarName">VarName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TypeDeclaration" id=
"doc-xquery-TypeDeclaration"></a>[118]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"as" <a href=
"#doc-xquery-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PositionalVar" id=
"doc-xquery-PositionalVar"></a>[35]&nbsp;&nbsp;&nbsp;</td>
<td><code>PositionalVar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"at" "$" <a href=
"#doc-xquery-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-WhereClause" id=
"doc-xquery-WhereClause"></a>[37]&nbsp;&nbsp;&nbsp;</td>
<td><code>WhereClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"where" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderByClause" id=
"doc-xquery-OrderByClause"></a>[38]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderByClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#doc-xquery-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderSpecList" id=
"doc-xquery-OrderSpecList"></a>[39]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderSpecList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-OrderSpec">OrderSpec</a> (","
<a href="#doc-xquery-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderSpec" id=
"doc-xquery-OrderSpec"></a>[40]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderSpec</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a> <a href=
"#doc-xquery-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderModifier" id=
"doc-xquery-OrderModifier"></a>[41]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderModifier</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#doc-xquery-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
</table>
<p>FLWOR 式の <code>for</code> 節と <code>let</code>
節は、束縛された変数の組の順序付き列を生成する。これを<b>組ストリーム</b>という。<code>where</code>
節は省略可能で、組ストリームを選別する機能、すなわちある組を残し他を捨てる機能を提供する。<code>order by</code>
節は省略可能で、組ストリームの順序を変更するのに用いることができる。<code>return</code> 節は FLWOR
式の結果を構成する。<code>return</code>
節は組ストリーム中の組それぞれに対して1回評価される。この評価が行われるのは <code>where</code>
節による選別の後である。また、評価の際、それぞれの組中の変数束縛が用いられる。FLWOR
式の結果は、これらの評価の結果を含む順序付き列であり、<a title="comma operator" href=
"#dt-comma-operator">コンマ演算子</a>を適用したかのように連接される。</p>
<p>以下の FLWOR 式の例には、利用可能なすべての節が含まれている。<code>for</code>
節では、入力文書中のすべての department に対して繰り返しが行われ、変数 <code>$d</code> を各々の
department の number に順に束縛する。<code>$d</code>
の束縛それぞれに対し、<code>let</code> 節で変数 <code>$e</code> が与えられた department
の employee すべてに束縛される。<code>for</code> 節と <code>let</code>
節の結果は組ストリームであり、それぞれの組は <code>$d</code> と <code>$e</code>
に対する束縛の2つ組を含む (<code>$d</code> は department の number
に束縛され、<code>$e</code> はその department の employee
の集合に束縛される)。<code>where</code> 節では、組ストリームに対して選別を行い、10人以上の employee
を持つ department を表す束縛の2つ組だけを残す。<code>order by</code> 節では、残った組を、その
department 中の employee の salary の平均値の降順で順序付けし直す。<code>return</code>
節では、残った組それぞれに対し新しい <code>big-dept</code> 要素を構成する。この要素は department の
number, headcount, salary の平均値を含む。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno = $d]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;</span>
</pre></div>
<p>FLWOR 式の節に関する詳細は以下で述べる。</p>
<div class="div3">
<h4><a name="id-for-let" id="id-for-let"></a>3.8.1 For 節と Let
節</h4>
<p>FLWOR 式の <code>for</code> 節と <code>let</code>
節の目的は組ストリームを生成することである。この組ストリーム中の各組は、それぞれ1個以上の束縛された変数からなる。</p>
<p><code>for</code> 節の最も簡単な例は、変数1つとそれに関連づけられた式からなる。 [<a name=
"dt-binding-sequence" id="dt-binding-sequence" title=
"binding sequence">Definition</a>: <code>for</code>
節中で変数に関連づけられた式の値を、その変数に対する<b>束縛列</b>という。] <code>for</code>
節では、束縛列中の項目に対する繰り返しを行い、変数を各項目に順に束縛する。<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば、結果として得られる変数束縛の列は、束縛列中の順序に基づいて順序づけられる。そうでない場合は、変数束縛の順序は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
<p><code>for</code>
節には1つ以上の変数が含まれてもよい。それぞれの変数に式が1つ対応し、その値がその変数に対する束縛列となる。この場合、<code>for</code>
節では、束縛列上の各変数に対して繰り返しが行われる。結果として得られる組ストリームは、それぞれの束縛列中の値からなる組み合わせそれぞれに対し、1つの組を含む。<a title="ordering mode"
href="#dt-ordering-mode">順序付けモード</a>が <code>ordered</code>
であれば、組ストリームの順序は、最も左側にある変数の束縛列の順序によってまず決定され、次に残りの変数の束縛列によって決定される。このとき変数は左から右に使用される。そうでない場合は、変数束縛の順序は<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>である。</p>
<p><code>let</code>
節にも1つ以上の変数が含まれてもよい。それぞれの変数に式が1つ関連づけられる。しかし、<code>for</code>
節とは異なり、<code>let</code>
節ではそれぞれの変数を関連づけられた式の結果に束縛し、繰り返しは行われない。<code>let</code>
節によって生成される変数束縛は、<code>for</code>
節によって生成された束縛の組に追加される。<code>for</code> 節がなければ、<code>let</code>
節はすべての変数束縛を含む1つの組を生成する。</p>
<p><code>for</code> 節と <code>let</code>
節はともに変数を束縛するが、以下の例で示す通り、変数を束縛する方法はかなり異なる。1つめの例は <code>let</code>
節を用いる:</p>
<div class="exampleInner">
<pre>
<span class=
"parse-test">let $s := (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</span>
</pre></div>
<p>変数 <code>$s</code> は式 <code>(&lt;one/&gt;, &lt;two/&gt;,
&lt;three/&gt;)</code> の結果に束縛される。<code>for</code>
節はないので、<code>let</code> 節は <code>$s</code> の束縛を含む組を1つ生成する。
<code>return</code> 節はこの組から起動され、以下のような出力を生成する:</p>
<div class="exampleInner">
<pre>
&lt;out&gt;
   &lt;one/&gt;
   &lt;two/&gt;
   &lt;three/&gt;
&lt;/out&gt;
</pre></div>
<p>次の例は同じような問合せであるが、<code>let</code> 節の代わりに <code>for</code>
節が含まれる:</p>
<div class="exampleInner">
<pre>
<span class=
"parse-test">for $s in (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</span>
</pre></div>
<p>この例では、変数 <code>$s</code> が与えられた式上で繰り返される。<a title=
"ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>ordered</code>であれば,
<code>$s</code> は最初に <code>&lt;one/&gt;</code> に、次に
<code>&lt;two/&gt;</code> に、最後に <code>&lt;three/&gt;</code>
に束縛される。これらの束縛それぞれに対して組が1つ生成され、それぞれの組に対して <code>return</code>
節が起動され、以下のような出力を生成する:</p>
<div class="exampleInner">
<pre>
&lt;out&gt;
   &lt;one/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;two/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;three/&gt;
&lt;/out&gt;
</pre></div>
<p>以下は、<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が <code>ordered</code>
であるときに、複数の変数を持つ束縛された組がいかにして <code>for</code> 節で生成されるかを示す例である。</p>
<div class="exampleInner">
<pre>
for $i in (1, 2), $j in (3, 4)
</pre></div>
<p>上の <code>for</code> 節で生成される組ストリームは以下の通りである:</p>
<div class="exampleInner">
<pre>
($i = 1, $j = 3)
($i = 1, $j = 4)
($i = 2, $j = 3)
($i = 2, $j = 4)
</pre></div>
<p>上の例でもし<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>が<code>unordered</code>であれば、<code>for</code>
節は同じ組ストリームを生成するが、これらの組の順序は<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<p><code>for</code> 節や <code>let</code> 節で束縛される変数の有効範囲は、それらが含まれる
FLWOR
式の部分式のうち、変数束縛の後ろに出現するものすべてからなる。裕広範囲には、変数が束縛される式自体は含まれない。以下に示すのは、<code>for</code>
節や <code>let</code> 節での束縛が、それより前の節で束縛された変数や、FLWOR
式の同じ節中で前に束縛された変数を参照してもよい、という例である:</p>
<div class="exampleInner">
<pre>
for $x in $w, $a in f($x)
let $y := g($a)
for $z in p($x, $y)
return q($x, $y, $z)
</pre></div>
<p>与えられた FLWOR 式の <code>for</code> 節と <code>let</code>
節は同じ変数名を1回以上束縛してもよい。この場合、新しい束縛が前の束縛を塞いでしまい、前の束縛は FLWOR
式の残りの部分から参照不能になる。</p>
<p><code>for</code> 節や <code>let</code>
節で束縛された変数はそれぞれ、省略可能な<b>型宣言</b>を持ってもよい。これは<a href=
"#id-sequencetype-syntax"><b>2.5.3
SequenceTypeの文法</b></a>の構文を用いて宣言された型である。<a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のルールに従って、その変数に束縛された値の型が宣言された型と照合されなければ、<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。例えば、以下の式は<a title="type error"
href="#dt-type-error">型エラー</a>を発生する。なぜなら、変数 <code>$salary</code>
が型宣言を持ち、それが変数に束縛された値では満たされないからである:</p>
<div class="exampleInner">
<pre>
let $salary as xs:decimal :=  "cat"
return $salary * 2
</pre></div>
<p><code>for</code>
節で束縛される変数はそれぞれ、関連する<b>位置変数</b>を持っていてもよい、これは元の変数と同時に束縛される。位置変数の名前の先頭にはキーワード<code>at</code>がつく。位置変数は常に暗黙的な型
<code>xs:integer</code> を持つ。変数は<a title="binding sequence" href=
"#dt-binding-sequence">束縛列</a>中の項目上で繰り返されると、その位置変数は、束縛列中での項目の順序位置を表す整数上で、1を起点として繰り返される。位置変数の展開済み
QName は、それと関連する変数の展開済 QName と区別されなければならない [<a title="err:XQST0089"
href="#ERRXQST0089">err:XQST0089</a>]。</p>
<p>以下の <code>for</code> 節は位置変数の例を示す:</p>
<div class="exampleInner">
<pre>
for $car at $i in ("Ford", "Chevy"),
    $pet at $j in ("Cat", "Dog")
</pre></div>
<p><a title="ordering mode" href="#dt-ordering-mode">順序付けモード</a>が
<code>ordered</code> であれば、上の <code>for</code>
節によって生成される組ストリームは以下のようになる:</p>
<div class="exampleInner">
<pre>
($i = 1, $car = "Ford", $j = 1, $pet = "Cat")
($i = 1, $car = "Ford", $j = 2, $pet = "Dog")
($i = 2, $car = "Chevy", $j = 1, $pet = "Cat")
($i = 2, $car = "Chevy", $j = 2, $pet = "Dog")
</pre></div>
<p><a title="ordering mode" href="#dt-ordering-mode">順序付けモード</a>が
<code>unordered</code> であれば、組ストリームの順序は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。さらに、<code>for</code>
節中に<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>に影響を与える部分式が含まれていれば、これらの部分式から返される位置変数と項目との対応付けは、<a title="ordering mode"
href="#dt-ordering-mode">順序付けモード</a>が <code>unordered</code>
であるとき、<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
</div>
<div class="div3">
<h4><a name="id-where" id="id-where"></a>3.8.2 Where 節</h4>
<p><code>where</code> 節は省略可能であり、<code>for</code> 節や
<code>let</code> 節で生成された変数束縛の組に対する選別機能を提供する。<code>where</code>
節中の式を<b>where-式</b>といい、これらの組それぞれに対して1回評価される。where-式の<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>が
<code>true</code> であれば、その組は残され、その変数束縛が <code>return</code>
節の実行に用いられる。where-式の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>が <code>false</code> であれば、その組は捨てられる。式の<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>は<a href=
"#id-ebv"><b>2.4.3 有効ブール値</b></a>で定義されている。</p>
<p>以下の式は、入力列にサンプリングを行うために、<code>where</code>
節がどのようにして<b>位置変数</b>に適用されるかを示している。この式は100個の入力値から1つをサンプリングすることで列の平均値を近似している。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">fn:avg(for $x at $i in $inputvalues
    where $i mod 100 = 0   
    return $x)</span>
</pre></div>
</div>
<div class="div3">
<h4><a name="id-orderby-return" id="id-orderby-return"></a>3.8.3
Order By 節と Return 節</h4>
<p>FLWOR 式の <code>return</code> 節は組ストリーム中の組それぞれに対して1度評価され、<a title=
"comma operator" href=
"#dt-comma-operator">コンマ演算子</a>のようにこれらの評価の結果が連接され、FLWOR
式の結果を形成する。</p>
<p><code>order by</code> 節がなければ、組ストリームの順序は <code>for</code> 節や
<code>let</code> 節、および<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>で決められる。<code>order by</code>
節があれば、組ストリームの組は再び順序づけされ、値を基礎とする新しい順序になる。どちらの場合も、結果の順序によって、それぞれの組について、組中の変数束縛を用いて
<code>return</code> 節が評価される順序が決定される。<code>order by</code>
節があれば、<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>は FLWOR 式には影響を及ぼさないことに注意せよ。なぜなら
<code>order by</code> が<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>に優先するからである。</p>
<p><code>order by</code> 節は1個以上の順序付け指定を含む。これを、上の文法に示す通り、<a href=
"#doc-xquery-OrderSpec">orderspecs</a> という。
組ストリーム中の各組に対して、<code>where</code> 節で選別を行った後、その組の変数束縛を用いて orderspec
が評価される。2つの組の間の相対順序は、それらの orderspec
の値を評価することで決定される。このとき、異なる値の組が得られるまで左から右に処理が行われる。orderspec に
<a title="collation" href=
"#dt-collation">照合順序</a>が指定されていれば、<code>xs:string</code>型、<code>xs:anyURI</code>型、およびそれらから導出される型の値を比較するのにその照合順序が用いられる
(そうでなければ、<a title="default collation" href=
"#dt-def-collation">デフォルト照合順序</a>が用いられる)。相対 URI によって orderspec
に照合順序が指定されていれば、<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="base URI" href=
"#dt-base-uri">基礎 URI</a>を用いて、その相対 URI が絶対 URI に解決される。<a title=
"statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>にない照合順序が orderspec
に指定されていれば、エラーが発生する [<a title="err:XQST0076" href=
"#ERRXQST0076">err:XQST0076</a>]。</p>
<p>orderspec を評価し比較する処理は以下のルールに基づいている:</p>
<ul>
<li>
<p>それぞれの orderspec 中の式の結果に<a title="atomization" href=
"#dt-atomization">原子化</a>が適用される。原子化の結果が原子値1つでも空列でもなければ、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する [<a title=
"err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>orderspec の値が<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a> <code>xs:untypedAtomic</code>を持っていれば
(スキーマのない文書中の文字データのように)、<code>xs:string</code>型に型変換される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
型付けされていない値を常に文字列と扱うことにより、整列されるべき値すべての型に関する完全な知識がなくても整列を始めることが可能になる。</p>
</div>
</li>
<li>
<p>空でない orderspec の値はすべて、<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>や<a title="type promotion"
href="#dt-type-promotion">型昇格</a>により、共通な型に変換しなければならない。順序付けは、<code>gt</code>
演算子を持つ最小の共通型上で行われる。2つ以上の空でない orderspec の値が <code>gt</code>
演算子を持つ共通型に変換できなければ、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<ul>
<li>
<p>例: orderdesc の値に <code>hatsize</code> 型の値と <code>shoesize</code>
型の値が含まれていたとする。ここで <code>hatsize</code> 型は <code>xs:integer</code>
から、<code>shoesize</code> 型は <code>xs:decimal</code>
からそれぞれ導出されているとする。部分型置換や型昇格によって到達可能な最小共通型は <code>xs:decimal</code>
である。</p>
</li>
<li>
<p>例: orderdesc の値に <code>xs:string</code> 型の値と
<code>xs:anyURI</code> 型の値が含まれていたとする。部分型置換や型昇格によって到達可能な最小共通型は
<code>xs:string</code> である。</p>
</li>
</ul>
</li>
</ul>
<p>2つの overspec の値が比較されて順序列中での相対位置が決定されるとき、<em>greater-than</em>
関連が以下のように定義される:</p>
<ul>
<li>
<p>orderspec が <code>empty least</code> と指定されているとき、値 W が値 V に対して
<em>greater-than</em> であるのは、以下のいずれかの条件が true のときである:</p>
<ul>
<li>
<p>V が空列で W が空列でない。</p>
</li>
<li>
<p>V が <code>NaN</code> で、W が <code>NaN</code> でも空列でもない。</p>
</li>
<li>
<p>照合順序が指定されておらず、W <code>gt</code> V が true である。</p>
</li>
<li>
<p>ある照合順序 C が指定されており、<code>fn:compare(V, W, C)</code> が 0
より小さい。</p>
</li>
</ul>
</li>
<li>
<p>orderspce が <code>empty greatest</code> と指定されているとき、値 W が値 V に対して
<em>greater-than</em> であるのは、以下の条件のいずれかが true のときである:</p>
<ul>
<li>
<p>W が空列で V が空列でない。</p>
</li>
<li>
<p>W が <code>NaN</code> で、V が <code>NaN</code> でも空列でもない。</p>
</li>
<li>
<p>照合順序が指定されておらず、W <code>gt</code> V が true である。</p>
</li>
<li>
<p>ある照合順序 C が指定されており、<code>fn:compare(V, W, C)</code> が 0
より小さい。</p>
</li>
</ul>
</li>
<li>
<p>orderspec が <code>empty least</code> とも <code>empty
greatest</code> とも指定されていなければ、<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title=
"default order for empty sequences" href=
"#dt-default-empty-order">空列に対するデフォルト順序付け</a>により、<code>empty
least</code> のためのルールと <code>empty greatest</code>
のためのルールのいずれが使われるか決定される。</p>
</li>
</ul>
<p>T1 と T2 を組ストリーム中の2つの組、これらの orderspec について (上で定義したように)
いずれかの値が他方の値に対して <em>greater-than</em> であるかを左から右に評価したときに得られた最初の値の組を
V1 と V2 とする。このとき:</p>
<ol class="enumar">
<li>
<p>V1 が V2 に対して <em>greater-than</em> であれば: orderspec が
<code>descending</code> と指定されていれば、T1 が T2
より組ストリーム中で前に来る。そうでない場合は、T2 が T1 より組ストリーム中で前に来る。</p>
</li>
<li>
<p>V2 が V1 に対して <em>greater-than</em> であれば: orderspce が
<code>descending</code> と指定されていれば、T2 が T1
より組ストリーム中で前に来る。そうでない場合は、T1 が T2 より組ストリーム中で前に来る。</p>
</li>
</ol>
<p>組 T1 と T2 の orderspec の任意の2つ組に対し、V1 も V2 も他方に対して
<em>greater-than</em> でない場合、以下のルールが適用される。</p>
<ol class="enumar">
<li>
<p><code>stable</code> が指定されていれば、組ストリーム中での T1 と T2 の元の順序が保存される。</p>
</li>
<li>
<p><code>stable</code> が指定されていなければ、組ストリーム中での T1 と T2 の順序は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>2つの orderspec が特別な浮動小数点数の値である正負の 0 を返せば、これらの値はいずれも他方に対して
<em>greater-than</em> ではない。なぜなら <code>+0.0 gt -0.0</code> と
<code>-0.0 gt +0.0</code> はいずれも <code>false</code> だからである。</p>
</div>
<p><code>order by</code> 節は、FLWOR 式の結果の整列を容易に行うことができる。整列のキーがその
FLWOR 式の結果に含まれていなくてもよい。例えば、以下の式は employee の名前を salary の降順に返すが、実際の
salary の値は返さない:</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $e in $employees 
order by $e/salary descending 
return $e/name</span>
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>FLWOR 式中の <code>order by</code> 節は XQuery
で値の整列を指定するために提供されている唯一の手段であるため、整列を行わないならば繰り返しが必要ないような問い合わせでも FLWOR
式を用いなければならない。例えば、price が 100 より小さい book
のリストは、<code>$books/book[price &lt; 100]</code> といった単純な<a title=
"path expression" href=
"#dt-path-expression">経路式</a>でも得ることができる。しかしこれらの book を title
のアルファベット順に返そうとすると、問合せは以下のように表現しなければならない:</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</span>
</pre></div>
</div>
<p>以下に示すのは、いろいろなオプションを用いた <code>order by</code> 節の例である。この例により、book
の集まりについて title を第1順序、price を第2順序として整列した結果が得られる。title
の順序付けには特定の<a title="collation" href=
"#dt-collation">照合順序</a>が指定されている。また、price の順序付けでは price のない book が
(可能な最小の値段を持つと考え) 最後に出現するように指定されている。同じ title と price を持つ2つの book
が出現した場合は、キーワード <code>stable</code> により、入力の順序が保存されることが示されている。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">for $b in $books/book
stable order by $b/title 
      collation "http://www.example.org/collations/fr-ca",
   $b/price descending empty least
return $b</span>
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>コンマ演算子を含む <code>return</code> 節では括弧が役に立つ。なぜなら FLWOR
式はコンマ演算より優先度が高いからである。例えば、以下の問い合わせはエラーを発生する。なぜならコンマの後ろでは、<code>$j</code>
は FLWOR 式の内側ではなく、未定義の変数であるからである:</p>
<div class="exampleInner">
<pre>
let $i := 5,
    $j := 20 * $i
return $i, $j
</pre></div>
<p><code>$j</code> を <code>return</code>
式の内側に持ってくるには、プログラマならおそらく意図した通りだろうが、括弧を用いることができる。</p>
<div class="exampleInner">
<pre>
let $i := 5,
    $j := 20 * $i
return ($i, $j)
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-flwor-example" id="id-flwor-example"></a>3.8.4
例</h4>
<p>以下に示すのは、FLWOR
式が入れ子にできるという例や、要素階層の複数の深さで順序付けを指定できるという例である。この例の問合せでは、文書階層を逆順にし、bibliograph
を author のリストに変換している。入力 (変数 <code>$bib</code> に束縛されている) は
<code>bib</code> 要素であり、これには book のリストが含まれる。それぞれの book にはさらに author
のリストが含まれる。この例は以下の入力に基づいている:</p>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>
以下の問合せは、入力文書を著者のリストに変換するものである。それぞれの著者について、名前が1回のみ出現し、次にその著者によって書かれた本のタイトルのリストが続く。<code>fn:distinct-values</code>
関数は、author 節点のリストから (値によって) 重複を取り除く関数である。author のリスト、およびそれぞれの
author によって出版された book のリストは、<a title="default collation" href=
"#dt-def-collation">デフォルト照合順序</a>を用いてアルファベット順で返される。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">&lt;authlist&gt;
 {
   for $a in fn:distinct-values($bib/book/author)
   order by $a
   return
     &lt;author&gt;
        &lt;name&gt; {$a} &lt;/name&gt;
        &lt;books&gt;
          {
            for $b in $bib/book[author = $a]
            order by $b/title
            return $b/title 
          }
        &lt;/books&gt;
     &lt;/author&gt;
 }
&lt;/authlist&gt;</span>
</pre></div>
<p>上の式の結果は次のようになる:</p>
<div class="exampleInner">
<pre>
&lt;authlist&gt;
   &lt;author&gt;
      &lt;name&gt;Abiteboul&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Buneman&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Stevens&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Advanced Programming
                in the Unix Environment&lt;/title&gt;
         &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Suciu&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
&lt;/authlist&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="id-unordered-expressions" id=
"id-unordered-expressions"></a>3.9 順序化式と非順序化式</h3>
<h5><a name="d2e13133" id="d2e13133"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderedExpr" id=
"doc-xquery-OrderedExpr"></a>[91]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"ordered" "{" <a href="#doc-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-UnorderedExpr" id=
"doc-xquery-UnorderedExpr"></a>[92]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnorderedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"unordered" "{" <a href="#doc-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
</table>
<p><code>順序化</code>式と<code>非順序化</code>式の目的は、問合せのある領域に対して<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"ordering mode" href="#dt-ordering-mode">順序付けモード</a>を
<code>ordered</code> や <code>unordered</code>
に設定することである。指定された順序付けモードは、波括弧の内側に入れ子になった式に対して適用される。結果の順序付けが明示されていない式に対しては、順序付けモードを
<code>unordered</code>
に設定し、最も効率的に得られる順序で結果を返すようなシステムの柔軟性を保証することにより、有利な処理性能が実現されるかもしれない。</p>
<p><a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>は以下の式の振舞いに影響を与える: "<code>/</code>" や
"<code>//</code>" 演算子、あるいは<a title="axis step" href=
"#dt-axis-step">軸ステップ</a>を含む<a title="path expression" href=
"#dt-path-expression">経路式</a>; <code>union</code>,
<code>intersect</code>, および <code>except</code> 式; the
<code>fn:id</code> and <code>fn:idref</code> functions; <code>order
by</code> 節を持たない FLWOR 式。順序付けモードが <code>ordered</code> であれば、経路式,
<code>union</code>, <code>intersect</code>, <code>except</code>
式などによって返される節点列は<a title="document order" href=
"#dt-document-order">文書順</a>である。そうでない場合は、これらの結果得られる節点列の順序は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。FLWOR
式上での順序付けモードの効果については<a href="#id-flwor-expressions"><b>3.8 FLWOR
式</b></a>で記述されている。重複の除去については、順序付けモードは効果がない。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>順序付けモードが <code>unordered</code>
であるような問合せの領域では、節点列の順序付けに依存するある種の関数は非決定的な結果を返してもよい。このような関数には、<code>fn:position</code>,
<code>fn:last</code>, <code>fn:index-of</code>,
<code>fn:insert-before</code>, <code>fn:remove</code>,
<code>fn:reverse</code>, <code>fn:subsequence</code>
がある。また、非順序化領域中の<a title="path expression" href=
"#dt-path-expression">経路式</a>では、<a title="numeric predicate" href=
"#dt-numeric-predicate">数述語</a>は非決定的である。例えば、順序化領域では、経路式
<code>(//a/b)[5]</code> は<a title="document order" href=
"#dt-document-order">文書順</a>で5番目に限量される <code>b</code>
要素を返す。非順序化領域では、同じ式は<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>で限量される <code>b</code>
要素を返す。</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>にあるように、<code>fn:id</code> 関数と
<code>fn:idref</code> 関数は、結果を<a title="document order" href=
"#dt-document-order">文書順</a>で返す。順序付けモードは XQuery の機能であるので、順序付けモードが
<code>unordered</code> のときに関数の結果に対する順序付けの要求を緩めることは、関数自身の機能というよりは
XQuery の機能である。</p>
</div>
<p><code>unordered</code> 式の使い方を以下の例で示す。この例は、2つの文書
<code>parts.xml</code> と <code>suppliers.xml</code>
を結合する、というものである。この例は、赤い部品 (part) の部品番号と、これらの部品を供給している供給者 (supplier)
の供給者番号を組にして返す。<code>unordered</code> 式を使わないならば、結果として得られる (部品番号,
供給者番号) のリストは、まず <code>parts.xml</code> の<a title="document order"
href="#dt-document-order">文書順</a>に、次に <code>suppliers.xml</code>
の<a title="document order" href=
"#dt-document-order">文書順</a>によって制御された順序付けを持つことが要求される。しかし、結果の順序が重要でないならば、これは、この問合せを処理する最も効率的な方法ではないかもしれない。XQuery
の実装は、索引を用いて赤い部品を見つけたり、結果の順序を制御するのに <code>suppliers.xml</code> を
<code>parts.xml</code>
よりも先に用いたりするなどして、問合せをより効率的に処理することができるかもしれない。<code>unordered</code>
式により、問合せ評価器はこれらの種類の最適化を自由に使える。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno  
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}</span>
</pre></div>
<p><code>ordered</code> 式と <code>unordered</code> 式に加え、XQuery は
<code>fn:unordered</code>
という名前の関数を用意している。これは任意の項目列に対して作用し、同じ列を非決定的な順序で返す。<code>fn:unordered</code>
関数の呼び出しは、実体化された引数の式に対して、システムがより効率的な順序を見つけてもよい、というある種の許可と考えてもよい。<code>fn:unordered</code>
関数は、その直接的な演算数の列に対してのみ順序付けを緩める。一方、<code>unordered</code>
式は、その演算数の式および入れ子になったすべての式に対して<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>を設定する。</p>
</div>
<div class="div2">
<h3><a name="id-conditionals" id="id-conditionals"></a>3.10
条件式</h3>
<p>XQueryはキーワード<code>if</code>, <code>then</code>,
<code>else</code>に基づく条件式を支援する。</p>
<h5><a name="d2e13365" id="d2e13365"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-IfExpr" id=
"doc-xquery-IfExpr"></a>[45]&nbsp;&nbsp;&nbsp;</td>
<td><code>IfExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"if" "(" <a href="#doc-xquery-Expr">Expr</a> ")" "then"
<a href="#doc-xquery-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>
キーワード<code>if</code>に続く式を<b>テスト式</b>という。またキーワード<code>then</code>や<code>else</code>に続く式をそれぞれ<b>then式</b>、<b>else式</b>という。</p>
<p>条件式を処理する最初の段階は、テスト式の<a title="effective boolean value" href=
"#dt-ebv">有効ブール値</a>を求めることである。これは<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>に定義されている通りである。</p>
<p>条件式の値は以下のように定義される:
テスト式の有効ブール値が<code>true</code>であれば、then式の値が返される。テスト式の有効ブール値が<code>false</code>であれば、else式の値が返される。</p>
<p>条件式には、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>の伝搬に関する特別なルールがある。テスト式の有効値が<code>true</code>であれば、条件式は、else式から起こる動的エラーをすべて無視する
(発生させない)。この場合、else式は観測可能な作用を持たなくてもよいため、評価される必要はない。同様に、テスト式の有効値が<code>false</code>であれば、条件式は、then式から起こる<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>をすべて無視し、then式は評価される必要はない。</p>
<p>以下に、条件式の例をいくつか示す。</p>
<ul>
<li>
<p>この例では、テスト式は比較式である。</p>
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre></div>
</li>
<li>
<p>
この例では、テスト式は<code>discounted</code>という属性の有無を調べている。その属性の値には依存しない。</p>
<div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>3.11 限量式</h3>
<p>
限量式は存在限量子と全称限量子を支援する。限量式の値は常に<code>true</code>か<code>false</code>である。</p>
<h5><a name="d2e13456" id="d2e13456"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-QuantifiedExpr" id=
"doc-xquery-QuantifiedExpr"></a>[42]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuantifiedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xquery-VarName">VarName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xquery-VarName">VarName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N145B3.doc-xquery-TypeDeclaration" id=
"noid_N145B3.doc-xquery-TypeDeclaration"></a>[118]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"as" <a href=
"#doc-xquery-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>
<b>限量式</b>は<b>限量子</b>で始まる。これはキーワード<code>some</code>か<code>every</code>である。これに1つ以上のin節が続き、変数を束縛するのに用いられる。さらにキーワード<code>satisfies</code>とテスト式が続く。各in節は、項目の列を返す式に変数を関連づける。この列のことを、その変数に対する<b>束縛列</b>という。in節は変数束縛の組を生成する。これには、それぞれの変数に対する束縛列中の項目の組み合わせ各々に対応する組が含まれる。概念的には、テスト式は、変数束縛の組それぞれについて評価される。結果はテスト式の<a title="effective boolean value"
href="#dt-ebv">有効ブール値</a>に依存する。これは<a href="#id-ebv"><b>2.4.3
有効ブール値</b></a>で定義されている通りである。限量式の値は以下のルールによって定義される。</p>
<ol class="enumar">
<li>
<p>限量子が<code>some</code>であれば、限量式は、テスト式の評価のうち少なくとも1つが<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>
<code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>false</code>であることが分かる。</p>
</li>
<li>
<p>限量子が<code>every</code>であれば、限量式は、テスト式の評価がすべて<a title=
"effective boolean value" href="#dt-ebv">有効ブール値</a>
<code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>true</code>であることが分かる。</p>
</li>
</ol>
<p>
限量式中で束縛された変数の有効範囲は、その限量式の部分式のうちその変数束縛の後ろで出現したものすべてから構成される。有効範囲にはその変数が束縛される式は含まれない。</p>
<p class="xquery">限量式の in 節で束縛された変数はそれぞれ、省略可能な<a href=
"#doc-xquery-TypeDeclaration">型宣言</a>を持つ。変数に束縛された値の型が、<a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType
の照合</a>のルールに従って、宣言された型と照合されないならば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>テスト式がさまざまな変数束縛組に対して評価される順序は<a title="implementation dependent"
href=
"#dt-implementation-dependent">実装依存</a>である。限量子が<code>some</code>であれば、実装は、テスト式が<code>true</code>という<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>を持つ束縛組を1つ見つけたら直ちに<code>true</code>を返してもよい。また、テスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。同様に、限量式が<code>every</code>であれば、実装は、テスト式が<code>false</code>という<a title="effective boolean value"
href=
"#dt-ebv">有効ブール値</a>を持つ束縛組を1つ見つけたら直ちに<code>false</code>を返してよい。またテスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<a title="dynamic error"
href=
"#dt-dynamic-error">動的エラー</a>を発生してもよい。これらのルールの結果として、以下の例で示すように、限量式の値は、エラーが存在する場合には決定的ではない。</p>
<p>以下に、限量式の例をいくつか示す。</p>
<ul>
<li>
<p>この式は、すべての<code>part</code>要素が<code>discounted</code>属性を持つならば
(これらの属性の値に関わらず)、<code>true</code>である。</p>
<div class="exampleInner">
<pre>
every $part in /parts/part satisfies $part/@discounted
</pre></div>
</li>
<li>
<p>
この式は、少なくとも1つの<code>employee</code>要素が与えられた比較式を満たすならば<code>true</code>である。</p>
<div class="exampleInner">
<pre>
some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</li>
<li>
<p>以下の例では、各限量式がテスト式を9つの変数束縛の組上で評価する。9つの変数束縛とは、列<code>(1, 2,
3)</code>と<code>(2, 3,
4)</code>の直積から構成される。<code>some</code>で始まる式を評価すると<code>true</code>であり、<code>every</code>で始まる式を評価すると<code>false</code>である。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span>
</pre></div>
<div class="exampleInner">
<pre>
<span class="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span>
</pre></div>
</li>
<li>
<p>この限量式は<code>true</code>を返すか、<a title="type error" href=
"#dt-type-error">型エラー</a>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>true</code>を返し、別の変数束縛に対して<a title="type error"
href="#dt-type-error">型エラー</a>を発生するからである。</p>
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>この限量式は<code>false</code>を返すか<a title="type error" href=
"#dt-type-error">型エラー</a>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>false</code>を返し、別の変数束縛に対して<a title="type error"
href="#dt-type-error">型エラー</a>を発生するからである。</p>
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
<li>
<p>この限量式は、テスト式中の項目いずれでも満たされない<a href=
"#doc-xquery-TypeDeclaration">型宣言</a>を含む。<a title=
"static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が実装されていれば、この式は、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>で<a title="type error" href=
"#dt-type-error">型エラー</a>を発生する。そうでない場合は、この式は<code>true</code>を返してもよいし、
or raise a <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>で<a title="type error" href=
"#dt-type-error">型エラー</a>を発生してもよい。</p>
<div class="exampleInner">
<pre>
some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-expressions-on-datatypes" id=
"id-expressions-on-datatypes"></a>3.12 SequenceTypes上の式</h3>
<p><span class="xquery">関数の引数や結果で使われるのに加えて、</span><a title=
"sequence type" href="#dt-sequence-type">列型</a>は<code>instance
of</code>式, <span class="xquery"><code>typeswitch</code>,</span>
<code>cast</code>式, <code>castable</code>式,
<code>treat</code>式で使われている。</p>
<div class="div3">
<h4><a name="id-instance-of" id="id-instance-of"></a>3.12.1
Instance Of</h4>
<h5><a name="d2e13751" id="d2e13751"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-InstanceofExpr" id=
"doc-xquery-InstanceofExpr"></a>[54]&nbsp;&nbsp;&nbsp;</td>
<td><code>InstanceofExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-TreatExpr">TreatExpr</a> (
"instance" "of" <a href="#doc-xquery-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>ブール演算子<code>instance of</code>は、第1演算数の値が第2演算数の<a href=
"#doc-xquery-SequenceType">SequenceType</a>に照合されるとき、<code>true</code>を返す。これは<a title="SequenceType matching"
href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>にあるルールに従う。そうでない場合は<code>false</code>を返す。例えば:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が与えられた型のインスタンスであるからである。</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>
この例は<code>true</code>を返す。なぜなら与えられた値が整数リテラルで、<code>xs:integer</code>が制限によって<code>xs:decimal</code>から導出されるからである。</p>
</li>
<li>
<p><code>&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code></p>
<p>この例は <code>false</code> を返す。なぜなら与えられた値は要素であり整数ではないからである。</p>
</li>
<li>
<p><code>(5, 6) instance of xs:integer+</code></p>
<p>
この例は<code>true</code>を返す。なぜなら与えられた列は2つの整数を含んでおり、指定された型の正しいインスタンスであるからである。</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>
文脈項目が要素節点のとき、この例は<code>true</code>を返す。文脈項目が定義されているが要素節点ではないとき、この例は<code>false</code>を返す。文脈項目が未定義であれば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0002"
href="#ERRXPDY0002">err:XPDY0002</a>]。</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-typeswitch" id="id-typeswitch"></a>3.12.2
Typeswitch</h4>
<h5><a name="d2e13843" id="d2e13843"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TypeswitchExpr" id=
"doc-xquery-TypeswitchExpr"></a>[43]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeswitchExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"typeswitch" "(" <a href="#doc-xquery-Expr">Expr</a> ")"
<a href="#doc-xquery-CaseClause">CaseClause</a>+ "default" ("$"
<a href="#doc-xquery-VarName">VarName</a>)? "return" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CaseClause" id=
"doc-xquery-CaseClause"></a>[44]&nbsp;&nbsp;&nbsp;</td>
<td><code>CaseClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"case" ("$" <a href="#doc-xquery-VarName">VarName</a>
"as")? <a href="#doc-xquery-SequenceType">SequenceType</a> "return"
<a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TypeswitchExpr" id=
"doc-xquery-TypeswitchExpr"></a>[43]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeswitchExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"typeswitch" "(" <a href="#doc-xquery-Expr">Expr</a> ")"
<a href="#doc-xquery-CaseClause">CaseClause</a>+ "default" ("$"
<a href="#doc-xquery-VarName">VarName</a>)? "return" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CaseClause" id=
"doc-xquery-CaseClause"></a>[44]&nbsp;&nbsp;&nbsp;</td>
<td><code>CaseClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"case" ("$" <a href="#doc-xquery-VarName">VarName</a>
"as")? <a href="#doc-xquery-SequenceType">SequenceType</a> "return"
<a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p class="xquery"><b>typeswitch</b> 式は、入力値の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>を基に、いくつかの式から評価すべき式を1つ選ぶ。</p>
<p class="xquery"><code>typeswitch</code> 式では、キーワード
<code>typeswitch</code>
の次に括弧で囲まれた式が続く。この式を<b>演算数式</b>という。これは、その型がテストされる式である。<code>typeswitch</code>
式の残りの部分は、1つ以上の <code>case</code> 節と <code>default</code>
節1つから成る。</p>
<p class="xquery"><code>case</code> 節はそれぞれ、<a href=
"#doc-xquery-SequenceType">SequenceType</a> の次に <code>return</code>
式を1つ指定する。 [<a name="dt-effective-case" id="dt-effective-case"
title="effective case">Definition</a>: <code>typeswitch</code>
式の<b>有効な case</b>は、演算数式の値が <code>case</code> 節中の<a href=
"#doc-xquery-SequenceType">SequenceType</a> に照合されるような
<code>case</code> 節のうち最初のものである。照合には<a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceTypeの照合</a>のルールが用いられる。]
<code>typeswitch</code> 式の値は、有効な case 中の <code>return</code>
式の値である。演算数式の値がどの <code>case</code> 節の <a href=
"#doc-xquery-SequenceType">SequenceType</a>
にも照合されなければ、<code>typeswitch</code> 式の値は <code>default</code> 節の
<code>return</code> 式の値である。</p>
<p><code>case</code> 節や <code>default</code>
節では、返すべき値が演算数式の値に依存していれば、その節は変数名を指定しなければならない。<code>case</code> 節や
<code>default</code> 節の <code>return</code>
式中では、この変数名は演算数式の値に束縛される。<code>case</code> 節の中では、変数の<a title=
"static type" href="#dt-static-type">静的型</a>は <code>case</code>
節で名付けられている <a href="#doc-xquery-SequenceType">SequenceType</a>
である。<code>default</code>
節の中では、変数の静的型は演算数式の静的型と等しい。<code>case</code> 節や <code>default</code>
節で返される値が演算数式の値に依存しないならば、その節で変数を指定する必要はない。</p>
<p>The scope of a variable binding in a <code>case</code> 節や
<code>default</code> 節中の変数束縛の有効範囲は、その節からなる。同じ
<code>typeswitch</code> 式中の2つ以上の <code>case</code> 節や
<code>default</code> 節に対して同じ名前の変数を束縛しても、エラーではない。</p>
<p><code>typeswitch</code> 式での<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を伝搬させる際には特別なルールが適用される。<code>typeswitch</code>
式は<a title="effective case" href="#dt-effective-case">有効な
case</a>以外の <code>case</code> 節で発生する動的エラーをいずれも無視する
(発生させない)。<code>default</code> 節で発生する動的エラーは、<a title=
"effective case" href="#dt-effective-case">有効な
case</a>がない場合にのみ発生する。</p>
<p class="xquery">以下に示すのは、式の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>に依存してその式を処理するのに、<code>typeswitch</code>
式を用いている例である。</p>
<div class="exampleInner">
<pre>
<span class="parse-test">typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"</span>
</pre></div>
</div>
<div class="div3">
<h4><a name="id-cast" id="id-cast"></a>3.12.3 Cast</h4>
<h5><a name="d2e14071" id="d2e14071"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CastExpr" id=
"doc-xquery-CastExpr"></a>[57]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xquery-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SingleType" id=
"doc-xquery-SingleType"></a>[117]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>
場合によっては、値を指定されたデータ型に変換する必要が生じる。この目的のため、XQueryは<code>cast</code>式を用意している。これは、すでにある値に基づき、指定された型の値を新たに生成する。<code>cast</code>式は2つの演算数を取る。<b>入力式</b>と<b>目的型</b>である。入力式の型を<b>入力型</b>という。目的型は原子型で、<a title="in-scope schema type"
href=
"#dt-is-types">有効範囲内スキーマ型</a>に含まれており、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また原子型の後ろに出現標識
"<code>?</code>" を置き、空列を許すということを示してもよい [<a title="err:XPST0080"
href=
"#ERRXPST0080">err:XPST0080</a>]。目的型が名前空間接頭辞を持たないならば、その目的型は<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>に属するとみなされる。<code>cast</code>式の意味は以下の通りである。</p>
<ol class="enumar">
<li>
<p><a title="atomization" href=
"#dt-atomization">原子化</a>が入力式に対して行われる。</p>
</li>
<li>
<p>原子化の結果が長さ1より大きい原子値の列であれば、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
<li>
<p>原子化の結果が空列であれば:</p>
<ol class="enumla">
<li>
<p>目的型の後ろに<code>?</code>が指定してあれば、<code>cast</code>式の結果は空列である。</p>
</li>
<li>
<p>目的型の後ろに<code>?</code>が指定してなければ、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
</li>
</ol>
</li>
<li>
<p>
原子化の結果が単一の原子値であれば、cast式の結果は入力型と目的型に依存する。一般的に、cast式は、入力値に基づき目的型の値を新たに生成しようと試みる。ある種の入力型と目的型の組み合わせだけが支援されている。このルールの概要を以下に列挙する。これらのルールの規範的定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。これらのルールの目的のため、実装は、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>を検査したり、あるいはその代替としてデータ辞書のような<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の機構を用いて、ある型が別の型から制限によって導出されると決定してもよい。</p>
<ol class="enumla">
<li>
<p><code>cast</code>は、<a href=
"http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1
Casting from primitive types to primitive types</a><sup xmlns=
""><small>FO</small></sup>に列挙されている入力型と目的型の組み合わせに対して支援される。これらの組み合わせそれぞれについて、入力型と目的型は基本<a title="schema type"
href=
"#dt-schema-type">スキーマ型</a>である。例えば、<code>xs:string</code>型の値はスキーマ型<code>xs:decimal</code>に型変換することができる。これらの組み込みの組み合わせについては、型変換の意味が<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>で指定されている。</p>
<p>
<code>cast</code>式の目的型が<code>xs:QName</code>であるか、<code>xs:QName</code>または<code>xs:NOTATION</code>から導出される型であるか、入力の基礎型が目的型の基礎型と等しくないならば、入力式は文字列リテラルでなければならない
[<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
このルールの理由は、これらの目的型の1つのインスタンスを文字列から構成するには名前空間の束縛に関する知識が必要になる、ということである。入力式がリテラルでない文字列であれば、名前空間の束縛が<a title="statically known namespaces"
href="#dt-static-namespaces">静的既知名前空間</a>と異なる入力文書から導出されるかもしれない。</p>
</div>
</li>
<li>
<p>
<code>cast</code>は、入力型が基本でない原子型で、目的型から制限によって導出される場合に支援される。この場合、入力値は目的型の値空間に写像され、その型以外には変更されない。例えば、<code>shoesize</code>が制限によって<code>xs:integer</code>から導出されるならば、型<code>shoesize</code>の値はスキーマ型<code>xs:integer</code>に型変換することができる。</p>
</li>
<li>
<p>
<code>cast</code>は、目的型が基本でない原子型で、入力型が<code>xs:string</code>または<code>xs:untypedAtomic</code>である場合に支援される。入力値はまず、目的型に対する空白の正規化ルールを適用する（<a href="#XMLSchema">[XML
Schema]</a>で定義されているように）ことで、目的型の字句空間中の値に変換される。結果の字句値が目的型のパターンの相
(facet) を満たさないならば、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a> [err:FORG0001]
が発生する。次に字句値は、目的型のスキーマ定義ルールを用いて、目的型の値空間に変換される。結果の値が目的型のすべての相を満たさないならば、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a> [err:FORG0001] が発生する。</p>
</li>
<li>
<p>
<code>cast</code>は、目的型が基本型でない原子型であり、かつ入力型から制限によって導出されるならば、支援される。入力値は目的型のすべての相を満たさなければならない
(パターンの相の場合には、これは、<code>xs:string</code>への型変換ルールを用いて、入力値の文字列表現を生成することで検査される)。結果の値は入力値と等しい。ただし<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>は異なる。</p>
</li>
<li>
<p>基本型 P1 が基本型 P2 に型変換されるならば、制限によって P1 から導出される任意の型は、制限によって P2
から導出される任意の型に型変換できる。そして、目的型の相が満たされると規定される。まず、上のルール (b) を用いて、入力値が P1
に型変換される。次に、上のルール (a) を用いて、P1 型の値が P2 型に変換される。最後に、上のルール (d) を用いて、P2
型の値が目的型に変換される。</p>
</li>
<li>
<p>上に列挙されていない入力型と目的型の組み合わせに対して、<code>cast</code>式は<a title=
"type error" href="#dt-type-error">型エラー</a> [<a title=
"err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]を発生する。</p>
</li>
</ol>
</li>
</ol>
<p>
入力型から目的型への型変換が支援されているが、にもかかわらず入力値を目的型の値空間に型変換することが不可能であれば、<a title=
"dynamic error" href="#dt-dynamic-error">動的エラー</a>が発生する。
[err:FORG0001] これは、目的型のどの相も満たされない場合を含む。例えば、式<code>"2003-02-31" cast
as xs:date</code>は<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>を発生する。</p>
</div>
<div class="div3">
<h4><a name="id-castable" id="id-castable"></a>3.12.4 Castable</h4>
<h5><a name="d2e14291" id="d2e14291"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CastableExpr" id=
"doc-xquery-CastableExpr"></a>[56]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastableExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#doc-xquery-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N14900.doc-xquery-SingleType" id=
"noid_N14900.doc-xquery-SingleType"></a>[117]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>XQueryは、与えられた値が与えられた目的型に型変換可能かテストする式を用意している。目的型は原子型で、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>に含まれていなければならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また、空列を許すことを示すために出現標識
"<code>?</code>" を後ろに付けることができる [<a title="err:XPST0080" href=
"#ERRXPST0080">err:XPST0080</a>]。式<code>V castable as
T</code>が<code>true</code>を返すのは、<code>cast</code>式を用いて値<code>V</code>が目的型<code>T</code>に型変換することに成功する場合である。そうでない場合は<code>false</code>を返す。<code>castable</code>式を<a title="predicate"
href=
"#dt-predicate">述語</a>として用い、評価時のエラーを避けることも可能である。また、適切な型を選択して与えられた値を処理することにも利用できる。以下に例を示す。</p>
<div class="exampleInner">
<pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</pre></div>
</div>
<div class="div3">
<h4><a name="id-constructor-functions" id=
"id-constructor-functions"></a>3.12.5 構成子関数</h4>
<p><a title="in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中の原子型それぞれについて
(<code>xs:NOTATION</code>および<code>xs:anyAtomicType</code>を除く。これらはインスタンスを生成できない)、<b>構成子関数</b>が暗黙的に定義される。それぞれの場合について、構成子関数の名前は目的型の名前
(名前空間を含む)と同じである。型<em>T</em>の構成子関数のシグネチャは以下の通りである。</p>
<div class="exampleInner">
<pre>
<em>T</em>($arg as xs:anyAtomicType?) as <em>T?</em>
</pre></div>
<p>[<a name="dt-constructor-function" id="dt-constructor-function"
title="constructor function">Definition</a>:
与えられた型に対する<b>構成子関数</b>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数
<code>T($arg)</code>の意味は式<code>($arg cast as
T?)</code>と同じであると定義される。]</p>
<p>
<code>xs:QName</code>、あるいは<code>xs:QName</code>や<code>xs:NOTATION</code>から導出される型に対する構成子関数では、文字列リテラルの引数か、目的型の基礎型と同じ基礎型を持つ引数を要求する。そうでない場合は型エラー
[<a title="err:XPST0004" href="#ERRXPST0004">err:XPST0004</a>]
が発生する。このルールは、<a href="#id-cast"><b>3.12.3
Cast</b></a>に定義されているこれらの型に対する<code>cast</code>式の意味と一貫している。</p>
<p>構成子関数の使い方を以下の例で示す。</p>
<ul>
<li>
<p>この例は<code>("2000-01-01" cast as xs:date?)</code>に等しい。</p>
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</li>
<li>
<p>この例は<code>(($floatvalue * 0.2E-5) cast as
xs:decimal?)</code>に等しい。</p>
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</li>
<li>
<p>
この例は、21日に等しい<code>xs:dayTimeDuration</code>の値を返す。これは<code>("P21D"
cast as xs:dayTimeDuration?)</code>と同値である。</p>
<div class="exampleInner">
<pre>
xs:dayTimeDuration("P21D")
</pre></div>
</li>
<li>
<p><code>usa:zipcode</code>がユーザ定義の原子型であり<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中にあるならば、以下の式は、式<code>("12345" cast as
usa:zipcode?)</code>と同値である。</p>
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>名前空間中にない原子型のインスタンスは、以下のいずれかの方法で構成することができる。</p>
<ul>
<li>
<p>もし<a title="default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>が "none"
であれば、<code>cast</code>式を用いる。<span class="xquery">(<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>の定義を取り消す方法については、<a href=
"#id-default-namespace"><b>4.13 デフォルト名前空間宣言</b></a>を見よ。)</span></p>
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</li>
<li>
<p>もし<a title="default function namespace" href=
"#dt-def-fn-ns">デフォルト関数名前空間</a>が "none" であれば、構成子関数を用いる。<span class=
"xquery">(<a title="default function namespace" href=
"#dt-def-fn-ns">デフォルト関数名前空間</a>を取り消す方法については、<a href=
"#id-default-namespace"><b>4.13 デフォルト名前空間宣言</b></a>を見よ。)</span></p>
<div class="exampleInner">
<pre>
apple(17)
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-treat" id="id-treat"></a>3.12.6 Treat</h4>
<h5><a name="d2e14490" id="d2e14490"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-TreatExpr" id=
"doc-xquery-TreatExpr"></a>[55]&nbsp;&nbsp;&nbsp;</td>
<td><code>TreatExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xquery-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>XQueryは<code>treat</code>と呼ばれる式を用意している。これは、演算数の<a title=
"static type" href="#dt-static-type">静的型</a>を変更するのに用いることができる。</p>
<p><code>cast</code>のように、<code>treat</code>式は2つの演算数をとる。式と<a href=
"#doc-xquery-SequenceType">SequenceType</a>である。しかし、<code>cast</code>とは異なり、<code>treat</code>はその演算数の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>や値は変更しない。そのかわり、<code>treat</code>の目的は、式が評価時に期待される動的型を持つことを保証することである。</p>
<p><em><code>expr1</code></em> <code>treat as</code>
<em><code>type1</code></em>の意味は以下の通りである。</p>
<ul>
<li>
<p>静的解析時:</p>
<p><code>treat</code>式の<a title="static type" href=
"#dt-static-type">静的型</a>は<em><code>type1</code></em>である。これにより、<em><code>type1</code></em>の引数を必要とする関数の引数として、その式を用いることが可能となる。</p>
</li>
<li>
<p>式の評価時:</p>
<p><a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のルールを用いて<em><code>expr1</code></em>が<em><code>type1</code></em>と照合されるならば、<code>treat</code>式は<em><code>expr1</code></em>の値を返す。そうでない場合は<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a> [<a title="err:XPDY0050" href=
"#ERRXPDY0050">err:XPDY0050</a>]が発生する。<em><code>expr1</code></em>の値が返るならば、その識別性は保存される。<code>treat</code>式は、その式の演算数の値が実行時に期待される型にしたがうことを保証する。</p>
</li>
<li>
<p>例:</p>
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
<p><code>$myaddress</code>の<a title="static type" href=
"#dt-static-type">静的型</a>は<code>element(*,
Address)</code>であってもよい。これは<code>element(*,
USAddress)</code>より詳しくない型である。しかし実行時には、<code>$myaddress</code>の値は、<a title="dynamic error"
href=
"#dt-dynamic-error">SequenceTypeの照合</a>のルールを用いて、型<code>element(*,
USAddress)</code>に照合されなければならない。そうでない場合は<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XPDY0050"
href="#ERRXPDY0050">err:XPDY0050</a>]。</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-validate" id="id-validate"></a>3.13 検証式</h3>
<h5><a name="d2e14630" id="d2e14630"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ValidateExpr" id=
"doc-xquery-ValidateExpr"></a>[63]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValidateExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"validate" <a href=
"#doc-xquery-ValidationMode">ValidationMode</a>? "{" <a href=
"#doc-xquery-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ValidationMode" id=
"doc-xquery-ValidationMode"></a>[64]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValidationMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
</table>
<p><code>validate</code> 式は、<a href="#XMLSchema">[XML
Schema]</a>に定義されているスキーマ検証処理を用いて、文書節点や要素節点を<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に関して検証するのに用いることができる。<code>validate</code>
式の演算数を評価した結果が正確に1つの文書節点もしくは要素節点にならない場合は、<a title="type error" href=
"#dt-type-error">型エラー</a>が発生する [<a title="err:XQTY0030" href=
"#ERRXQTY0030">err:XQTY0030</a>]。この仕様では、<code>validate</code>
式の演算数である節点を<b>演算数節点</b>という。</p>
<p><code>validate</code>
式は新しい節点を1つ返す。この節点は固有の識別性を持ち、また親を持たない。新しい節点とその子孫には、演算数節点に検証処理を適用した結果生成される<a title="type annotation"
href=
"#dt-type-annotation">型注釈</a>が付けられている。ある場合には、検証処理によってデフォルト値も生成されるかもしれない。</p>
<p><code>validate</code> 式は、省略可能な<a href=
"#doc-xquery-ValidationMode">検証モード</a>を指定してもよい。デフォルトの<a href=
"#doc-xquery-ValidationMode">検証モード</a>は <code>strict</code>
である。<code>validate</code> 式の結果は以下のルールによって定義される:</p>
<ol class="enumar">
<li>
<p>
演算数節点が文書節点であれば、その子は要素節点1つ、および0個以上のコメント節点や処理命令節点から構成されなければならない。それらの順序は任意である。これ以外の場合には、<a title="dynamic error"
href="#dt-dynamic-error">動的エラー</a> [<a title="err:XQDY0061" href=
"#ERRXQDY0061">err:XQDY0061</a>] が発生する。</p>
</li>
<li>
<p><a href="#datamodel">[XQuery/XPath Data Model (XDM)]</a>で定義される
"情報集合への写像" ルールに従って、演算数節点が XML 情報集合 (<a href="#XINFO">[XML
Infoset]</a>) に変換される。この処理によって、すでに存在する<a title="type annotation"
href="#dt-type-annotation">型注釈</a>はすべて捨てられることに注意せよ。</p>
</li>
<li>
<p>結果として得られる情報集合の根要素の情報項目上で、妥当性評価が実行される。このとき、<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>が有効スキーマとして用いられる。妥当性評価の処理は、有効スキーマによって必要とされる範囲に含まれる要素や属性に対して再帰的に適用される。妥当性評価の間、以下の特別なルールが有効となる:</p>
<ol class="enumla">
<li>
<p><a href="#doc-xquery-ValidationMode">検証モード</a>が
<code>strict</code> であれば、<a title="in-scope element declarations"
href=
"#dt-is-elems">有効範囲内要素定義</a>中の最上位要素定義に、情報集合の根要素の情報項目と照合されるものが存在しなければならない。そしてスキーマ妥当性評価が
<a href="#XMLSchema">[XML Schema]</a> Part 1, 5.2節, "スキーマ妥当性の評価"
の2項に一致した宣言を用いて実行される。このような要素宣言がなければ、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0084" href=
"#ERRXQDY0084">err:XQDY0084</a>]。</p>
</li>
<li>
<p><a href="#doc-xquery-ValidationMode">検証モード</a>が <code>lax</code>
であれば、<a href="#XMLSchema">[XML Schema]</a> Part 1, 5.2節,
"スキーマ妥当性の評価" の3項の通りにスキーマ妥当性評価が実行される。</p>
<p><a href="#doc-xquery-ValidationMode">検証モード</a>が <code>lax</code>
であり、根要素の情報項目が最上位要素定義にも <code>xsi:type</code> 属性にもない場合、<a href=
"#XMLSchema">[XML Schema]</a>
では、子や属性を再帰的に検査する方法がオプションとして定義されている。XQuery の <code>validate</code>
式の処理では、この再帰的な検査が必要とされる。</p>
</li>
<li>
<p>演算数節点が要素節点であれば、"Validation Root Valid (ID/IDREF)" や
"Identity-constraint Satisfied"
と名付けられた検証ルールは適用されない。この意味するところは、文書レベルの一意性や参照一貫性に関する制約は強制されない、ということである。</p>
</li>
<li>
<p>文書中に含まれる解析対象外実体について、その名前が <code>xs:ENTITY</code> 型もしくは
<code>xs:ENTITIES</code> 型の節点の値に照合されるかどうかの検査は行われない。</p>
</li>
<li>
<p>文書中に含まれる記法について、その名前が <code>xs:NOTATION</code>
型の節点の値と照合されるかどうかの検査は行われない。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>妥当性評価は、検証される要素に <code>xsi:type</code>
属性があるかどうかによって影響を受ける。また妥当性評価によって、デフォルト属性のように新しい情報項目が生成されてもよい。</p>
</div>
</li>
<li>
<p>次のステップは、<a href=
"#doc-xquery-ValidationMode">検証モード</a>、および検証処理の結果として得られる PSVI
中の根要素の情報項目の <code>validity</code> 性質に依存する。</p>
<ol class="enumla">
<li>
<p>根要素の情報項目の <code>validity</code> 性質が <code>valid</code>
(どの<a href="#doc-xquery-ValidationMode">検証モード</a>についても)
であるか、<a href="#doc-xquery-ValidationMode">検証モード</a>が
<code>lax</code> かつ根要素の情報項目の <code>validity</code> 性質が
<code>notKnown</code> であれば、<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a> 3.3節, "PSVI からの構成" にある通り、PSVI が <a title=
"XDM instance" href="#dt-data-model-instance">XDM
インスタンス</a>に逆変換される。結果として得られる節点 (演算数節点と同じ種類の新しい節点) が
<code>validate</code> 式の結果として返される。</p>
</li>
<li>
<p>そうでない場合は、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>が発生する [<a title="err:XQDY0027" href=
"#ERRXQDY0027">err:XQDY0027</a>]。</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>これらのルールの効果は以下の通りである: <a href=
"#doc-xquery-ValidationMode">検証モード</a>が <code>strict</code>
であれば、検証された要素は有効スキーマ中に最上位要素の宣言を持っていなければならず、かつこの宣言に従わなければならない。<a href="#doc-xquery-ValidationMode">検証モード</a>が
<code>lax</code>
であれば、検証された要素は、その最上位要素の宣言が有効スキーマ中にあるならば、それに従わなければならない。<a href=
"#doc-xquery-ValidationMode">検証モード</a>が <code>lax</code>
であり、かつその要素の最上位要素宣言がなく、かつその要素が <code>xsi:type</code> 属性を持っている場合は、その
<code>xsi:type</code>
属性が有効スキーマ中の最上位要素の型定義を名前付けしなければならず、要素はその型に従わなければならない。検証された要素は、演算数節点もしくは
(演算数節点が文書節点の場合は) その子要素に一致する。</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>検証後に PSVI を <a title="XDM instance" href=
"#dt-data-model-instance">XDM インスタンス</a>に変換するとき、要素の情報項目のうち、その
validity 性質が <code>notKnown</code> であるものはいずれも、<a title=
"type annotation" href="#dt-type-annotation">型注釈</a>
<code>xs:anyType</code> のついた要素節点に変換される。また属性の情報項目のうち、その validity 性質が
<code>notKnown</code> であるものはいずれも、<a title="type annotation" href=
"#dt-type-annotation">型注釈</a> <code>xs:untypedAtomic</code>
のついた属性節点に変換される。これについては<a href=
"http://www.w3.org/TR/xpath-datamodel/#PSVI2NodeTypes">3.3.1.1
Element and Attribute Node Type Names</a><sup xmlns=
""><small>DM</small></sup>にある通りである。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-extension-expressions" id=
"id-extension-expressions"></a>3.14 拡張式</h3>
<p>[<a name="dt-extension-expression" id="dt-extension-expression"
title="extension expression">Definition</a>:
<b>拡張式</b>は、意味が<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>であるような式である。]
通常、拡張は、ある実装では認識されるが、別の実装では認識されない。拡張式の構文は、この式の構文解析はすべての実装で成功し、拡張を認識しない実装に対しては、それを処理できないときの振舞いが定義できるように設計されている。</p>
<h5><a name="d2e14901" id="d2e14901"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ExtensionExpr" id=
"doc-xquery-ExtensionExpr"></a>[65]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExtensionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Pragma">Pragma</a>+ "{" <a href=
"#doc-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Pragma" id=
"doc-xquery-Pragma"></a>[66]&nbsp;&nbsp;&nbsp;</td>
<td><code>Pragma</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(#" <a href="#prod-xquery-S">S</a>? <a href=
"#prod-xquery-QName">QName</a> <a href=
"#doc-xquery-PragmaContents">PragmaContents</a> "#)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PragmaContents" id=
"doc-xquery-PragmaContents"></a>[67]&nbsp;&nbsp;&nbsp;</td>
<td><code>PragmaContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
</table>
<p>拡張式は1個以上の <b>pragmas</b> からなり、これらの後ろには波括弧で囲まれた式が1つ続く。 [<a name=
"dt-pragma" id="dt-pragma" title="pragma">Definition</a>:
<b>pragma</b> は区切り記号 <code>(#</code> と <code>#)</code>
によって表され、識別可能な QName の次に<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の内容が続く。] pragma の内容は終了の区切り記号
<code>#)</code> を含まない任意の文字列からなる。pragma の QName は、<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて名前空間 URI と局所名に解決されなければならない
[<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>pragma に対するデフォルト名前空間はない。</p>
</div>
<p>実装はそれぞれ、pragma を表すのに用いられる名前空間 URI の<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の集合を認識しなければならない。</p>
<p>pragma の QName の名前空間部分が pragma の名前空間として実装に認識されなければ、その pragma
は無視される。<a href="#doc-xquery-ExtensionExpr">ExtensionExpr</a>中の
pragma がすべて無視されれば、<a href=
"#doc-xquery-ExtensionExpr">ExtensionExpr</a>の値は、波括弧で囲まれた式の値に等しい。この式がなければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0079"
href="#ERRXQST0079">err:XQST0079</a>]。</p>
<p>実装が <a href="#doc-xquery-ExtensionExpr">ExtensionExpr</a> 中の
pragma を1個以上認識するならば、<a href=
"#doc-xquery-ExtensionExpr">ExtensionExpr</a>
の値は、エラーに対する振舞いも含め、<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。例えば、ある実装が pragma の QName
の名前空間は認識するが、その QName の局所名は認識しない場合、エラーを発生させてもよいし、その pragma
を無視してもよい。</p>
<p>実装が pragma を認識するが、その内容が正当でないと決定した場合は、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XQST0013" href=
"#ERRXQST0013">err:XQST0013</a>] である。</p>
<p>実装が pragma
を認識するならば、実装は、それに続く式中の任意の静的エラーを報告しなければならない。これは、その式が評価されない場合でもあてはまる
(ただし静的型エラーを発生させるのは、<a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>が有効である場合だけである)。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>以下に、拡張式が用いられる方法を3通り、例として示す。</p>
<ul>
<li>
<p>pragma
は以下の式をどのように評価するかについてのヒントを与えるのに用いられる。結果は実際には変更されない。例えば:</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</pre></div>
<p><code>exq:use-index</code> pragma
を認識する実装では、以下に続く式を評価するのに索引を用いてもよい。この pragma
を認識しない実装では、通常の方法で式が評価される。</p>
</li>
<li>
<p>pragma は以下に続く式の意味を、(pragma がなければ)
この仕様に適合しないように変更するのに用いられる。例えば、pragma を用いて <code>xs:duration</code>
の値の比較を実装定義の意味で行えるようにしてもよい
(通常はこれはエラーである)。言語の意味に対するこのような変更の有効範囲は、pragma
に続く波括弧の内部に含まれる式に限定されなければならない。</p>
</li>
<li>
<p>pragma に、以下の式の場所で評価される構文要素を含めることもできる。この場合、以下の式 (もしあれば)
はそれ自身で、pragma が認識されない実装で用いられる失敗用処理を提供する。例えば:</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</pre></div>
<p>ここでは、pragma を認識する実装は、その pragma の持つ構文 <code>exq:distinct //city
by @country</code> を評価した結果を返す。一方、pragma を認識しない実装は、代わりに式
<code>//city[not(@country = preceding::city/@country)]</code>
を評価した結果を返す。失敗用の式が必要とされなかったり、あるいは何も実行されなければ、波括弧の間の式は省略されてもよい。この場合、pragma
を認識しない実装では<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-query-prolog" id="id-query-prolog"></a>4
モジュールと前書き</h2>
<h5><a name="d2e15044" id="d2e15044"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Module" id=
"doc-xquery-Module"></a>[1]&nbsp;&nbsp;&nbsp;</td>
<td><code>Module</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-VersionDecl">VersionDecl</a>?
(<a href="#doc-xquery-LibraryModule">LibraryModule</a> | <a href=
"#doc-xquery-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-MainModule" id=
"doc-xquery-MainModule"></a>[3]&nbsp;&nbsp;&nbsp;</td>
<td><code>MainModule</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Prolog">Prolog</a> <a href=
"#doc-xquery-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-LibraryModule" id=
"doc-xquery-LibraryModule"></a>[4]&nbsp;&nbsp;&nbsp;</td>
<td><code>LibraryModule</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-ModuleDecl">ModuleDecl</a> <a href=
"#doc-xquery-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Prolog" id=
"doc-xquery-Prolog"></a>[6]&nbsp;&nbsp;&nbsp;</td>
<td><code>Prolog</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>((<a href=
"#doc-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#doc-xquery-Setter">Setter</a> | <a href=
"#doc-xquery-NamespaceDecl">NamespaceDecl</a> | <a href=
"#doc-xquery-Import">Import</a>) <a href=
"#doc-xquery-Separator">Separator</a>)* ((<a href=
"#doc-xquery-VarDecl">VarDecl</a> | <a href=
"#doc-xquery-FunctionDecl">FunctionDecl</a> | <a href=
"#doc-xquery-OptionDecl">OptionDecl</a>) <a href=
"#doc-xquery-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Setter" id=
"doc-xquery-Setter"></a>[7]&nbsp;&nbsp;&nbsp;</td>
<td><code>Setter</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#doc-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#doc-xquery-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#doc-xquery-BaseURIDecl">BaseURIDecl</a> | <a href=
"#doc-xquery-ConstructionDecl">ConstructionDecl</a> | <a href=
"#doc-xquery-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#doc-xquery-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#doc-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Import" id=
"doc-xquery-Import"></a>[8]&nbsp;&nbsp;&nbsp;</td>
<td><code>Import</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-SchemaImport">SchemaImport</a> |
<a href="#doc-xquery-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Separator" id=
"doc-xquery-Separator"></a>[9]&nbsp;&nbsp;&nbsp;</td>
<td><code>Separator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-QueryBody" id=
"doc-xquery-QueryBody"></a>[30]&nbsp;&nbsp;&nbsp;</td>
<td><code>QueryBody</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Expr">Expr</a></code></td>
</tr>
</tbody>
</table>
<p>問合せは<b>モジュール</b>と呼ばれる1つ以上の断片から組み立てることができる。 [<a name="dt-module"
id="dt-module" title="module">Definition</a>: <b>モジュール</b>は XQuery
コードの断片であり、<a href="#doc-xquery-Module">Module</a>
の文法に従っており、またそれぞれ独立に<a href="#id-expression-processing"><b>2.2.3
式の処理</b></a>にある<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>を受けることができる。各モジュールは<a title=
"main module" href="#dt-main-module">主モジュール</a>か<a title=
"library module" href=
"#dt-library-module">ライブラリモジュール</a>のいずれかである。]</p>
<p>[<a name="dt-main-module" id="dt-main-module" title=
"main module">Definition</a>: <b>主モジュール</b>は、<a title="Prolog"
href="#dt-prolog">前書き</a>とそれに続く<a title="query body" href=
"#dt-queryBody">問合せ本体</a>から構成される。]
問合せは主モジュールを1つ持つ。主モジュールでは、<a title="query body" href=
"#dt-queryBody">問合せ本体</a>を評価することができ、その値が問合せの結果になる。</p>
<p>[<a name="dt-library-module" id="dt-library-module" title=
"library module">Definition</a>: <a title="query body" href=
"#dt-queryBody">問合せ本体</a>を持たないモジュールを<b>ライブラリモジュール</b>という。ライブラリモジュールは<a title="module declaration"
href="#dt-module-declaration">モジュール定義</a>およびそれに続く<a title="Prolog"
href="#dt-prolog">前書き</a>からなる。]
ライブラリモジュールを直接評価することはできない。そのかわり、他のモジュールから輸入できる関数や変数の宣言を提供する。</p>
<p>XQuery の構文では、<a title="module" href=
"#dt-module">モジュール</a>に<a title="module declaration" href=
"#dt-module-declaration">モジュール宣言</a>と<a title="query body" href=
"#dt-queryBody">問合せ本体</a>を両方含めることは許されない。</p>
<p>[<a name="dt-prolog" id="dt-prolog" title=
"Prolog">Definition</a>: <b>前書き</b>は一連の宣言や輸入であり、その前書きを含む<a title=
"module" href="#dt-module">モジュール</a>に対する処理環境を定義する。]
それぞれの宣言や輸入の後ろにはセミコロンが続く。前書きは2つの部分からなる。</p>
<p>前書きの最初の部分は設定子、輸入、名前空間宣言、およびデフォルト名前空間宣言からなる。[<a name="dt-setter"
id="dt-setter" title="setter">Definition</a>:
<b>設定子</b>は、問合せ処理に影響を与える性質の値を設定する。このような性質には、構成モード、順序付けモード、デフォルト照合順序などがある。]
名前空間宣言やデフォルト名前空間宣言は問合せ中の QName
の解釈に影響を与える。輸入は、スキーマやモジュールから定義を輸入するのに用いられる。[<a name=
"dt-target-namespace" id="dt-target-namespace" title=
"target namespace">Definition</a>:
輸入されたスキーマやモジュールはそれぞれ、その<b>目的名前空間</b>によって識別される。これは、そのスキーマやモジュールで定義されるオブジェクト
(要素や関数など) の名前空間である。]</p>
<p>
前書きの2つ目の部分は変数、関数、オプションの宣言からなる。これらの宣言は前書きの最後に現れる。なぜならこれらは、前書きの1つめの部分中にある宣言や輸入の影響を受けるかもしれないからである。</p>
<p>[<a name="dt-queryBody" id="dt-queryBody" title=
"query body">Definition</a>: <b>問合せ本体</b>は、もしあれば、問合せの結果を定義する式からなる。]
式の評価は<a href="#id-expressions"><b>3
式</b></a>にある。モジュールが評価可能なのは、それが問合せ本体を持つ場合に限る。</p>
<div class="div2">
<h3><a name="id-version-declaration" id=
"id-version-declaration"></a>4.1 バージョン宣言</h3>
<h5><a name="d2e15253" id="d2e15253"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-VersionDecl" id=
"doc-xquery-VersionDecl"></a>[2]&nbsp;&nbsp;&nbsp;</td>
<td><code>VersionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"xquery" "version" <a href=
"#doc-xquery-StringLiteral">StringLiteral</a> ("encoding" <a href=
"#doc-xquery-StringLiteral">StringLiteral</a>)? <a href=
"#doc-xquery-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-version-declaration" id="dt-version-declaration"
title="version declaration">Definition</a>: <a title="module" href=
"#dt-module">モジュール</a>はいずれも<b>バージョン宣言</b>を含んでよい。もしあれば、バージョン宣言は<a title="module"
href="#dt-module">モジュール</a>の先頭に出現し、その<a title="module" href=
"#dt-module">モジュール</a>に対して適用可能な XQuery の構文と意味を識別する。] バージョン番号 "1.0"
は、その<a title="module" href="#dt-module">モジュール</a>が XQuery バージョン 1.0
を支援する実装によって処理されなければならないという要求を示す。 バージョン宣言がなければ、バージョンは "1.0"
であるとみなされる。XQuery の実装は、その実装が支援しないバージョンにラベル付けされた<a title="module"
href="#dt-module">モジュール</a>を処理すると、<a title="static error" href=
"#dt-static-error">静的エラー</a> [<a title="err:XQST0031" href=
"#ERRXQST0031">err:XQST0031</a>] を発生させなければならない。XQuery
作業部会は、この仕様について "1.0" より後の番号を与えることを意図している。しかしこの意図は、将来の XQuery
のバージョンを作る約束を意味するわけではないし、もしそれを作ったとしても、特定の番号付けの枠組を用いる約束を意味するわけでもない。</p>
<p>[<a name="dt-encoding-declaration" id="dt-encoding-declaration"
title="encoding declaration">Definition</a>:
バージョン宣言は、もしあれば、省略可能な<b>符号化宣言</b>を含んでもよい。キーワード <code>encoding</code>
の後に続く文字列リテラルが符号化名であり、<a href="#XML">[XML 1.0]</a>で指定される
<code>EncName</code> に適合しなければならない [<a title="err:XQST0087" href=
"#ERRXQST0087">err:XQST0087</a>]。符号化宣言の目的は、問合せを書くときに、その問合せがどのように符号化されるかを示す文字列を用意することを許すことである。例えば
"<code>UTF-8</code>", "<code>UTF-16</code>",
"<code>US-ASCII</code>" のような文字列である。]
問合せをある環境から違う環境に移すと、問合せの符号化は変化するかもしれないので、符号化宣言が正しいという保証はできない。</p>
<p>バージョン宣言の処理方法は<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。実装が<em>あらかじめ</em>問合せの符号化に関する知識を持っていれば、この知識を用いて、符号化宣言を捨ててもよい。問合せの意味は、符号化宣言があるかないかには影響を受けない。</p>
<p>バージョン宣言があれば、そのバージョン宣言の終わりより前に<a href=
"#doc-xquery-Comment">Comment</a>が出現してはならない。このような <a href=
"#doc-xquery-Comment">Comment</a> がある場合、結果は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>バージョン宣言の終わりより前に Comment が出現すると、その効果は実装依存である。なぜならそのような Comment
は符号化宣言の発見を妨げ、問合せ処理を抑制するかもしれないからである。</p>
</div>
<p>以下に示すのはバージョン宣言の例である:</p>
<div class="exampleInner">
<pre>
xquery version "1.0";
</pre></div>
<div class="exampleInner">
<pre>
xquery version "1.0" encoding "utf-8";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-module-declaration" id=
"id-module-declaration"></a>4.2 モジュール宣言</h3>
<h5><a name="d2e15352" id="d2e15352"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ModuleDecl" id=
"doc-xquery-ModuleDecl"></a>[5]&nbsp;&nbsp;&nbsp;</td>
<td><code>ModuleDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=" <a href=
"#doc-xquery-URILiteral">URILiteral</a> <a href=
"#doc-xquery-Separator">Separator</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-module-declaration" id="dt-module-declaration"
title="module declaration">Definition</a>:
<b>モジュール宣言</b>は、ある<a title="module" href=
"#dt-module">モジュール</a>を<a title="library module" href=
"#dt-library-module">ライブラリモジュール</a>として識別する機能を提供する。モジュール宣言はキーワード
<code>module</code> で始まり、名前空間接頭辞1つと <a href=
"#doc-xquery-URILiteral">URILiteral</a> 1つを含む。] URILiteral
の長さは0以外でなければならない [<a title="err:XQST0088" href=
"#ERRXQST0088">err:XQST0088</a>]。URILiteral はライブラリモジュールの<a title=
"target namespace" href=
"#dt-target-namespace">目的名前空間</a>を識別する。これはライブラリモジュールによって輸出される変数や関数すべてに対する名前空間である。ライブラリモジュール中で宣言される変数や関数の名前はそれぞれ、そのモジュールの目的な前空間と同じ名前空間
URI を持っていなければならない。そうでなければ、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0048" href=
"#ERRXQST0048">err:XQST0048</a>]。ライブラリモジュールの<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中では、モジュール宣言で指定された名前空間接頭辞は、そのモジュールの目的名前空間に束縛される。モジュール宣言で指定される名前空間接頭辞は
<code>xml</code> や <code>xmlns</code> であってはならない [<a title=
"err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]。</p>
<p>いずれの<a title="module" href="#dt-module">モジュール</a>も、<a title=
"module import" href=
"#dt-module-import">モジュール輸入</a>の手段によって1つ以上のライブラリモジュールを輸入してもよい。モジュール輸入は、輸入されるライブラリモジュールの目的名前空間を指定する。モジュールが1つ以上のライブラリモジュールを輸入するとき、輸入されるモジュール中で宣言されている変数や関数が、輸入するモジュールの<a title="static context"
href="#dt-static-context">静的文脈</a>と (適用可能であれば) <a title=
"dynamic context" href="#dt-dynamic-context">動的文脈</a>に追加される。</p>
<p>以下に示すのはモジュール宣言の例である:</p>
<div class="exampleInner">
<pre>
module namespace math = "http://example.org/math-functions";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-boundary-space-decls" id=
"id-boundary-space-decls"></a>4.3 境界空白宣言</h3>
<h5><a name="d2e15427" id="d2e15427"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-BoundarySpaceDecl" id=
"doc-xquery-BoundarySpaceDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td>
<td><code>BoundarySpaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-boundary-space-decl" id="dt-boundary-space-decl"
title="boundary-space declaration">Definition</a>:
<b>境界空白宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="boundary-space policy"
href=
"#dt-boundary-space-policy">境界空白ポリシー</a>を設定する。このとき実装定義の任意のデフォルト値を上書きする。境界空白ポリシーは、問合せ処理で要素構成子によって<a title="boundary whitespace"
href="#dt-boundary-whitespace">境界空白</a>が保存されるかどうかを制御する。] 境界空白ポリシーが
<code>preserve</code> であれば、境界空白は保存される。境界空白ポリシーが <code>strip</code>
であれば、境界空白ははぎ取られる (削除される)。構成される要素中の空白に関する更なる議論は<a href=
"#id-whitespace"><b>3.7.1.4 境界空白</b></a>にある。</p>
<p>以下に示すのは境界空白宣言の例である:</p>
<div class="exampleInner">
<pre>
declare boundary-space preserve;
</pre></div>
<p>前書きに2つ以上の境界空白宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0068" href=
"#ERRXQST0068">err:XQST0068</a>]。</p>
</div>
<div class="div2">
<h3><a name="id-default-collation-declaration" id=
"id-default-collation-declaration"></a>4.4 デフォルト照合順序宣言</h3>
<h5><a name="d2e15471" id="d2e15471"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DefaultCollationDecl" id=
"doc-xquery-DefaultCollationDecl"></a>[19]&nbsp;&nbsp;&nbsp;</td>
<td><code>DefaultCollationDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" "collation" <a href=
"#doc-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-default-collation-decl" id=
"dt-default-collation-decl" title=
"default collation declaration">Definition</a>:
<b>デフォルト照合順序宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="default collation" href=
"#dt-def-collation">デフォルト照合順序</a>の値を設定する。このとき、実装定義の任意のデフォルト値を上書きする。]
デフォルト照合順序は、照合順序を必要とする関数や演算子において、照合順序が他に指定されていないときに用いられる照合順序である。例えば、文字列上の
<code>gt</code> 演算子は <code>fn:compare</code>
関数の呼び出しによって定義される。この関数は照合順序を省略可能な引数として取る。<code>gt</code>
演算子は照合順序を指定しないので、<code>fn:compare</code> 関数が <code>gt</code>
を実装するときデフォルト照合順序が用いられる。</p>
<p>実装にも前書きにもデフォルト照合順序が指定されていないときは、Unicode コードポイント照合順序
(<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
が用いられる。</p>
<p>以下に示すのはデフォルト照合順序の例である:</p>
<div class="exampleInner">
<pre>
declare default collation
         "http://example.org/languages/Icelandic";
</pre></div>
<p>デフォルト照合順序宣言が相対 URI によって照合順序を指定しているならば、その相対 URI は、<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"base URI" href="#dt-base-uri">基礎 URI</a>を用いて絶対 URI
に解決される。前書きに2つ以上のデフォルト照合順序宣言が含まれていたり、デフォルト照合順序宣言で指定された値が (必要なら相対 URI
を解決した後) <a title="statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0038"
href="#ERRXQST0038">err:XQST0038</a>].</p>
</div>
<div class="div2">
<h3><a name="id-base-uri-decl" id="id-base-uri-decl"></a>4.5 基礎 URI
宣言</h3>
<h5><a name="d2e15535" id="d2e15535"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-BaseURIDecl" id=
"doc-xquery-BaseURIDecl"></a>[20]&nbsp;&nbsp;&nbsp;</td>
<td><code>BaseURIDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "base-uri" <a href=
"#doc-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-base-uri-decl" id="dt-base-uri-decl" title=
"base URI declaration">Definition</a>: <b>基礎 URI 宣言</b>は<a title=
"static context" href="#dt-static-context">静的文脈</a>の<a title=
"base URI" href="#dt-base-uri">基礎
URI</a>性質を指定し、実装依存の任意のデフォルト値を上書きする。<a title="base URI" href=
"#dt-base-uri">基礎 URI</a> 性質は<a title="module" href=
"#dt-module">モジュール</a>中の相対 URI を解決するのに用いられる。]
例えば、<code>fn:doc</code> 関数は呼び出したモジュールの基礎 URI を用いて相対 URI を解決する。</p>
<p>以下に示すのは基礎 URI 宣言の例である:</p>
<div class="exampleInner">
<pre>
declare base-uri "http://example.org";
</pre></div>
<p>前書きに2つ以上の基礎 URI 宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0032" href=
"#ERRXQST0032">err:XQST0032</a>]。</p>
</div>
<div class="div2">
<h3><a name="id-construction-declaration" id=
"id-construction-declaration"></a>4.6 構成宣言</h3>
<h5><a name="d2e15579" id="d2e15579"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ConstructionDecl" id=
"doc-xquery-ConstructionDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td>
<td><code>ConstructionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-construction-decl" id="dt-construction-decl" title=
"construction declaration">Definition</a>: <b>構成宣言</b>は<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"construction mode" href=
"#dt-construction-mode">構成モード</a>を設定する。このとき任意の実装定義のデフォルト値を上書きする。]
構成モードは要素構成子や文書節点構成子の振舞いを決定する。構成モードが <code>preserve</code>
であれば、構成された要素節点の型は <code>xs:anyType</code>
であり、節点の構成中に複製された属性節点や要素節点はすべて、元の型を保つ。構成モードが <code>strip</code>
であれば、構成された要素節点の型は <code>xs:untyped</code>
である。また、節点の構成中に複製された要素節点にはすべて型 <code>xs:untyped</code>
が与えられ、節点の構成中に複製された属性節点にはすべて型 <code>xs:untypedAtomic</code>
が与えられる。</p>
<p>以下に示すのは構成宣言の例である:</p>
<div class="exampleInner">
<pre>
declare construction strip;
</pre></div>
<p>前書きに2つ以上の構成宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0067" href=
"#ERRXQST0067">err:XQST0067</a>]。</p>
</div>
<div class="div2">
<h3><a name="id-default-ordering-decl" id=
"id-default-ordering-decl"></a>4.7 順序付けモード宣言</h3>
<h5><a name="d2e15630" id="d2e15630"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OrderingModeDecl" id=
"doc-xquery-OrderingModeDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderingModeDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-ordering-mode-decl" id="dt-ordering-mode-decl"
title="ordering mode declaration">Definition</a>:
<b>順序付けモード宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>を設定する。このとき任意の実装依存のデフォルト値を上書きする。]
この順序付けモードは<a title="module" href="#dt-module">モジュール</a>中 (<a title=
"Prolog" href="#dt-prolog">前書き</a>も<a title="query body" href=
"#dt-queryBody">問合せ本体</a>も、もしあれば、ともに含む) のすべての式に適用される。ただし
<code>ordered</code> 式や <code>unordered</code> によって上書きされた場合を除く。</p>
<p><a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>は、<a title="path expression" href=
"#dt-path-expression">経路式</a>のうち "<code>/</code>" 演算子あるいは
"<code>//</code>" 演算子、<a title="axis step" href=
"#dt-axis-step">軸ステップ</a>を含むもの、<code>union</code> 式,
<code>intersect</code> 式, <code>except</code> 式、<code>order
by</code> 節を持たない FLWOR 式の振舞いに影響を及ぼす。順序付けモードが <code>ordered</code>
であれば、経路、<code>union</code> 式, <code>intersect</code> 式,
<code>except</code> 式によって返される節点列は<a title="document order" href=
"#dt-document-order">文書順</a>である。そうでなければ、これらの結果の列の順序は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。FLWOR
式に対する順序付けモードの影響については、<a href="#id-flwor-expressions"><b>3.8 FLWOR
式</b></a>にある。</p>
<p>以下に示すのは、順序付けモード宣言の例である:</p>
<div class="exampleInner">
<pre>
declare ordering unordered;
</pre></div>
<p>前書きに2つ以上の順序付けモード宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0065" href=
"#ERRXQST0065">err:XQST0065</a>]。</p>
</div>
<div class="div2">
<h3><a name="id-empty-order-decl" id="id-empty-order-decl"></a>4.8
空順序宣言</h3>
<h5><a name="d2e15727" id="d2e15727"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-EmptyOrderDecl" id=
"doc-xquery-EmptyOrderDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td>
<td><code>EmptyOrderDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-empty-order-decl" id="dt-empty-order-decl" title=
"empty order declaration">Definition</a>: <b>空順序宣言</b>は<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"default order for empty sequences" href=
"#dt-default-empty-order">空列のためのデフォルト順序</a>を設定し、実装依存の任意のデフォルト値を上書きする。この宣言は空列や、FLWOR
式の <code>order by</code> 節中の順序付けキーとしての値 <code>NaN</code> の処理を制御する。]
個々の <code>order by</code> 節は、<code>empty greatest</code> や
<code>empty least</code> を指定することで、空列に対するデフォルト順序を上書きしてもよい。</p>
<p>以下に示すのは、空順序宣言の例である:</p>
<div class="exampleInner">
<pre>
declare default order empty least;
</pre></div>
<p>前書きに2つ以上の空順序宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0069" href=
"#ERRXQST0069">err:XQST0069</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="empty order declaration" href=
"#dt-empty-order-decl">空順序宣言</a>と<a title=
"ordering mode declaration" href=
"#dt-ordering-mode-decl">順序付けモード宣言</a>の区別をつけておくことは重要である。<a title=
"empty order declaration" href="#dt-empty-order-decl">空順序宣言</a>は
<code>order by</code> 節がある場合にのみ適用され、(上書きがなければ) <code>order
by</code> 節で空列をどのように扱うかを指定する。一方、<a title=
"ordering mode declaration" href=
"#dt-ordering-mode-decl">順序付けモード宣言</a>は <code>order by</code>
節がない場合にのみ適用される。</p>
</div>
</div>
<div class="div2">
<h3><a name="id-copy-namespaces-decl" id=
"id-copy-namespaces-decl"></a>4.9 名前空間複製宣言</h3>
<h5><a name="d2e15798" id="d2e15798"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-CopyNamespacesDecl" id=
"doc-xquery-CopyNamespacesDecl"></a>[16]&nbsp;&nbsp;&nbsp;</td>
<td><code>CopyNamespacesDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#doc-xquery-PreserveMode">PreserveMode</a> "," <a href=
"#doc-xquery-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-PreserveMode" id=
"doc-xquery-PreserveMode"></a>[17]&nbsp;&nbsp;&nbsp;</td>
<td><code>PreserveMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-InheritMode" id=
"doc-xquery-InheritMode"></a>[18]&nbsp;&nbsp;&nbsp;</td>
<td><code>InheritMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-copy-namespaces-decl" id="dt-copy-namespaces-decl"
title="copy-namespaces declaration">Definition</a>:
<b>名前空間複製宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="copy-namespaces mode"
href="#dt-copy-namespaces-mode">名前空間複製モード</a>の値を設定し、実装定義の任意のデフォルト値を上書きする。名前空間複製モードは、すでに存在する要素が要素構成子によって複製されたときに割り当てられる名前空間束縛を制御する。]
要素構成子による名前空間束縛の処理については、<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>に記述がある。</p>
<p>以下に示すのは名前空間複製モードの例である:</p>
<div class="exampleInner">
<pre>
declare copy-namespaces preserve, no-inherit;
</pre></div>
<p>前書きに2つ以上の名前空間複製宣言が含まれていれば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する [<a title="err:XQST0055" href=
"#ERRXQST0055">err:XQST0055</a>]。</p>
</div>
<div class="div2">
<h3><a name="id-schema-imports" id="id-schema-imports"></a>4.10
スキーマ輸入</h3>
<h5><a name="d2e15848" id="d2e15848"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SchemaImport" id=
"doc-xquery-SchemaImport"></a>[21]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaImport</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"import" "schema" <a href=
"#doc-xquery-SchemaPrefix">SchemaPrefix</a>? <a href=
"#doc-xquery-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-SchemaPrefix" id=
"doc-xquery-SchemaPrefix"></a>[22]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaPrefix</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("namespace" <a href="#prod-xquery-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-schema-import" id="dt-schema-import" title=
"schema import">Definition</a>:
<b>スキーマ輸入</b>は、1つのスキーマから要素宣言、属性宣言、および型宣言を<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に輸入する。] 輸入されるスキーマは、その<a title=
"target namespace" href=
"#dt-target-namespace">目的名前空間</a>によって識別される。スキーマ輸入は輸入されるスキーマの目的名前空間に名前空間接頭辞を束縛してもよい。またその目的名前空間を<a title="default element/type namespace"
href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>と宣言してもよい。また、スキーマ輸入は、そのスキーマの場所に対する省略可能なヒントを用意してもよい。スキーマ輸入中で指定される名前空間接頭辞は
<code>xml</code> や <code>xmlns</code> であってはならない [<a title=
"err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]。</p>
<p>スキーマ輸入中の最初の <a href="#doc-xquery-URILiteral">URILiteral</a>
は輸入されるスキーマの目的名前空間を指定する。キーワード <code>at</code> に続く URILiteral
は場所のヒントであり、省略可能である。これらは、実装依存の方法により、解釈することも無視することも可能である。場所のヒントを複数用いて、スキーマ、あるいはそのスキーマを組み立てる複数の物理的資源を探す場所の可能性を1つ以上示してもよい。</p>
<p>
長さ0の文字列を目的名前空間として指定するスキーマ輸入は、目的名前空間を持たないスキーマを輸入するとみなされる。このようなスキーマ輸入は名前空間接頭辞を束縛してはならない
[<a title="err:XQST0057" href="#ERRXQST0057">err:XQST0057</a>]
が、しかしデフォルト要素/型名前空間を長さ0の文字列 ("名前空間なし" を意味する)
に設定してもよい。その結果、輸入されたスキーマの定義を参照することができるようになる。デフォルト要素/型名前空間が "名前空間なし"
と設定されなければ、目的名前空間のない輸入されたスキーマの定義を参照する方法はない。</p>
<p>同じ<a title="Prolog" href=
"#dt-prolog">前書き</a>中の2つ以上のスキーマ輸入で同じ目的名前空間が指定されていれば、<a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0058" href=
"#ERRXQST0058">err:XQST0058</a>]。実装が、指定された目的名前空間を持つ正しいスキーマを見つけてスキーマ輸入を処理することができなければ、<a title="static error"
href="#dt-static-error">静的エラー</a> である [<a title="err:XQST0059"
href="#ERRXQST0059">err:XQST0059</a>]
。複数の輸入されたスキーマ、あるいは1つのスキーマ内部の複数の物理的資源が、同じ記号空間中に同じ名前の定義を含んでいれば
(例えば、同じ要素名に対する2つの定義があれば、たとえそれらの定義が一貫していたとしても)、<a title=
"static error" href="#dt-static-error">型エラー</a> である [<a title=
"err:XQST0035" href="#ERRXQST0035">err:XQST0035</a>]。しかし、目的名前空間
<code>http://www.w3.org/2001/XMLSchema</code> (あらかじめ接頭辞
<code>xs</code> が宣言されている)
を持つスキーマを輸入してもエラーではない。たとえ、このスキーマで定義されている組み込み型が暗黙的に<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>に輸入されたとしても、エラーではない。a</p>
<p>前書きで輸入されたすべてのスキーマに含まれる定義集合が、<a href="#XMLSchema">[XML
Schema]</a> Part 1 の 3章と
5章で指定されているスキーマ妥当性の条件を満たさないならば、すなわち定義が妥当で、完全で、唯一でなければならないという条件を満たさないならば、<a title="static error"
href="#dt-static-error">静的エラー</a> である [<a title="err:XQST0012"
href="#ERRXQST0012">err:XQST0012</a>]。</p>
<p>以下に示す例では、目的名前空間と場所をともに指定してスキーマを輸入し、その目的名前空間に接頭辞
<code>soap</code> を束縛している:</p>
<div class="exampleInner">
<pre>
import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";
</pre></div>
<p>以下の例では、目的名前空間だけを指定してスキーマを輸入し、それをデフォルト要素/型名前空間にしている:</p>
<div class="exampleInner">
<pre>
import schema default element namespace "http://example.org/abc";
</pre></div>
<p>以下の例では、目的名前空間を持たないスキーマを輸入し、場所のヒントを与え、デフォルト要素/型名前空間を "名前空間なし"
に設定している。その結果、輸入されたスキーマ中の定義が参照可能となる:</p>
<div class="exampleInner">
<pre>
import schema default element namespace "" 
at "http://example.org/xyz.xsd";
</pre></div>
<p>以下の例では、目的名前空間のないスキーマを輸入し、デフォルト要素/型名前空間を "名前空間なし"
に設定している。場所のヒントが用意されていないので、輸入されるスキーマを見つけるのは実装の責任である。</p>
<div class="exampleInner">
<pre>
import schema default element namespace "";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-module-imports" id="id-module-imports"></a>4.11
モジュール輸入</h3>
<h5><a name="d2e15970" id="d2e15970"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ModuleImport" id=
"doc-xquery-ModuleImport"></a>[23]&nbsp;&nbsp;&nbsp;</td>
<td><code>ModuleImport</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=")? <a href=
"#doc-xquery-URILiteral">URILiteral</a> ("at" <a href=
"#doc-xquery-URILiteral">URILiteral</a> ("," <a href=
"#doc-xquery-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-module-import" id="dt-module-import" title=
"module import">Definition</a>: <b>モジュール輸入</b>は1つ以上の<a title=
"library module" href=
"#dt-library-module">ライブラリモジュール</a>から関数宣言や変数宣言を輸入する。輸入の先は、輸入する<a title="module"
href="#dt-module">モジュール</a>の<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>や<a title="in-scope variables"
href="#dt-in-scope-variables">有効範囲内変数</a>である。] 各モジュール輸入は<a title=
"target namespace" href=
"#dt-target-namespace">目的名前空間</a>に名前をつけ、この目的名前空間を共有する<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>のモジュール集合を輸入する。モジュール輸入は名前空間接頭辞を目的名前空間に束縛してもよい。また輸入されるモジュールの場所に関する省略可能なヒントを用意してもよい。モジュールで指定される名前空間接頭辞は
<code>xml</code> や <code>xmlns</code> であってはならない [<a title=
"err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]。</p>
<p>モジュール輸入中の最初の <a href="#doc-xquery-URILiteral">URILiteral</a>
は長さが0であってはならず [<a title="err:XQST0088" href=
"#ERRXQST0088">err:XQST0088</a>]、輸入されるモジュールの目的名前空間を指定する。キーワード
<code>at</code> に続く URILiteral は場所のヒントであり、省略可能である。これらは、<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の方法により、解釈することも無視することも可能である。</p>
<p><a title="Prolog" href=
"#dt-prolog">前書き</a>中の2つ以上のモジュールが同じ目的名前空間を指定していれば、<a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0047" href=
"#ERRXQST0047">err:XQST0047</a>]。実装が、指定された目的名前空間の正しいモジュール定義を見つけてモジュールを処理することができなければ、<a title="static error"
href="#dt-static-error">静的エラー</a>である [<a title="err:XQST0059" href=
"#ERRXQST0059">err:XQST0059</a>]。輸入されたモジュールで宣言されている関数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済
QName</a>と次数が、輸入するモジュール、もしくは輸入された別のモジュールで宣言されている関数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済 QName</a>と次数にそれぞれ
(<code>eq</code> 演算子によって定義される通りに) 等しいならば、(宣言が一貫していても) <a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0034" href=
"#ERRXQST0034">err:XQST0034</a>]。輸入されたモジュールで宣言されている変数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済
QName</a>が、輸入するモジュール、もしくは輸入された別のモジュールで宣言されている変数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済
QName</a>と等しいならば、(宣言が一貫していても) <a title="static error" href=
"#dt-static-error">静的エラー</a>である [<a title="err:XQST0049" href=
"#ERRXQST0049">err:XQST0049</a>]。</p>
<p><a title="module" href="#dt-module">モジュール</a>はそれぞれ、固有の<a title=
"static context" href="#dt-static-context">静的文脈</a>を持つ。<a title=
"module import" href=
"#dt-module-import">モジュール輸入</a>は関数や変数の宣言のみを輸入し、他のオブジェクト、例えば<a title="in-scope schema definitions"
href="#dt-issd">有効範囲内スキーマ定義</a>や<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>は、輸入されるモジュールから輸入しない。モジュール輸入は推移的ではない。すなわち、あるモジュールを輸入すると、その輸入されたモジュール中に直接含まれる関数や変数の宣言のみにアクセスすることができる。例えば、モジュール
A がモジュール B を輸入し、モジュール B がモジュール C を輸入しているならば、モジュール A はモジュール C
で宣言されている関数や変数に対してアクセスすることはできない。</p>
<p>モジュールは、それ自身の目的名前空間を輸入してもよい
(これは、その目的名前空間を共有する別のモジュールからなる<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>の集合を輸入すると解釈される)。しかし、モジュール輸入のグラフが巡回路を持つならば
(すなわち、モジュール列 M<sub>1</sub> ... M<sub>n</sub> で M<sub>i</sub> が
M<sub>i+1</sub> を輸入し、M<sub>n</sub> が M<sub>1</sub>
を輸入するようなものが存在すれば)、巡回路中のモジュールがすべて共通の名前空間を共有しない限り、<a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0073" href="#ERRXQST0073">err:XQST0073</a>]。</p>
<p>あるモジュールを輸入するとき、輸入するモジュールの<a title="in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>が、輸入されるモジュール中にある変数や関数
(引数の型や返り値の型に関わらず)
の宣言のうち輸入するモジュール中で参照されるものに出現するスキーマ型名に対する定義を含まないならば、<a title=
"static error" href="#dt-static-error">静的エラー</a>である [<a title=
"err:XQST0036" href="#ERRXQST0036">err:XQST0036</a>]。</p>
<p>上のルールを示すために、<code>triangle</code>
という名前の型を定義するスキーマを考えよう。ライブラリモジュールがこのスキーマを輸入し、その目的名前空間を接頭辞
<code>geometry</code> に束縛し、以下の<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>を持つ関数を宣言しているとする:
<code>math:area($t as geometry:triangle) as
xs:double</code>。ある問合せでこの関数を使おうとするならば、ライブラリモジュールと、それの元になっているスキーマの<em>両方</em>を輸入しなければならない。ライブラリモジュールだけを輸入すると、<code>area</code>
関数のシグネチャで用いられている型 <code>geometry:triangle</code>
の定義にアクセスすることができない。</p>
<p>以下に示すのはモジュール輸入の例である:</p>
<div class="exampleInner">
<pre>
import module namespace math = "http://example.org/math-functions";
</pre></div>
</div>
<div class="div2">
<h3><a name="id-namespace-decls" id="id-namespace-decls"></a>4.12
名前空間宣言</h3>
<h5><a name="d2e16157" id="d2e16157"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-NamespaceDecl" id=
"doc-xquery-NamespaceDecl"></a>[10]&nbsp;&nbsp;&nbsp;</td>
<td><code>NamespaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=" <a href=
"#doc-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-namespace-declaration" id=
"dt-namespace-declaration" title=
"namespace declaration">Definition</a>:
<b>名前空間宣言</b>は、名前空間接頭辞を宣言し、それを名前空間 URI と関連づけ、(接頭辞, URI)
の組を<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の集合に加える。] 名前空間宣言は、<a title=
"direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>中の<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前区間宣言属性</a>によって上書きされない限り、それが宣言されている問合せを通して有効である。</p>
<p>名前空間宣言の URILiteral
部分が長さ0の文字列であれば、与えられた接頭辞に対してすでに存在する名前空間束縛は<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>から削除される。この機能は、<code>local</code>
のようにあらかじめ宣言されている名前空間接頭辞を削除する方法を提供する。</p>
<p>以下に示すのは、名前空間宣言の例である:</p>
<div class="exampleInner">
<pre>
declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;
</pre></div>
<p>この問合せの結果、新しく生成された節点は、名前空間 URI <code>http://example.org</code>
と関連づけられた名前空間中にある。</p>
<p><a title="Prolog" href=
"#dt-prolog">前書き</a>中で同じ名前空間接頭辞を複数回宣言すると、<a title="static error"
href="#dt-static-error">静的エラー</a>である [<a title="err:XQST0033" href=
"#ERRXQST0033">err:XQST0033</a>]。</p>
<p>ある式が名前空間接頭辞を持つ QName を含んでおり、かつその QName が<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中になければ、<a title="static error"
href="#dt-static-error">静的エラー</a>である [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]。</p>
<p>XQuery には、あらかじめ宣言された名前空間接頭辞がいくつかある。これらは、それぞれの問合せを処理する前に<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>中にある。これらの接頭辞は、明示的な宣言をすることなく用いてもよい。これらの接頭辞は<a title="Prolog"
href="#dt-prolog">前書き</a>中の<a title="namespace declaration" href=
"#dt-namespace-declaration">名前空間宣言</a>や、構成された要素の<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>によって上書きされてもよい (ただし、接頭辞
<code>xml</code> を再宣言することはできない。また接頭辞 <code>xml</code>
に関連づけられている名前空間 URI を他の接頭辞に束縛することもできない [<a title="err:XQST0070"
href="#ERRXQST0070">err:XQST0070</a>])。あらかじめ宣言された名前空間接頭辞は以下の通りである:</p>
<ul>
<li>
<p><code>xml = http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>xdt = http://www.w3.org/2005/xpath-datatypes</code></p>
</li>
<li>
<p><code>local =
http://www.w3.org/2005/xquery-local-functions</code> (<a href=
"#FunctionDeclns"><b>4.15 関数宣言</b></a>を見よ。)</p>
</li>
</ul>
<p>実装によって、あらかじめ宣言された名前空間接頭辞をさらに<a title=
"statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>に追加してもよい。</p>
<p>名前空間接頭辞 <code>xmlns</code> もまた特別な意味を持ち (<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>を識別する)、再宣言することはできない[<a title=
"err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]。</p>
<p>要素や属性の名前が比較されるとき、局所部と名前空間 URI
がそれぞれコードポイントを基礎として照合されるならば、それらは等しいとみなされる。以下の例の通り、照合される2つの名前の名前空間接頭辞は同じである必要はない:</p>
<div class="exampleInner">
<pre>
declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing
</pre></div>
<p>名前空間接頭辞 <code>xx</code> と <code>foo</code> は異なるが、これらはいずれも名前空間
URI <code>"http://example.org"</code> に束縛されている。<code>xx:bing</code>
と <code>foo:bing</code> は同じ局所名と同じ名前空間 URI
を持っているので、これらは照合される。上の問合せの出力は以下のようになる。</p>
<div class="exampleInner">
<pre>
&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="id-default-namespace" id=
"id-default-namespace"></a>4.13 デフォルト名前空間宣言</h3>
<h5><a name="d2e16311" id="d2e16311"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-DefaultNamespaceDecl" id=
"doc-xquery-DefaultNamespaceDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td>
<td><code>DefaultNamespaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#doc-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
</table>
<p><b>デフォルト名前空間宣言</b>は<a title="Prolog" href=
"#dt-prolog">前書き</a>の中で用いることができ、接頭辞のない QName
を利用できるようにするためのものである。以下の種類のデフォルト名前空間宣言が支援されている:</p>
<ul>
<li>
<p><b>デフォルト要素/型名前空間宣言</b>は、接頭辞のない要素名や型名を関連づける名前空間 URI
を宣言する。この宣言は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>として記録される。<a title="Prolog"
href="#dt-prolog">前書き</a>には、たかだか1つのデフォルト要素/型名前空間宣言が含まれてもよい
[<a title="err:XQST0066" href=
"#ERRXQST0066">err:XQST0066</a>]。デフォルト要素/型名前空間宣言中の <a href=
"#doc-xquery-URILiteral">URILiteral</a> が長さ0の文字列であるならば、<a title=
"default element/type namespace" href=
"#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>は宣言されず ("none"
に設定される)、接頭辞のない要素名や型名はどの名前空間にも属さないとみなされる。以下に示すのは要素名や型名のデフォルト名前空間の宣言の例である:</p>
<div class="exampleInner">
<pre>
declare default element namespace "http://example.org/names";
</pre></div>
<p>デフォルト要素/型名前空間宣言は、<a title="direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>中の<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>によって上書きされてもよい。</p>
<p>デフォルト要素/型名前空間宣言がなければ、接頭辞のない要素名や型名はどの名前空間にも属さない (ただし、<a href=
"#id-xq-static-context-components"><b>C.1 静的文脈の構成要素</b></a>
にあるように、実装が異なるデフォルト値を定義してもよい)。</p>
</li>
<li>
<p><b>デフォルト関数名前空間宣言</b>は、関数呼び出しや関数宣言における接頭辞なしの関数名に関連づけられる名前空間 URI
を宣言する。この宣言は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title=
"default function namespace" href=
"#dt-def-fn-ns">デフォルト関数名前空間</a>として記録される。<a title="Prolog" href=
"#dt-prolog">前書き</a>には、たかだか1つのデフォルト関数名前空間宣言が含まれてもよい [<a title=
"err:XQST0066" href=
"#ERRXQST0066">err:XQST0066</a>]。もしデフォルト関数名前空間宣言中の StringLiteral
が長さ0の文字列であるならば，デフォルト関数名前空間は宣言されない ("none"
に設定される)。この場合，名前空間に関連づけられる関数はいずれも明示的な名前空間接頭辞を用いてのみ呼び出すことができる。</p>
<p>デフォルト関数名前空間宣言がなければ、デフォルト関数名前空間は XPath/XQeury
の関数の名前空間、<code>http://www.w3.org/2005/xpath-functions</code> である
(ただし、<a href="#id-xq-static-context-components"><b>C.1
静的文脈の構成要素</b></a>にある通り、実装は異なるデフォルト値を定義してもよい)。</p>
<p>以下に示すのは、デフォルト関数名前空間の宣言の例である:</p>
<div class="exampleInner">
<pre>
declare default function namespace 
     "http://example.org/math-functions";
</pre></div>
<p>デフォルト関数名前空間を宣言することにより、暗黙的に定義される<a title="constructor function"
href=
"#dt-constructor-function">構成子関数</a>を含め、デフォルト関数名前空間に属するすべての関数は、名前空間接頭辞をつけずに起動することができる。接頭辞のない関数名を用いて関数を呼び出すとき、その関数の局所名は、デフォルト関数名前空間中の関数に
(暗黙的に宣言される<a title="constructor function" href=
"#dt-constructor-function">構成子関数</a>を含む) 照合されなければならない [<a title=
"err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="constructor function" href=
"#dt-constructor-function">構成子関数</a>だけは、どの名前空間にも属さないことが可能である</p>
</div>
</li>
</ul>
<p>接頭辞のない属性名や変数名は、どの名前空間にも属さない。</p>
</div>
<div class="div2">
<h3><a name="id-variable-declarations" id=
"id-variable-declarations"></a>4.14 変数宣言</h3>
<h5><a name="d2e16411" id="d2e16411"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-VarDecl" id=
"doc-xquery-VarDecl"></a>[24]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "variable" "$" <a href=
"#prod-xquery-QName">QName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href=
"#doc-xquery-ExprSingle">ExprSingle</a>) | "external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N15334.doc-xquery-VarName" id=
"noid_N15334.doc-xquery-VarName"></a>[88]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N15336.doc-xquery-TypeDeclaration" id=
"noid_N15336.doc-xquery-TypeDeclaration"></a>[118]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"as" <a href=
"#doc-xquery-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p><b>変数宣言</b>は、変数の<a title="static type" href=
"#dt-static-type">静的型</a>を<a title="in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>に追加する。また、その変数の値を<a title=
"variable values" href=
"#dt-variable-values">変数値</a>に追加してもよい。その変数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済 QName</a>が<a title=
"in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>中の別の変数の名前と (<code>eq</code>
演算子によって定義される通り) 等しいならば、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する[<a title="err:XQST0049" href=
"#ERRXQST0049">err:XQST0049</a>]。</p>
<p>変数宣言に型が含まれていれば、その型が、変数の型として<a title="static context" href=
"#dt-static-context">静的文脈</a>に追加される。変数宣言に式が含まれているが明示的な型が含まれていなければ、その式の静的解析によって変数の型が推論され、<a title="static context"
href=
"#dt-static-context">静的文脈</a>に追加される。変数宣言に型と式の両方が含まれていれば、式によって返される値は、<a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType
の照合</a>に対するルールに従って、宣言された型と照合されなければならない。そうでなければ<a title="type error"
href="#dt-type-error">型エラー</a>が発生する [<a title="err:XPTY0004" href=
"#ERRXPTY0004">err:XPTY0004</a>]。</p>
<p>[<a name="dt-initializing-expression" id=
"dt-initializing-expression" title=
"initializing expression">Definition</a>:
変数宣言に式が含まれていれば、その式を<b>初期化式</b>という。]
与えられた変数に対する初期化式は、その変数を参照するどの式の評価よりも前に評価されなければならない。初期化式の<a title=
"static context" href="#dt-static-context">静的文脈</a>には、<a title=
"Prolog" href=
"#dt-prolog">前書き</a>中の任意の場所で宣言されたり輸入されたりする関数がすべて含まれる。しかし、変数や名前空間については、前書きのうち、初期化される変数よりも前で宣言されたり輸入されたりしているものしか含まれない。初期化式が巡回性のために評価できないならば
(例えば、初期化式がある関数に依存しており、さらにその関数が初期化される変数の値に依存している、など)、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する [<a title=
"err:XQST0054" href="#ERRXQST0054">err:XQST0054</a>]。</p>
<p>変数宣言にキーワード <code>external</code>
が含まれていれば、その問合せが評価される前に、外部環境によって変数に対する値が提供されなければならない。外部変数宣言に宣言された型も含まれるならば，外部環境によって提供される値は、<a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType
の照合</a>に対するルールに従って，宣言された型に照合されなければならない (<a href=
"#id-consistency-constraints"><b>2.2.5
無矛盾性制約</b></a>を見よ)。外部変数宣言に宣言された型が含まれないならば、評価時に、型とそれに照合される値が外部環境によって提供されなければならない。このような変数の<a title="static type"
href="#dt-static-type">静的型</a>は <code>item()*</code> であるとみなされる。</p>
<p><a title="library module" href=
"#dt-library-module">ライブラリモジュール</a>で宣言された変数名はすべて、(展開されたときに)
そのライブラリモジュールの<a title="target namespace" href=
"#dt-target-namespace">目的名前空間</a>中になければならない [<a title=
"err:XQST0048" href=
"#ERRXQST0048">err:XQST0048</a>]。ライブラリモジュールが輸入されるとき、輸入されたモジュールで宣言されている変数が、輸入しているモジュールの<a title="in-scope variables"
href="#dt-in-scope-variables">有効範囲内変数</a>に追加される。</p>
<p>
名前空間接頭辞のない変数名はどの名前空間にも属さない。名前空間接頭辞のない変数宣言は、主モジュールにしか出現してはならない。</p>
<p><b>変数宣言</b>という用語は、<a title="Prolog" href="#dt-prolog">前書き</a>
中で常に変数の宣言を参照する。FLWOR
式などの問い合せ式中で変数に値を束縛するのは<b>変数束縛</b>として知られており、その変数を輸入されたモジュールから見えるようにすることはしない。</p>
<p>以下に、変数宣言の例をいくつか示す:</p>
<ul>
<li>
<p>以下の宣言では、変数の型と値を両方指定している。この宣言では、<a title="static context" href=
"#dt-static-context">静的文脈</a>中で変数 <code>$x</code> に関連づけられる型を
<code>xs:integer</code> とし、<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>中で変数 <code>$x</code> に関連づけられる値を
<code>7</code> としている。</p>
<div class="exampleInner">
<pre>
declare variable $x as xs:integer := 7;
</pre></div>
</li>
<li>
<p>以下の宣言では、値は指定しているが型は指定していない。変数の<a title="static type" href=
"#dt-static-type">静的型</a>は、値の静的型から推論される。この場合は、変数 <code>$x</code> は
<code>xs:decimal</code> という静的型を持つ。これは 7.5 という値から推論される。</p>
<div class="exampleInner">
<pre>
declare variable $x := 7.5;
</pre></div>
</li>
<li>
<p>以下の宣言では、型は指定しているが値は指定していない。キーワード <code>external</code>
によって、変数の値は外部環境によって提供されるということが示されている。評価時には、<a title=
"dynamic context" href="#dt-dynamic-context">動的文脈</a>中の変数
<code>$x</code> が <code>xs:integer</code> 型の値を持たなければ、型エラーが発生する。</p>
<div class="exampleInner">
<pre>
declare variable $x as xs:integer external;
</pre></div>
</li>
<li>
<p>以下の宣言では、型も値も宣言されていない。ここでは、単に、問合せが <code>$x</code>
と名付けられた変数の存在に依存しており、この変数の型や値は外部環境によって提供されるということが宣言されている。問合せの解析では、<code>$x</code>
の型は <code>item()*</code> とみなされる。問合せの評価では、<a title="dynamic context"
href="#dt-dynamic-context">動的文脈</a>に <code>$x</code>
の型と値が含まれていなければならず、その値は型と互換でなければならない。</p>
<div class="exampleInner">
<pre>
declare variable $x external;
</pre></div>
</li>
<li>
<p>以下の宣言は、ライブラリモジュール中に出現するかもしれないものであり、名前空間接頭辞を含む名前を持つ変数を宣言している:</p>
<div class="exampleInner">
<pre>
declare variable $math:pi as xs:double := 3.14159E0;
</pre></div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="FunctionDeclns" id="FunctionDeclns"></a>4.15 関数宣言</h3>
<p><a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a> で述べている組み込み関数に加えて、XQuery
ではユーザが独自の関数を宣言することができる。関数宣言は、その関数の名前、引数の名前とデータ型、結果のデータ型を指定する。データ型はすべて、<a href="#id-types"><b>2.5
型</b></a> で述べる構文を用いて指定される。関数宣言により、それが出現する<a title="module" href=
"#dt-module">モジュール</a>の<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>に、宣言された関数が加えられる。</p>
<h5><a name="d2e16637" id="d2e16637"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-FunctionDecl" id=
"doc-xquery-FunctionDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "function" <a href=
"#prod-xquery-QName">QName</a> "(" <a href=
"#doc-xquery-ParamList">ParamList</a>? ")" ("as" <a href=
"#doc-xquery-SequenceType">SequenceType</a>)? (<a href=
"#doc-xquery-EnclosedExpr">EnclosedExpr</a> |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-ParamList" id=
"doc-xquery-ParamList"></a>[27]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParamList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#doc-xquery-Param">Param</a> ("," <a href=
"#doc-xquery-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-Param" id=
"doc-xquery-Param"></a>[28]&nbsp;&nbsp;&nbsp;</td>
<td><code>Param</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href="#prod-xquery-QName">QName</a> <a href=
"#doc-xquery-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_N15448.doc-xquery-TypeDeclaration" id=
"noid_N15448.doc-xquery-TypeDeclaration"></a>[118]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"as" <a href=
"#doc-xquery-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
</table>
<p>関数宣言では、関数が<a title="user-defined function" href=
"#dt-udf">ユーザ定義</a>なのか<a title="external function" href=
"#dt-external-function">外部</a>なのかを指定する。[<a name="dt-udf" id=
"dt-udf" title="user-defined function">Definition</a>:
<b>ユーザ定義関数</b>に対して、関数宣言には<b>関数の本体</b>と呼ばれる式が含まれる。これは、その関数の結果が引数からどのように計算されるかを定義する。]
関数の本体に対する<a title="static context" href=
"#dt-static-context">静的文脈</a>には、<a title="Prolog" href=
"#dt-prolog">前書き</a>中のどこかで宣言されたり輸入されたりする関数がすべて含まれる。しかし、変数や名前空間については、定義された関数より前書き中で早く宣言されたり輸入されたりするものしか含まれない。</p>
<p>[<a name="dt-external-function" id="dt-external-function" title=
"external function">Definition</a>:
<b>外部関数</b>は、その問合せの環境の外側で実装されている関数である。] 例えば、XQuery の実装は、<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>に述べられているコア関数ライブラリに加えて、外部関数の集合を用意しているかもしれない。外部関数は、キーワード
<code>external</code>
によって識別される。。外部関数に対する関数宣言の目的は、その関数の引数や結果のデータ型を宣言し、その関数宣言を含んだり輸入する問合せの型検査に用いることである。</p>
<p>XQuery
の実装は、ホストプログラミング言語を用いて外部関数を実装できる機能を提供してもよいが、そうすることを要求はされない。このような機能が提供されているならば、引数を外部関数に渡したり、その関数の結果を呼び出しを行った問合せに戻すプロトコルは<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。XQuery の実装は<a href=
"#datamodel">[XQuery/XPath Data Model
(XDM)]</a>の型システムを、ホストプログラミング言語とデータを交換する機能のために設計された追加型で拡張してもよい。また、ユーザがこのような型を定義することのできる機構を提供してもよい。例えば、SQLデータベースの接続など、外部関数によって返されるオブジェクトをカプセル化する型を提供してもよい。このような追加型は、もし定義されれば、<code>xs:anyAtomicType</code>
から制限によって導出されているとみなされる。</p>
<p>ユーザ定義の関数はいずれもある名前空間に属していなければならない -- すなわち、宣言された関数名は (展開した時に)
空でない名前空間 URI を持っていなければならない [<a title="err:XQST0060" href=
"#ERRXQST0060">err:XQST0060</a>]。関数宣言中の関数名が名前空間接頭辞を持っていなければ、<a title="default function namespace"
href="#dt-def-fn-ns">デフォルト関数名前空間</a>に属しているとみなされる。<a title=
"library module" href=
"#dt-library-module">ライブラリモジュール</a>中で定義される関数名はいずれも (展開した時に)
そのライブラリモジュールの<a title="target namespace" href=
"#dt-target-namespace">目的名前空間</a>に属していなければならない [<a title=
"err:XQST0048" href="#ERRXQST0048">err:XQST0048</a>]。関数宣言中の関数名が
(展開した時に) 以下の名前空間のいずれかに属していれば、<a title="static error" href=
"#dt-static-error">静的エラー</a> [<a title="err:XQST0045" href=
"#ERRXQST0045">err:XQST0045</a>] である:</p>
<ul>
<li>
<p><code>http://www.w3.org/XML/1998/namespace</code></p>
</li>
<li>
<p><code>http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>http://www.w3.org/2001/XMLSchema-instance</code></p>
</li>
<li>
<p><code>http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li>
<p><code>http://www.w3.org/2005/xpath-datatypes</code></p>
</li>
</ul>
<p>宣言された関数の<a title="expanded QName" href="#dt-expanded-qname">展開済
QName</a>と次数 (引数の数) が<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>中の別の関数の<a title=
"expanded QName" href="#dt-expanded-qname">展開済 QName</a>と次数に
(<code>eq</code> 演算子によって定義されるように) 等しければ、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XQST0034" href=
"#ERRXQST0034">err:XQST0034</a>] である。</p>
<p>新しい名前空間を定義することなく、主モジュールがそのモジュール内で局所的に使用する関数を宣言できるようにするために、XQuery
では名前空間接頭辞 <code>local</code> を名前空間
<code>http://www.w3.org/2005/xquery-local-functions</code>
にあらかじめ定義している。この名前空間は、局所関数を定義するのに用いることが推奨される (しかし要求される訳ではない)。</p>
<p>関数の引数の宣言に名前はあるが型がないならば、そのデフォルト型は <code>item()*</code>
である。結果型が関数の宣言から省略されていれば、そのデフォルト結果型は <code>item()*</code> である。</p>
<p>
関数宣言の引数は、有効範囲が関数の本体であるような変数とみなされる。2つ以上の引数が同じ名前を持つような関数宣言は<a title=
"static error" href="#dt-static-error">静的エラー</a> [<a title=
"err:XQST0039" href="#ERRXQST0039">err:XQST0039</a>]
である。関数の引数の型は<a title="sequence type" href=
"#dt-sequence-type">列型</a>として表現可能な任意の型であってよい。</p>
<p>以下の例では、<code>employee</code>
要素の列を受け取り、それらを部門ごとにまとめ、<code>dept</code>
要素の列を返すような局所変数の宣言と使用を示している。</p>
<ul>
<li>
<p>関数を用いて、Denver にいる従業員に関するまとめを用意する。</p>
<div class="exampleInner">
<pre>
declare function local:summary($emps as element(employee)*) 
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])
</pre></div>
</li>
</ul>
<p>関数の引数を宣言された引数の型に変換するルールや、関数の結果を宣言された結果の型に変換するルールについては、<a href=
"#id-function-calls"><b>3.1.5 関数呼び出し</b></a>に述べられている。</p>
<p>
関数宣言は再帰的であってもよい。すなわち、自分自身を参照していてもよい。相互再帰関数、すなわち関数の本体が互いに参照し合うような関数も許される。以下の例では、節点の階層の深さの最大値を計算する再帰関数を定義し、その関数を呼び出してある文書の深さの最大値を求めている。この宣言の中で、ユーザ定義関数
<code>local:depth</code> は組み込み関数 <code>empty</code> と
<code>max</code> を呼び出しているが、これらはいずれもデフォルト関数名前空間に属している。</p>
<ul>
<li>
<p><code>partlist.xml</code> という名前の文書の深さの最大値を求める。</p>
<div class="exampleInner">
<pre>
declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</pre></div>
</li>
</ul>
<p><a title="constructor function" href=
"#dt-constructor-function">構成子関数</a>は<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中のユーザ定義の原子型それぞれに効果的に宣言されるため、前書き中でこれらの型のいずれかと同じ<a title="expanded QName"
href="#dt-expanded-qname">展開済 QName</a>を持つ引数1つの関数が宣言されていれば<a title=
"static error" href="#dt-static-error">静的エラー</a> [<a title=
"err:XQST0034" href="#ERRXQST0034">err:XQST0034</a>] が発生する。</p>
</div>
<div class="div2">
<h3><a name="id-option-declaration" id=
"id-option-declaration"></a>4.16 オプション宣言</h3>
<p>[<a name="dt-option-declaration" id="dt-option-declaration"
title="option declaration">Definition</a>:
<b>オプション宣言</b>は特定の実装の振舞いに影響を与えるオプションを宣言する。オプションはそれぞれ、識別される QName と
StringLiteral 1つずつから構成される。]</p>
<h5><a name="d2e16873" id="d2e16873"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xquery-OptionDecl" id=
"doc-xquery-OptionDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td>
<td><code>OptionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "option" <a href="#prod-xquery-QName">QName</a>
<a href="#doc-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<p>
通常、オプションはある実装には認識されるが他の実装には認識されない。オプション宣言がどの実装でも構文解析に成功するように、構文は設計されている。</p>
<p><a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>を用いて、オプションの QName は名前空間 URI
と局所名に解決されなければならない [<a title="err:XPST0081" href=
"#ERRXPST0081">err:XPST0081</a>]。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>オプションにはデフォルト名前空間はない。</p>
</div>
<p>実装はそれぞれ、オプション宣言を表す名前空間 URI の<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>の集合を認識する。</p>
<p>QName
の名前空間部分が、実装によってオプション宣言を表すと認識される名前空間でないならば、そのオプション宣言は無視される。</p>
<p>そうでない場合、オプション宣言の効果は、エラーに関する振舞いを含め、<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。例えば、QName
の局所名が認識されなかったり、StringLiteral
が特定のオプション宣言に対して実装によって定義されるルールに適合しない場合、実装は、エラーを報告する、オプション宣言を無視する、これ以外の動作を行う、などのどれを選択してもよい。</p>
<p>
実装は、オプション宣言が変数宣言や関数宣言に対して相対的に出現する位置に関するルールを課してもよい。またオプション宣言の解釈はその位置に依存してもよい。</p>
<p>
オプション宣言は、処理器によって受理される構文を変更するのに用いてはならない。また静的エラーの検出の抑制に用いてもならない。しかし、問合せの意味を変更することには制限なしに用いてもよい。オプション宣言の有効範囲は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である -
例えば、オプション宣言は問合せ全体に適用されてもよいし、現在のモジュールのみに適用されてもよいし、直後に続く関数宣言のみに適用されてもよい。</p>
<p>以下の例では、オプション宣言の使い方としてあり得るものをいろいろ示す:</p>
<ul>
<li>
<p>このオプション宣言は直列化のパラメータを設定するのに用いられる:</p>
<div class="exampleInner">
<pre>
declare namespace exq = "http://example.org/XQueryImplementation";
declare option exq:output "encoding = iso-8859-1";
</pre></div>
</li>
<li>
<p>このオプション宣言は、<code>fn:doc()</code>
関数によって返されるソース文書中のコメントがどのように扱われるかを指定する:</p>
<div class="exampleInner">
<pre>
declare option exq:strip-comments "true";
</pre></div>
</li>
<li>
<p>このオプション宣言は、関数名中で用いられる名前空間と Java クラスを関連づけるのに用いられる:</p>
<div class="exampleInner">
<pre>
declare namespace math = "http://example.org/MathLibrary";
declare option exq:java-class "math = java.lang.Math";
</pre></div>
</li>
</ul>
</div>
</div>
<div class="div1">
<h2><a name="id-xquery-conformance" id=
"id-xquery-conformance"></a>5 適合性</h2>
<p>この節では、XQuery 処理器の適合性規準を定義する。この節では、<a href="#RFC2119">[RFC
2119]</a>で定義される要求水準を表すのに以下の用語を用いる。 [<a name="must" id="must" title=
"must">Definition</a>: <b>しなければならない</b> (MUST)
は、仕様の絶対的な要求である項目を意味する。] [<a name="may" id="may" title=
"may">Definition</a>: <b>してもよい</b> (MAY) は、項目が真に選択可能であることを意味する。]
[<a name="should" id="should" title="should">Definition</a>:
<b>べきである</b> (SHOULD)
は、特定の状況ではその項目を無視する正当な理由があるかもしれないが、影響を完全に理解しなければならず、異なる選択を選ぶ前に十分慎重に考慮しなければならない、ということを意味する。]</p>
<p>この仕様に適合することを要求する XQuery 処理器は、<a href=
"#id-minimal-conformance"><b>5.1
最小適合性</b></a>で定義される最小適合性の要求を含ま<a title="must" href=
"#must">なければならない</a>。最小適合性の要求に加え、<a href=
"#id-conform-optional-features"><b>5.2
省略可能な機能</b></a>で定義される省略可能な機能のうち1つ以上に関する適合性を要求<a title="may" href=
"#may">してもよい</a>。</p>
<div class="div2">
<h3><a name="id-minimal-conformance" id=
"id-minimal-conformance"></a>5.1 最小適合性</h3>
<p>この仕様に対する最小適合性は、以下の項目のすべてを含ま<a title="must" href=
"#must">なければならない</a>:</p>
<ol class="enumar">
<li>
<p>この文書で指定されているすべての支援。ただし、<a href=
"#id-conform-optional-features"><b>5.2
省略可能な機能</b></a>で省略可能と指定されている機能を除く。実装がある省略可能な機能を提供しないならば、<a href=
"#id-conform-optional-features"><b>5.2
省略可能な機能</b></a>で指定されている要求のうち、その機能を提供しない実装に対するものをいずれも実装<a title=
"must" href="#must">しなければならない</a>。</p>
</li>
<li>
<p><a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>と指定されているすべての項目の定義。ただし、その項目がその実装によって支援されない省略可能な機能の一部でない場合に限る。<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>の項目のリストは<a href=
"#id-impl-defined-items"><b>D 実装定義の項目</b></a>にある。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>実装は、<a title="implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>と指定されている項目を定義することは要求されない。</p>
</div>
</li>
<li>
<p><a href="#id-data-model-conformance"><b>5.3
データモデル適合</b></a>に指定されている通りに<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>を支援すること。</p>
</li>
<li>
<p><a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators]</a>に定義されているすべての関数の支援。</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-conform-optional-features" id=
"id-conform-optional-features"></a>5.2 省略可能な機能</h3>
<div class="div3">
<h4><a name="id-schema-import-feature" id=
"id-schema-import-feature"></a>5.2.1 スキーマ輸入機能</h4>
<p>[<a name="dt-schema-import-feature" id=
"dt-schema-import-feature" title=
"schema import feature">Definition</a>:
<b>スキーマ輸入機能</b>は問合せの前書きに<a title="schema import" href=
"#dt-schema-import">スキーマ輸入</a>を含めることを許す。]</p>
<p>XQuery の実装がスキーマ輸入機能を支援しないならば、その実装は，スキーマ輸入を発見すると静的エラー [<a title=
"err:XQST0009" href="#ERRXQST0009">err:XQST0009</a>] を発生<a title=
"must" href="#must">しなければならない</a>。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>実装がスキーマ輸入機能を支援しないならば、<a href=
"#id-xq-static-context-components"><b>C.1
静的文脈の構成要素</b></a>にある通り，<a title="in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>は組み込みスキーマ型定義と<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>のスキーマ型定義のみからなる。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-schema-validation-feature" id=
"id-schema-validation-feature"></a>5.2.2 スキーマ検証機能</h4>
<p>[<a name="dt-schema-validation-feature" id=
"dt-schema-validation-feature" title=
"schema validation feature">Definition</a>: <b>スキーマ検証機能</b>は、問合せに
<code>validate</code> 式 (<a href="#id-validate"><b>3.13
検証式</b></a>を見よ) を含めることを許す。]</p>
<p>XQuery の実装がスキーマ検証機能を支援しないならば、その実装は、<code>validate</code>
式を発見すると静的エラー [<a title="err:XQST0075" href=
"#ERRXQST0075">err:XQST0075</a>] を発生<a title="must" href=
"#must">しなければならない</a>。</p>
</div>
<div class="div3">
<h4><a name="id-static-typing-feature" id=
"id-static-typing-feature"></a>5.2.3 静的型付け機能</h4>
<p>[<a name="dt-static-typing-feature" id=
"dt-static-typing-feature" title=
"static typing feature">Definition</a>: <b>静的型付け機能</b>は<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>に定義されている静的意味の支援を提供し、実装に、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>において<a title="type error" href=
"#dt-type-error">型エラー</a>を検出し報告することを要求する。]</p>
<p>実装が<a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>を支援せず、にもかかわらず静的解析相で、ある式が評価されると実行時に型エラーを必ず発生させると決定できるならば、実装は、静的解析相でエラーを発生させ<a title="may"
href="#may">てもよい</a>。解析時にこのようなエラーを発生させるかどうかの選択は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="static typing feature" href=
"#dt-static-typing-feature">静的解析相</a>を支援しない実装は、静的解析相で型エラーを発生させる必要はない。しかし、型に関係しないエラーは静的解析相で検出し発生させ<a title="must"
href="#must">なければならない</a>。</p>
</div>
<div class="div4">
<h5><a name="id-static-extensions" id=
"id-static-extensions"></a>5.2.3.1 静的型付け拡張</h5>
<p>場合によっては、<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath
2.0 Formal Semantics]</a>で定義される静的型付けルールはあまり詳細ではない (例えば、祖先方向の軸 --
つまり parent, ancenstor, ancestor-or-self -- や <code>fn:root</code>
関数に対する型推論ルールを見よ)。実装によっては、より詳細な静的型付けルールを支援することを期待してもよい。</p>
<p><a title="static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>を実装している適合実装は、また1つ以上の<b>静的型付け拡張</b>を提供<a title="may"
href="#may">してもよい</a>。[<a name="dt-static-typing-extension" id=
"dt-static-typing-extension" title=
"static typing extension">Definition</a>: <b>静的型付け拡張</b>は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の型推論ルールである。これは<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>の型推論ルールによって推論される静的型よりも詳細な静的型を推論する。]
静的型付け拡張の制約の形式的な定義については <a href=
"http://www.w3.org/TR/xquery-semantics/#id-static-extensions">6.1.1
Static Typing Extensions</a><sup xmlns=""><small>FS</small></sup>
を見よ。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-full-axis-feature" id=
"id-full-axis-feature"></a>5.2.4 全軸機能</h4>
<p>[<a name="dt-optional-axis" id="dt-optional-axis" title=
"optional axis">Definition</a>: 以下の軸は<b>選択的な軸</b>として設計されている:
<code>ancestor</code>, <code>ancestor-or-self</code>,
<code>following</code>, <code>following-sibling</code>,
<code>preceding</code>, および <code>preceding-sibling</code>。]</p>
<p>[<a name="dt-full-axis-feature" id="dt-full-axis-feature" title=
"Full Axis Feature">Definition</a>: <b>全軸機能</b>を支援する適合 XQuery
実装は、すべての<a title="optional axis" href=
"#dt-optional-axis">選択的な軸</a>を支援<a title="must" href=
"#must">しなければならない</a>。]</p>
<p>全軸機能を支援しない適合 XQuery 実装は、選択的な軸を1つ以上支援<a title="may" href=
"#may">してもよい</a>。このような実装によってどの軸が支援されるかは<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。適合実装が、それが支援しない選択的な軸への参照を発見した場合、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XPST0010" href=
"#ERRXPST0010">err:XPST0010</a>] を発生させ<a title="must" href=
"#must">なければならない</a>。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XQuery は <code>namespace</code> 軸 (XPath 1.0 で定義され、XPath 2.0
では推奨されない) を認識しない。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-module-feature" id="id-module-feature"></a>5.2.5
モジュール機能</h4>
<p>[<a name="dt-module-feature" id="dt-module-feature" title=
"module feature">Definition</a>: <b>モジュール機能</b>を支援する適合 XQuery
実装は、問合せの前書きに<b>モジュール輸入</b>が含まれることを許す。また<b>ライブラリモジュール</b>を生成することを許す。]</p>
<p>モジュール機能を支援しない適合実装は、<a title="module declaration" href=
"#dt-module-declaration">モジュール定義</a>や<a title="module import" href=
"#dt-module-import">モジュール輸入</a>を発見した場合、<a title="static error"
href="#dt-static-error">静的エラー</a> [<a title="err:XQST0016" href=
"#ERRXQST0016">err:XQST0016</a>] を発生させ<a title="must" href=
"#must">なければならない</a>。<a title="module declaration" href=
"#dt-module-declaration">モジュール定義</a>は<a title="library module"
href="#dt-library-module">ライブラリモジュール</a>中で必要であるので、モジュール機能は、<a title="library module"
href="#dt-library-module">ライブラリモジュール</a>を生成するために必要である。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>モジュール機能がなければ、各問合せは単一の<a title="main module" href=
"#dt-main-module">主モジュール</a>から構成される。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization-feature" id=
"id-serialization-feature"></a>5.2.6 直列化機能</h4>
<p>[<a name="dt-serialization-feature" id=
"dt-serialization-feature" title=
"serialization feature">Definition</a>: <b>直列化機能</b>を支援する適合 XQuery
実装は、<a href="#id-serialization"><b>2.2.4
直列化</b></a>で指定されている通りに、問合せの結果を直列化する手段を提供<a title="must" href=
"#must">しなければならない</a>。]</p>
<p>直列化機能を支援する適合 XQuery 実装は<a href=
"#id-xq-serialization-parameters"><b>C.3
直列化パラメータ</b></a>に適合してい<a title="must" href=
"#must">なければならない</a>。直列化が実行される方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</p>
<p><a href="#serialization">[XSLT 2.0 and XQuery 1.0
Serialization]</a>に指定されている通りの直列化プロセスでエラーが発生すれば、適合 XQuery
実装は呼び出している環境にエラーを報告し<a title="must" href="#must">なければならない</a>。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>すべての実装が直列化を必要とするわけではない。例えば、ある実装は、テキスト表現を生成する代わりに XML API
を通して結果を提供するかもしれない。</p>
</div>
</div>
<div class="div3">
<h4><a name="id-trivial-xml-embedding-feature" id=
"id-trivial-xml-embedding-feature"></a>5.2.7 自明な XML 埋め込み機能</h4>
<p>[<a name="dt-trivial-xml-embedding" id=
"dt-trivial-xml-embedding" title=
"Trivial XML Embedding">Definition</a>: <b>自明な XML
埋め込み機能</b>を支援する適合 XQuery 実装は、<a href="#XQueryX">[XQueryX 1.0]</a>
5章, "A Trivial Embedding of XQuery" に指定されている埋め込みを提供<a title="must"
href="#must">しなければならない</a>。]</p>
</div>
</div>
<div class="div2">
<h3><a name="id-data-model-conformance" id=
"id-data-model-conformance"></a>5.3 データモデル適合</h3>
<p>すべての XQuery 実装は<a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>に指定されている<a title="data model" href=
"#dt-datamodel">データモデル</a>中で表現されているデータを処理する。データモデルの仕様は、対応する環境中でのそのデータモデルに対する適合性水準を指定するのに
XQuery のような言語に頼っている。そして、以下の項目を考慮すべきであると提案している:</p>
<ol class="enumar">
<li>
<p><em>情報集合からの規範的な構成の支援。</em> 適合実装は<a href=
"http://www.w3.org/TR/xpath-datamodel/#const-infoset">3.2
Construction from an Infoset</a><sup xmlns=
""><small>DM</small></sup>への適合を要求することを選択<a title="may" href=
"#may">してもよい</a>。これは、単なる整形式 XML 文書や DTD によって管理されている XML
文書から<a title="XDM instance" href="#dt-data-model-instance">XDM
インスタンス</a>を構成する規範的な方法を定義する。</p>
</li>
<li>
<p><em>PSVI からの規範的な構成の支援。</em> 適合実装は<a href=
"http://www.w3.org/TR/xpath-datamodel/#const-psvi">3.3 Construction
from a PSVI</a><sup xmlns=
""><small>DM</small></sup>への適合を要求することを選択<a title="may" href=
"#may">してもよい</a>。これは、W3C XML Schema によって管理されている XML 文書から<a title=
"XDM instance" href="#dt-data-model-instance">XDM
インスタンス</a>を構成する規範的な方法を定義する。</p>
</li>
<li>
<p><em>XML 1.0 と XML 1.1 に対する支援。</em> <a href=
"#datamodel">[XQuery/XPath Data Model (XDM)]</a>は<a href=
"#XML">[XML 1.0]</a>か<a href="#XML1.1">[XML
1.1]</a>のいずれか一方を支援する。XQuery では、どちらの XML バージョンを支援するかの選択は<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。</p>
<p>執筆時点では、XML 1.1 の仕様を参照する XML Schema
のバージョンは出版されていない。これにより、<code>xs:NCName</code> や <code>xs:ID</code>
といったデータ型は XML 1.0 のルールに制約される。XQuery 1.0 処理器は、XML Schema
の将来のバージョンが有効になれば、そのバージョンで定義されるルールを実装するべきである。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XML 1.1 文書の処理に関する示唆については<a href="#xml11schema10">[XML 1.1 and
Schema 1.0]</a>を見よ。</p>
</div>
</li>
<li>
<p><em>データ値の範囲。</em> XQuery では、以下の制限が<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>である:</p>
<ol class="enumla">
<li>
<p><code>xs:decimal</code> 型に対して、10進数の最大値 (<code>totalDigits</code>
相) (少なくとも 18 でなければならない)。</p>
</li>
<li>
<p><code>xs:date</code> 型、<code>xs:time</code>
型、<code>xs:dateTime</code> 型、<code>xs:gYear</code>
型、<code>xs:gYearMonth</code> 型に対して: 年の構成要素の最大値と、断片となる秒数 (少なくとも 3
でなくてはならない)。</p>
</li>
<li>
<p><code>xs:duration type</code> 型に対して: 年、月、日、時、分の構成要素の最大絶対値。</p>
</li>
<li>
<p><code>xs:yearMonthDuration</code> 型に対して:
最大絶対値。これは月の整数値として表現される。</p>
</li>
<li>
<p><code>xs:dayTimeDuration type</code> に対して:
最大絶対値。これは秒の10進数として表現される。</p>
</li>
<li>
<p><code>xs:string</code>, <code>xs:hexBinary</code>,
<code>xs:base64Binary</code>, <code>xs:QName</code>,
<code>xs:anyURI</code>, <code>xs:NOTATION</code>
の各型、およびこれらから導出される型に対して: 値の長さに関して実装によって強いられる制限 (もしあれば)。</p>
</li>
</ol>
<p>
上に列挙した制限は固定されなくてもよい。しかしシステム資源のような環境の要素に依存してもよい。例えば、<code>xs:string</code>
型の値の長さは、使用できるメモリによって制限されてもよい。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="nt-bnf" id="nt-bnf"></a>A XQueryの文法</h2>
<div class="div2">
<h3><a name="id-grammar" id="id-grammar"></a>A.1 EBNF</h3>
<p>XQueryの文法は、単純な拡張バッカス記法 (EBNF) を用いる。これは<a href="#XML">[XML
1.0]</a>と同じものであるが、以下に述べるように、若干の違いがある。</p>
<ul>
<li>
<p>名前づけられた記号はすべて、大文字で始まる名前を持つ。</p>
</li>
<li>
<p>外部の仕様の生成規則を参照するための記法を加える。</p>
</li>
<li>
<p>コメントや、文法の生成規則に関する特別な文法的制限を '/*' と '*/' という記号の間に置く。</p>
<ul>
<li>
<p>'xgc:' 接頭辞は特別な文法的制限であり、その詳細は<a href=
"#extra-grammatical-constraints"><b>A.1.2
特別な文法上の制約</b></a>に説明がある。</p>
</li>
<li>
<p>'ws:' 接頭辞は生成規則に対する空白のルールであり、その詳細は<a href=
"#whitespace-rules"><b>A.2.4 空白規則</b></a>に説明がある。</p>
</li>
<li>
<p>'gn:' 接頭辞は '文法上の備考' (Grammar
Note)の意味であり、ルール解釈を明確にすることを意味する。これについては<a href=
"#notes-on-parsing"><b>A.1.3
文法に関する備考</b></a>に説明されている。これらの備考は参考である。</p>
</li>
</ul>
</li>
</ul>
<p>この文法の終端記号には、既出の生成規則で用いられた引用符付き文字列や、<a href=
"#terminal-symbols"><b>A.2.1 終端記号</b></a>で定義された終端記号が含まれる。</p>
<p>EBNF記法についてのより詳しい説明は<a href="#EBNFNotation"><b>A.1.1
記法</b></a>にある。</p>
<p>
可読性を上げるため、この文書の本体のEBNFでは記法上の特徴をいくつか省略している。この附録はEBNFの参考バージョンである。</p>
<h5><a name="BNF-Grammar" id="BNF-Grammar"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Module" id=
"prod-xquery-Module"></a>[1]&nbsp;&nbsp;&nbsp;</td>
<td><code>Module</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-VersionDecl">VersionDecl</a>?
(<a href="#prod-xquery-LibraryModule">LibraryModule</a> | <a href=
"#prod-xquery-MainModule">MainModule</a>)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-VersionDecl" id=
"prod-xquery-VersionDecl"></a>[2]&nbsp;&nbsp;&nbsp;</td>
<td><code>VersionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"xquery" "version" <a href=
"#prod-xquery-StringLiteral">StringLiteral</a> ("encoding" <a href=
"#prod-xquery-StringLiteral">StringLiteral</a>)? <a href=
"#prod-xquery-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-MainModule" id=
"prod-xquery-MainModule"></a>[3]&nbsp;&nbsp;&nbsp;</td>
<td><code>MainModule</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Prolog">Prolog</a> <a href=
"#prod-xquery-QueryBody">QueryBody</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-LibraryModule" id=
"prod-xquery-LibraryModule"></a>[4]&nbsp;&nbsp;&nbsp;</td>
<td><code>LibraryModule</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ModuleDecl">ModuleDecl</a> <a href=
"#prod-xquery-Prolog">Prolog</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ModuleDecl" id=
"prod-xquery-ModuleDecl"></a>[5]&nbsp;&nbsp;&nbsp;</td>
<td><code>ModuleDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"module" "namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=" <a href=
"#prod-xquery-URILiteral">URILiteral</a> <a href=
"#prod-xquery-Separator">Separator</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Prolog" id=
"prod-xquery-Prolog"></a>[6]&nbsp;&nbsp;&nbsp;</td>
<td><code>Prolog</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>((<a href=
"#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a> |
<a href="#prod-xquery-Setter">Setter</a> | <a href=
"#prod-xquery-NamespaceDecl">NamespaceDecl</a> | <a href=
"#prod-xquery-Import">Import</a>) <a href=
"#prod-xquery-Separator">Separator</a>)* ((<a href=
"#prod-xquery-VarDecl">VarDecl</a> | <a href=
"#prod-xquery-FunctionDecl">FunctionDecl</a> | <a href=
"#prod-xquery-OptionDecl">OptionDecl</a>) <a href=
"#prod-xquery-Separator">Separator</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Setter" id=
"prod-xquery-Setter"></a>[7]&nbsp;&nbsp;&nbsp;</td>
<td><code>Setter</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a> | <a href=
"#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</a> |
<a href="#prod-xquery-BaseURIDecl">BaseURIDecl</a> | <a href=
"#prod-xquery-ConstructionDecl">ConstructionDecl</a> | <a href=
"#prod-xquery-OrderingModeDecl">OrderingModeDecl</a> | <a href=
"#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</a> | <a href=
"#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Import" id=
"prod-xquery-Import"></a>[8]&nbsp;&nbsp;&nbsp;</td>
<td><code>Import</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-SchemaImport">SchemaImport</a> |
<a href="#prod-xquery-ModuleImport">ModuleImport</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Separator" id=
"prod-xquery-Separator"></a>[9]&nbsp;&nbsp;&nbsp;</td>
<td><code>Separator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>";"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NamespaceDecl" id=
"prod-xquery-NamespaceDecl"></a>[10]&nbsp;&nbsp;&nbsp;</td>
<td><code>NamespaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=" <a href=
"#prod-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-BoundarySpaceDecl" id=
"prod-xquery-BoundarySpaceDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td>
<td><code>BoundarySpaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "boundary-space" ("preserve" |
"strip")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DefaultNamespaceDecl" id=
"prod-xquery-DefaultNamespaceDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td>
<td><code>DefaultNamespaceDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" ("element" | "function") "namespace"
<a href="#prod-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OptionDecl" id=
"prod-xquery-OptionDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td>
<td><code>OptionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "option" <a href="#prod-xquery-QName">QName</a>
<a href="#prod-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderingModeDecl" id=
"prod-xquery-OrderingModeDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderingModeDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "ordering" ("ordered" |
"unordered")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-EmptyOrderDecl" id=
"prod-xquery-EmptyOrderDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td>
<td><code>EmptyOrderDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" "order" "empty" ("greatest" |
"least")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CopyNamespacesDecl" id=
"prod-xquery-CopyNamespacesDecl"></a>[16]&nbsp;&nbsp;&nbsp;</td>
<td><code>CopyNamespacesDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "copy-namespaces" <a href=
"#prod-xquery-PreserveMode">PreserveMode</a> "," <a href=
"#prod-xquery-InheritMode">InheritMode</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PreserveMode" id=
"prod-xquery-PreserveMode"></a>[17]&nbsp;&nbsp;&nbsp;</td>
<td><code>PreserveMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"preserve" | "no-preserve"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-InheritMode" id=
"prod-xquery-InheritMode"></a>[18]&nbsp;&nbsp;&nbsp;</td>
<td><code>InheritMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"inherit" | "no-inherit"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DefaultCollationDecl" id=
"prod-xquery-DefaultCollationDecl"></a>[19]&nbsp;&nbsp;&nbsp;</td>
<td><code>DefaultCollationDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "default" "collation" <a href=
"#prod-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-BaseURIDecl" id=
"prod-xquery-BaseURIDecl"></a>[20]&nbsp;&nbsp;&nbsp;</td>
<td><code>BaseURIDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "base-uri" <a href=
"#prod-xquery-URILiteral">URILiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SchemaImport" id=
"prod-xquery-SchemaImport"></a>[21]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaImport</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"import" "schema" <a href=
"#prod-xquery-SchemaPrefix">SchemaPrefix</a>? <a href=
"#prod-xquery-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SchemaPrefix" id=
"prod-xquery-SchemaPrefix"></a>[22]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaPrefix</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("namespace" <a href="#prod-xquery-NCName">NCName</a>
"=") | ("default" "element" "namespace")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ModuleImport" id=
"prod-xquery-ModuleImport"></a>[23]&nbsp;&nbsp;&nbsp;</td>
<td><code>ModuleImport</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"import" "module" ("namespace" <a href=
"#prod-xquery-NCName">NCName</a> "=")? <a href=
"#prod-xquery-URILiteral">URILiteral</a> ("at" <a href=
"#prod-xquery-URILiteral">URILiteral</a> ("," <a href=
"#prod-xquery-URILiteral">URILiteral</a>)*)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-VarDecl" id=
"prod-xquery-VarDecl"></a>[24]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "variable" "$" <a href=
"#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>? ((":=" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a>) | "external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ConstructionDecl" id=
"prod-xquery-ConstructionDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td>
<td><code>ConstructionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "construction" ("strip" |
"preserve")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-FunctionDecl" id=
"prod-xquery-FunctionDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionDecl</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"declare" "function" <a href=
"#prod-xquery-QName">QName</a> "(" <a href=
"#prod-xquery-ParamList">ParamList</a>? ")" ("as" <a href=
"#prod-xquery-SequenceType">SequenceType</a>)? (<a href=
"#prod-xquery-EnclosedExpr">EnclosedExpr</a> |
"external")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ParamList" id=
"prod-xquery-ParamList"></a>[27]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParamList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Param">Param</a> ("," <a href=
"#prod-xquery-Param">Param</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Param" id=
"prod-xquery-Param"></a>[28]&nbsp;&nbsp;&nbsp;</td>
<td><code>Param</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href="#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-EnclosedExpr" id=
"prod-xquery-EnclosedExpr"></a>[29]&nbsp;&nbsp;&nbsp;</td>
<td><code>EnclosedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"{" <a href="#prod-xquery-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-QueryBody" id=
"prod-xquery-QueryBody"></a>[30]&nbsp;&nbsp;&nbsp;</td>
<td><code>QueryBody</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Expr" id=
"prod-xquery-Expr"></a>[31]&nbsp;&nbsp;&nbsp;</td>
<td><code>Expr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a> (","
<a href="#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ExprSingle" id=
"prod-xquery-ExprSingle"></a>[32]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExprSingle</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-FLWORExpr">FLWORExpr</a><br />
| <a href="#prod-xquery-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xquery-TypeswitchExpr">TypeswitchExpr</a><br />
| <a href="#prod-xquery-IfExpr">IfExpr</a><br />
| <a href="#prod-xquery-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-FLWORExpr" id=
"prod-xquery-FLWORExpr"></a>[33]&nbsp;&nbsp;&nbsp;</td>
<td><code>FLWORExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-ForClause">ForClause</a> |
<a href="#prod-xquery-LetClause">LetClause</a>)+ <a href=
"#prod-xquery-WhereClause">WhereClause</a>? <a href=
"#prod-xquery-OrderByClause">OrderByClause</a>? "return" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ForClause" id=
"prod-xquery-ForClause"></a>[34]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"for" "$" <a href="#prod-xquery-VarName">VarName</a>
<a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?
<a href="#prod-xquery-PositionalVar">PositionalVar</a>? "in"
<a href="#prod-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xquery-VarName">VarName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>? <a href=
"#prod-xquery-PositionalVar">PositionalVar</a>? "in" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PositionalVar" id=
"prod-xquery-PositionalVar"></a>[35]&nbsp;&nbsp;&nbsp;</td>
<td><code>PositionalVar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"at" "$" <a href=
"#prod-xquery-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-LetClause" id=
"prod-xquery-LetClause"></a>[36]&nbsp;&nbsp;&nbsp;</td>
<td><code>LetClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"let" "$" <a href="#prod-xquery-VarName">VarName</a>
<a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>? ":="
<a href="#prod-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xquery-VarName">VarName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>? ":=" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-WhereClause" id=
"prod-xquery-WhereClause"></a>[37]&nbsp;&nbsp;&nbsp;</td>
<td><code>WhereClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"where" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderByClause" id=
"prod-xquery-OrderByClause"></a>[38]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderByClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("order" "by") | ("stable" "order" "by")) <a href=
"#prod-xquery-OrderSpecList">OrderSpecList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderSpecList" id=
"prod-xquery-OrderSpecList"></a>[39]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderSpecList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-OrderSpec">OrderSpec</a> (","
<a href="#prod-xquery-OrderSpec">OrderSpec</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderSpec" id=
"prod-xquery-OrderSpec"></a>[40]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderSpec</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a> <a href=
"#prod-xquery-OrderModifier">OrderModifier</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderModifier" id=
"prod-xquery-OrderModifier"></a>[41]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderModifier</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("ascending" | "descending")? ("empty" ("greatest" |
"least"))? ("collation" <a href=
"#prod-xquery-URILiteral">URILiteral</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-QuantifiedExpr" id=
"prod-xquery-QuantifiedExpr"></a>[42]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuantifiedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xquery-VarName">VarName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xquery-VarName">VarName</a> <a href=
"#prod-xquery-TypeDeclaration">TypeDeclaration</a>? "in" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-TypeswitchExpr" id=
"prod-xquery-TypeswitchExpr"></a>[43]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeswitchExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"typeswitch" "(" <a href="#prod-xquery-Expr">Expr</a> ")"
<a href="#prod-xquery-CaseClause">CaseClause</a>+ "default" ("$"
<a href="#prod-xquery-VarName">VarName</a>)? "return" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CaseClause" id=
"prod-xquery-CaseClause"></a>[44]&nbsp;&nbsp;&nbsp;</td>
<td><code>CaseClause</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"case" ("$" <a href="#prod-xquery-VarName">VarName</a>
"as")? <a href="#prod-xquery-SequenceType">SequenceType</a>
"return" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-IfExpr" id=
"prod-xquery-IfExpr"></a>[45]&nbsp;&nbsp;&nbsp;</td>
<td><code>IfExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"if" "(" <a href="#prod-xquery-Expr">Expr</a> ")" "then"
<a href="#prod-xquery-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xquery-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrExpr" id=
"prod-xquery-OrExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-AndExpr">AndExpr</a> ( "or"
<a href="#prod-xquery-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AndExpr" id=
"prod-xquery-AndExpr"></a>[47]&nbsp;&nbsp;&nbsp;</td>
<td><code>AndExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ComparisonExpr">ComparisonExpr</a>
( "and" <a href="#prod-xquery-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ComparisonExpr" id=
"prod-xquery-ComparisonExpr"></a>[48]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComparisonExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-RangeExpr">RangeExpr</a> (
(<a href="#prod-xquery-ValueComp">ValueComp</a><br />
| <a href="#prod-xquery-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xquery-NodeComp">NodeComp</a>) <a href=
"#prod-xquery-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-RangeExpr" id=
"prod-xquery-RangeExpr"></a>[49]&nbsp;&nbsp;&nbsp;</td>
<td><code>RangeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xquery-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AdditiveExpr" id=
"prod-xquery-AdditiveExpr"></a>[50]&nbsp;&nbsp;&nbsp;</td>
<td><code>AdditiveExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-MultiplicativeExpr" id=
"prod-xquery-MultiplicativeExpr"></a>[51]&nbsp;&nbsp;&nbsp;</td>
<td><code>MultiplicativeExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xquery-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-UnionExpr" id=
"prod-xquery-UnionExpr"></a>[52]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-IntersectExceptExpr" id=
"prod-xquery-IntersectExceptExpr"></a>[53]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntersectExceptExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-InstanceofExpr">InstanceofExpr</a>
( ("intersect" | "except") <a href=
"#prod-xquery-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-InstanceofExpr" id=
"prod-xquery-InstanceofExpr"></a>[54]&nbsp;&nbsp;&nbsp;</td>
<td><code>InstanceofExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-TreatExpr">TreatExpr</a> (
"instance" "of" <a href=
"#prod-xquery-SequenceType">SequenceType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-TreatExpr" id=
"prod-xquery-TreatExpr"></a>[55]&nbsp;&nbsp;&nbsp;</td>
<td><code>TreatExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xquery-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CastableExpr" id=
"prod-xquery-CastableExpr"></a>[56]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastableExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#prod-xquery-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CastExpr" id=
"prod-xquery-CastExpr"></a>[57]&nbsp;&nbsp;&nbsp;</td>
<td><code>CastExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xquery-SingleType">SingleType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-UnaryExpr" id=
"prod-xquery-UnaryExpr"></a>[58]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("-" | "+")* <a href=
"#prod-xquery-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ValueExpr" id=
"prod-xquery-ValueExpr"></a>[59]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ValidateExpr">ValidateExpr</a> |
<a href="#prod-xquery-PathExpr">PathExpr</a> | <a href=
"#prod-xquery-ExtensionExpr">ExtensionExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-GeneralComp" id=
"prod-xquery-GeneralComp"></a>[60]&nbsp;&nbsp;&nbsp;</td>
<td><code>GeneralComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ValueComp" id=
"prod-xquery-ValueComp"></a>[61]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValueComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NodeComp" id=
"prod-xquery-NodeComp"></a>[62]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeComp</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ValidateExpr" id=
"prod-xquery-ValidateExpr"></a>[63]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValidateExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"validate" <a href=
"#prod-xquery-ValidationMode">ValidationMode</a>? "{" <a href=
"#prod-xquery-Expr">Expr</a> "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ValidationMode" id=
"prod-xquery-ValidationMode"></a>[64]&nbsp;&nbsp;&nbsp;</td>
<td><code>ValidationMode</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"lax" | "strict"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ExtensionExpr" id=
"prod-xquery-ExtensionExpr"></a>[65]&nbsp;&nbsp;&nbsp;</td>
<td><code>ExtensionExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Pragma">Pragma</a>+ "{" <a href=
"#prod-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Pragma" id=
"prod-xquery-Pragma"></a>[66]&nbsp;&nbsp;&nbsp;</td>
<td><code>Pragma</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(#" <a href="#prod-xquery-S">S</a>? <a href=
"#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-PragmaContents">PragmaContents</a> "#)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PragmaContents" id=
"prod-xquery-PragmaContents"></a>[67]&nbsp;&nbsp;&nbsp;</td>
<td><code>PragmaContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '#)'
Char*))</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PathExpr" id=
"prod-xquery-PathExpr"></a>[68]&nbsp;&nbsp;&nbsp;</td>
<td><code>PathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("/" <a href=
"#prod-xquery-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xquery-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xquery-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">xgs:
leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-RelativePathExpr" id=
"prod-xquery-RelativePathExpr"></a>[69]&nbsp;&nbsp;&nbsp;</td>
<td><code>RelativePathExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-StepExpr">StepExpr</a> (("/" |
"//") <a href="#prod-xquery-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-StepExpr" id=
"prod-xquery-StepExpr"></a>[70]&nbsp;&nbsp;&nbsp;</td>
<td><code>StepExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-FilterExpr">FilterExpr</a> |
<a href="#prod-xquery-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AxisStep" id=
"prod-xquery-AxisStep"></a>[71]&nbsp;&nbsp;&nbsp;</td>
<td><code>AxisStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-ReverseStep">ReverseStep</a> |
<a href="#prod-xquery-ForwardStep">ForwardStep</a>) <a href=
"#prod-xquery-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ForwardStep" id=
"prod-xquery-ForwardStep"></a>[72]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-ForwardAxis">ForwardAxis</a>
<a href="#prod-xquery-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ForwardAxis" id=
"prod-xquery-ForwardAxis"></a>[73]&nbsp;&nbsp;&nbsp;</td>
<td><code>ForwardAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AbbrevForwardStep" id=
"prod-xquery-AbbrevForwardStep"></a>[74]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevForwardStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"@"? <a href=
"#prod-xquery-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ReverseStep" id=
"prod-xquery-ReverseStep"></a>[75]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-ReverseAxis">ReverseAxis</a>
<a href="#prod-xquery-NodeTest">NodeTest</a>) | <a href=
"#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ReverseAxis" id=
"prod-xquery-ReverseAxis"></a>[76]&nbsp;&nbsp;&nbsp;</td>
<td><code>ReverseAxis</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AbbrevReverseStep" id=
"prod-xquery-AbbrevReverseStep"></a>[77]&nbsp;&nbsp;&nbsp;</td>
<td><code>AbbrevReverseStep</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NodeTest" id=
"prod-xquery-NodeTest"></a>[78]&nbsp;&nbsp;&nbsp;</td>
<td><code>NodeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-KindTest">KindTest</a> | <a href=
"#prod-xquery-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NameTest" id=
"prod-xquery-NameTest"></a>[79]&nbsp;&nbsp;&nbsp;</td>
<td><code>NameTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a> | <a href=
"#prod-xquery-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Wildcard" id=
"prod-xquery-Wildcard"></a>[80]&nbsp;&nbsp;&nbsp;</td>
<td><code>Wildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"*"<br />
| (<a href="#prod-xquery-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xquery-NCName">NCName</a>)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-FilterExpr" id=
"prod-xquery-FilterExpr"></a>[81]&nbsp;&nbsp;&nbsp;</td>
<td><code>FilterExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-PrimaryExpr">PrimaryExpr</a>
<a href="#prod-xquery-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PredicateList" id=
"prod-xquery-PredicateList"></a>[82]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredicateList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Predicate" id=
"prod-xquery-Predicate"></a>[83]&nbsp;&nbsp;&nbsp;</td>
<td><code>Predicate</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"[" <a href="#prod-xquery-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PrimaryExpr" id=
"prod-xquery-PrimaryExpr"></a>[84]&nbsp;&nbsp;&nbsp;</td>
<td><code>PrimaryExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Literal">Literal</a> | <a href=
"#prod-xquery-VarRef">VarRef</a> | <a href=
"#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#prod-xquery-ContextItemExpr">ContextItemExpr</a> | <a href=
"#prod-xquery-FunctionCall">FunctionCall</a> | <a href=
"#prod-xquery-OrderedExpr">OrderedExpr</a> | <a href=
"#prod-xquery-UnorderedExpr">UnorderedExpr</a> | <a href=
"#prod-xquery-Constructor">Constructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Literal" id=
"prod-xquery-Literal"></a>[85]&nbsp;&nbsp;&nbsp;</td>
<td><code>Literal</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-NumericLiteral">NumericLiteral</a>
| <a href=
"#prod-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NumericLiteral" id=
"prod-xquery-NumericLiteral"></a>[86]&nbsp;&nbsp;&nbsp;</td>
<td><code>NumericLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-IntegerLiteral">IntegerLiteral</a>
| <a href="#prod-xquery-DecimalLiteral">DecimalLiteral</a> |
<a href="#prod-xquery-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-VarRef" id=
"prod-xquery-VarRef"></a>[87]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"$" <a href=
"#prod-xquery-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-VarName" id=
"prod-xquery-VarName"></a>[88]&nbsp;&nbsp;&nbsp;</td>
<td><code>VarName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ParenthesizedExpr" id=
"prod-xquery-ParenthesizedExpr"></a>[89]&nbsp;&nbsp;&nbsp;</td>
<td><code>ParenthesizedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(" <a href="#prod-xquery-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ContextItemExpr" id=
"prod-xquery-ContextItemExpr"></a>[90]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContextItemExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OrderedExpr" id=
"prod-xquery-OrderedExpr"></a>[91]&nbsp;&nbsp;&nbsp;</td>
<td><code>OrderedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"ordered" "{" <a href="#prod-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-UnorderedExpr" id=
"prod-xquery-UnorderedExpr"></a>[92]&nbsp;&nbsp;&nbsp;</td>
<td><code>UnorderedExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"unordered" "{" <a href="#prod-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-FunctionCall" id=
"prod-xquery-FunctionCall"></a>[93]&nbsp;&nbsp;&nbsp;</td>
<td><code>FunctionCall</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a> "(" (<a href=
"#prod-xquery-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xquery-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgs:
reserved-function-names</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Constructor" id=
"prod-xquery-Constructor"></a>[94]&nbsp;&nbsp;&nbsp;</td>
<td><code>Constructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-DirectConstructor">DirectConstructor</a><br />
| <a href=
"#prod-xquery-ComputedConstructor">ComputedConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirectConstructor" id=
"prod-xquery-DirectConstructor"></a>[95]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirectConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-DirElemConstructor">DirElemConstructor</a><br />
| <a href=
"#prod-xquery-DirCommentConstructor">DirCommentConstructor</a><br />

| <a href=
"#prod-xquery-DirPIConstructor">DirPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirElemConstructor" id=
"prod-xquery-DirElemConstructor"></a>[96]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirElemConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;" <a href="#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-DirAttributeList">DirAttributeList</a> ("/&gt;" |
("&gt;" <a href="#prod-xquery-DirElemContent">DirElemContent</a>*
"&lt;/" <a href="#prod-xquery-QName">QName</a> <a href=
"#prod-xquery-S">S</a>? "&gt;"))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirAttributeList" id=
"prod-xquery-DirAttributeList"></a>[97]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirAttributeList</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-S">S</a> (<a href=
"#prod-xquery-QName">QName</a> <a href="#prod-xquery-S">S</a>? "="
<a href="#prod-xquery-S">S</a>? <a href=
"#prod-xquery-DirAttributeValue">DirAttributeValue</a>)?)*</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirAttributeValue" id=
"prod-xquery-DirAttributeValue"></a>[98]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirAttributeValue</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href="#prod-xquery-EscapeQuot">EscapeQuot</a> |
<a href=
"#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</a>)*
'"')<br />
| ("'" (<a href="#prod-xquery-EscapeApos">EscapeApos</a> | <a href=
"#prod-xquery-AposAttrValueContent">AposAttrValueContent</a>)*
"'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-QuotAttrValueContent" id=
"prod-xquery-QuotAttrValueContent"></a>[99]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuotAttrValueContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a><br />
| <a href=
"#prod-xquery-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AposAttrValueContent" id=
"prod-xquery-AposAttrValueContent"></a>[100]&nbsp;&nbsp;&nbsp;</td>
<td><code>AposAttrValueContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-AposAttrContentChar">AposAttrContentChar</a><br />
| <a href=
"#prod-xquery-CommonContent">CommonContent</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirElemContent" id=
"prod-xquery-DirElemContent"></a>[101]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirElemContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-DirectConstructor">DirectConstructor</a><br />
| <a href="#prod-xquery-CDataSection">CDataSection</a><br />
| <a href="#prod-xquery-CommonContent">CommonContent</a><br />
| <a href=
"#prod-xquery-ElementContentChar">ElementContentChar</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CommonContent" id=
"prod-xquery-CommonContent"></a>[102]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommonContent</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery-CharRef">CharRef</a> | "{{" | "}}" | <a href=
"#prod-xquery-EnclosedExpr">EnclosedExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirCommentConstructor" id=
"prod-xquery-DirCommentConstructor"></a>[103]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirCommentConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;!--" <a href=
"#prod-xquery-DirCommentContents">DirCommentContents</a>
"--&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirCommentContents" id=
"prod-xquery-DirCommentContents"></a>[104]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirCommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>((<a href="#prod-xquery-Char">Char</a> - '-') | ('-'
(<a href="#prod-xquery-Char">Char</a> - '-')))*</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirPIConstructor" id=
"prod-xquery-DirPIConstructor"></a>[105]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirPIConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;?" <a href="#prod-xquery-PITarget">PITarget</a>
(<a href="#prod-xquery-S">S</a> <a href=
"#prod-xquery-DirPIContents">DirPIContents</a>)?
"?&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DirPIContents" id=
"prod-xquery-DirPIContents"></a>[106]&nbsp;&nbsp;&nbsp;</td>
<td><code>DirPIContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '?&gt;'
Char*))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CDataSection" id=
"prod-xquery-CDataSection"></a>[107]&nbsp;&nbsp;&nbsp;</td>
<td><code>CDataSection</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&lt;![CDATA[" <a href=
"#prod-xquery-CDataSectionContents">CDataSectionContents</a>
"]]&gt;"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CDataSectionContents" id=
"prod-xquery-CDataSectionContents"></a>[108]&nbsp;&nbsp;&nbsp;</td>
<td><code>CDataSectionContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* ']]&gt;'
Char*))</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ComputedConstructor" id=
"prod-xquery-ComputedConstructor"></a>[109]&nbsp;&nbsp;&nbsp;</td>
<td><code>ComputedConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-CompDocConstructor">CompDocConstructor</a><br />
| <a href=
"#prod-xquery-CompElemConstructor">CompElemConstructor</a><br />
| <a href=
"#prod-xquery-CompAttrConstructor">CompAttrConstructor</a><br />
| <a href=
"#prod-xquery-CompTextConstructor">CompTextConstructor</a><br />
| <a href=
"#prod-xquery-CompCommentConstructor">CompCommentConstructor</a><br />

| <a href=
"#prod-xquery-CompPIConstructor">CompPIConstructor</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompDocConstructor" id=
"prod-xquery-CompDocConstructor"></a>[110]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompDocConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document" "{" <a href="#prod-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompElemConstructor" id=
"prod-xquery-CompElemConstructor"></a>[111]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompElemConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" (<a href="#prod-xquery-QName">QName</a> | ("{"
<a href="#prod-xquery-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery-ContentExpr">ContentExpr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ContentExpr" id=
"prod-xquery-ContentExpr"></a>[112]&nbsp;&nbsp;&nbsp;</td>
<td><code>ContentExpr</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompAttrConstructor" id=
"prod-xquery-CompAttrConstructor"></a>[113]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompAttrConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" (<a href="#prod-xquery-QName">QName</a> |
("{" <a href="#prod-xquery-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompTextConstructor" id=
"prod-xquery-CompTextConstructor"></a>[114]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompTextConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "{" <a href="#prod-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompCommentConstructor" id=
"prod-xquery-CompCommentConstructor"></a>[115]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompCommentConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "{" <a href="#prod-xquery-Expr">Expr</a>
"}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CompPIConstructor" id=
"prod-xquery-CompPIConstructor"></a>[116]&nbsp;&nbsp;&nbsp;</td>
<td><code>CompPIConstructor</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" (<a href=
"#prod-xquery-NCName">NCName</a> | ("{" <a href=
"#prod-xquery-Expr">Expr</a> "}")) "{" <a href=
"#prod-xquery-Expr">Expr</a>? "}"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SingleType" id=
"prod-xquery-SingleType"></a>[117]&nbsp;&nbsp;&nbsp;</td>
<td><code>SingleType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-TypeDeclaration" id=
"prod-xquery-TypeDeclaration"></a>[118]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"as" <a href=
"#prod-xquery-SequenceType">SequenceType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SequenceType" id=
"prod-xquery-SequenceType"></a>[119]&nbsp;&nbsp;&nbsp;</td>
<td><code>SequenceType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xquery-ItemType">ItemType</a> <a href=
"#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-OccurrenceIndicator" id=
"prod-xquery-OccurrenceIndicator"></a>[120]&nbsp;&nbsp;&nbsp;</td>
<td><code>OccurrenceIndicator</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <a href="#parse-note-occurrence-indicators">xgs:
occurrence-indicators</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ItemType" id=
"prod-xquery-ItemType"></a>[121]&nbsp;&nbsp;&nbsp;</td>
<td><code>ItemType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-KindTest">KindTest</a> | ("item"
"(" ")") | <a href=
"#prod-xquery-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AtomicType" id=
"prod-xquery-AtomicType"></a>[122]&nbsp;&nbsp;&nbsp;</td>
<td><code>AtomicType</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-KindTest" id=
"prod-xquery-KindTest"></a>[123]&nbsp;&nbsp;&nbsp;</td>
<td><code>KindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xquery-ElementTest">ElementTest</a><br />
| <a href="#prod-xquery-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xquery-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xquery-PITest">PITest</a><br />
| <a href="#prod-xquery-CommentTest">CommentTest</a><br />
| <a href="#prod-xquery-TextTest">TextTest</a><br />
| <a href="#prod-xquery-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AnyKindTest" id=
"prod-xquery-AnyKindTest"></a>[124]&nbsp;&nbsp;&nbsp;</td>
<td><code>AnyKindTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DocumentTest" id=
"prod-xquery-DocumentTest"></a>[125]&nbsp;&nbsp;&nbsp;</td>
<td><code>DocumentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xquery-ElementTest">ElementTest</a> | <a href=
"#prod-xquery-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-TextTest" id=
"prod-xquery-TextTest"></a>[126]&nbsp;&nbsp;&nbsp;</td>
<td><code>TextTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CommentTest" id=
"prod-xquery-CommentTest"></a>[127]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PITest" id=
"prod-xquery-PITest"></a>[128]&nbsp;&nbsp;&nbsp;</td>
<td><code>PITest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xquery-NCName">NCName</a> | <a href=
"#prod-xquery-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AttributeTest" id=
"prod-xquery-AttributeTest"></a>[129]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xquery-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AttribNameOrWildcard" id=
"prod-xquery-AttribNameOrWildcard"></a>[130]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttribNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SchemaAttributeTest" id=
"prod-xquery-SchemaAttributeTest"></a>[131]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaAttributeTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xquery-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AttributeDeclaration" id=
"prod-xquery-AttributeDeclaration"></a>[132]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ElementTest" id=
"prod-xquery-ElementTest"></a>[133]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"element" "(" (<a href=
"#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#prod-xquery-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ElementNameOrWildcard" id=
"prod-xquery-ElementNameOrWildcard"></a>[134]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementNameOrWildcard</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-SchemaElementTest" id=
"prod-xquery-SchemaElementTest"></a>[135]&nbsp;&nbsp;&nbsp;</td>
<td><code>SchemaElementTest</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xquery-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ElementDeclaration" id=
"prod-xquery-ElementDeclaration"></a>[136]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementDeclaration</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AttributeName" id=
"prod-xquery-AttributeName"></a>[137]&nbsp;&nbsp;&nbsp;</td>
<td><code>AttributeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ElementName" id=
"prod-xquery-ElementName"></a>[138]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-TypeName" id=
"prod-xquery-TypeName"></a>[139]&nbsp;&nbsp;&nbsp;</td>
<td><code>TypeName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-URILiteral" id=
"prod-xquery-URILiteral"></a>[140]&nbsp;&nbsp;&nbsp;</td>
<td><code>URILiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"#prod-xquery-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="EBNFNotation" id="EBNFNotation"></a>A.1.1 記法</h4>
<p>以下の定義は、この解説を正確に定義するのに役立つ。</p>
<p>[<a name="symbol" id="symbol" title="symbol">Definition</a>:
文法中の各規則は1つの<b>記号</b>を定義する。ここで用いられる形式は以下の通りである。</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
]
<p>[<a name="terminal" id="terminal" title=
"terminal">Definition</a>:
<b>終端記号</b>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。]
以下の構成要素が、長さ1以上の文字からなる文字列で終端記号中にあるものと照合されて用いられる。</p>
<dl>
<dt class="label">[a-zA-Z]</dt>
<dd>
<p>任意の<a href=
"#prod-xquery-Char">Char</a>で、示された範囲(すべての)中の値であるようなものと照合される。</p>
</dd>
<dt class="label">[abc]</dt>
<dd>
<p>任意の<a href=
"#prod-xquery-Char">Char</a>で、列挙された文字のどれかの値であるようなものと照合される。<span>列挙と範囲を1つの角括弧の中で混ぜることもできる。</span></p>
</dd>
<dt class="label">[^abc]</dt>
<dd>
<p>任意の<a href=
"#prod-xquery-Char">Char</a>で、与えられた文字のどれでもない値と照合される。<span>禁止される値の列挙と範囲を1つの角括弧のなかで混ぜることもできる。</span></p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>二重引用符の中に出現する文字の列と照合される。</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>一重引用符の中に出現する文字の列と照合される。</p>
</dd>
<dt class="label">
[http://www.w3.org/TR/REC-example/#NT-Example]</dt>
<dd>
<p>用意された参照の通りの外部仕様で定義される生成規則によって照合される文字列と照合される。</p>
</dd>
</dl>
<p>パターン (上記の構成要素を含む)
を文法構成子で組み合わせ、より複雑なパターンを形成することができる。このようなパターンは文字列の複雑な集合に照合される。以下の例では、AとBは(部分)パターンを表す。</p>
<dl>
<dt class="label">(A)</dt>
<dd>
<p><code>A</code>は1つの単位として扱われ、このリスト中に記述されているように組み合わせても構わない。</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>
<code>A</code>に照合されるか、何とも照合されない。すなわち省略可能な<code>A</code>と照合される。</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>
<code>A</code>の後ろに<code>B</code>が続くものと照合される。この演算子は代替よりも優先度が高い。従って<code>A
B | C D</code>は<code>(A B) | (C D)</code>と同じである。</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p><code>A</code>または<code>B</code>に照合される。ただし両方同時には照合されない。</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p><code>A</code>に照合されるが、<code>B</code>には照合されないすべての文字列に照合される。</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p><code>A</code>の1回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A+ |
B+</code>は<code>(A+) | (B+)</code>と同じである。</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p><code>A</code>の0回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A* |
B*</code>は<code>(A*) | (B*)</code>と同じである。</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="extra-grammatical-constraints" id=
"extra-grammatical-constraints"></a>A.1.2 特別な文法上の制約</h4>
<p>
この節はEBNFの生成規則の制約を含む。これらは正当な文を解釈するのに必要となる。以下の備考は、次のような記法で、生成規則の右辺から参照される:
<em>/* xgc: &lt;id&gt; */</em>。</p>
<div class="constraint">
<p class="prefix"><a name="parse-note-leading-lone-slash" id=
"parse-note-leading-lone-slash"></a><b>Constraint:
leading-lone-slash</b></p>
<p>単一のスラッシュは、完全経路式として出現するか、<a href=
"#doc-xquery-RelativePathExpr">RelativePathExpr</a>の後に続く経路式の最初の部分として出現するかのいずれかである。後者の場合、<a href="#doc-xquery-NameTest">NameTest</a>
("*" または QName)の形式を取る。"*", "union"
などの演算子が出現しうる文脈では、構文解析器は演算子とNameTestを区別するのが困難であってもよい。例えば、先読みをしなければ、式
"/ * 5" の最初の部分は例えば容易に "/ *" という完全経路式だととられる。これは全く異なる解釈を持つ
("/"の子節点)。</p>
<p>そこで、先読みの必要を削減するため、スラッシュの直後に続くトークンが "*"
またはキーワードである場合は、スラッシュは<a href=
"#doc-xquery-PathExpr">PathExpr</a>の先頭でなければならないが、その全体であってはならない
(そして、それに続くトークンは<a href=
"#doc-xquery-NameTest">NameTest</a>でなければならず、演算子であってはならない)。</p>
<p>単一のスラッシュは、括弧で囲むことにより、演算子の左側の引数として用いてもよい: <code>(/) *
5</code>。一方、式<code>5 * /</code>は括弧なしでも正しい式である。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-xml-version" id=
"parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
<p>実装が<a href="#XML">[XML 1.0]</a>と<a href="#XMLNAMES">[XML
Names]</a>の字句定義、あるいは<a href="#XML1.1">[XML 1.1]</a>と<a href=
"#XMLNAMES11">[XML Names
1.1]</a>の字句定義のいずれを支援することを選択するかによって、この生成規則の定義を得る外部文書が決定される。EBNFではバージョン1.0への参照しか持たせていない。ある場合には、XML
1.0とXML
1.1の定義は全く同じであるかもしれない。また、これらの外部定義は、その仕様の空白のルールに従い、この仕様のルール、特に<a href="#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>には従わないことに注意すること。したがって<code>prefix :
localname</code>は、XML文書中では許されないのと同様に、この仕様では正しくないQNameである。またコメントはコロンのどちら側にも許されない。また整形式制約のような特別な文法的制約を考慮しなければならない。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-reserved-function-names" id=
"parse-note-reserved-function-names"></a><b>Constraint:
reserved-function-names</b></p>
<p>
言語のキーワードと同じように綴られた接頭辞なしの関数名は、言語の認識を困難にするかもしれない。例えば<code>if(foo)</code>は、<a href="#doc-xquery-FunctionCall">FunctionCall</a>とも、<a href="#doc-xquery-IfExpr">IfExpr</a>の先頭ともとれる。そのため、<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>中の名前のいずれかと一致する接頭辞なし名前の関数を呼び出すことは、文法的に誤りである。</p>
<p>"if"という名前の関数は、その名前空間をある接頭辞に束縛し、接頭辞付きの形式を用いれば、呼び出すことができる:
"if(foo)" の代わりに "library:if(foo)" というようにである。</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-occurrence-indicators" id=
"parse-note-occurrence-indicators"></a><b>Constraint:
occurrence-indicators</b></p>
<p>すでに書いたように、<a href="#nt-bnf"><b>A XQueryの文法</b></a>の文法は '+' と '*'
の Kleene
演算子を用いたある種の形式について、曖昧である。この曖昧性は以下のようにして解消される。これらの演算子は<a href=
"#doc-xquery-SequenceType">SequenceType</a>式と強く結合しており、これらの記号を他の用途で用いた場合より高い優先度を持つ。列型に続いて
'?' ばかりでなく '+' や '*' が出現しても、出現標識であると仮定される。すなわち、<a href=
"#doc-xquery-ItemType">ItemType</a>の直後に出現する "+", "*", "?" は<a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>でなければならない。したがって、<code>4
treat as item() + - 5</code>は<code>(4 treat as item()+) -
5</code>と解釈されなければならない。つまり '+' は OccurrenceIndicator として、'-'
は減算演算子として解釈されなければならない。"+" を強制的に加算演算子と解釈するには (その結果として "-"
は単項のマイナスと解釈される)、括弧を用いてもよい: <code>(4 treat as item()) +
-5</code>という形で、<a href=
"#doc-xquery-SequenceType">SequenceType</a>式を括弧で囲むと、期待される解釈を導く。</p>
<p>このルールの結果として、このルールを用いなければ正しくかつ曖昧性のないある種の形式は、認識されない。"4 treat as
item() + 5" では、"+" は<a href=
"#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>ととられ、演算子とは見なされない。そのため、この式は正しい式ではないと解釈される。</p>
</div>
</div>
<div class="div3">
<h4><a name="notes-on-parsing" id="notes-on-parsing"></a>A.1.3
文法に関する備考</h4>
<p>
この節は、EBNFの生成規則についての一般的な備考を含む。これらはEBNFをどのように解釈し、またどのように実装するかを理解する助けとなるかもしれない。これらの備考は規範的である。以下の備考は、<em>/*
gn: &lt;id&gt; */</em>という形式で、生成規則の右辺から参照される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<dl>
<dt class="label"><a name="parse-note-parens" id=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p><a href=
"#doc-xquery-FunctionCall">FunctionCall</a>を、<span class="xquery"><a href="#doc-xquery-Pragma">Pragma</a>
or</span>の続くQNameやキーワードと区別するには、先読みが必要である。例えば: <code>address (: this
may be empty
:)</code>は、先読みを用いないと、"address"という名前の関数の呼び出しと間違われるかもしれない。
別の例は<code>for (: whom the bell :) $tolls in 3 return
$tolls</code>である。これはキーワード "for" を関数名と間違ってはならない。</p>
</dd>
<dt class="label"><a name="parse-note-comments" id=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>コメントは<a title="ignorable whitespace" href=
"#IgnorableWhitespace">無視可能な空白</a>が許される場所にならどこでも許される。<a href=
"#doc-xquery-Comment">Comment</a>記号は生成規則の右辺に明示的に出現はしない
(それ自身の生成規則を除く)。<a href="#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>を見よ。<span class=
"xquery">コメントは直接構成子の内容中には許されないが、入れ子になった<a href=
"#doc-xquery-EnclosedExpr">EnclosedExprs</a>中では許されることに注意せよ。</span></p>
<p>コメントはコメントを入れ子で含むことができる。ただし、すべての "(:" と ":)"
パターンの対応が取れている限りにおいてである。さらに外側のコメントの中で発生するかには関係しない。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>字句解析では概して、入れ子のコメントを扱うのに各 "(:" パターンでカウンタを1増やし、各 ":)"
パターンでカウンタを1減らすという方法を用いるかもしれない。そのコメントは、カウンタが0に戻るまでずっと終了しない。</p>
</div>
<p>いくつか例で説明する。</p>
<ul>
<li>
<p><code>(: commenting out a (: comment :) may be confusing, but
often helpful
:)</code>は正しいコメントである。なぜなら対応の取れたコメントの入れ子は許されるからである。</p>
</li>
<li>
<p><code>"this is just a string :)"</code>は正しい式である。しかし、<code>(:
"this is just a string :)" :)</code>は構文エラーを引き起こす。同様に<code>"this is
another string (:"</code>は正しい式だが、<code>(: "this is another string
(:"
:)</code>は構文エラーを引き起こす。入れ子のコメントの限界として、リテラル内容により対応の取れない入れ子コメントが生じる。</p>
</li>
<li>
<p><code>for (: set up loop :) $i in $x return
$i</code>は、コメントを無視すると、構文的には正しい。</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of
xs:integer</code>もまた構文的に正しい。</p>
</li>
<li>
<p><code>&lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;</code>
は構文的に正しくない。</p>
</li>
<li>
<p><code>&lt;eg&gt; (: an example:) &lt;/eg&gt;</code>
は構文的には正しいが、コメントのように見える文字は実際はリテラル要素内容である。</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="lexical-structure" id="lexical-structure"></a>A.2
字句構造</h3>
<p>上の文法で仮定されている終端記号を、この節で述べる。</p>
<p>生成規則中に出現する引用符つき文字列は終端記号である。</p>
<p>その他の終端記号は<a href="#terminal-symbols"><b>A.2.1
終端記号</b></a>で定義されている。</p>
<p class="xquery"><a href="#XML">[XML 1.0]</a>と<a href=
"#XMLNAMES">[XML Names]</a>の構文ルールに従うか、それとも<a href="#XML1.1">[XML
1.1]</a>と<a href="#XMLNAMES11">[XML Names
1.1]</a>の構文ルールに従うかは<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。<a href="#XML1.1">[XML
1.1]</a>の完全な文字集合を支援する実装は、相互互換性のために、<a href="#XML">[XML
1.0]</a>と<a href="#XMLNAMES">[XML
Names]</a>の構文ルールにのみ従うモードを提供す<a title="should" href=
"#should">べきである</a>。</p>
<p>トークンを切り出すときには、現在の文脈で正しい照合のうち、最長のものが使われる。</p>
<p>
すべてのキーワードは大文字小文字を区別する。キーワードは予約されない。すなわち、任意のQNameはキーワードと重複してよい。ただし、<a href="#id-reserved-fn-names"><b>A.3
予約済関数名</b></a>に述べるものを除く。</p>
<div class="div3">
<h4><a name="terminal-symbols" id="terminal-symbols"></a>A.2.1
終端記号</h4>
<h5><a name="d2e19457" id="d2e19457"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-IntegerLiteral" id=
"prod-xquery-IntegerLiteral"></a>[141]&nbsp;&nbsp;&nbsp;</td>
<td><code>IntegerLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DecimalLiteral" id=
"prod-xquery-DecimalLiteral"></a>[142]&nbsp;&nbsp;&nbsp;</td>
<td><code>DecimalLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>("." <a href="#prod-xquery-Digits">Digits</a>) |
(<a href="#prod-xquery-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-DoubleLiteral" id=
"prod-xquery-DoubleLiteral"></a>[143]&nbsp;&nbsp;&nbsp;</td>
<td><code>DoubleLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(("." <a href="#prod-xquery-Digits">Digits</a>) |
(<a href="#prod-xquery-Digits">Digits</a> ("." [0-9]*)?)) [eE]
[+-]? <a href="#prod-xquery-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-StringLiteral" id=
"prod-xquery-StringLiteral"></a>[144]&nbsp;&nbsp;&nbsp;</td>
<td><code>StringLiteral</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>('"' (<a href=
"#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a> |
<a href="#prod-xquery-CharRef">CharRef</a> | <a href=
"#prod-xquery-EscapeQuot">EscapeQuot</a> | [^"&amp;])* '"') | ("'"
(<a href="#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>
| <a href="#prod-xquery-CharRef">CharRef</a> | <a href=
"#prod-xquery-EscapeApos">EscapeApos</a> | [^'&amp;])*
"'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PredefinedEntityRef" id=
"prod-xquery-PredefinedEntityRef"></a>[145]&nbsp;&nbsp;&nbsp;</td>
<td><code>PredefinedEntityRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos")
";"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-EscapeQuot" id=
"prod-xquery-EscapeQuot"></a>[146]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeQuot</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-EscapeApos" id=
"prod-xquery-EscapeApos"></a>[147]&nbsp;&nbsp;&nbsp;</td>
<td><code>EscapeApos</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-ElementContentChar" id=
"prod-xquery-ElementContentChar"></a>[148]&nbsp;&nbsp;&nbsp;</td>
<td><code>ElementContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
[{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-QuotAttrContentChar" id=
"prod-xquery-QuotAttrContentChar"></a>[149]&nbsp;&nbsp;&nbsp;</td>
<td><code>QuotAttrContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
["{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-AposAttrContentChar" id=
"prod-xquery-AposAttrContentChar"></a>[150]&nbsp;&nbsp;&nbsp;</td>
<td><code>AposAttrContentChar</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href="#prod-xquery-Char">Char</a> -
['{}&lt;&amp;]</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Comment" id=
"prod-xquery-Comment"></a>[151]&nbsp;&nbsp;&nbsp;</td>
<td><code>Comment</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>"(:" (<a href=
"#prod-xquery-CommentContents">CommentContents</a> | <a href=
"#prod-xquery-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-PITarget" id=
"prod-xquery-PITarget"></a>[152]&nbsp;&nbsp;&nbsp;</td>
<td><code>PITarget</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CharRef" id=
"prod-xquery-CharRef"></a>[153]&nbsp;&nbsp;&nbsp;</td>
<td><code>CharRef</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-QName" id=
"prod-xquery-QName"></a>[154]&nbsp;&nbsp;&nbsp;</td>
<td><code>QName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-NCName" id=
"prod-xquery-NCName"></a>[155]&nbsp;&nbsp;&nbsp;</td>
<td><code>NCName</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-S" id=
"prod-xquery-S"></a>[156]&nbsp;&nbsp;&nbsp;</td>
<td><code>S</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml#NT-S]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Char" id=
"prod-xquery-Char"></a>[157]&nbsp;&nbsp;&nbsp;</td>
<td><code>Char</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code><a href=
"">[http://www.w3.org/TR/REC-xml#NT-Char]</a></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
</table>
<p>以下の記号は、終端記号の定義中でのみ用いられる。これらは<a href="#id-grammar"><b>A.1
EBNF</b></a>の文法の終端記号ではない。</p>
<h5><a name="d2e19635" id="d2e19635"></a></h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-Digits" id=
"prod-xquery-Digits"></a>[158]&nbsp;&nbsp;&nbsp;</td>
<td><code>Digits</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xquery-CommentContents" id=
"prod-xquery-CommentContents"></a>[159]&nbsp;&nbsp;&nbsp;</td>
<td><code>CommentContents</code></td>
<td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td>
<td><code>(<a href="#prod-xquery-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="id-terminal-delimitation" id=
"id-terminal-delimitation"></a>A.2.2 終端記号の区切り</h4>
<p class="xquery">XQuery 1.0 の式は<a href=
"#terminal-symbols">終端記号</a>と<a title="symbol separators" href=
"#symbolseparators">記号区切り</a>からなる。</p>
<p>終端記号には2種類ある。区切り終端記号と非区切り終端記号である。</p>
<p class="xquery">[<a name="delimiting-token" id="delimiting-token"
title="delimiting terminal symbol">Definition</a>: <b>区切り終端記号</b>は:
"=", ";", ",", "$", ":=", "(", ")", "!=", "&lt;=", "&gt;", "&gt;=",
"&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?",
"-", "+", <a href=
"#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>, "{",
"}", "{{", "}}", "&lt;", """, "'", "/&gt;", "&lt;/", "(#", "#)",
"&lt;?", "?&gt;", "&lt;![CDATA[", "]]&gt;", "&lt;!--", "--&gt;",
<a href="#prod-xquery-Comment">Comment</a>, "/", "//", <a href=
"#prod-xquery-CharRef">CharRef</a>, ":", <a href=
"#prod-xquery-S">S</a>]</p>
<p class="xquery">[<a name="non-delimiting-token" id=
"non-delimiting-token" title=
"non-delimiting terminal symbol">Definition</a>: <b>非区切り終端記号</b>は:
"xquery", "version", "encoding", "module", "namespace", "declare",
"boundary-space", "preserve", "strip", "default", "element",
"function", "option", "ordering", "ordered", "unordered", "order",
"empty", "copy-namespaces", "no-preserve", "inherit", "no-inherit",
"collation", "base-uri", "import", "schema", "at", "variable",
"construction", "as", "return", "for", "in", "let", "where", "by",
"stable", "some", "every", "satisfies", "typeswitch", "case", "if",
"then", "else", "eq", "ne", "lt", "le", "gt", "ge", "is",
"validate", "lax", "strict", "child", "descendant", "attribute",
"self", "descendant-or-self", "following-sibling", "following",
"parent", "ancestor", "preceding-sibling", "preceding",
"ancestor-or-self", "document", "text", "comment",
"processing-instruction", "empty-sequence", "item", "node",
"document-node", "schema-attribute", "schema-element", <a href=
"#prod-xquery-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xquery-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xquery-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xquery-StringLiteral">StringLiteral</a>, "external",
"ascending", "descending", "greatest", "least", <a href=
"#prod-xquery-EscapeQuot">EscapeQuot</a>, <a href=
"#prod-xquery-EscapeApos">EscapeApos</a>, <a href=
"#prod-xquery-ElementContentChar">ElementContentChar</a>, <a href=
"#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a>,
<a href="#prod-xquery-AposAttrContentChar">AposAttrContentChar</a>,
<a href="#prod-xquery-PITarget">PITarget</a>, <a href=
"#prod-xquery-QName">QName</a>, <a href=
"#prod-xquery-NCName">NCName</a>, <a href=
"#prod-xquery-Char">Char</a>, <a href=
"#prod-xquery-Digits">Digits</a>]</p>
<p>[<a name="symbolseparators" id="symbolseparators" title=
"symbol separators">Definition</a>: <b>記号区切り</b>としての<a title=
"whitespace" href="#Whitespace">空白</a>や<a href=
"#doc-xquery-Comment">Comments</a>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<a href="#ws-explicit">/*
ws: explicit */</a>という備考や、<a href="#parse-note-xml-version">/* xgs:
xml-version */</a>という備考で禁止されている場所を除く。]</p>
<p>通例として、連続した終端記号は<a title="whitespace" href=
"#Whitespace">空白</a>や<a href=
"#doc-xquery-Comment">Comments</a>で区切る。しかし、このことが要求されるのは、そうしなければ2つの非区切り終端記号が互いに隣接してしまう場合のみである。この例外が2つある。"."
と "-" がQNameやNCNameに続くならば、その間に<a title="symbol separators" href=
"#symbolseparators">記号区切り</a>が必要である。</p>
</div>
<div class="div3">
<h4><a name="id-eol-handling" id="id-eol-handling"></a>A.2.3
行末処理</h4>
<p>
XQuery処理器は、入力中にあるすべての行末を、構文解析前に正規化するように振る舞わなければならない。正規化は、<a href="#XML">[XML
1.0]</a>か<a href="#XML1.1">[XML
1.1]</a>かいずれの字句処理を支援すると選択するかに従って行われるべきである。</p>
<div class="div4">
<h5><a name="id-xml10-eol-handling" id=
"id-xml10-eol-handling"></a>A.2.3.1 XML 1.0の行末処理</h5>
<p><a href="#XML">[XML 1.0]</a>の処理では、以下のすべてが単一の文字 #xA
に変換されなければならない。</p>
<ol class="enumar">
<li>
<p>2文字の列 #xD #xA</p>
</li>
<li>
<p>#xA の直後に続かない #xD 文字</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-xml11-eol-handling" id=
"id-xml11-eol-handling"></a>A.2.3.2 XML 1.1の行末処理</h5>
<p><a href="#XML1.1">[XML 1.1]</a>の処理では、以下のすべてが単一の文字 #xA
に変換されなければならない。</p>
<ol class="enumar">
<li>
<p>2文字の列 #xD #xA</p>
</li>
<li>
<p>2文字の列 #xD #x85</p>
</li>
<li>
<p>単一の文字 #x85</p>
</li>
<li>
<p>単一の文字 #x2028</p>
</li>
<li>
<p>#xA または #x85 の直後に続かない #xD 文字</p>
</li>
</ol>
<p class="xquery">文字 #x85 と #x2028 は、<a href=
"#doc-xquery-VersionDecl">VersionDecl</a> 宣言が (もしあれば)
読まれるまで、信頼をもって認識したり翻訳したりすることはできない。</p>
</div>
</div>
<div class="div3">
<h4><a name="whitespace-rules" id="whitespace-rules"></a>A.2.4
空白規則</h4>
<div class="div4">
<h5><a name="DefaultWhitespaceHandling" id=
"DefaultWhitespaceHandling"></a>A.2.4.1 デフォルト空白処理</h5>
<p>[<a name="Whitespace" id="Whitespace" title=
"whitespace">Definition</a>: <b>空白</b>文字は、<a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>で定義される任意の文字である。]</p>
<p>[<a name="IgnorableWhitespace" id="IgnorableWhitespace" title=
"ignorable whitespace">Definition</a>: <b>無視可能な空白</b>は、<a title=
"whitespace" href="#Whitespace">空白</a>文字のうち<a title="terminal"
href="#terminal">終端記号</a>の間に出現してもよいものである。ただし、これらの文字が<a href=
"#ExplicitWhitespaceHandling">ws:explicit</a>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない
(<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
明示的空白処理</b></a>を見よ)。]
無視可能な空白文字は、式の意味には影響しない。空白は、モジュールの最初の終端記号の前や、最後の終端記号の後ろにも許される。空白は、任意の2つの<a title="terminal"
href="#terminal">終端記号</a>の間に許される。<a href=
"#doc-xquery-Comment">Comments</a>もまた "空白"
として振舞い、2つの隣接した終端記号を1つだと認識されることを防いでもよい。いくつか例で説明する。</p>
<ul>
<li>
<p><code>foo- foo</code>は構文エラーになる。"foo-" が QName として認識される。</p>
</li>
<li>
<p><code>foo -foo</code>は構文的には<code>foo -
foo</code>、すなわち減算演算子によって区切られた2つのQNameと同値である。</p>
</li>
<li>
<p><code>foo(: This is a comment :)- foo</code>は構文的には<code>foo -
foo</code>と等価である。これは、コメントによって、2つの隣接した終端記号が1つのものとして認識されるのが防がれているからである。</p>
</li>
<li>
<p><code>foo-foo</code>は構文的には1つのQNameと等価である。これは、"-"
がQName中の正しい文字だからである。名前の文字の後ろで演算子として使うときには、"-"
は、例えば空白や括弧によって、名前から区切らなければならない。</p>
</li>
<li>
<p><code>10div 3</code>は構文エラーになる。</p>
</li>
<li>
<p><code>10 div3</code>もまた構文エラーになる。</p>
</li>
<li>
<p><code>10div3</code>もまた構文エラーになる。</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="ExplicitWhitespaceHandling" id=
"ExplicitWhitespaceHandling"></a>A.2.4.2 明示的空白処理</h5>
<p>
EBNFの生成規則では、空白処理がデフォルトルールと異なる場合、以下に示す記述で明示的空白処理を指定する。この記述は継承されない。言い換えると、EBNFルールが
/* ws: explicit */ と目印付けされているならば、この記述は、そのルールの '子' の EBNF
生成規則いずれにも自動的には適用されない。</p>
<dl>
<dt class="label"><a name="ws-explicit" id="ws-explicit"></a>ws:
explicit</dt>
<dd>
<p>/* ws: explicit */ は、EBNF記述で、<code>S</code>もしくは他の方法により、<a title=
"whitespace" href=
"#Whitespace">空白文字</a>の許される場所が明示的に記述されていることを意味している。備考 /* ws:
explicit */ を持つ生成規則では、<a href=
"#DefaultWhitespaceHandling"><b>A.2.4.1
デフォルト空白処理</b></a>は適用されない。<a href=
"#doc-xquery-Comment">Comments</a>もまたこれらの生成規則中では許されない。</p>
</dd>
</dl>
<p id="ws-explicit-lex-states" class="xquery">
例えば、直接構成子の生成規則では空白は自由に許されることはないが、文法中では明示的に指定されている。これは XML
との一貫性を高めるためである。</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-reserved-fn-names" id=
"id-reserved-fn-names"></a>A.3 予約済関数名</h3>
<p>以下の名前は、接頭辞のない形式の関数名としては許されない。なぜなら、式の構文のほうが優先するからである。</p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty-sequence</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>schema-attribute</code></p>
</li>
<li>
<p><code>schema-element</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-precedence-order" id="id-precedence-order"></a>A.4
優先順位</h3>
<p><a href="#id-grammar"><b>A.1
EBNF</b></a>中の文法では、XQueryの演算子の間の組み込み優先順位を規定として定義している。これらの演算子をここでまとめ、優先度を低い順から高い順に明らかにする。より低い優先度順位を持つ演算子を、より高い優先度順位を持つ演算子が含むことはできない。結合性の欄は、式中で同じ優先度を持つ演算子が適用される順番を表している。</p>
<table border="1">
<tbody>
<tr>
<th>#</th>
<th>演算子</th>
<th>結合性</th>
</tr>
<tr>
<td>1</td>
<td>, (コンマ)</td>
<td>左から右</td>
</tr>
<tr class="xquery">
<td>2</td>
<td>:= (代入)</td>
<td>右から左</td>
</tr>
<tr>
<td>3</td>
<td><span class="xquery"><a href=
"#doc-xquery-FLWORExpr">for</a>,</span> <a href=
"#doc-xquery-QuantifiedExpr">some, every</a>, <span class=
"xquery"><a href=
"#doc-xquery-TypeswitchExpr">typeswitch</a>,</span> <a href=
"#doc-xquery-IfExpr">if</a></td>
<td>左から右</td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xquery-OrExpr">or</a></td>
<td>左から右</td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xquery-AndExpr">and</a></td>
<td>左から右</td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xquery-ValueComp">eq, ne, lt, le, gt, ge</a>,
<a href="#doc-xquery-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xquery-NodeComp">is</a>, <a href=
"#doc-xquery-NodeComp">&lt;&lt;, &gt;&gt;</a></td>
<td>左から右</td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xquery-RangeExpr">to</a></td>
<td>左から右</td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xquery-AdditiveExpr">+, -</a></td>
<td>左から右</td>
</tr>
<tr>
<td>9</td>
<td><a href="#doc-xquery-MultiplicativeExpr">*, div, idiv,
mod</a></td>
<td>左から右</td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xquery-UnionExpr">union, |</a></td>
<td>左から右</td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xquery-IntersectExceptExpr">intersect,
except</a></td>
<td>左から右</td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xquery-InstanceofExpr">instance of</a></td>
<td>左から右</td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xquery-TreatExpr">treat</a></td>
<td>左から右</td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xquery-CastableExpr">castable</a></td>
<td>左から右</td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xquery-CastExpr">cast</a></td>
<td>左から右</td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xquery-UnaryExpr">-(unary), +(unary)</a></td>
<td>右から左</td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xquery-OccurrenceIndicator">?,
*(OccurrenceIndicator), +(OccurrenceIndicator)</a></td>
<td>左から右</td>
</tr>
<tr>
<td>18</td>
<td><a href="#doc-xquery-PathExpr">/, //</a></td>
<td>左から右</td>
</tr>
<tr>
<td>19</td>
<td><a href="#doc-xquery-Predicate">[ ]</a>, <a href=
"#doc-xquery-ParenthesizedExpr">( )</a>, {}</td>
<td>左から右</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-type-promotion-and-operator-mapping" id=
"id-type-promotion-and-operator-mapping"></a>B 型の昇格と演算子の写像</h2>
<div class="div2">
<h3><a name="promotion" id="promotion"></a>B.1 型の昇格</h3>
<p>[<a name="dt-type-promotion" id="dt-type-promotion" title=
"type promotion">Definition</a>:
ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<a href=
"#id-function-calls"><b>3.1.5 関数呼び出し</b></a>を見よ)<span class=
"xquery">, <code>order by</code> 節 (<a href=
"#id-orderby-return"><b>3.8.3 Order By 節と Return
節</b></a>を見よ)</span>や演算子の評価 (<a href="#mapping"><b>B.2
演算子の写像</b></a>を見よ)のときに、<b>型の昇格</b>が用いられる。] 以下のような型の昇格が許されている。</p>
<ol class="enumar">
<li>
<p>数型の昇格:</p>
<ol class="enumla">
<li>
<p><code>xs:float</code>型
(もしくは<code>xs:float</code>型から制限によって導出される任意の型)
の値は<code>xs:double</code>型に昇格させることができる。結果は、元の値と等しい<code>xs:double</code>の値である。</p>
</li>
<li>
<p><code>xs:decimal</code>型
(もしくは<code>xs:decimal</code>から制限によって導出される任意の型)
の値は、<code>xs:float</code>型、もしくは<code>xs:double</code>型のいずれかに昇格させることができる。この昇格の結果は、元の値を要求された型に型変換することで生成される。この種の昇格は、正確さを損なうことを引き起こすかもしれない。</p>
</li>
</ol>
</li>
<li>
<p>URI型の昇格: <code>xs:anyURI</code>型
(もしくは<code>xs:anyURI</code>から制限によって導出される任意の型)
の値は、<code>xs:string</code>型に昇格させることができる。この昇格の結果は、元の値を<code>xs:string</code>型に型変換することで生成される。</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>
<code>xs:anyURI</code>の値は<code>xs:string</code>に昇格させることができるので、<a title="default collation"
href="#dt-def-collation">デフォルト照合順序</a>を用いて文字列を比較する関数や演算子は、<a title=
"default collation" href=
"#dt-def-collation">デフォルト照合順序</a>を用いて<code>xs:anyURI</code>の値も比較する。このことにより、文字列や<code>xs:anyURI</code>の値、またはこれら2つの型の組み合わせを含む順序は、一定でかつはっきり定義されることが保証される。</p>
</div>
</li>
</ol>
<p><a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>は<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>とは異なることに注意すること。例えば:</p>
<ul>
<li>
<p>
<code>xs:float</code>型の引数<code>$p</code>を期待する関数は、<code>xs:decimal</code>型の値を与えて呼び出すことができる。これは<a title="type promotion"
href=
"#dt-type-promotion">型の昇格</a>の例である。この値は期待される型に実際に変換される。関数の本体の内部では、<code>$p
instance of xs:decimal</code>は<code>false</code>を返す。</p>
</li>
<li>
<p>
<code>xs:decimal</code>型の引数<code>$p</code>を期待する関数は、<code>xs:integer</code>型の値を与えて呼び出すことができる。これは<a title="subtype substitution"
href=
"#dt-subtype-substitution">部分型置換</a>の例である。この値は元の型のまま残されている。関数の本体の内部では、<code>$p
instance of xs:integer</code>は<code>true</code>を返す。</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="mapping" id="mapping"></a>B.2 演算子の写像</h3>
<p>この節の演算子の写像表は、さまざまなXQueryの演算子に対して定義される方の組み合わせを列挙する。[<a name=
"dt-operator-function" id="dt-operator-function" title=
"operator function">Definition</a>:
各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<b>演算子関数</b>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。]
演算子関数の定義は<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and
Operators]</a>で与えられている。演算子の結果、その演算子関数によってエラーが発生してもよい。これに関する定義は<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and
Operators]</a>にある。ある場合には、演算子関数は与えられた演算子の完全な意味を実装しない。各演算子の定義
(空列や長さが1より大きい列に対する振舞いを含む) については、この文書の主部分中の記述を見よ。</p>
<p>
<code>and</code>や<code>or</code>演算子は、この文書の主部分に直接定義されており、演算子の写像表には出現していない。</p>
<p>演算子の写像表中の演算子が型 <em>ET</em> の演算数を要求するとき、<a title="type promotion"
href="#dt-type-promotion">型の昇格</a>や<a title="subtype substitution"
href="#dt-subtype-substitution">部分型置換</a>によって型 <em>AT</em> が型
<em>ET</em> に変換されるならば、その演算子は型 <em>AT</em> の演算数に適用することができる。
例えば、表のエントリに<code>gt</code>演算子を2つの<code>xs:date</code>演算数に適用してよく、そのとき<code>xs:boolean</code>を返すと示しているものがある。したがって、<code>gt</code>演算子は2つの<code>xs:date</code>の部分型
(これらは異なることもある) に適用してもよく、この場合も<code>xs:boolean</code>を返す。</p>
<p>[<a name="dt-numeric" id="dt-numeric" title=
"numeric">Definition</a>:
型を参照するとき、<b>数</b>という用語は<code>xs:integer</code>型,
<code>xs:decimal</code>型, <code>xs:float</code>型,
<code>xs:double</code>型を表す。] 演算数と結果が<a title="numeric" href=
"#dt-numeric">数</a>と指定されている演算子は、4つの演算子、すなわち数型それぞれに対し1つの演算子を表していると考えられる。例えば、数型の<code>+</code>演算子は、以下の4つの演算子を表していると考えられる:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">演算子</td>
<td align="center">第1演算数の型</td>
<td align="center">第2演算数の型</td>
<td align="center">結果の型</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p><a title="type promotion" href=
"#dt-type-promotion">型の昇格</a>や<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>によって型 <em>AT</em>
が4つの数型のいずれかに変換可能であれば、
数演算子は型<em>AT</em>の演算数に正しく適用してよい。演算子の結果の型が数と列挙されていれば、その意味は "順序リスト
<code>(xs:integer, xs:decimal, xs:float,
xs:double)</code>のうち、すべての演算数が<a title="subtype substitution" href=
"#dt-subtype-substitution">部分型置換</a>や<a title="type promotion"
href="#dt-type-promotion">型の昇格</a>により変換することのできる型の最初のもの"
である。例として、型<code>hatsize</code>が<code>xs:integer</code>から導出されており、型<code>shoesize</code>が<code>xs:float</code>から導出されているとしよう。このとき、<code>+</code>演算子が、型<code>hatsize</code>と<code>shoesize</code>の演算数を伴って実行されるならば,
型<code>xs:float</code>の結果を返す。同様に、<code>+</code>が型<code>hatsize</code>の2つの演算数を伴って実行されるならば、型<code>xs:integer</code>の結果を返す。</p>
<p>[<a name="dt-gregorian" id="dt-gregorian" title=
"Gregorian">Definition</a>:
演算子の写像表で、<b>Gregorian</b>という用語は、<code>xs:gYearMonth</code>型,
<code>xs:gYear</code>型, <code>xs:gMonthDay</code>型,
<code>xs:gDay</code>型, <code>xs:gMonth</code>型を表す。]
2つのGregorian型の演算数を取ることのできる2項演算子について、演算数はともに同じ型でなければならない。
(例えば、1つの演算数が<code>xs:gDay</code>型であれば、もう一方の演算数も<code>xs:gDay</code>でなければならない。)</p>
<table border="1" summary="Binary operators" class="small">
<caption>2項演算子</caption>
<tbody>
<tr>
<th>演算子</th>
<th>型(A)</th>
<th>型(B)</th>
<th>関数</th>
<th>結果の型</th>
</tr>
<tr>
<td>A + B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-add(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:dateTime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dateTime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-subtract(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:subtract-dates(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:subtract-dateTimes(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-multiply(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:yearMonthDuration</td>
<td>数</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>xs:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:dayTimeDuration</td>
<td>数</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>数</td>
<td>xs:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-integer-divide(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-divide(A, B)</td>
<td>数; ただし、演算数がともに xs:integer であれば xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>数</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>数</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A mod B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-mod(A, B)</td>
<td>数</td>
</tr>
<tr>
<td>A eq B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>op:duration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hex-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>数</td>
<td>数</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>fn:not(op:duration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hex-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:datetime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>数</td>
<td>数</td>
<td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:datetime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer*</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
</tbody>
</table>
<table border="1" summary="Unary operators" class="small">
<caption>単項演算子</caption>
<tbody>
<tr>
<th>演算子</th>
<th>演算数の型</th>
<th>関数</th>
<th>結果の型</th>
</tr>
<tr>
<td>+ A</td>
<td>数</td>
<td>op:numeric-unary-plus(A)</td>
<td>数</td>
</tr>
<tr>
<td>- A</td>
<td>数</td>
<td>op:numeric-unary-minus(A)</td>
<td>数</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-xq-context-components" id=
"id-xq-context-components"></a>C 文脈の構成要素</h2>
<p>
この節の表は、静的文脈や動的文脈のさまざまな構成要素や、直列化処理を制御するパラメータにどのようにして値が割り当てられるかを記述する。</p>
<div class="div2">
<h3><a name="id-xq-static-context-components" id=
"id-xq-static-context-components"></a>C.1 静的文脈の構成要素</h3>
<p>以下の表は<b>静的文脈</b>の構成要素について記述している。各構成要素について、以下の面が記述されている:</p>
<ul>
<li>
<p><em>デフォルト初期値:</em>
これは構成要素の初期値である。ただし、実装や問合せによって上書きされたり拡張されたりしない場合に限る。</p>
</li>
<li>
<p><em>実装によって上書きしたり拡張したりできるかどうか:</em> XQuery
実装が、その構成要素のデフォルト初期値を異なる<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の値で置き換えたり、デフォルト初期値を追加の<a title="implementation defined"
href=
"#dt-implementation-defined">実装定義</a>の値によって拡張したりすることが許されるかどうかを示す。</p>
</li>
<li>
<p><em>問合せによって上書きしたり拡張したりできるかどうか:</em>
問合せが、デフォルトや実装によって用意される初期値を置き換えたり拡張したりすることを許すかどうかを示す。もし許されるならば、これがどのようにして成し遂げられるか
(例えば、前書き中での宣言によって) を示す。</p>
</li>
<li>
<p><em>有効範囲:</em> その構成要素がどこで使用できるかを示す。"大域" (Global)
は、その構成要素が大域的、すなわち問合せ中で用いられるすべてのモジュールを通して使用できることを示す。"モジュール" (Module)
は、その構成要素が一つの<a title="module" href=
"#dt-module">モジュール</a>を通して使用できることを示す。"構文" (Lexical)
は、その構成要素が、それが定義されている式の中で使用できることを示す (その構成要素が<a title="Prolog" href=
"#dt-prolog">前書き</a>中で宣言されていれば、"モジュール" と等しい)。</p>
</li>
<li>
<p><em>整合性ルール:</em>
構成要素中の値を割り当てるときに従わなければならないルールを示す。これ以外の整合性ルールは<a href=
"#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>にあるかもしれない。</p>
</li>
</ul>
<table width="100%" border="1" summary="Static Context" class=
"small">
<caption>静的文脈の構成要素</caption>
<tbody>
<tr>
<th>構成要素</th>
<th>デフォルト初期値</th>
<th>実装によって上書きしたり拡張したりできるか?</th>
<th>問合せによって上書きしたり拡張したりできるか?</th>
<th>有効範囲</th>
<th>整合性ルール</th>
</tr>
<tr>
<td>XPath 1.0 互換性モード</td>
<td><code>false</code></td>
<td>不可</td>
<td>不可</td>
<td>大域</td>
<td><code>false</code> でなければならない。</td>
</tr>
<tr>
<td>静的既知名前空間</td>
<td><code>fn</code>, <code>xml</code>, <code>xs</code>,
<code>xsi</code>, <code>xdt</code>, <code>local</code></td>
<td>上書き可能・拡張可能 (<code>xml</code> を除く)</td>
<td>前書きまたは要素構成子によって上書き可能・拡張可能</td>
<td>構文</td>
<td>1つの名前空間は、構文の有効範囲ごとに、接頭辞1つに割り当てることができる。</td>
</tr>
<tr>
<td>デフォルト要素/型名前空間</td>
<td>名前空間なし</td>
<td>上書き可能</td>
<td>前書きまたは要素構成子によって上書き可能</td>
<td>構文</td>
<td>構文の有効範囲ごとに1つのデフォルト名前空間だけ。</td>
</tr>
<tr>
<td>デフォルト関数名前空間</td>
<td><code>fn</code></td>
<td>上書き可能 (推奨されない)</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>なし。</td>
</tr>
<tr>
<td>有効範囲内スキーマ型</td>
<td><code>xs</code> 内の組み込み型</td>
<td>拡張可能</td>
<td>スキーマ輸入や前書きによって拡張可能</td>
<td>モジュール</td>
<td>大域型または局所型ごとに1つの定義のみ。</td>
</tr>
<tr>
<td>有効範囲内要素宣言</td>
<td>なし</td>
<td>拡張可能</td>
<td>スキーマ輸入や前書きによって拡張可能</td>
<td>モジュール</td>
<td>大域要素名や局所要素名ごとに1つの定義のみ。</td>
</tr>
<tr>
<td>有効範囲内属性宣言</td>
<td>なし</td>
<td>拡張可能</td>
<td>スキーマ輸入や前書きによって拡張可能</td>
<td>モジュール</td>
<td>大域属性名や局所属性名ごとに1つの定義のみ。</td>
</tr>
<tr>
<td>有効範囲内変数</td>
<td>なし</td>
<td>拡張可能</td>
<td>前書きや変数束縛式により上書き可能・拡張可能</td>
<td>構文</td>
<td>構文の有効範囲ごとに1つの定義のみ。</td>
</tr>
<tr>
<td>文脈項目の静的型</td>
<td><code>none</code> (アクセスがあるとエラーを発生)</td>
<td>上書き可能</td>
<td>明示的には不可。しかし式によって影響を受ける可能性はある</td>
<td>構文</td>
<td>なし。</td>
</tr>
<tr>
<td>関数シグネチャ</td>
<td>名前空間 <code>fn</code> 中の関数、および組み込みの基本型に対する構成子</td>
<td>拡張可能</td>
<td>モジュール輸入や、前書き中での関数宣言によって拡張可能</td>
<td>モジュール</td>
<td>関数はそれぞれ一意の展開済 QName と引数の数とを持っていなければならない。</td>
</tr>
<tr>
<td>静的既知照合順序</td>
<td>デフォルト照合順序のみ</td>
<td>拡張可能</td>
<td>なし</td>
<td>モジュール</td>
<td>各 URI は1つの照合順序を一意に識別する。</td>
</tr>
<tr>
<td>デフォルト照合順序</td>
<td>Unicode コードポイント照合順序</td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>なし。</td>
</tr>
<tr>
<td>構成モード</td>
<td><code>preserve</code></td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>値は <code>preserve</code> か <code>strip</code> でなければならない。</td>
</tr>
<tr>
<td>順序付けモード</td>
<td><code>ordered</code></td>
<td>上書き可能</td>
<td>前書きや式によって上書き可能</td>
<td>構文</td>
<td>値は <code>ordered</code> か <code>unordered</code>
でなければならない。</td>
</tr>
<tr>
<td>空列に対するデフォルト順序</td>
<td>実装定義</td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>値は <code>greatest</code> か <code>least</code> でなければならない。</td>
</tr>
<tr>
<td>境界空白ポリシー</td>
<td><code>strip</code></td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>値は <code>preserve</code> か <code>strip</code> でなければならない。</td>
</tr>
<tr>
<td>名前空間複製モード</td>
<td><code>inherit, preserve</code></td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>値は <code>inherit</code> か <code>no-inherit</code>、そして
<code>preserve</code> か <code>no-preserve</code> から構成される。</td>
</tr>
<tr>
<td>基礎 URI</td>
<td>なし</td>
<td>上書き可能</td>
<td>前書きによって上書き可能</td>
<td>モジュール</td>
<td>値は xs:anyURI 型の正しい構文式でなければならない。</td>
</tr>
<tr>
<td>静的既知文書</td>
<td>なし</td>
<td>拡張可能</td>
<td>不可</td>
<td>モジュール</td>
<td>なし。</td>
</tr>
<tr>
<td>静的既知コレクション</td>
<td>なし</td>
<td>拡張可能</td>
<td>不可</td>
<td>モジュール</td>
<td>なし。</td>
</tr>
<tr>
<td>静的既知デフォルトコレクション型</td>
<td><code>node()*</code></td>
<td>上書き可能</td>
<td>不可</td>
<td>モジュール</td>
<td>なし。</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="id-xq-evaluation-context-components" id=
"id-xq-evaluation-context-components"></a>C.2 動的文脈の構成要素</h3>
<p>以下の表は<b>動的文脈</b>の構成要素を記述している。各構成要素について、以下の面を記述している:</p>
<ul>
<li>
<p><em>デフォルト初期値:</em>
これは構成要素の初期値である。ただし、実装や問合せによって上書きされたり拡張されたりしない場合に限る。</p>
</li>
<li>
<p><em>実装によって上書きしたり拡張したりできるか:</em> XQuery
の実装が、その構成要素のデフォルト初期値を異なる<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の値で置き換えたり、<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の値を追加して拡張したりすることが許されるかを示す。</p>
</li>
<li>
<p><em>問合せによって上書きしたり拡張したりできるか:</em>
問合せが、デフォルトや実装によって提供された初期値を置き換えたり拡張したりすることが許されるかを示す。もし許されるなら、これがどのように成し遂げられるかを示す。</p>
</li>
<li>
<p><em>有効範囲:</em> その構成要素がどこで使用可能かを示す。"大域"
は構成要素が大域的、すなわち問合せで用いられるすべてのモジュールで使用可能であり、問合せを評価する間、定数のままであることを表す。"動的"
は、式の評価によって、その式や入れ子の式に対する構成要素の値が影響を受けるかもしれない、ということを表す。</p>
</li>
<li>
<p><em>整合性ルール:</em>
値を構成要素に割り当てるときに従わなければならないルールを示す。これ以外の整合性ルールが<a href=
"#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>にあるかもしれない。</p>
</li>
</ul>
<table width="100%" border="1" summary="Static Context" class=
"small">
<caption>動的文脈の構成要素</caption>
<tbody>
<tr>
<th>構成要素</th>
<th>デフォルト初期値</th>
<th>実装によって上書きしたり拡張したりできるか?</th>
<th>問合せによって上書きしたり拡張したりできるか?</th>
<th>有効範囲</th>
<th>整合性ルール</th>
</tr>
<tr>
<td>文脈項目</td>
<td>なし</td>
<td>上書き可能</td>
<td>経路式や述語の評価の間上書きされる</td>
<td>動的</td>
<td>なし</td>
</tr>
<tr>
<td>文脈位置</td>
<td>なし</td>
<td>上書き可能</td>
<td>経路式や述語の評価の間上書きされる</td>
<td>動的</td>
<td>文脈項目が定義されていれば、文脈位置は &gt;0 かつ &lt;=
文脈サイズでなければならない。そうでない場合は、文脈位置は未定義である。</td>
</tr>
<tr>
<td>文脈サイズ</td>
<td>なし</td>
<td>上書き可能</td>
<td>経路式や述語の評価の間上書きされる</td>
<td>動的</td>
<td>文脈項目が定義されていれば、文脈サイズは &gt;0 でなければならない。そうでない場合は文脈サイズは未定義である。</td>
</tr>
<tr>
<td>変数の値</td>
<td>なし</td>
<td>拡張可能</td>
<td>前書きや変数束縛式によって上書き可能・拡張可能</td>
<td>動的</td>
<td>名前と値が有効範囲内変数と整合していなければならない。</td>
</tr>
<tr>
<td>関数の実装</td>
<td>名前空間 <code>fn</code> 中の関数、および組み込み原子型に対する構成子</td>
<td>拡張可能</td>
<td>モジュール輸入や、前書き中の関数宣言によって拡張可能</td>
<td>大域</td>
<td>関数シグネチャと整合していなければならない</td>
</tr>
<tr>
<td>現在の dateTime</td>
<td>なし</td>
<td>実装によって初期化されなければならない</td>
<td>不可</td>
<td>大域</td>
<td>タイムゾーンを含んでいなければならない。問合せの評価の間定数のままである。</td>
</tr>
<tr>
<td>暗黙的タイムゾーン</td>
<td>なし</td>
<td>実装によって初期化されなければならない</td>
<td>不可</td>
<td>大域</td>
<td>問合せの評価の間定数のままである。</td>
</tr>
<tr>
<td>使用可能文書</td>
<td>なし</td>
<td>実装によって初期化されなければならない</td>
<td>不可</td>
<td>大域</td>
<td>なし</td>
</tr>
<tr>
<td>使用可能コレクション</td>
<td>なし</td>
<td>実装によって初期化されなければならない</td>
<td>不可</td>
<td>大域</td>
<td>なし</td>
</tr>
<tr>
<td>デフォルトコレクション</td>
<td>なし</td>
<td>上書き可能</td>
<td>不可</td>
<td>大域</td>
<td>なし</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="id-xq-serialization-parameters" id=
"id-xq-serialization-parameters"></a>C.3 直列化パラメータ</h3>
<p>以下の表は、<a title="XDM instance" href="#dt-data-model-instance">XDM
インスタンス</a>を XML 表記 (<code>method = "xml"</code>)
に直列化する処理を制御するパラメータのデフォルト値を指定する。さまざまなパラメータの意味は<a href=
"#serialization">[XSLT 2.0 and XQuery 1.0
Serialization]</a>で定義されている。各パラメータについて、XQuery
の実装は、ユーザがデフォルト値を上書きできる方法を提供してもよい (が要求はされない)。</p>
<table border="1" width="60%" summary="Unary operators" class=
"small">
<caption>直列化パラメータ</caption>
<tbody>
<tr>
<th>パラメータ</th>
<th>デフォルト値</th>
</tr>
<tr>
<td>byte-order-mark</td>
<td>実装定義</td>
</tr>
<tr>
<td>cdata-section-elements</td>
<td>empty</td>
</tr>
<tr>
<td>doctype-public</td>
<td>(なし)</td>
</tr>
<tr>
<td>doctype-system</td>
<td>(なし)</td>
</tr>
<tr>
<td>encoding</td>
<td>"utf-8" もしくは "utf-16" の間で実装定義の選択</td>
</tr>
<tr>
<td>escape-uri-attributes</td>
<td>(method = xml の場合使用できない)</td>
</tr>
<tr>
<td>include-content-type</td>
<td>(method = xml の場合使用できない)</td>
</tr>
<tr>
<td>indent</td>
<td>no</td>
</tr>
<tr>
<td>media-type</td>
<td>実装定義</td>
</tr>
<tr>
<td>method</td>
<td>xml</td>
</tr>
<tr>
<td>normalization-form</td>
<td>実装定義</td>
</tr>
<tr>
<td>omit-xml-declaration</td>
<td>実装定義</td>
</tr>
<tr>
<td>standalone</td>
<td>実装定義</td>
</tr>
<tr>
<td>undeclare-prefixes</td>
<td>no</td>
</tr>
<tr>
<td>use-character-maps</td>
<td>empty</td>
</tr>
<tr>
<td>version</td>
<td>実装定義</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div1">
<h2><a name="id-impl-defined-items" id=
"id-impl-defined-items"></a>D 実装定義の項目</h2>
<p>この仕様中の以下の項目は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である:</p>
<ol class="enumar">
<li>
<p>式を構成するUnicodeの版</p>
</li>
<li>
<p><a title="statically known collations" href=
"#dt-static-collations">静的既知照合順序</a></p>
</li>
<li>
<p><a title="implicit timezone" href=
"#dt-timezone">暗黙的タイムゾーン</a></p>
</li>
<li>
<p><a title="warning" href=
"#dt-warning">警告</a>が発生する状況、および警告が処理される方法</p>
</li>
<li>
<p>エラーが外部処理環境に通知される方法</p>
</li>
<li>
<p>実装が<a href="#XML">[XML 1.0]</a>や<a href="#XMLNAMES">[XML
Names]</a>のルール、<a href="#XML1.1">[XML 1.1]</a>や<a href=
"#XMLNAMES11">[XML Names
1.1]</a>のルールのいずれに基づいているか。これらのルール集合のうち1つが、実装のすべての局面で常に適用されなければならない。</p>
</li>
<li>
<p><a title="static context" href=
"#dt-static-context">静的文脈</a>または<a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の構成要素のうち、実装によって上書きされたり拡張されたりするもの。</p>
</li>
<li>
<p><code>order by</code> 節中の順序付けキー (sortspec) によて返される空列のデフォルト処理方法
(<code>empty least</code> または <code>empty greatest</code>)。</p>
</li>
<li>
<p>実装によって認識される<a title="extension expression" href=
"#dt-extension-expression">拡張式</a> (<a title="pragma" href=
"#dt-pragma">pragmas</a>) の名前と意味。</p>
</li>
<li>
<p>実装によって認識される<a title="option declaration" href=
"#dt-option-declaration">オプション宣言</a>の名前と意味。</p>
</li>
<li>
<p>パラメータを (もしあれば) 外部関数に渡し、関数の結果を呼び出し元の問合せに返すためのプロトコル。</p>
</li>
<li>
<p><a title="module import" href=
"#dt-module-import">モジュール輸入</a>によって輸入されると指定されたモジュールを認識する処理方法。ただし<a title="module feature"
href="#dt-module-feature">モジュール機能</a>を支援している場合に限る
(場所のヒントがあるならば、その処理を含む)。</p>
</li>
<li>
<p>実装によって支援される<a title="static typing extension" href=
"#dt-static-typing-extension">静的型付け拡張</a>。ただし<a title=
"static typing feature" href=
"#dt-static-typing-feature">静的型付け機能</a>を支援している場合に限る。</p>
</li>
<li>
<p>直列化が呼び出される方法。ただし<a title="serialization feature" href=
"#dt-serialization-feature">直列化機能</a>を支援している場合に限る。</p>
</li>
<li>
<p><code>byte-order-mark</code>, <code>encoding</code>,
<code>media-type</code>, <code>normalization-form</code>,
<code>omit-xml-declaration</code>, <code>standalone</code>, および
<code>version</code> の各パラメータのデフォルト値。ただし<a title=
"serialization feature" href=
"#dt-serialization-feature">直列化機能</a>を支援している場合に限る。</p>
</li>
<li>
<p>外部関数の呼び出しが成功しなかった場合の結果
(例えば、関数の実装が見つからない場合や宣言された型の値を返さなかった場合など)。</p>
</li>
<li>
<p>さまざまなデータ型の値の限度や範囲。これについては<a href=
"#id-data-model-conformance"><b>5.3 データモデル適合</b></a>に列挙されている通り。</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>追加の<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の項目が<a href=
"#datamodel">[XQuery/XPath Data Model (XDM)]</a>や<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>に列挙されている。</p>
</div>
</div>
<div class="div1">
<h2><a name="id-references" id="id-references"></a>E 参考文献</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 規格</h3>
<dl>
<dt class="label"><a name="RFC2119" id="RFC2119"></a>RFC 2119</dt>
<dd>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://rfc.net/rfc2119.html">http://www.ietf.org/rfc/rfc2119.txt</a>.</dd>
<dt class="label"><a name="RFC2396" id="RFC2396"></a>RFC2396</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 2396. See
<a href=
"http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</dd>
<dt class="label"><a name="RFC3986" id="RFC3986"></a>RFC3986</dt>
<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</dd>
<dt class="label"><a name="RFC3987" id="RFC3987"></a>RFC3987</dt>
<dd>M. Duerst and M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</dd>
<dt class="label"><a name="ISO10646" id="ISO10646"></a>ISO/IEC
10646</dt>
<dd>ISO (International Organization for Standardization).
<em>ISO/IEC 10646:2003. Information technology—Universal
Multiple-Octet Coded Character Set (UCS)</em>, ただし,
日々修正されたり、新しい版に置き換えられたり、新しい部の追加によって拡張されたりする。 [Geneva]: International
Organization for Standardization. (最新版については<a href=
"http://www.iso.ch">http://www.iso.ch</a>を見よ。)</dd>
<dt class="label"><a name="Unicode" id="Unicode"></a>Unicode</dt>
<dd>The Unicode Consortium. <em>The Unicode Standard</em> Reading,
Mass.: Addison-Wesley, 2003,
ただし、日々新たな版が公表されることにより更新される。最新版、およびこの標準の版や Unicode Character
Databaseに関する追加情報については、<a href=
"http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</a>を見よ。使用される
Unicode の版は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>である。ただし、実装は最新の Unicode
の版を使用することが推奨される。</dd>
<dt class="label"><a name="XML" id="XML"></a>XML 1.0</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML)
1.0. (Third Edition)</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a></dd>
<dt class="label"><a name="XML1.1" id="XML1.1"></a>XML 1.1</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML)
1.1.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></dd>
<dt class="label"><a name="XMLNAMES" id="XMLNAMES"></a>XML
Names</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></dd>
<dt class="label"><a name="XMLNAMES11" id="XMLNAMES11"></a>XML
Names 1.1</dt>
<dd>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></dd>
<dt class="label"><a name="XMLID" id="XMLID"></a>XML ID</dt>
<dd>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C
Proposed Recommendation. See <a href=
"http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></dd>
<dt class="label"><a name="XMLSchema" id="XMLSchema"></a>XML
Schema</dt>
<dd>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2
(Second Edition)</em>. W3C Recommendation, 28 October 2004. See
<a href=
"http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
<a href=
"http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</dd>
<dt class="label"><a name="datamodel" id=
"datamodel"></a>XQuery/XPath Data Model (XDM)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Data
Model (XDM)</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>
<dt class="label"><a name="XQueryFormalSemantics" id=
"XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal
Semantics</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>
<dt class="label"><a name="FunctionsAndOperators" id=
"FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0
Functions and Operators</em> W3C Candidate Recommendation, 03 Nov.
2005. See <a href=
"http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a>.</dd>
<dt class="label"><a name="serialization" id=
"serialization"></a>XSLT 2.0 and XQuery 1.0 Serialization</dt>
<dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery 1.0
Serialization</em>. W3C Candidate Recommendation, 03 Nov. 2005. See
<a href=
"http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 参考</h3>
<dl>
<dt class="label"><a name="Requirements" id="Requirements"></a>XML
Query 1.0 Requirements</dt>
<dd>World Wide Web Consortium. <em>XML Query 1.0 Requirements</em>.
W3C Working Draft, 14 Nov 2003. See <a href=
"http://www.w3.org/TR/xquery-requirements/">http://www.w3.org/TR/xquery-requirements/</a>.</dd>
<dt class="label"><a name="XPath20" id="XPath20"></a>XPath 2.0</dt>
<dd>World Wide Web Consortium. <em>XML Path Language (XPath)
Version 2.0</em>. W3C Working Draft, 03 Nov. 2005. See <a href=
"http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a>.</dd>
<dt class="label"><a name="XQueryX" id="XQueryX"></a>XQueryX
1.0</dt>
<dd>World Wide Web Consortium. <em>XQueryX, Version 1.0</em>. W3C
Working Draft, 03 Nov. 2005. See <a href=
"http://www.w3.org/TR/xqueryx">http://www.w3.org/TR/xqueryx</a>.</dd>
<dt class="label"><a name="XSLT" id="XSLT"></a>XSLT 2.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT)
2.0.</em> W3C Candidate Recommendation, 03 Nov. 2005. See <a href=
"http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>
<dt class="label"><a name="DOM" id="DOM"></a>Document Object
Model</dt>
<dd>World Wide Web Consortium. <em>Document Object Model (DOM)
Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004.
See <a href=
"http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</dd>
<dt class="label"><a name="XINFO" id="XINFO"></a>XML Infoset</dt>
<dd>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></dd>
<dt class="label"><a name="XPath" id="XPath"></a>XPath 1.0</dt>
<dd>World Wide Web Consortium. <em>XML Path Language (XPath)
Version 1.0</em>. W3C Recommendation, Nov. 16, 1999. See <a href=
"http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></dd>
<dt class="label"><a name="XPTR" id="XPTR"></a>XPointer</dt>
<dd>World Wide Web Consortium. <em>XML Pointer Language
(XPointer).</em> W3C Last Call Working Draft 8 January 2001. See
<a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></dd>
<dt class="label"><a name="UseCases" id="UseCases"></a>XML Query
Use Cases</dt>
<dd>World Wide Web Consortium. <em>XML Query Use Cases</em>. W3C
Working Draft, 15 Sep. 2005. See <a href=
"http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</a>.</dd>
<dt class="label"><a name="xml11schema10" id=
"xml11schema10"></a>XML 1.1 and Schema 1.0</dt>
<dd>World Wide Web Consortium. <em>Processing XML 1.0 Documents
with XML Schema 1.0 Processors</em>. W3C Working Group Note, 11 May
2005. See <a href=
"http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</a>.</dd>
<dt class="label"><a name="RFC1738" id="RFC1738"></a>Uniform
Resource Locators (URL)</dt>
<dd>Internet Engineering Task Force (IETF). <em>Uniform Resource
Locators (URL)</em>. Request For Comment No. 1738, Dec. 1994. See
<a href=
"http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a>.</dd>
<dt class="label"><a name="ODMG" id="ODMG"></a>ODMG</dt>
<dd>Rick Cattell et al. <em>The Object Database Standard: ODMG-93,
Release 1.2</em>. Morgan Kaufmann Publishers, San Francisco,
1996.</dd>
<dt class="label"><a name="Quilt" id="Quilt"></a>Quilt</dt>
<dd>Don Chamberlin, Jonathan Robie, and Daniela Florescu.
<em>Quilt: an XML Query Language for Heterogeneous Data
Sources</em>. In <em>Lecture Notes in Computer Science</em>,
Springer-Verlag, Dec. 2000. Also available at <a href=
"http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</a>.
See also <a href=
"http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</a>.</dd>
<dt class="label"><a name="XML-QL" id="XML-QL"></a>XML-QL</dt>
<dd>Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and
Dan Suciu. <em>A Query Language for XML</em>. See <a href=
"http://www.research.att.com/~mff/files/final.html">http://www.research.att.com/~mff/files/final.html</a></dd>
<dt class="label"><a name="SQL" id="SQL"></a>SQL</dt>
<dd>International Organization for Standardization (ISO).
<em>Information Technology-Database Language SQL</em>. Standard No.
ISO/IEC 9075:2003. (Available from American National Standards
Institute, New York, NY 10036, (212) 642-4900.)</dd>
<dt class="label"><a name="XQL" id="XQL"></a>XQL</dt>
<dd>J. Robie, J. Lapp, D. Schach. <em>XML Query Language
(XQL)</em>. See <a href=
"http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-material" id=
"id-background-material"></a>E.3 背景資料</h3>
<dl>
<dt class="label"><a name="CHARMOD" id="CHARMOD"></a>Character
Model</dt>
<dd>World Wide Web Consortium. <em>Character Model for the World
Wide Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</dd>
<dt class="label"><a name="XSLT1" id="XSLT1"></a>XSLT 1.0</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT)
1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></dd>
<dt class="label"><a name="UseCaseQueries" id=
"UseCaseQueries"></a>Use Case Sample Queries</dt>
<dd>Queries from the XQuery 1.0 Use Cases, presented in a single
file. See <a href=
"http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt">
http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt</a>.</dd>
<dt class="label"><a name="XQueryQueries" id=
"XQueryQueries"></a>XQuery Sample Queries</dt>
<dd>Queries from this document, presented in a single file. See
<a href=
"http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt">
http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt</a>.</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>F エラー条件</h2>
<dl>
<dt><a name="ERRXPST0001" id="ERRXPST0001"></a>err:XPST0001</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式の解析が、値の割り当てられていない<a title=
"static context" href=
"#dt-static-context">静的文脈</a>の構成要素に依存している。</p>
</dd>
<dt><a name="ERRXPDY0002" id="ERRXPDY0002"></a>err:XPDY0002</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、式の評価が、値の割り当てられていない<a title=
"dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の部分に依存している。</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式が<a href="#id-grammar"><b>A.1
EBNF</b></a>で定義されている文法の正しいインスタンスではない。</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、<a title="static analysis phase" href=
"#dt-static-analysis">静的解析相</a>において、式が、その式の出現する文脈に適さない<a title=
"static type" href="#dt-static-type">静的型</a>を持っていると分かったり、<a title=
"dynamic evaluation phase" href=
"#dt-dynamic-evaluation">動的評価相</a>において、値の<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が<a href=
"#id-sequencetype-matching"><b>2.5.4
SequenceTypeの照合</b></a>の照合ルールで指定された要求型と照合されない。</p>
</dd>
<dt><a name="ERRXPST0005" id="ERRXPST0005"></a>err:XPST0005</dt>
<dd>
<p>静的解析における<a title="static error" href=
"#dt-static-error">型エラー</a>であり、<code>()</code>または<code>data(())</code>以外の式に割り当てられた<a title="static type"
href=
"#dt-static-type">静的型</a>が<code>empty-sequence()</code>である。</p>
</dd>
<dt><a name="ERRXPTY0006" id="ERRXPTY0006"></a>err:XPTY0006</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPTY0007" id="ERRXPTY0007"></a>err:XPTY0007</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPST0008" id="ERRXPST0008"></a>err:XPST0008</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、式が<a title="static context" href=
"#dt-static-context">静的文脈</a>で定義されていない要素名、属性名、スキーマ型名、名前空間接頭辞、変数名を参照している。ただし、<a href="#doc-xquery-ElementTest">ElementTest</a>や<a href="#doc-xquery-AttributeTest">AttributeTest</a>の中での参照を除く。</p>
</dd>
<dt><a name="ERRXQST0009" id="ERRXQST0009"></a>err:XQST0009</dt>
<dd>
<p>スキーマ輸入機能を支援しない実装は、前書きにスキーマ輸入が含まれていれば<a title="static error"
href="#dt-static-error">静的エラー</a>を発生させなければならない。</p>
</dd>
<dt><a name="ERRXPST0010" id="ERRXPST0010"></a>err:XPST0010</dt>
<dd>
<p>実装は、その実装が支援しない軸の参照に出会うと、<a title="static error" href=
"#dt-static-error">静的エラー</a>を発生しなければならない。</p>
</dd>
<dt><a name="ERRXQST0012" id="ERRXQST0012"></a>err:XQST0012</dt>
<dd>
<p>前書きによって輸入されるすべてのスキーマに含まれる定義集合が、<a href="#XMLSchema">[XML
Schema]</a> Part 1,
3章と5章に指定されているスキーマ妥当性の条件、すなわち各定義は正しく、完全で、一意でなければならないという条件を満たさないならば、<a title="static error"
href="#dt-static-error">静的エラー</a>である。</p>
</dd>
<dt><a name="ERRXQST0013" id="ERRXQST0013"></a>err:XQST0013</dt>
<dd>
<p>実装が pragma を認識し、その内容が正しくないと決定した場合、<a title="static error" href=
"#dt-static-error">静的エラー</a>である。</p>
</dd>
<dt><a name="ERRXQST0014" id="ERRXQST0014"></a>err:XQST0014</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0015" id="ERRXQST0015"></a>err:XQST0015</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0016" id="ERRXQST0016"></a>err:XQST0016</dt>
<dd>
<p>モジュール機能を支援しない実装は、<a title="module declaration" href=
"#dt-module-declaration">モジュール宣言</a>や<a title="module import" href=
"#dt-module-import">モジュール輸入</a>に出会うと<a title="static error" href=
"#dt-static-error">静的エラー</a>を発生させなければならない。</p>
</dd>
<dt><a name="ERRXPST0017" id="ERRXPST0017"></a>err:XPST0017</dt>
<dd>
<p><span class="xquery"><a title="static error" href=
"#dt-static-error">静的エラー</a></span>
であり、関数呼び出し中の引数の展開済QNameや引数の数が、<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>の名前や次数と一致しない。</p>
</dd>
<dt><a name="ERRXPTY0018" id="ERRXPTY0018"></a>err:XPTY0018</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、経路式の最後のステップの結果が節点も原子値も含んでいない。</p>
</dd>
<dt><a name="ERRXPTY0019" id="ERRXPTY0019"></a>err:XPTY0019</dt>
<dd>
<p><a title="type error" href="#dt-type-error">型エラー</a>であり、経路式のステップ
(最後のステップ以外) の結果が原子値を含んでいる。</p>
</dd>
<dt><a name="ERRXPTY0020" id="ERRXPTY0020"></a>err:XPTY0020</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、軸ステップで文脈項目が節点ではない。</p>
</dd>
<dt><a name="ERRXPDY0021" id="ERRXPDY0021"></a>err:XPDY0021</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0022" id="ERRXQST0022"></a>err:XQST0022</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title=
"namespace declaration attribute" href=
"#dt-namespace-decl-attr">名前空間宣言属性</a>の値が<a href=
"#doc-xquery-URILiteral">URILiteral</a>でない。</p>
</dd>
<dt><a name="ERRXQTY0023" id="ERRXQTY0023"></a>err:XQTY0023</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQTY0024" id="ERRXQTY0024"></a>err:XQTY0024</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、要素構成子中の内容列に、属性節点でない節点が続く属性節点が含まれる。</p>
</dd>
<dt><a name="ERRXQDY0025" id="ERRXQDY0025"></a>err:XQDY0025</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、構成された要素の任意の属性が、その構成された要素の他の属性すべての名前と区別される名前を持たない。</p>
</dd>
<dt><a name="ERRXQDY0026" id="ERRXQDY0026"></a>err:XQDY0026</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算処理命令構成子の内容式の結果が文字列
"<code>?&gt;</code>" を含む。</p>
</dd>
<dt><a name="ERRXQDY0027" id="ERRXQDY0027"></a>err:XQDY0027</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、妥当な式中で、妥当性検証の結果得られる PSVI
中の根要素情報項目が、期待される妥当性性質を持たない: 妥当性検証モードが <code>strict</code> であれば
<code>valid</code>、妥当性検証モードが <code>lax</code> であれば
<code>valid</code> か <code>notKnown</code> のいずれか。</p>
</dd>
<dt><a name="ERRXQTY0028" id="ERRXQTY0028"></a>err:XQTY0028</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQDY0029" id="ERRXQDY0029"></a>err:XQDY0029</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQTY0030" id="ERRXQTY0030"></a>err:XQTY0030</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、<code>validate</code>
式の引数を評価すると、ただ1つの文書節点もしくは要素節点にならない。</p>
</dd>
<dt><a name="ERRXQST0031" id="ERRXQST0031"></a>err:XQST0031</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、バージョン宣言中で指定されているバージョン番号が実装によって支援されていない。</p>
</dd>
<dt><a name="ERRXQST0032" id="ERRXQST0032"></a>err:XQST0032</dt>
<dd>
<p>前書き中に複数の<a title="base URI declaration" href=
"#dt-base-uri-decl">基礎 URI 宣言</a>が含まれていれば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0033" id="ERRXQST0033"></a>err:XQST0033</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、前書きに同じ名前空間接頭辞に対する宣言が複数含まれている。</p>
</dd>
<dt><a name="ERRXQST0034" id="ERRXQST0034"></a>err:XQST0034</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title="module" href=
"#dt-module">モジュール</a>によって宣言もしくは輸入された複数の関数が同じ数の引数を持ち、かつそれらの展開済
QName が (<code>eq</code> 演算子で定義される意味で) 等しい。</p>
</dd>
<dt><a name="ERRXQST0035" id="ERRXQST0035"></a>err:XQST0035</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、同じシンボル空間中かつ同じ有効範囲中に同じ名前で定義されている2つのスキーマ構成要素を輸入している。</p>
</dd>
<dt><a name="ERRXQST0036" id="ERRXQST0036"></a>err:XQST0036</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、輸入しているモジュールの<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>に含まれる定義の中に、輸入されるモジュール中に存在しかつ輸入するモジュールから参照される変数や関数
(引数の型や戻り値の型に関わらず) の宣言中に現れるスキーマ型名に対応するものがない。</p>
</dd>
<dt><a name="ERRXQST0037" id="ERRXQST0037"></a>err:XQST0037</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0038" id="ERRXQST0038"></a>err:XQST0038</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、前書き中に<a title=
"default collation declaration" href=
"#dt-default-collation-decl">デフォルト照合順序宣言</a>が複数含まれていたり、デフォルト照合順序によって指定される値が<a title="statically known collations"
href="#dt-static-collations">静的既知照合順序</a>中にない。</p>
</dd>
<dt><a name="ERRXQST0039" id="ERRXQST0039"></a>err:XQST0039</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、同一名の引数を2つ以上持つ関数宣言がある。</p>
</dd>
<dt><a name="ERRXQST0040" id="ERRXQST0040"></a>err:XQST0040</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、直接要素構成子によって指定される属性の展開済 QName
が区別されない。</p>
</dd>
<dt><a name="ERRXQDY0041" id="ERRXQDY0041"></a>err:XQDY0041</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算処理命令構成子中の名前式の値が
<code>xs:NCName</code> 型に型変換できない。</p>
</dd>
<dt><a name="ERRXQST0042" id="ERRXQST0042"></a>err:XQST0042</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0043" id="ERRXQST0043"></a>err:XQST0043</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQDY0044" id="ERRXQDY0044"></a>err:XQDY0044</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算属性構成子によって構成される節点の
<code>node-name</code> 性質が名前空間
<code>http://www.w3.org/2000/xmlns/</code> (名前空間接頭辞
<code>xmlns</code> に対応する) 中にある。もしくはどの名前空間にも属さず、局所名
<code>xmlns</code> を持つ。</p>
</dd>
<dt><a name="ERRXQST0045" id="ERRXQST0045"></a>err:XQST0045</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、関数宣言中の関数名が以下の名前空間のいずれかに属している:
<code>http://www.w3.org/XML/1998/namespace,
http://www.w3.org/2001/XMLSchema,
http://www.w3.org/2001/XMLSchema-instance,
http://www.w3.org/2005/xpath-functions,
http://www.w3.org/2005/xpath-datatypes</code>。</p>
</dd>
<dt><a name="ERRXQST0046" id="ERRXQST0046"></a>err:XQST0046</dt>
<dd>
<p><a href="#doc-xquery-URILiteral">URILiteral</a>
の値が長さ0ではなく、<code>xs:anyURI</code> の構文空間中にない、もしくは<a href=
"#RFC3986">[RFC3986]</a>で定義されている "相対参照" を表現する文字列であるとき、実装は<a title=
"static error" href="#dt-static-error">静的エラー</a>を発生させ<a title="may"
href="#may">てもよい</a>。</p>
</dd>
<dt><a name="ERRXQST0047" id="ERRXQST0047"></a>err:XQST0047</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、複数のモジュールが同じ前書き中で同じ目的名前空間の指定を輸入している。</p>
</dd>
<dt><a name="ERRXQST0048" id="ERRXQST0048"></a>err:XQST0048</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、ライブラリモジュール中で宣言されている関数や変数が、そのライブラリモジュールの目的名前空間中にない。</p>
</dd>
<dt><a name="ERRXQST0049" id="ERRXQST0049"></a>err:XQST0049</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title="module" href=
"#dt-module">モジュール</a>で宣言もしくは輸入される2つ以上の変数が (<code>eq</code>
演算子で定義される意味で) 等しい展開済 QName を持つ。</p>
</dd>
<dt><a name="ERRXPDY0050" id="ERRXPDY0050"></a>err:XPDY0050</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、<code>treat</code>式の演算数の<a title=
"dynamic type" href=
"#dt-dynamic-type">動的型</a>が<code>treat</code>式で指定された<a title=
"sequence type" href=
"#dt-sequence-type">静的型</a>と一致しない。このエラーは、"<code>/</code>" や
"<code>//</code>"
で始まる経路式のうち、その文脈節点が文書節点を根とする木の中にないときも発生する。これは、経路式の先頭の
"<code>/</code>" や "<code>//</code>" が、節<code>treat as
document-node()</code>を含む初期ステップの省略形だからである。</p>
</dd>
<dt><a name="ERRXPST0051" id="ERRXPST0051"></a>err:XPST0051</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a href=
"#doc-xquery-SequenceType">SequenceType</a>中の<a href=
"#doc-xquery-AtomicType">AtomicType</a>として用いられるQNameが、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中で原子型として定義されていない。</p>
</dd>
<dt><a name="ERRXQDY0052" id="ERRXQDY0052"></a>err:XQDY0052</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0053" id="ERRXQST0053"></a>err:XQST0053</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0054" id="ERRXQST0054"></a>err:XQST0054</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、変数宣言中の<a title=
"initializing expression" href=
"#dt-initializing-expression">初期化式</a>が巡回性のために実行できない
(例えば、その式がある関数に依存しており、その関数がさらに初期化される変数の値に依存している)。</p>
</dd>
<dt><a name="ERRXQST0055" id="ERRXQST0055"></a>err:XQST0055</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、前書き中に<a title=
"copy-namespaces declaration" href=
"#dt-copy-namespaces-decl">名前空間複製宣言</a>が複数含まれている。</p>
</dd>
<dt><a name="ERRXQST0056" id="ERRXQST0056"></a>err:XQST0056</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0057" id="ERRXQST0057"></a>err:XQST0057</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、スキーマ輸入が名前空間接頭辞を束縛しているが、長さ0の文字列以外で目的名前空間を指定していない。</p>
</dd>
<dt><a name="ERRXQST0058" id="ERRXQST0058"></a>err:XQST0058</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、複数のスキーマ輸入が同じ目的名前空間を指定している。</p>
</dd>
<dt><a name="ERRXQST0059" id="ERRXQST0059"></a>err:XQST0059</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、実装が、指定された目的名前空間をもつスキーマやモジュールを発見してスキーマ輸入やモジュール輸入を処理することができない。</p>
</dd>
<dt><a name="ERRXQST0060" id="ERRXQST0060"></a>err:XQST0060</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、関数宣言中の関数名がどの名前空間にも属していない (展開済 QName
が空の名前空間 URI を持つ)。</p>
</dd>
<dt><a name="ERRXQDY0061" id="ERRXQDY0061"></a>err:XQDY0061</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、validate
式の演算数が文書節点であり、その子がただ1つの要素節点、および0個以上のコメント節点と処理命令節点から構成されない。ただし順序は問わない。</p>
</dd>
<dt><a name="ERRXQDY0062" id="ERRXQDY0062"></a>err:XQDY0062</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0063" id="ERRXQST0063"></a>err:XQST0063</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQDY0064" id="ERRXQDY0064"></a>err:XQDY0064</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算処理命令構成子の名前式の値が "XML" に等しい
(大文字小文字の組み合わせは任意)。</p>
</dd>
<dt><a name="ERRXQST0065" id="ERRXQST0065"></a>err:XQST0065</dt>
<dd>
<p>前書き中に<a title="ordering mode declaration" href=
"#dt-ordering-mode-decl">順序付けモード宣言</a>が複数含まれていれば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0066" id="ERRXQST0066"></a>err:XQST0066</dt>
<dd>
<p>前書き中にデフォルト要素/型名前空間宣言が複数含まれていたり、デフォルト関数名前空間宣言が複数含まれていれば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0067" id="ERRXQST0067"></a>err:XQST0067</dt>
<dd>
<p>前書き中に<a title="construction declaration" href=
"#dt-construction-decl">構成子宣言</a>が複数含まれていれば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0068" id="ERRXQST0068"></a>err:XQST0068</dt>
<dd>
<p>前書き中に<a title="boundary-space declaration" href=
"#dt-boundary-space-decl">境界空白宣言</a>が複数含まれていれば、<a title=
"static error" href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0069" id="ERRXQST0069"></a>err:XQST0069</dt>
<dd>
<p>前書き中に<a title="empty order declaration" href=
"#dt-empty-order-decl">空順序宣言</a>が複数含まれていれば、<a title="static error"
href="#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0070" id="ERRXQST0070"></a>err:XQST0070</dt>
<dd>
<p>既定義名前空間接頭辞 <code>xml</code> または <code>xmlns</code>
が名前空間宣言や名前空間宣言属性によって再定義されたり、接頭辞 <code>xml</code> に束縛されている名前空間 URI
に別の名前空間接頭辞が束縛されたりすると、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQST0071" id="ERRXQST0071"></a>err:XQST0071</dt>
<dd>
<p>直接要素構成子の名前空間宣言属性が互いに区別されない名前を持つと、<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXQDY0072" id="ERRXQDY0072"></a>err:XQDY0072</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算コメント構成子の内容式の結果が、2つの隣接するハイフンを含んでいたり、ハイフン1つで終わっている。</p>
</dd>
<dt><a name="ERRXQST0073" id="ERRXQST0073"></a>err:XQST0073</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title="module import" href=
"#dt-module-import">モジュール輸入</a>のグラフが巡回路を含んでいる (すなわちモジュール列
M<sub>1</sub> ... M<sub>n</sub> で M<sub>i</sub> が M<sub>i+1</sub>
を輸入し、M<sub>n</sub> が M<sub>1</sub>
を輸入しているようなものが存在する)。ただし、巡回路中のすべてのモジュールが共通の名前空間を共有する場合は除く。</p>
</dd>
<dt><a name="ERRXQDY0074" id="ERRXQDY0074"></a>err:XQDY0074</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、被計算要素構成子や被計算属性構成子中の名前式の値が<a title=
"expanded QName" href="#dt-expanded-qname">展開済 QName</a>に変換できない
(例えば、<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>にない名前空間接頭辞が含まれるなど)。</p>
</dd>
<dt><a name="ERRXQST0075" id="ERRXQST0075"></a>err:XQST0075</dt>
<dd>
<p>妥当性検証機能を支援しない実装は、<code>validate</code> 式に遭遇すると<a title=
"static error" href="#dt-static-error">静的エラー</a>を発生させなければならない。</p>
</dd>
<dt><a name="ERRXQST0076" id="ERRXQST0076"></a>err:XQST0076</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、FLWOR 式の <code>order by</code> 節中の
<code>collation</code> 部分節が<a title="statically known collations"
href="#dt-static-collations">静的既知照合順序</a>にある照合順序を識別しない。</p>
</dd>
<dt><a name="ERRXQST0077" id="ERRXQST0077"></a>err:XQST0077</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0078" id="ERRXQST0078"></a>err:XQST0078</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQST0079" id="ERRXQST0079"></a>err:XQST0079</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、拡張式に、実装によって認識される <a title="pragma"
href="#dt-pragma">pragma</a> も波括弧で囲まれる式も含まれない。</p>
</dd>
<dt><a name="ERRXPST0080" id="ERRXPST0080"></a>err:XPST0080</dt>
<dd>
<p><code>cast</code>式や<code>castable</code>式の目的型は原子型で、<a title=
"in-scope schema type" href=
"#dt-is-types">有効範囲内スキーマ型</a>中になくてはならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。後ろに出現標識
"<code>?</code>" が続いてもよい。そうでない場合は<a title="static error" href=
"#dt-static-error">静的エラー</a>が発生する。</p>
</dd>
<dt><a name="ERRXPST0081" id="ERRXPST0081"></a>err:XPST0081</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<span class="xquery">a
query</span>で用いられているQNameが、<a title="statically known namespaces"
href=
"#dt-static-namespaces">静的既知名前空間</a>を用いても名前空間URIに展開できない名前空間接頭辞を含む。</p>
</dd>
<dt><a name="ERRXQST0082" id="ERRXQST0082"></a>err:XQST0082</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXPST0083" id="ERRXPST0083"></a>err:XPST0083</dt>
<dd>
<p>(現在は使われていない。)</p>
</dd>
<dt><a name="ERRXQDY0084" id="ERRXQDY0084"></a>err:XQDY0084</dt>
<dd>
<p><a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>であり、<code>validate</code>
文によって検証される要素が<a title="in-scope element declarations" href=
"#dt-is-elems">有効範囲内要素宣言</a>中の最上位要素宣言を持たない。ただし妥当性検証モードが
<code>strict</code> の場合に限る。</p>
</dd>
<dt><a name="ERRXQST0085" id="ERRXQST0085"></a>err:XQST0085</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、名前空間宣言属性中の名前空間 URI
が長さ0の文字列であり、かつ実装が<a href="#XMLNAMES11">[XML Names
1.1]</a>を支援しない。</p>
</dd>
<dt><a name="ERRXQTY0086" id="ERRXQTY0086"></a>err:XQTY0086</dt>
<dd>
<p><a title="type error" href=
"#dt-type-error">型エラー</a>であり、複製された要素節点や属性節点の値が<a title=
"namespace-sensitive" href=
"#dt-namespace-sensitive">名前空間に対して敏感</a>である。ただし、<a title=
"construction mode" href="#dt-construction-mode">構成モード</a>が
<code>preserve</code> で、<a title="copy-namespaces mode" href=
"#dt-copy-namespaces-mode">名前空間複製モード</a>が <code>no-preserve</code>
であるときに限る。</p>
</dd>
<dt><a name="ERRXQST0087" id="ERRXQST0087"></a>err:XQST0087</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、バージョン宣言中で指定される文字符号化が<a href=
"#XML">[XML 1.0]</a>で指定される <code>EncName</code> の定義に適合しない。</p>
</dd>
<dt><a name="ERRXQST0088" id="ERRXQST0088"></a>err:XQST0088</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title="module import" href=
"#dt-module-import">モジュール輸入</a>や<a title="module declaration" href=
"#dt-module-declaration">モジュール宣言</a>中で目的名前空間を指定するリテラルが長さ0のリテラルである。</p>
</dd>
<dt><a name="ERRXQST0089" id="ERRXQST0089"></a>err:XQST0089</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、FLWOR 式の for
節中の変数束縛、およびそれに関連する位置変数が区別可能な名前 (展開済 QName) を持たない。</p>
</dd>
<dt><a name="ERRXQST0090" id="ERRXQST0090"></a>err:XQST0090</dt>
<dd>
<p><a title="static error" href=
"#dt-static-error">静的エラー</a>であり、<a title="character reference"
href="#dt-character-reference">文字参照</a>が、使われている XML
のバージョン中で正しい文字を識別しない。</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-mime-type" id="id-mime-type"></a>G
<code>application/xquery</code> メディア型</h2>
<p>この附録では XQuery バージョン 1.0 に対するメディア型を指定する。XQuery は XML
データ源からのデータコレクションに対して問合せを行うための言語である。このことについては、本文書の主部分で指定した通りである。このメディア型は現在、IANA
(Internet Assigned Numbers Authority) での査読、承認、登録のために IESG (Internet
Engineering Steering Group) に提案中である。</p>
<div class="div2">
<h3><a name="id-mime-type-intro" id="id-mime-type-intro"></a>G.1
はじめに</h3>
<p>この文書は、その規範的参照も含め、XQuery バージョン 1.0
という言語を定義する。この附録では、<code>application/xquery</code>
メディア型についての情報を提供する。これは、XQuery 言語で書かれた問合せを転送するのに用いることを意図している。</p>
<p>この文書は W3C XML Query Working Group のメンバーによって用意された。コメントは
public-qt-comments@w3.org に送ってほしい。これは公開メーリングリストであり、そのアーカイブは<a href=
"http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</a>にある。</p>
</div>
<div class="div2">
<h3><a name="id-registration-of-mime-type" id=
"id-registration-of-mime-type"></a>G.2 MIME メディア型
<code>application/xquery</code> の登録</h3>
<p>MIME メディア型名: <code>application</code></p>
<p>MIME 部分型名: <code>xquery</code></p>
<p>必要とされる引数: なし</p>
<p>省略可能な引数: なし</p>
<p>XQuery の構文は Unicode で表現されているが、UTF-8 や UTF-16 など、Unicode
互換の文字符号化を用いて書かれていてもよい。また、与えられた符号化の範囲外にある Unicode 文字を XML 形式の
<code>&amp;#xddd;</code> という構文で表現して、US-ASCII や Latin-1
として転送してもよい。</p>
<div class="div3">
<h4><a name="id-interoperability-considerations" id=
"id-interoperability-considerations"></a>G.2.1 相互運用性に関する考慮</h4>
<p>何も知られていない。</p>
</div>
<div class="div3">
<h4><a name="id-applications-of-media-type" id=
"id-applications-of-media-type"></a>G.2.2 このメディア型を用いている応用</h4>
<p>公式の<a href="http://www.w3.org/XML/Query">XQuery Web ページ</a>に
XQuery 言語の実装が2ダース以上列挙されている。これらには商用のものもオープンソースのものもある。</p>
<p>この新しいメディア型は World Wide Web 上で XQuery を展開することを許すために現在登録中である。</p>
</div>
<div class="div3">
<h4><a name="id-file-extensions" id="id-file-extensions"></a>G.2.3
ファイルの拡張子</h4>
<p>XQuery に最も広く用いられるファイル拡張子は <code>.xq</code> と
<code>.xquery</code> である。</p>
<p>適切な Macintosh ファイル型コードは <code>TEXT</code> である。</p>
</div>
<div class="div3">
<h4><a name="id-intended-usage" id="id-intended-usage"></a>G.2.4
意図する用い方</h4>
<p>このメディア型の用い方として意図しているのは、XQuery 式の相互交換である。</p>
</div>
<div class="div3">
<h4><a name="id-author-change-controller" id=
"id-author-change-controller"></a>G.2.5 著者/変更の管理者</h4>
<p>XQuery は World Wide Web コンソーシアムの XML Query Working Group
で作成され、また管理されている。W3C がこの仕様の変更を管理している。</p>
</div>
</div>
<div class="div2">
<h3><a name="xquery-mime-encoding" id=
"xquery-mime-encoding"></a>G.3 符号化に関する考慮</h3>
<p>8-bit クリーンでない転送を用いるために、quoted-printable 符号化が推奨される。なぜなら XQuery
の構文自体は US-ASCII 互換の Unicode 部分集合を用いているからである。</p>
<p>XQuery の文書は<a title="version declaration" href=
"#dt-version-declaration">バージョン宣言</a>の一部として<a title=
"encoding declaration" href=
"#dt-encoding-declaration">符号化宣言</a>を含むかもしれない:</p>
<div class="exampleInner">
<pre>
xquery version "1.0" encoding "utf-8";
</pre></div>
</div>
<div class="div2">
<h3><a name="xquery-mime-recognizing" id=
"xquery-mime-recognizing"></a>G.4 XQuery ファイルの認識</h3>
<p>XQuery ファイルは文字列 <code>xquery version "V.V"</code>
を文書の先頭付近に持っているかもしれない。ここで <code>"V.V"</code>
はバージョン番号である。現在のところ、バージョン番号は、もし存在するなら、<code>"1.0"</code>
でなければならない。</p>
</div>
<div class="div2">
<h3><a name="id-charset-default-rules" id=
"id-charset-default-rules"></a>G.5 文字集合デフォルトルール</h3>
<p>XQuery 文書は Unicode 文字集合、およびデフォルトでは UTF-8 文字符号化を用いる。</p>
</div>
<div class="div2">
<h3><a name="id-security-considerations" id=
"id-security-considerations"></a>G.6 セキュリティに関する考慮</h3>
<p>XQuery で書かれた問合せでは、結果として、任意の URI や IRI
を逆参照するかもしれない。したがって、<a href="#RFC3987">[RFC3987]</a>
8章のセキュリティの問題を考慮するべきである。加えて、場合によっては <code>file:</code> URI
の内容にアクセスしたり、処理したり、結果として返したりすることができる。</p>
<p>さらに、XQuery 言語は拡張を許しているため、<code>application/xquery</code>
はセキュリティに関してここで記述されている以上の意味を持つ内容を記述しても良い。</p>
<p>XML Query Workign Group は XQuery
式を永続的データを生成したり更新したりするのに用いることができるような機能について、作業中である。信頼できない問合せはデータに対する書き込みアクセスを与えられるべきではない。</p>
</div>
</div>
<div class="div1">
<h2><a name="id-glossary" id="id-glossary"></a>H 用語集
(Non-Normative)</h2>
<dl>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic
value</dt>
<dd><b>原子値</b>は<a href="#XMLSchema">[XML
Schema]</a>で定義される<b>原子型</b>の値空間に含まれる値である。</dd>
<dt><a name="GLdt-atomization" id=
"GLdt-atomization"></a>atomization</dt>
<dd>列の<b>原子化</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and
Operators]</a>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available collections</dt>
<dd>
<b>利用可能コレクション</b>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。</dd>
<dt><a name="GLdt-available-docs" id=
"GLdt-available-docs"></a>available documents</dt>
<dd>
<b>利用可能文書</b>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<a title=
"data model" href=
"#dt-datamodel">データモデル</a>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。</dd>
<dt><a name="GLdt-axis-step" id="GLdt-axis-step"></a>axis step</dt>
<dd>
<b>軸ステップ</b>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<b>軸</b>はステップでの
"移動方向" を定義し、<a title="node test" href=
"#dt-node-test">節点テスト</a>は節点の種類、名前、<a title="type annotation" href=
"#dt-type-annotation">型注釈</a>により節点を選択する。</dd>
<dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base URI</dt>
<dd><b>基底URI</b>。 これは絶対URIであり、
(例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。</dd>
<dt><a name="GLdt-base-uri-decl" id="GLdt-base-uri-decl"></a>base
URI declaration</dt>
<dd><b>基礎 URI 宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>の<a title="base URI" href=
"#dt-base-uri">基礎 URI</a>性質を指定し、実装依存の任意のデフォルト値を上書きする。<a title=
"base URI" href="#dt-base-uri">基礎 URI</a> 性質は<a title="module"
href="#dt-module">モジュール</a>中の相対 URI を解決するのに用いられる。</dd>
<dt><a name="GLdt-binding-sequence" id=
"GLdt-binding-sequence"></a>binding sequence</dt>
<dd><code>for</code> 節中で変数に関連づけられた式の値を、その変数に対する<b>束縛列</b>という。</dd>
<dt><a name="GLdt-boundary-space-decl" id=
"GLdt-boundary-space-decl"></a>boundary-space declaration</dt>
<dd><b>境界空白宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="boundary-space policy"
href=
"#dt-boundary-space-policy">境界空白ポリシー</a>を設定する。このとき実装定義の任意のデフォルト値を上書きする。境界空白ポリシーは、問合せ処理で要素構成子によって<a title="boundary whitespace"
href="#dt-boundary-whitespace">境界空白</a>が保存されるかどうかを制御する。</dd>
<dt><a name="GLdt-boundary-space-policy" id=
"GLdt-boundary-space-policy"></a>boundary-space policy</dt>
<dd><b>境界空白ポリシー</b>。この構成要素は、<a title="direct element constructor"
href="#dt-direct-elem-const">直接要素構成子</a>による<a title=
"boundary whitespace" href=
"#dt-boundary-whitespace">境界空白</a>の処理を制御する。これについての記述は<a href=
"#id-whitespace"><b>3.7.1.4 境界空白</b></a>にある。</dd>
<dt><a name="GLdt-boundary-whitespace" id=
"GLdt-boundary-whitespace"></a>boundary whitespace</dt>
<dd><b>境界空白</b>は<a title="direct element constructor" href=
"#dt-direct-elem-const">直接要素構成子</a>の文脈に現れる連続した空白文字の列であり、内容の始まりや終わり、<a href="#doc-xquery-DirectConstructor">DirectConstructor</a>、<a href="#doc-xquery-EnclosedExpr">EnclosedExpr</a>のいずれかによって両端を区切られている。この目的のために、<code>&amp;#x20;</code>といった<a title="character reference"
href="#dt-character-reference">文字参照</a>、あるいは<a href=
"#doc-xquery-CDataSection">CdataSections</a>によって生成される文字は空白文字とはみなされない。</dd>
<dt><a name="GLdt-built-in-function" id=
"GLdt-built-in-function"></a>built-in function</dt>
<dd>XQueryで支援されている<b>組み込み関数</b>は<a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators]</a>で定義されている。</dd>
<dt><a name="GLdt-character-reference" id=
"GLdt-character-reference"></a>character reference</dt>
<dd><b>文字参照</b>は<a href=
"#Unicode">[Unicode]</a>文字のXML形式の参照であり、10進または16進のコード位置で識別される。</dd>
<dt><a name="GLdt-collation" id="GLdt-collation"></a>collation</dt>
<dd>
<b>照合順序</b>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators]</a>を見よ。</dd>
<dt><a name="GLdt-comma-operator" id=
"GLdt-comma-operator"></a>comma operator</dt>
<dd>
列を構成する1つの方法は、<b>コンマ演算子</b>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。</dd>
<dt><a name="GLdt-computed-elem-const" id=
"GLdt-computed-elem-const"></a>computed element constructor</dt>
<dd><b>被計算要素構成子</b>は要素節点を1つ生成する。このとき、節点の名前も内容も計算して得ることができる。</dd>
<dt><a name="GLdt-construction-decl" id=
"GLdt-construction-decl"></a>construction declaration</dt>
<dd><b>構成宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="construction mode" href=
"#dt-construction-mode">構成モード</a>を設定する。このとき任意の実装定義のデフォルト値を上書きする。</dd>
<dt><a name="GLdt-construction-mode" id=
"GLdt-construction-mode"></a>construction mode</dt>
<dd><b>構成モード</b>。
構成モードは、要素や文書節点の構成子の振舞いを決定する。構成モードが<code>preserve</code>であれば、構成された要素節点の型は<code>xs:anyType</code>であり、節点構成において複製された属性節点や要素節点はすべて、元の型を保存する。構成モードが<code>strip</code>であれば、構成された要素節点の型は<code>xs:untyped</code>であり、節点構成において複製された要素節点はすべて型<code>xs:untyped</code>を受け取り、節点構成において複製された属性節点はすべて型<code>xs:untypedAtomic</code>を受け取る。</dd>
<dt><a name="GLdt-constructor-function" id=
"GLdt-constructor-function"></a>constructor function</dt>
<dd>与えられた型に対する<b>構成子関数</b>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数
<code>T($arg)</code>の意味は式<code>($arg cast as
T?)</code>と同じであると定義される。</dd>
<dt><a name="GLdt-content-expression" id=
"GLdt-content-expression"></a>content expression</dt>
<dd>
被計算構成子の最後の部分は括弧で囲まれた式であり、その節点の内容を生成する。これを、その構成子の<b>内容式</b>と呼ぶ。</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context
item</dt>
<dd><b>文脈項目</b>は現在処理している項目である。項目は原子値か節点である。</dd>
<dt><a name="GLdt-context-item-static-type" id=
"GLdt-context-item-static-type"></a>context item static type</dt>
<dd><b>文脈項目の静的型</b>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<a title=
"static type" href="#dt-static-type">静的型</a>を定義する。</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context
node</dt>
<dd>文脈項目が節点であるとき、<b>文脈節点</b>と呼ぶこともできる。</dd>
<dt><a name="GLdt-context-position" id=
"GLdt-context-position"></a>context position</dt>
<dd><b>文脈位置</b>は、現在処理されている項目列中での文脈項目の位置である。</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context
size</dt>
<dd><b>文脈サイズ</b>は、現在処理されている項目列に含まれる項目数である。</dd>
<dt><a name="GLdt-copy-namespaces-decl" id=
"GLdt-copy-namespaces-decl"></a>copy-namespaces declaration</dt>
<dd><b>名前空間複製宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="copy-namespaces mode"
href="#dt-copy-namespaces-mode">名前空間複製モード</a>の値を設定し、実装定義の任意のデフォルト値を上書きする。名前空間複製モードは、すでに存在する要素が要素構成子によって複製されたときに割り当てられる名前空間束縛を制御する。</dd>
<dt><a name="GLdt-copy-namespaces-mode" id=
"GLdt-copy-namespaces-mode"></a>copy-namespaces mode</dt>
<dd>
<b>名前空間複製モード</b>。この構成要素は、すでにある要素節点が要素構成子によって複製されるときに割り当てられる名前空間束縛を制御する。これについての記述は<a href="#id-element-constructor"><b>3.7.1
直接要素構成子</b></a>にある。この値は2つの部分からなる:
<code>preserve</code>または<code>no-preserve</code>、そして<code>inherit</code>または<code>no-inherit</code>である。</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current
dateTime</dt>
<dd><b>現在のdateTime</b>。この情報は<span class=
"xquery">問合せ</span>の処理の間のある<a title="implementation dependent"
href="#dt-implementation-dependent">実装依存</a>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<span class="xquery">問合せ</span>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
model</dt>
<dd>XQueryは、XML文書の抽象 的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<b>データモデル</b>と呼ばれ、<a href="#datamodel">[XQuery/XPath Data
Model (XDM)]</a>で定義されている。</dd>
<dt><a name="GLdt-data-model-schema" id=
"GLdt-data-model-schema"></a>data model schema</dt>
<dd><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中のある節点に対して、<b>データモデルスキーマ</b>は、その節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>が導出されたスキーマとして定義される。</dd>
<dt><a name="GLdt-def-collation" id=
"GLdt-def-collation"></a>default collation</dt>
<dd><b>デフォルト照合順序</b>。これは、明示的に照合順序が指定されていないときに、<a title=
"statically known collations" href=
"#dt-static-collations">静的既知照合順序</a>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型
(およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。</dd>
<dt><a name="GLdt-default-collation-decl" id=
"GLdt-default-collation-decl"></a>default collation
declaration</dt>
<dd><b>デフォルト照合順序宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="default collation" href=
"#dt-def-collation">デフォルト照合順序</a>の値を設定する。このとき、実装定義の任意のデフォルト値を上書きする。</dd>
<dt><a name="GLdt-default-collection" id=
"GLdt-default-collection"></a>default collection</dt>
<dd>
<b>デフォルトコレクション</b>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。</dd>
<dt><a name="GLdt-def-elemtype-ns" id=
"GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<b>デフォルト要素/型名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default
function namespace</dt>
<dd>
<b>デフォルト関数名前空間</b>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。</dd>
<dt><a name="GLdt-default-empty-order" id=
"GLdt-default-empty-order"></a>default order for empty
sequences</dt>
<dd><b>空列のデフォルト順序</b>。 この構成要素は、FLWOR式中の<code>order
by</code>節中の順序付けキーとしての空列や値<code>NaN</code>の処理を制御する。これについての記述は<a href="#id-orderby-return"><b>3.8.3
Order By 節と Return 節</b></a>にある。</dd>
<dt><a name="GLdelimiting-token" id=
"GLdelimiting-token"></a>delimiting terminal symbol</dt>
<dd><b>区切り終端記号</b>は: "=", ";", ",", "$", ":=", "(", ")", "!=",
"&lt;=", "&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..",
"*", "[", "]", ".", "?", "-", "+", <a href=
"#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>, "{",
"}", "{{", "}}", "&lt;", """, "'", "/&gt;", "&lt;/", "(#", "#)",
"&lt;?", "?&gt;", "&lt;![CDATA[", "]]&gt;", "&lt;!--", "--&gt;",
<a href="#prod-xquery-Comment">Comment</a>, "/", "//", <a href=
"#prod-xquery-CharRef">CharRef</a>, ":", <a href=
"#prod-xquery-S">S</a></dd>
<dt><a name="GLdt-direct-elem-const" id=
"GLdt-direct-elem-const"></a>direct element constructor</dt>
<dd><b>直接要素構成子</b>は、構成される要素の名前が定数であるような要素構成子の形式である。</dd>
<dt><a name="GLdt-document-order" id=
"GLdt-document-order"></a>document order</dt>
<dd>直観的には、<b>文書順</b>は直列化されたXML文書中で節点が出現する順序である。</dd>
<dt><a name="GLdt-dynamic-context" id=
"GLdt-dynamic-context"></a>dynamic context</dt>
<dd>式の<b>動的文脈</b>は、その式が評価されているときに利用可能な情報として定義される。</dd>
<dt><a name="GLdt-dynamic-error" id=
"GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<b>動的エラー</b>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd><b>動的評価相</b>は式の値を計算する相である。</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic
type</dt>
<dd><b>動的型</b>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<a title=
"static type" href=
"#dt-static-type">静的型</a>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
value</dt>
<dd>ある値の<b>有効ブール値</b>は、<a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and
Operators]</a>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。</dd>
<dt><a name="GLdt-effective-case" id=
"GLdt-effective-case"></a>effective case</dt>
<dd><code>typeswitch</code> 式の<b>有効な case</b>は、演算数式の値が
<code>case</code> 節中の<a href=
"#doc-xquery-SequenceType">SequenceType</a> に照合されるような
<code>case</code> 節のうち最初のものである。照合には<a title="SequenceType matching"
href=
"#dt-sequencetype-matching">SequenceTypeの照合</a>のルールが用いられる。</dd>
<dt><a name="GLdt-empty-order-decl" id=
"GLdt-empty-order-decl"></a>empty order declaration</dt>
<dd><b>空順序宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title=
"default order for empty sequences" href=
"#dt-default-empty-order">空列のためのデフォルト順序</a>を設定し、実装依存の任意のデフォルト値を上書きする。この宣言は空列や、FLWOR
式の <code>order by</code> 節中の順序付けキーとしての値 <code>NaN</code>
の処理を制御する。</dd>
<dt><a name="GLdt-empty-sequence" id=
"GLdt-empty-sequence"></a>empty sequence</dt>
<dd>0個の項目を含む列を<b>空列</b>という。</dd>
<dt><a name="GLdt-encoding-declaration" id=
"GLdt-encoding-declaration"></a>encoding declaration</dt>
<dd>バージョン宣言は、もしあれば、省略可能な<b>符号化宣言</b>を含んでもよい。キーワード
<code>encoding</code> の後に続く文字列リテラルが符号化名であり、<a href="#XML">[XML
1.0]</a>で指定される <code>EncName</code> に適合しなければならない [<a title=
"err:XQST0087" href=
"#ERRXQST0087">err:XQST0087</a>]。符号化宣言の目的は、問合せを書くときに、その問合せがどのように符号化されるかを示す文字列を用意することを許すことである。例えば
"<code>UTF-8</code>", "<code>UTF-16</code>",
"<code>US-ASCII</code>" のような文字列である。</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error
value</dt>
<dd>
識別可能なQNameに加え、動的エラーは、説明的な文字列や、<b>エラー値</b>と呼ばれる1つ以上の付加的な値を伴ってもよい。</dd>
<dt><a name="GLdt-expanded-qname" id=
"GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<b>展開済QName</b>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>ある式に対する<b>式文脈</b>は、その式の結果に影響を与えうるすべての情報からなる。</dd>
<dt><a name="GLdt-extension-expression" id=
"GLdt-extension-expression"></a>extension expression</dt>
<dd><b>拡張式</b>は、意味が<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>であるような式である。</dd>
<dt><a name="GLdt-external-function" id=
"GLdt-external-function"></a>external function</dt>
<dd><b>外部関数</b>は、その問合せの環境の外側で実装されている関数である。</dd>
<dt><a name="GLdt-filter-expression" id=
"GLdt-filter-expression"></a>filter expression</dt>
<dd><b>選別式</b>は、単に、1つの<b>基本式</b>の後ろに0個以上の<a title="predicate" href=
"#dt-predicate">述語</a>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd><a title="dynamic context" href=
"#dt-dynamic-context">動的文脈</a>の最初の3つの構成要素
(文脈項目、文脈位置、文脈サイズ)を、式の<b>焦点</b>という。</dd>
<dt><a name="GLdt-full-axis-feature" id=
"GLdt-full-axis-feature"></a>Full Axis Feature</dt>
<dd><b>全軸機能</b>を支援する適合 XQuery 実装は、すべての<a title="optional axis"
href="#dt-optional-axis">選択的な軸</a>を支援<a title="must" href=
"#must">しなければならない</a>。</dd>
<dt><a name="GLdt-function-implementation" id=
"GLdt-function-implementation"></a>function implementation</dt>
<dd><b>関数の実装</b>。<a title="function signature" href=
"#dt-function-signature">関数のシグネチャ</a>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。<span class="xquery"><a title="user-defined function"
href="#dt-udf">利用者定義関数</a>については、関数の実装はXQuery式である。<a title=
"built-in function" href=
"#dt-built-in-function">組み込み関数</a>や<a title="external function"
href="#dt-external-function">外部関数</a>については、関数の実装は<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>である。</span></dd>
<dt><a name="GLdt-function-signature" id=
"GLdt-function-signature"></a>function signature</dt>
<dd>
<b>関数のシグネチャ</b>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<a title="expanded QName"
href="#dt-expanded-qname">展開済QName</a>と次数 (引数の数) によって一意に識別される。</dd>
<dt><a name="GLdt-gregorian" id="GLdt-gregorian"></a>Gregorian</dt>
<dd>演算子の写像表で、<b>Gregorian</b>という用語は、<code>xs:gYearMonth</code>型,
<code>xs:gYear</code>型, <code>xs:gMonthDay</code>型,
<code>xs:gDay</code>型, <code>xs:gMonth</code>型を表す。</dd>
<dt><a name="GLIgnorableWhitespace" id=
"GLIgnorableWhitespace"></a>ignorable whitespace</dt>
<dd><b>無視可能な空白</b>は、<a title="whitespace" href=
"#Whitespace">空白</a>文字のうち<a title="terminal" href=
"#terminal">終端記号</a>の間に出現してもよいものである。ただし、これらの文字が<a href=
"#ExplicitWhitespaceHandling">ws:explicit</a>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない
(<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
明示的空白処理</b></a>を見よ)。</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<b>実装定義</b>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<b>実装依存</b>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
timezone</dt>
<dd><b>暗黙タイムゾーン</b>。これは、タイムゾーンを持たない data, time,
dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<a title="implementation defined"
href=
"#dt-implementation-defined">実装定義</a>の値である。タイムゾーンの正しい値の範囲については<a href="#XMLSchema">[XML
Schema]</a>を見よ。</dd>
<dt><a name="GLdt-initializing-expression" id=
"GLdt-initializing-expression"></a>initializing expression</dt>
<dd>変数宣言に式が含まれていれば、その式を<b>初期化式</b>という。</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
attribute declarations</dt>
<dd><b>有効範囲内属性定義</b> 各属性定義は<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位属性定義に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の属性識別子
(局所属性定義に対して)のいずれかで識別される。<span class="xquery">もし<a title=
"schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内属性定義には、輸入されたスキーマ中にある属性定義がすべて含まれる。</span></dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd><b>有効範囲内要素定義</b>。各要素定義は、<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (最上位要素定義に対して)か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の要素識別子
(局所要素定義に対して)のいずれかで識別される。<span class="xquery">もし<a title=
"schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内要素定義には、輸入されたスキーマ定義中にある要素定義がすべて含まれる。</span></dd>
<dt><a name="GLdt-in-scope-namespaces" id=
"GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
要素節点の<b>有効範囲内名前空間</b>性質は、<b>名前空間束縛</b>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
definitions</dt>
<dd>
<b>有効範囲内スキーマ定義</b>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope schema
type</dt>
<dd><b>有効範囲内スキーマ型</b>。各スキーマ型定義は、 <a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a> (<b>名前付けされた型</b>に対して) か<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>の型識別子
(<b>無名型</b>に対して)のいずれかで識別される。有効範囲内スキーマ型は<a href=
"#id-predefined-types"><b>2.5.1 既定義スキーマ型</b></a>で述べられる既定義スキーマ型を含む。
<span class="xquery">もし<a title="schema import feature" href=
"#dt-schema-import-feature">スキーマ輸入機能</a>が支援されていれば、有効範囲内スキーマ型には、輸入されたスキーマ中にある型定義がすべて含まれる。</span></dd>
<dt><a name="GLdt-in-scope-variables" id=
"GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd><b>有効範囲内変数</b>。これは組 (展開済QName, 型)
の集合であり、式中で参照可能な変数の集合を定義する。<a title="expanded QName" href=
"#dt-expanded-qname">展開済QName</a>は変数名、型はその変数の<a title="static type"
href="#dt-static-type">静的型</a>である。</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd><b>項目</b>は<a title="atomic value" href=
"#dt-atomic-value">原子値</a>か<a title="node" href=
"#dt-node">節点</a>である。</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>節点テストのもう一つの形式は<b>種類テスト</b>と呼ばれる。これは、節点の種類、名前、<a title=
"type annotation" href=
"#dt-type-annotation">型注釈</a>に基づき、節点を選択することができる。</dd>
<dt><a name="GLdt-library-module" id=
"GLdt-library-module"></a>library module</dt>
<dd><a title="query body" href=
"#dt-queryBody">問合せ本体</a>を持たないモジュールを<b>ライブラリモジュール</b>という。ライブラリモジュールは<a title="module declaration"
href="#dt-module-declaration">モジュール定義</a>およびそれに続く<a title="Prolog"
href="#dt-prolog">前書き</a>からなる。</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd><b>リテラル</b>は原子値の直接的構文表現である。</dd>
<dt><a name="GLdt-main-module" id="GLdt-main-module"></a>main
module</dt>
<dd><b>主モジュール</b>は、<a title="Prolog" href=
"#dt-prolog">前書き</a>とそれに続く<a title="query body" href=
"#dt-queryBody">問合せ本体</a>から構成される。</dd>
<dt><a name="GLmay" id="GLmay"></a>may</dt>
<dd><b>してもよい</b> (MAY) は、項目が真に選択可能であることを意味する。</dd>
<dt><a name="GLdt-module" id="GLdt-module"></a>module</dt>
<dd><b>モジュール</b>は XQuery コードの断片であり、<a href=
"#doc-xquery-Module">Module</a> の文法に従っており、またそれぞれ独立に<a href=
"#id-expression-processing"><b>2.2.3 式の処理</b></a>にある<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>を受けることができる。各モジュールは<a title=
"main module" href="#dt-main-module">主モジュール</a>か<a title=
"library module" href=
"#dt-library-module">ライブラリモジュール</a>のいずれかである。</dd>
<dt><a name="GLdt-module-declaration" id=
"GLdt-module-declaration"></a>module declaration</dt>
<dd><b>モジュール宣言</b>は、ある<a title="module" href=
"#dt-module">モジュール</a>を<a title="library module" href=
"#dt-library-module">ライブラリモジュール</a>として識別する機能を提供する。モジュール宣言はキーワード
<code>module</code> で始まり、名前空間接頭辞1つと <a href=
"#doc-xquery-URILiteral">URILiteral</a> 1つを含む。</dd>
<dt><a name="GLdt-module-feature" id=
"GLdt-module-feature"></a>module feature</dt>
<dd><b>モジュール機能</b>を支援する適合 XQuery
実装は、問合せの前書きに<b>モジュール輸入</b>が含まれることを許す。また<b>ライブラリモジュール</b>を生成することを許す。</dd>
<dt><a name="GLdt-module-import" id="GLdt-module-import"></a>module
import</dt>
<dd><b>モジュール輸入</b>は1つ以上の<a title="library module" href=
"#dt-library-module">ライブラリモジュール</a>から関数宣言や変数宣言を輸入する。輸入の先は、輸入する<a title="module"
href="#dt-module">モジュール</a>の<a title="function signature" href=
"#dt-function-signature">関数シグネチャ</a>や<a title="in-scope variables"
href="#dt-in-scope-variables">有効範囲内変数</a>である。</dd>
<dt><a name="GLmust" id="GLmust"></a>must</dt>
<dd><b>しなければならない</b> (MUST) は、仕様の絶対的な要求である項目を意味する。</dd>
<dt><a name="GLdt-name-expression" id=
"GLdt-name-expression"></a>name expression</dt>
<dd>ある式が、構成された節点の名前を指定するのに用いられるとき、その式は、その構成子の<b>名前式</b>と呼ばれる。</dd>
<dt><a name="GLdt-namespace-declaration" id=
"GLdt-namespace-declaration"></a>namespace declaration</dt>
<dd><b>名前空間宣言</b>は、名前空間接頭辞を宣言し、それを名前空間 URI と関連づけ、(接頭辞, URI)
の組を<a title="statically known namespaces" href=
"#dt-static-namespaces">静的既知名前空間</a>の集合に加える。</dd>
<dt><a name="GLdt-namespace-decl-attr" id=
"GLdt-namespace-decl-attr"></a>namespace declaration attribute</dt>
<dd>
<b>名前空間宣言属性</b>は、直接要素構成子の内部で用いられる。その目的は、構成された要素節点やその属性に対して、名前空間接頭辞を束縛したり、<a title="default element/type namespace"
href="#dt-def-elemtype-ns">デフォルト要素/型名前空間</a>を設定することである。</dd>
<dt><a name="GLdt-namespace-sensitive" id=
"GLdt-namespace-sensitive"></a>namespace-sensitive</dt>
<dd>値が<b>名前空間に対して敏感</b>であるとは、その値に、<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が<code>xs:QName</code>または<code>xs:NOTATION</code>、または制限によって<code>xs:QName</code>か<code>xs:NOTATION</code>から導出されるかのいずれかであるような項目が含まれていることである。</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>QNameまたはワイルドカードのみからなる節点テストを<b>名前テスト</b>という。</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd><b>節点</b>は<a href="#datamodel">[XQuery/XPath Data Model
(XDM)]</a>で定義されている<b>節点の種類</b>のいずれかのインスタンスである。</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd><b>節点テスト</b>は、<a title="step" href=
"#dt-step">ステップ</a>によって選択された節点それぞれについて真にならなければならない条件である。</dd>
<dt><a name="GLnon-delimiting-token" id=
"GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt>
<dd><b>非区切り終端記号</b>は: "xquery", "version", "encoding", "module",
"namespace", "declare", "boundary-space", "preserve", "strip",
"default", "element", "function", "option", "ordering", "ordered",
"unordered", "order", "empty", "copy-namespaces", "no-preserve",
"inherit", "no-inherit", "collation", "base-uri", "import",
"schema", "at", "variable", "construction", "as", "return", "for",
"in", "let", "where", "by", "stable", "some", "every", "satisfies",
"typeswitch", "case", "if", "then", "else", "eq", "ne", "lt", "le",
"gt", "ge", "is", "validate", "lax", "strict", "child",
"descendant", "attribute", "self", "descendant-or-self",
"following-sibling", "following", "parent", "ancestor",
"preceding-sibling", "preceding", "ancestor-or-self", "document",
"text", "comment", "processing-instruction", "empty-sequence",
"item", "node", "document-node", "schema-attribute",
"schema-element", <a href=
"#prod-xquery-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xquery-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xquery-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xquery-StringLiteral">StringLiteral</a>, "external",
"ascending", "descending", "greatest", "least", <a href=
"#prod-xquery-EscapeQuot">EscapeQuot</a>, <a href=
"#prod-xquery-EscapeApos">EscapeApos</a>, <a href=
"#prod-xquery-ElementContentChar">ElementContentChar</a>, <a href=
"#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a>,
<a href="#prod-xquery-AposAttrContentChar">AposAttrContentChar</a>,
<a href="#prod-xquery-PITarget">PITarget</a>, <a href=
"#prod-xquery-QName">QName</a>, <a href=
"#prod-xquery-NCName">NCName</a>, <a href=
"#prod-xquery-Char">Char</a>, <a href=
"#prod-xquery-Digits">Digits</a></dd>
<dt><a name="GLdt-numeric" id="GLdt-numeric"></a>numeric</dt>
<dd>型を参照するとき、<b>数</b>という用語は<code>xs:integer</code>型,
<code>xs:decimal</code>型, <code>xs:float</code>型,
<code>xs:double</code>型を表す。</dd>
<dt><a name="GLdt-numeric-predicate" id=
"GLdt-numeric-predicate"></a>numeric predicate</dt>
<dd>述語式が数型を返す述語を<b>数述語</b>という。</dd>
<dt><a name="GLdt-operator-function" id=
"GLdt-operator-function"></a>operator function</dt>
<dd>
各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<b>演算子関数</b>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。</dd>
<dt><a name="GLdt-optional-axis" id=
"GLdt-optional-axis"></a>optional axis</dt>
<dd>以下の軸は<b>選択的な軸</b>として設計されている: <code>ancestor</code>,
<code>ancestor-or-self</code>, <code>following</code>,
<code>following-sibling</code>, <code>preceding</code>, および
<code>preceding-sibling</code>。</dd>
<dt><a name="GLdt-option-declaration" id=
"GLdt-option-declaration"></a>option declaration</dt>
<dd><b>オプション宣言</b>は特定の実装の振舞いに影響を与えるオプションを宣言する。オプションはそれぞれ、識別される
QName と StringLiteral 1つずつから構成される。</dd>
<dt><a name="GLdt-ordering-mode" id=
"GLdt-ordering-mode"></a>ordering mode</dt>
<dd><b>順序付けモード</b>。
順序付けモードは<code>ordered</code>か<code>unordered</code>という値を取り、ある種の<a title="path expression"
href="#dt-path-expression">経路式</a>, <code>union</code>式,
<code>intersect</code>式, <code>except</code>式, <code>order
by</code>節を持たないFLWOR式などによって生成される結果列の順序付けに影響を与える。</dd>
<dt><a name="GLdt-ordering-mode-decl" id=
"GLdt-ordering-mode-decl"></a>ordering mode declaration</dt>
<dd><b>順序付けモード宣言</b>は<a title="static context" href=
"#dt-static-context">静的文脈</a>中の<a title="ordering mode" href=
"#dt-ordering-mode">順序付けモード</a>を設定する。このとき任意の実装依存のデフォルト値を上書きする。</dd>
<dt><a name="GLdt-path-expression" id=
"GLdt-path-expression"></a>path expression</dt>
<dd><b>経路式</b>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の <a title="step"
href="#dt-step">ステップ</a>の並びからなり、各ステップは "<code>/</code>" または
"<code>//</code>", で区切られている。また、経路式は "<code>/</code>" または
"<code>//</code>"で始まる場合もある。</dd>
<dt><a name="GLdt-pragma" id="GLdt-pragma"></a>pragma</dt>
<dd><b>pragma</b> は区切り記号 <code>(#</code> と <code>#)</code>
によって表され、識別可能な QName の次に<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の内容が続く。</dd>
<dt><a name="GLdt-predefined-entity-reference" id=
"GLdt-predefined-entity-reference"></a>predefined entity
reference</dt>
<dd>
<b>既定義実体参照</b>は短い文字列であり、&amp;記号で始まる。これは単一の文字のうち、他の場合には構文上の目印となるものを表す。</dd>
<dt><a name="GLdt-predicate" id="GLdt-predicate"></a>predicate</dt>
<dd>
<b>述語</b>は式からなり、角括弧で囲まれる。この式のことを<b>述語式</b>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd><b>基本式</b>(primary
expression)はXQuery言語の基本原式である。これにはリテラル、変数参照、文脈項目式、<span class=
"xquery">構成子、</span>関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。</dd>
<dt><a name="GLdt-principal-node-kind" id=
"GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
軸はそれぞれ<b>主要節点種類</b>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。</dd>
<dt><a name="GLdt-prolog" id="GLdt-prolog"></a>Prolog</dt>
<dd><b>前書き</b>は一連の宣言や輸入であり、その前書きを含む<a title="module" href=
"#dt-module">モジュール</a>に対する処理環境を定義する。</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>QName</dt>
<dd>
字句としては、<b>QName</b>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。</dd>
<dt><a name="GLdt-query" id="GLdt-query"></a>query</dt>
<dd><b>問合せ</b>は1つ以上の<a title="module" href=
"#dt-module">モジュール</a>から構成される。</dd>
<dt><a name="GLdt-queryBody" id="GLdt-queryBody"></a>query
body</dt>
<dd><b>問合せ本体</b>は、もしあれば、問合せの結果を定義する式からなる。</dd>
<dt><a name="GLdt-reverse-document-order" id=
"GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>文書順の逆順であるような節点の順序を<b>逆文書順</b>という。</dd>
<dt><a name="GLdt-schema-import" id="GLdt-schema-import"></a>schema
import</dt>
<dd><b>スキーマ輸入</b>は、1つのスキーマから要素宣言、属性宣言、および型宣言を<a title=
"in-scope schema definitions" href=
"#dt-issd">有効範囲内スキーマ定義</a>に輸入する。</dd>
<dt><a name="GLdt-schema-import-feature" id=
"GLdt-schema-import-feature"></a>schema import feature</dt>
<dd><b>スキーマ輸入機能</b>は問合せの前書きに<a title="schema import" href=
"#dt-schema-import">スキーマ輸入</a>を含めることを許す。</dd>
<dt><a name="GLdt-schema-type" id="GLdt-schema-type"></a>schema
type</dt>
<dd><b>スキーマ型</b>(schema type)は<a href="#XMLSchema">[XML
Schema]</a>の機能(<a href="#XMLSchema">[XML
Schema]</a>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<b>複合型</b>か<b>単純型</b>のいずれかである。単純型はさらに<b>リスト型</b>、<b>共用体型</b>、<b>原子型</b>に分けられる(これらの用語の定義と説明は<a href="#XMLSchema">[XML
Schema]</a>を見よ)。</dd>
<dt><a name="GLdt-schema-validation-feature" id=
"GLdt-schema-validation-feature"></a>schema validation feature</dt>
<dd><b>スキーマ検証機能</b>は、問合せに <code>validate</code> 式 (<a href=
"#id-validate"><b>3.13 検証式</b></a>を見よ) を含めることを許す。</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd><b>列</b>は0個以上の<a title="item" href=
"#dt-item">項目</a>の順序付きコレクションである。</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>sequence type</dt>
<dd><b>列型</b>(sequence type)は<a href=
"#doc-xquery-SequenceType">SequenceType</a>の構文を用いて表現することのできる型である。列型は、XQuery式で型を参照する必要があるときにはいつでも用いられる。<b>列型</b>という用語は、この構文がXQueryの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>式の評価の間、既知の<a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される<a title="sequence type" href=
"#dt-sequence-type">列型</a>に「照合」されるか決定する必要があることがある。この処理を<b>SequenceTypeの照合</b>という。</dd>
<dt><a name="GLdt-serialization" id=
"GLdt-serialization"></a>serialization</dt>
<dd><b>直列化</b>は<a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>をオクテット列に変換する処理である(図1の段階DM4)。</dd>
<dt><a name="GLdt-serialization-feature" id=
"GLdt-serialization-feature"></a>serialization feature</dt>
<dd><b>直列化機能</b>を支援する適合 XQuery 実装は、<a href=
"#id-serialization"><b>2.2.4
直列化</b></a>で指定されている通りに、問合せの結果を直列化する手段を提供<a title="must" href=
"#must">しなければならない</a>。</dd>
<dt><a name="GLdt-setter" id="GLdt-setter"></a>setter</dt>
<dd>
<b>設定子</b>は、問合せ処理に影響を与える性質の値を設定する。このような性質には、構成モード、順序付けモード、デフォルト照合順序などがある。</dd>
<dt><a name="GLshould" id="GLshould"></a>should</dt>
<dd><b>べきである</b> (SHOULD)
は、特定の状況ではその項目を無視する正当な理由があるかもしれないが、影響を完全に理解しなければならず、異なる選択を選ぶ前に十分慎重に考慮しなければならない、ということを意味する。</dd>
<dt><a name="GLdt-singleton" id="GLdt-singleton"></a>singleton</dt>
<dd>ただ一つの項目しか含まない列を<b>単一値列</b>という。</dd>
<dt><a name="GLstable" id="GLstable"></a>stable</dt>
<dd>文書順は<b>安定</b>である。ここで安定とは、ある<span class=
"xquery">問合せ</span>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<a title=
"implementation dependent" href=
"#dt-implementation-dependent">実装依存</a>であっても)ことを意味する。</dd>
<dt><a name="GLdt-static-collations" id=
"GLdt-static-collations"></a>statically known collations</dt>
<dd><b>静的既知照合順序</b>。これは組 (URI, 照合順序)の<a title=
"implementation defined" href=
"#dt-implementation-defined">実装定義</a>の集合である。<span class=
"xquery">問合せや</span>式の処理に用いることのできる照合順序の名前を定義する。</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically known collections</dt>
<dd>
<b>静的既知コレクション</b>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。</dd>
<dt><a name="GLdt-known-default-collection" id=
"GLdt-known-default-collection"></a>statically known default
collection type</dt>
<dd>
<b>静的既知デフォルトコレクション型</b>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically
known documents</dt>
<dd><b>静的既知文書</b>。
これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<a title="static type"
href="#dt-static-type">静的型</a>である。</dd>
<dt><a name="GLdt-static-namespaces" id=
"GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd><b>静的既知名前空間</b>。これは、組(接頭辞,
URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。</dd>
<dt><a name="GLdt-static-analysis" id=
"GLdt-static-analysis"></a>static analysis phase</dt>
<dd><b>静的解析相</b>は式自身と<a title="static context" href=
"#dt-static-context">静的文脈</a>に依存する。<b>静的解析相</b>は入力データ(スキーマを除く)には依存しない。</dd>
<dt><a name="GLdt-static-context" id=
"GLdt-static-context"></a>static context</dt>
<dd>式の<b>静的文脈</b>は、その式の評価よりも静的解析において有効である情報である。</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static
error</dt>
<dd><b>静的エラー</b>は静的解析相で検出されなければならないエラーである。構文エラーは<a title=
"static error" href="#dt-static-error">静的エラー</a>の例である。</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static
type</dt>
<dd>式の<b>静的型</b>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。</dd>
<dt><a name="GLdt-static-typing-extension" id=
"GLdt-static-typing-extension"></a>static typing extension</dt>
<dd><b>静的型付け拡張</b>は<a title="implementation defined" href=
"#dt-implementation-defined">実装定義</a>の型推論ルールである。これは<a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics]</a>の型推論ルールによって推論される静的型よりも詳細な静的型を推論する。</dd>
<dt><a name="GLdt-static-typing-feature" id=
"GLdt-static-typing-feature"></a>static typing feature</dt>
<dd><b>静的型付け機能</b>は<a href="#XQueryFormalSemantics">[XQuery 1.0 and
XPath 2.0 Formal Semantics]</a>に定義されている静的意味の支援を提供し、実装に、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>において<a title="type error" href=
"#dt-type-error">型エラー</a>を検出し報告することを要求する。</dd>
<dt><a name="GLdt-step" id="GLdt-step"></a>step</dt>
<dd><b>ステップ</b>は<a title="path expression" href=
"#dt-path-expression">経路式</a>の一部であり、項目の列を生成し、その列を0個以上の<a title=
"predicate" href=
"#dt-predicate">述語</a>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<a title="axis step"
href="#dt-axis-step">軸ステップ</a>または<a title="filter expression" href=
"#dt-filter-expression">選別式</a>のいずれかである。</dd>
<dt><a name="GLdt-string-value" id="GLdt-string-value"></a>string
value</dt>
<dd>
節点の<b>文字列値</b>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。</dd>
<dt><a name="GLdt-substitution-group" id=
"GLdt-substitution-group"></a>substitution group</dt>
<dd><b>置換グループ</b>は<a href="#XMLSchema">[XML Schema]</a>第1部,
2.2.2.2節で定義されている。直観的には、与えられた要素(<b>先導要素</b>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。</dd>
<dt><a name="GLdt-subtype-substitution" id=
"GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd><a title="dynamic type" href=
"#dt-dynamic-type">動的型</a>が期待される型から導出されるような値を用いることを<b>部分型置換</b>という。</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>文法中の各規則は1つの<b>記号</b>を定義する。ここで用いられる形式は以下の通りである。
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
</dd>
<dt><a name="GLsymbolseparators" id="GLsymbolseparators"></a>symbol
separators</dt>
<dd><b>記号区切り</b>としての<a title="whitespace" href=
"#Whitespace">空白</a>や<a href=
"#doc-xquery-Comment">Comments</a>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<a href="#ws-explicit">/*
ws: explicit */</a>という備考や、<a href="#parse-note-xml-version">/* xgs:
xml-version */</a>という備考で禁止されている場所を除く。</dd>
<dt><a name="GLdt-target-namespace" id=
"GLdt-target-namespace"></a>target namespace</dt>
<dd>
輸入されたスキーマやモジュールはそれぞれ、その<b>目的名前空間</b>によって識別される。これは、そのスキーマやモジュールで定義されるオブジェクト
(要素や関数など) の名前空間である。</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<b>終端記号</b>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。</dd>
<dt><a name="GLdt-trivial-xml-embedding" id=
"GLdt-trivial-xml-embedding"></a>Trivial XML Embedding</dt>
<dd><b>自明な XML 埋め込み機能</b>を支援する適合 XQuery 実装は、<a href=
"#XQueryX">[XQueryX 1.0]</a> 5章, "A Trivial Embedding of XQuery"
に指定されている埋め込みを提供<a title="must" href="#must">しなければならない</a>。</dd>
<dt><a name="GLdt-type-annotation" id=
"GLdt-type-annotation"></a>type annotation</dt>
<dd><a title="XDM instance" href=
"#dt-data-model-instance">XDMインスタンス</a>中の要素節点や属性節点はそれぞれ<b>型注釈</b>(<a href="#datamodel">[XQuery/XPath
Data Model
(XDM)]</a>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<a title=
"schema type" href="#dt-schema-type">スキーマ型</a>であり、節点の<a title=
"string value" href="#dt-string-value">文字列値</a>と<a title=
"typed value" href="#dt-typed-value">型付けされた値</a>の関連を記述する。</dd>
<dt><a name="GLdt-typed-value" id="GLdt-typed-value"></a>typed
value</dt>
<dd>
節点の<b>型付けされた値</b>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
error</dt>
<dd><b>型エラー</b>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<a title=
"static type" href=
"#dt-static-type">静的型</a>とその式の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href=
"#dt-type-error">型エラー</a>が発生する。動的評価相では、値の<a title="dynamic type"
href=
"#dt-dynamic-type">動的型</a>とその値の出現する文脈から期待される型とが一致しないとき、<a title=
"type error" href="#dt-type-error">型エラー</a>が発生する。</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type
promotion</dt>
<dd>ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<a href=
"#id-function-calls"><b>3.1.5 関数呼び出し</b></a>を見よ)<span class=
"xquery">, <code>order by</code> 節 (<a href=
"#id-orderby-return"><b>3.8.3 Order By 節と Return
節</b></a>を見よ)</span>や演算子の評価 (<a href="#mapping"><b>B.2
演算子の写像</b></a>を見よ)のときに、<b>型の昇格</b>が用いられる。</dd>
<dt><a name="GLdt-URI" id="GLdt-URI"></a>URI</dt>
<dd>この仕様書では、<b>URI</b>という用語は、<a href=
"#RFC3986">[RFC3986]</a>で定義され<a href=
"#RFC3987">[RFC3987]</a>で新しい名前<b>IRI</b>として拡張されたUniversal Resource
Identifierを表す。</dd>
<dt><a name="GLdt-udf" id="GLdt-udf"></a>user-defined function</dt>
<dd>
<b>ユーザ定義関数</b>に対して、関数宣言には<b>関数の本体</b>と呼ばれる式が含まれる。これは、その関数の結果が引数からどのように計算されるかを定義する。</dd>
<dt><a name="GLdt-value" id="GLdt-value"></a>value</dt>
<dd><a title="data model" href=
"#dt-datamodel">データモデル</a>では、<b>値</b>は常に<a title="sequence" href=
"#dt-sequence">列</a>である。</dd>
<dt><a name="GLdt-variable-reference" id=
"GLdt-variable-reference"></a>variable reference</dt>
<dd><b>変数参照</b>は$記号にQNameを続けたものである。</dd>
<dt><a name="GLdt-variable-values" id=
"GLdt-variable-values"></a>variable values</dt>
<dd><b>変数の値</b>。これは、組 (展開済QName, 値)の集合である。式の<a title=
"static context" href="#dt-static-context">静的文脈</a>中の<a title=
"in-scope variables" href=
"#dt-in-scope-variables">有効範囲内変数</a>と同じ<a title="expanded QName"
href=
"#dt-expanded-qname">展開済QName</a>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<a title="dynamic type"
href="#dt-dynamic-type">動的型</a>が含まれる。</dd>
<dt><a name="GLdt-version-declaration" id=
"GLdt-version-declaration"></a>version declaration</dt>
<dd><a title="module" href=
"#dt-module">モジュール</a>はいずれも<b>バージョン宣言</b>を含んでよい。もしあれば、バージョン宣言は<a title="module"
href="#dt-module">モジュール</a>の先頭に出現し、その<a title="module" href=
"#dt-module">モジュール</a>に対して適用可能な XQuery の構文と意味を識別する。</dd>
<dt><a name="GLdt-warning" id="GLdt-warning"></a>warning</dt>
<dd><a title="static error" href=
"#dt-static-error">静的エラー</a>、<a title="dynamic error" href=
"#dt-dynamic-error">動的エラー</a>、<a title="type error" href=
"#dt-type-error">型エラー</a>に加えて、XQueryの実装は、<a title=
"static analysis phase" href=
"#dt-static-analysis">静的解析相</a>、<a title="dynamic evaluation phase"
href=
"#dt-dynamic-evaluation">動的評価相</a>のいずれかで<b>警告</b>を発生してもよい。警告が発生する状況や、警告を処理する方法は<a title="implementation defined"
href="#dt-implementation-defined">実装定義</a>である。</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>whitespace</dt>
<dd><b>空白</b>文字は、<a href=
"http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>で定義される任意の文字である。</dd>
<dt><a name="GLdt-data-model-instance" id=
"GLdt-data-model-instance"></a>XDM instance</dt>
<dd><b>XDMインスタンス</b>という用語は<b>値</b>という用語と同義であり、<a title="data model"
href="#dt-datamodel">データモデル</a>中の<a title="node" href=
"#dt-node">節点</a>や<a title="atomic value" href=
"#dt-atomic-value">原子値</a>からなる制約なしの列を表す。</dd>
<dt><a name="GLdt-xpath-compat-mode" id=
"GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd><b>XPath 1.0互換モード</b>。<span class="xquery">この構成要素は、XPath 2.0
を部分集合として含むようなすべてのホスト言語で設定されなければならない。この構成要素により、XPath 1.0
との互換性のためのルールが有効であるかどうかを示す。XQuery
では、この構成要素の値を<code>false</code>に設定している。</span></dd>
<dt><a name="GLdt-anyAtomicType" id=
"GLdt-anyAtomicType"></a>xs:anyAtomicType</dt>
<dd>
<code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>,
<code>xs:string</code>,
<code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。</dd>
<dt><a name="GLdt-dayTimeDuration" id=
"GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt>
<dd>
<code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xs:untyped</dt>
<dd>
<code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<a title="type annotation"
href="#dt-type-annotation">型注釈</a>として用いられる。</dd>
<dt><a name="GLdt-untypedAtomic" id=
"GLdt-untypedAtomic"></a>xs:untypedAtomic</dt>
<dd>
<code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。</dd>
<dt><a name="GLdt-yearMonthDuration" id=
"GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt>
<dd>
<code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-example-applications" id=
"id-example-applications"></a>I 応用例 (Non-Normative)</h2>
<p>この節は、XQuery
を用いて表現できる問合せのうち、いくつかの重要なクラスの例を含む。ここで記述されている応用は、複数のデータ源にまたがる結合、グループ化と集計、順序関連に基づく問合せ、再帰的変換、区別可能な値の組の選択である。</p>
<div class="div2">
<h3><a name="id-joins" id="id-joins"></a>I.1 結合</h3>
<p>
結合は、複数のデータ源からのデータを1つの結果にまとめるものであり、非常に重要な種類の問合せである。この節では、さまざまな種類の結合を
XQuery でどのように表現できるかについて示す。この例は次の3つの文書に基づいている:</p>
<ol class="enumar">
<li>
<p><code>parts.xml</code> という名前の文書。これには多くの <code>part</code>
要素が含まれる。さらに、それぞれの <code>part</code> 要素には子要素として <code>partno</code>
と <code>description</code> が含まれる。</p>
</li>
<li>
<p><code>suppliers.xml</code> という名前の文書。これには多くの
<code>supplier</code> 要素が含まれる。さらに、それぞれの <code>supplier</code>
要素には子要素として <code>suppno</code> と <code>suppname</code> が含まれる。</p>
</li>
<li>
<p><code>catalog.xml</code> という名前の文書。これには supplier と part
の関連に関する情報が含まれる。catalog 文書には多くの <code>item</code>
要素が含まれている。さらに、それぞれの <code>item</code> 要素には子要素として
<code>partno</code>, <code>suppno</code>, および <code>price</code>
が含まれる。</p>
</li>
</ol>
<p>よくある ("内部")
結合は、以下の例に示すように、2つ以上の関連するデータ源からの情報を返す。以下の例では、3つの文書からの情報をまとめている。この例では、カタログ文書から導出される
"記述的なカタログ" を生成している。しかし、part 番号の代わりに part の記述を、supplier 番号の代わりに
supplier の名前を含んでいる。新しいカタログは part の記述のアルファベット順に整列され、次いで supplier
の名前のアルファベット順に整列される。</p>
<div class="exampleInner">
<pre>
&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;
</pre></div>
<p>前の問合せでは、supplier を持つ part と part を持つ supplier
に関する情報しか返さない。<b>外部結合</b>は、問合せに用いる1つ以上のデータ源からの情報を保存し、他方のデータ源に対応する要素がない要素も結果に含む。例えば、supplier
と part の<b>左外部結合</b>は、対応する part を持たない supplier に関する情報を返す。</p>
<p>以下の問合せは、左外部結合を示している。これは、すべての supplier の名前をアルファベット順に返す。これには、part
を何も供給しない supplier も含まれる。結果では、各 supplier 要素は、それが供給するすべての part
の記述をアルファベット順に含む。</p>
<div class="exampleInner">
<pre>
for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/pno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;
</pre></div>
<p>前の問合せでは、part を供給しない supplier
に関する情報が保存される。もう一つの種類の結合は<b>完全外部結合</b>と呼ばれ、part を供給しない supplier
に関する情報も、supplier のない part
に関する情報も保存するのに用いられる。完全外部結合の結果はいくつかの方法で構成することができる。以下の問合せでは、まず<code>supplier</code>
要素のリストを生成している。各要素には、それが供給する (もしあるなら) 入れ子になった <code>part</code>
要素が含まれている。これに続いて、supplier のない <code>part</code> 要素のリストが生成される。これは
"supplier を中心とする" 完全外部結合と考えられる。他の形式の完全結合問合せも可能である。</p>
<div class="exampleInner">
<pre>
&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;
</pre></div>
<p>前の問合せでは、要素構成子を用いて出力を <code>master-list</code> 要素の内部に囲んでいる。連接演算子
(",") を用いて、問合せの2つの主な部分をまとめている。結果は、<code>supplier</code>
要素の順序付き列に、supplier を持たない part すべての記述を含む <code>orphan-parts</code>
要素1つが続くようなものになる。</p>
</div>
<div class="div2">
<h3><a name="id-grouping" id="id-grouping"></a>I.2 グループ化</h3>
<p>多くの問合せでは、データをグループ化し、各グループに <code>fn:count</code> や
<code>fn:avg</code> のような集計関数を適用することを必要とする。以下の例では、このような問合せを XQuery
でどのように表現するかを示す。ここでは前節で定義した catalog 文書を用いる。</p>
<p>この問合せでは、3 つ以上の supplier を持つ part について、その part
の番号と平均価格を求めている。</p>
<div class="exampleInner">
<pre>
for $pn in fn:distinct-values(
      fn:doc("catalog.xml")/items/item/partno)
let $i := fn:doc("catalog.xml")/items/item[partno = $pn]
where fn:count($i) &gt;= 3
order by $pn
return 
   &lt;well-supplied-item&gt;
      &lt;partno&gt; {$p} &lt;/partno&gt;
      &lt;avgprice&gt; {fn:avg($i/price)} &lt;/avgprice&gt;
   &lt;/well-supplied-item&gt;
</pre></div>
<p>この問合せ中、<code>fn:distinct-values</code> 関数は catalog 文書中のすべての part
の番号の集合から重複する part 番号を取り除いている。<code>fn:distinct-values</code>
の結果は、順序に意味を持たない列である。</p>
<p>注意しておいてほしいのだが、for 節で束縛されている <code>$pn</code> は個々の part
の番号を表している一方、let 節で束縛されている <code>$i</code> は集計関数
<code>fn:count($i)</code> と <code>fn:avg($i/price)</code>
への引数として働いている。この問合せでは、要素構成子を用いて、各 part の番号と平均価格を
<code>well-supplied-item</code> という要素の中に囲んでいる。</p>
<p>上で示した方法は、容易に、2つ以上のデータ値によるグループ化に一般化される。例えば、<code>person</code>
要素の列を含む census 文書を考える。それぞれの <code>person</code> 要素は
<code>state</code>, <code>job</code>, および <code>income</code>
という子要素を持つ。census アナリストは、<code>state</code> と <code>job</code>
の組み合わせそれぞれについて平均の <code>income</code>
を列挙したようなレポートを準備する必要があるとする。このレポートは、以下のような問合せを用いて生成される:</p>
<div class="exampleInner">
<pre>
for $s in fn:distinct-values(
        fn:doc("census.xml")/census/person/state),
    $j in fn:distinct-values(
        fn:doc("census.xml")/census/person/job)
let $p := fn:doc("census.xml")/census/person
        [state = $s and job = $j]
order by $s, $j
return 
   if (fn:exists($p)) then
      &lt;group&gt;
         &lt;state&gt; {$s} &lt;/state&gt;
         &lt;job&gt; {$j} &lt;/job&gt;
         &lt;avgincome&gt; {fn:avg($p/income)} &lt;/avgincome&gt;
      &lt;/group&gt;
   else ()
</pre></div>
<p>上の例で、<code>if-then-else</code>
式はデータを含まないグループを生成することを防いでいる。例えば、census データにはネブラスカ州に済む人や仕事が Deep Sea
Fisherman であるような人は含まれるが、ネブラスカ州に住みかつ仕事が Deep Sea Fisherman
であるような人はいないかもしれない。出力となるグループが、州と仕事の可能な組み合わせすべてについて要求されるのであれば、<code>if-then-else</code>
式は問合せから省略することができる。この場合、出力には次のような "空の" グループが含まれるかもしれない:</p>
<div class="exampleInner">
<pre>
&lt;group&gt;
   &lt;state&gt;Nebraska&lt;/state&gt;
   &lt;job&gt;Deep Sea Fisherman&lt;/state&gt;
   &lt;avgincome/&gt;
&lt;/group&gt;
</pre></div>
</div>
<div class="div2">
<h3><a name="id-queries-on-sequence" id=
"id-queries-on-sequence"></a>I.3 列への問合せ</h3>
<p>XQuery では、<code>&lt;&lt;</code> 演算子や <code>&gt;&gt;</code>
演算子を用いて文書順に基づく節点の比較を行う。これらの演算子は非常に単純であるが、順序に意味を持つ XML
文書に対する複雑な問合せを表現するのに用いることができる。この節の最初の2つの問合せは、<code>procedure</code>,
<code>incision</code>, <code>instrument</code>,
<code>action</code>, および <code>anesthesia</code>
の各要素を含む外科レポートを意味する。</p>
<p>次の問合せは <code>action</code> 要素のうち、最初の procedure の内部にある最初と2番目の
<code>incision</code>
の間に出現するものすべてを返す。これらの節点間の元々の文書順が問合せの結果に保存される。</p>
<div class="exampleInner">
<pre>
let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i
</pre></div>
<p>
ここでは、文書順の定義について、ある節点がその子孫よりも文書順で前にあるとみなすという方法は何の価値もない。この外科レポートでは、<code>action</code>
が <code>incision</code> の部分であることは決してないが、<code>instrument</code> は
<code>incision</code> の部分である。<code>&gt;&gt;</code>
演算子は文書順に基づいているので、述語 <code>$i &gt;&gt; ($proc//incision)[1]</code> は
<code>instrument</code> 要素のうち最初の procedure 中の1つ目の
<code>incision</code> 要素の子孫であるものに対して真である。</p>
<p>
問合せによっては、ある節点が他の節点より前にあり、かつその節点の先祖ではないことを検査できる関数を定義することは有用かもしれない。以下の関数は、1つ目の演算数が2つ目の演算数より前にあるが、2つ目の演算数の先祖ではないときに
<code>true</code> を返す。それ以外の場合には <code>false</code> を返す:</p>
<div class="exampleInner">
<pre>
declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</pre></div>
<p>同様に、<code>local:follows</code> 関数は次のように書けるだろう:</p>
<div class="exampleInner">
<pre>
declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</pre></div>
<p><code>local:precedes</code> 関数を用いると、最初の2つの incision の間にある
<code>instrument</code> 要素を見つける問合せを書くことができる。ただし、問合せの結果から、最初の
<code>incision</code> の子孫である <code>instrument</code> は除かれる:</p>
<div class="exampleInner">
<pre>
let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i
</pre></div>
<p>以下の問合せは、過去に外科レポートに anesthesia の記録がない incision
を報告する。<code>anesthesia</code> は <code>incision</code>
の部分では決してないため、効率の悪い <code>local:precedes</code> 関数の代わりに
<code>&lt;&lt;</code> を用いることができる:</p>
<div class="exampleInner">
<pre>
for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc
</pre></div>
<p>文書によっては、特定の要素列が論理的な階層を表しているかもしれない。これは HTML
では特に広く見られる。以下の問合せでは、XHTML 文書のまえがきを <code>div</code>
要素で囲んで返す。この例では、テキスト "Introduction" を含む <code>h2</code>
要素がまえがきの始まりの目印となっており、次の <code>h2</code> 要素か <code>h1</code>
要素、あるいは文書の終わりのいずれかが最初に出現するところまでまえがきが続く、と仮定している。</p>
<div class="exampleInner">
<pre>
let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;
</pre></div>
<p>注意してほしいのだが、上の問合せでは元の文書中では暗黙的であった階層を明示的にしている。この例では、テキスト
"Instroduction" を含む <code>h2</code> 要素は部分要素を持たないと仮定している。</p>
</div>
<div class="div2">
<h3><a name="id-recursive-transformations" id=
"id-recursive-transformations"></a>I.4 再帰的変換</h3>
<p>要素の階層を走査し、階層の各レベルで何らかの変換を適用する必要があることが時々ある。XQuery
では、これは再帰関数を定義することで遂行することができる。この切では、このような再帰関数の例を2つ示す。</p>
<p>ある文書に対して、目次を計算する必要があるとしよう。これは、文書を走査し、<code>section</code> もしくは
<code>title</code>
という名前の要素のみ残し、これらの間の階層関係を残すことで行える。<code>section</code>
それぞれについて、<code>section</code> か <code>title</code>
という名前の部分要素をそのまま保つ。しかし <code>title</code>
に対しては、要素の内容を全部保つ。これは以下のような再帰関数によって遂行される:</p>
<div class="exampleInner">
<pre>
declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };
</pre></div>
<p>与えられた文書の "骨格" 、これはすなわち文書の section と title
のみから構成されているのだが、<code>local:sections-and-titles</code>
関数を文書の根要素に対して実行することで、以下のように得られる:</p>
<div class="exampleInner">
<pre>
local:sections-and-titles(fn:doc("cookbook.xml"))
</pre></div>
<p>再帰的変換のもう1つの例として、文書を走査し、<code>color</code> という名前の属性をそれぞれ
<code>color</code> という名前の要素に、<code>size</code> という名前の要素を
<code>size</code> という名前の属性にそれぞれ変換したいとする。これは以下のような再帰関数によって遂行される:</p>
<div class="exampleInner">
<pre>
declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in $e/(* | @*) return local:swizzle($c) } 
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };
</pre></div>
<p>この変換は、<code>local:swizzle</code>
関数を文書の根要素に以下のように実行することで、文書全体に適用することができる:</p>
<div class="exampleInner">
<pre>
local:swizzle(fn:doc("plans.xml"))
</pre></div>
</div>
<div class="div2">
<h3><a name="id-select-distinct" id="id-select-distinct"></a>I.5
区別可能な組み合わせの選択</h3>
<p>ときにはデータの集合を探索して、ある性質のリストの区別可能な組み合わせをすべて求める必要がある。例えば、入力データ集合が
<code>order</code>
要素からなる大きな集合からなり、それぞれの要素は、以下の例のように、同じ基本的な構造をしているものとする:</p>
<div class="exampleInner">
<pre>
&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;
</pre></div>
<p>このデータ集合から、1つの <code>order</code> にともに出現する <code>product</code>,
<code>size</code>, および <code>color</code>
の区別可能な組み合わせをすべて見つけたいとする。以下の問合せはこのリストを返す。このとき、区別可能な組み合わせをそれぞれ
<code>option</code> という名前の新たな要素で囲む:</p>
<div class="exampleInner">
<pre>
for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-revisions-log" id="id-revisions-log"></a>J Revision
Log (Non-Normative)</h2>
<p>This log records the substantive and significant editorial
changes that have been made to this document since the Candidate
Recommendation Draft of 03 November 2005. Minor editorial changes
are not included in this log.</p>
<div class="div2">
<h3><a name="id-log-050707" id="id-log-050707"></a>J.1 10 May
2006</h3>
<ol class="enumar">
<li>
<p>Deleted all references to the namespace
<code>http://www.w3.org/2005/xpath-datatypes</code>, formerly known
by the prefix <code>xdt:</code>, and moved all the schema types
defined in this namespace to the namespace
<code>http://www.w3.org/2001/XMLSchema</code>, known in this
document by the prefix <code>xs:</code>. All built-in schema types
used by XPath and XQuery are now consolidated in the
<code>xs:</code> namespace.</p>
<p>This change closes Bugzilla entry 2548. It affects many sections
throughout this document and other XPath and XQuery
specifications.</p>
</li>
<li>
<p>Deleted a paragraph requiring the functions <code>fn:doc</code>
and <code>fn:collection</code> to be stable (returning the same
results when called repeatedly.) Stability of these functions is
now covered in the Functions and Operators specification. The
functions are stable by default but an implementation may provide a
user option to relax this requirement.</p>
<p>This change closes Bugzilla entry 2553. Section affected:
<a href="#id-input-sources"><b>2.4.4 入力源</b></a></p>
</li>
<li>
<p>A cast expression or constructor function whose target type is
<code>xs:QName</code> or is derived from <code>xs:QName</code> or
<code>xs:NOTATION</code> formerly required its operand to be a
literal string. Now it accepts either a literal string or an
expression whose base type is the same as the base type of the
target type. For example, it is now possible to cast a value of
type <code>xs:QName</code> to <code>my:BigQName</code> which is
derived from <code>xs:QName</code>.</p>
<p>This change closes Bugzilla entry 2678. Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#id-cast"><b>3.12.3 Cast</b></a></p>
</li>
<li>
<p><a href="#id-constructor-functions"><b>3.12.5 構成子関数</b></a></p>
</li>
<li>
<p>Error code XPST0083 is eliminated (all casts and calls to
constructor functions with invalid operands raise XPTY0004.)</p>
</li>
</ol>
</li>
<li>
<p>It is now a <a title="static error" href=
"#dt-static-error">static error</a> if a variable bound in a for
clause of a FLWOR expression, and its associated positional
variable, do not have distinct names (expanded QNames).</p>
<p>This change closes Bugzilla entry 2692. Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#id-for-let"><b>3.8.1 For 節と Let 節</b></a></p>
</li>
<li>
<p>New error code XQST0089.</p>
</li>
</ol>
</li>
<li>
<p>Modified the definition of Effective Boolean Value to specify
that a value of type <code>xs:anyURI</code> is treated the same as
a value of type <code>xs:string</code> (a consequence of placing
<code>xs:anyURI</code> and <code>xs:string</code> in the same
promotion hierarchy).</p>
<p>This change closes Bugzilla entry 2545. Section affected:
<a href="#id-ebv"><b>2.4.3 有効ブール値</b></a></p>
</li>
<li>
<p>It is now a <a title="static error" href=
"#dt-static-error">static error</a> if the target namespace in a
module declaration is of zero length.</p>
<p>Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#id-module-declaration"><b>4.2 モジュール宣言</b></a></p>
</li>
<li>
<p>Definition of error code XQST0088. (Formerly applied only to
module import; now applies to module declaration as well.)</p>
</li>
</ol>
</li>
<li>
<p>The rules for whitespace normalization of URI Literals have been
made more specific.</p>
<p>Section affected: <a href="#id-uri-literals"><b>2.4.5
URIリテラル</b></a></p>
</li>
<li>
<p>When a namespace prefix cannot be resolved, error code XPST0081
is raised rather than the more generic error XPST0008.</p>
<p>This change closes Bugzilla entry 2447. Sections affected:</p>
<ol class="enumla">
<li>
<p><a href="#node-tests"><b>3.2.1.2 節点テスト</b></a></p>
</li>
<li>
<p><a href="#id-namespaces"><b>3.7.1.2 名前空間宣言属性</b></a></p>
</li>
<li>
<p><a href="#id-namespace-decls"><b>4.12 名前空間宣言</b></a></p>
</li>
</ol>
</li>
<li>
<p>When the axis name is omitted from an axis step containing a
SchemaAttributeTest, the default axis is <code>attribute</code>.
Example: <code>part/schema-attribute(color)</code>.</p>
<p>This change closes Bugzilla entry 2527. Section affected:
<a href="#abbrev"><b>3.2.4 省略構文</b></a></p>
</li>
<li>
<p>When ordering mode is <code>unordered</code>, XQuery does not
require the results of <code>fn:id</code> and <code>fn:idref</code>
to be returned in document order. This is a feature of XQuery
rather than of the functions themselves.</p>
<p>This change closes Bugzilla entry 2542. Section affected:
<a href="#id-unordered-expressions"><b>3.9 順序化式と非順序化式</b></a></p>
</li>
<li>
<p>In an extension expression (pragma), whitespace is required
between the pragma name and pragma content.</p>
<p>This change closes Bugzilla entry 2710. Section affected:
<a href="#id-extension-expressions"><b>3.14 拡張式</b></a></p>
</li>
<li>
<p>When importing a module, an error is not raised if the importing
module contains functions or variables that use unknown types
unless such a function or variable is actually referenced in the
importing module.</p>
<p>This change closes Bugzilla entry 2546. Section affected:
<a href="#id-module-imports"><b>4.11 モジュール輸入</b></a> and the
definition of error XQST0036.</p>
</li>
<li>
<p>A static error is now raised if a character reference is
syntactically valid but does not identify a valid character.</p>
<p>This change closes Bugzilla entry 2610. Section affected:
<a href="#id-literals"><b>3.1.1 リテラル</b></a> and new error code
XQST0090.</p>
</li>
<li>
<p>Equality of QNames is defined by the <code>eq</code> operator,
which performs codepoint-comparisons of the namespace URIs and the
local names, ignoring the namespace prefixes. This is not a change,
but some editorial clarifications have been made in the XPath,
XQuery, and Functions and Operators documents. For example, phrases
such as "QNames are the same" have been replaced by "QNames are
equal as defined by the <code>eq</code> operator", and a new
example has been added to the section on Value Comparisons.</p>
<p>This change closes Bugzilla entry 2634. Sections affected: Minor
editorial changes to various sections and to the definitions of
error codes XQST0034 and XQST0049.</p>
</li>
<li>
<p>An implementation is not required to enforce cardinality
constraints on operands that are not evaluated.</p>
<p>This change closes Bugzilla entry 2708. Section affected:
<a href="#id-errors-and-opt"><b>2.3.4 エラーと最適化</b></a></p>
</li>
<li>
<p>Entries for the <code>eq</code> and <code>ne</code> operators on
the types <code>xs:yearMonthDuration</code> and
<code>xs:dateTimeDuration</code> have been removed from the
operator mapping table. These operators are now handled by
promotion to <code>xs:duration</code>.</p>
<p>This change closes Bugzilla entry 2789. Section affected:
<a href="#mapping"><b>B.2 演算子の写像</b></a></p>
</li>
<li>
<p>Editorial changes have been made to clarify that type promotions
and subtype substitutions may be performed on the operands of all
operators, including value comparisons. This is not a substantive
change.</p>
<p>This change closes Bugzilla entries 2324 and 2631. Sections
affected: <a href="#id-value-comparisons"><b>3.5.1 値比較</b></a> and
<a href="#mapping"><b>B.2 演算子の写像</b></a>.</p>
</li>
<li>
<p>Editorial changes have been made to clarify that a sequence of
adjacent predicates is processed from left to right, and to clarify
the assignment of context positions on reverse axes. This is not a
substantive change.</p>
<p>This change closes Bugzilla entry 2500. Sections affected:
<a href="#id-steps"><b>3.2.1 ステップ</b></a>, <a href=
"#axes"><b>3.2.1.1 軸</b></a>, <a href="#id-predicates"><b>3.2.2
述語</b></a>, and <a href="#id-filter-expr"><b>3.3.2 選別式</b></a>.</p>
</li>
<li>
<p>The namespace prefix specified in a module declaration, schema
import, or module import must not be <code>xml</code> or
<code>xmlns</code>.</p>
<p>This change closes Bugzilla entry 2950. Sections affected:
<a href="#id-module-declaration"><b>4.2 モジュール宣言</b></a>, <a href=
"#id-schema-imports"><b>4.10 スキーマ輸入</b></a>, <a href=
"#id-module-imports"><b>4.11 モジュール輸入</b></a>, and error code
XQST0070.</p>
</li>
<li>
<p>An external function must either return a value of the type
declared in its function declaration or raise an
implementation-defined error.</p>
<p>This change closes Bugzilla entry 2977. Sections affected:
<a href="#id-consistency-constraints"><b>2.2.5 無矛盾性制約</b></a>,
<a href="#id-function-calls"><b>3.1.5 関数呼び出し</b></a>, and <a href=
"#id-impl-defined-items"><b>D 実装定義の項目</b></a>.</p>
</li>
<li>
<p>If multiple errors are detected, an implementation may report
any non-empty subset of the detected errors.</p>
<p>This change closes Bugzilla entry 3122. Section affected:
<a href="#id-kinds-of-errors"><b>2.3.1 エラーの種類</b></a>.</p>
</li>
</ol>
</div>
</div>
</div>
</body>
</html>
