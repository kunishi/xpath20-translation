<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="cr">
<?translation-notice?>
<header id="id-spec-header">
<title role="spec-conditional" id="x">XQuery 1.0: XML問合せ言語</title>
<version role="spec-conditional"/>
<w3c-designation>CR-xquery-20060608</w3c-designation>
<w3c-doctype>W3C勧告候補</w3c-doctype>
<pubdate><day>8</day><month>June</month><year>2006</year></pubdate>

<publoc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xquery-20060608/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2006/CR-xquery-20060608/</loc>

</publoc>

<altlocs>
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xquery-20060608/xquery.xml" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xquery-20060608/diff-from-20051103.html" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recent revisions</loc>
  
  
</altlocs>

<latestloc>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xquery/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</loc>
</latestloc>

<prevlocs>

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-20051103/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-20050915/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xquery-20050915/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-20050404/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xquery-20050404/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xquery-20050211/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xquery-20050211/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2004/WD-xquery-20040723/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2004/WD-xquery-20040723/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xquery-20031112/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xquery-20031112/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xquery-20030822/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xquery-20030822/</loc>


<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2003/WD-xquery-20030502/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2003/WD-xquery-20030502/</loc>

</prevlocs>

<authlist>


<author>
<name>Scott Boag (XSL WG)</name>
<affiliation>IBM  Research</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:scott_boag@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">scott_boag@us.ibm.com</email>

</author><author> <name>Don Chamberlin (XML Query
WG)</name>
<affiliation>IBM Almaden Research Center</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:chamberlin@almaden.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">chamberlin@almaden.ibm.com</email>
</author>

<author><name>Mary F. Fernández (XML Query
WG)</name><affiliation>AT&amp;T Labs</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mff@research.att.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mff@research.att.com</email>
</author>

<author role="xquery"><name>Daniela Florescu (XML Query WG)</name>
<affiliation>Oracle</affiliation>
<email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:dana.florescu@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">dana.florescu@oracle.com</email></author>



<author><name>Jonathan
Robie (XML Query WG)</name><affiliation>DataDirect Technologies</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jonathan.robie@datadirect-technologies.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jonathan.robie@datadirect-technologies.com</email></author>

<author><name>Jérôme Siméon (XML Query
WG)</name><affiliation>IBM T.J. Watson Research Center
</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:simeon@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">simeon@us.ibm.com</email></author>

</authlist>

<status id="id-status">
<p><emph>This section describes the status of this document at the
time of its publication. Other documents may supersede this document.
A list of current W3C publications and the latest revision of this
technical report can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc> at
http://www.w3.org/TR/.</emph></p>

<p>On 3 November 2005, this specification
<phrase role="xquery"><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">was published</loc></phrase> 

as a
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate
Recommendation</loc>, and a Call for Implementations was announced. This revision is published in order to give visibility to the technical decisions
that have been made so far during this phase of the process
and to allow review by W3C Members and other interested parties.
The maturity
level of the specification remains unchanged, and the work is on track to
move forward to the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed
Recommendation</loc> stage when the exit criteria for
the current phase have been met.</p>

<p>Publication as a Candidate Recommendation does not imply
endorsement by the W3C Membership. This is a draft document and may be
updated, replaced or obsoleted by other documents at any time. It is
inappropriate to cite this document as other than work in progress.
This specification will remain a Candidate Recommendation until at
least 28 February 2006.</p>

<p>The
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XPath and
XML Query Test Suite</loc> is under development.
Implementors are encouraged to run this test suite and report their results.
<phrase role="xquery">A
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/XQTSReport.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">preliminary
XQuery Test Suite Result Summary</loc>
has been prepared that contains information submitted for several
implementations.</phrase>
</p>

<p>
<phrase role="xquery">This document has been produced by the 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> 
(WG), which is part of the 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</phrase>
</p>

<p>This draft includes corrections and changes based on 

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=XPath&amp;component=XQuery&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public comments</loc>
 
recorded in the W3C public Bugzilla repository 
(<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Bugs/Public/</loc>) 
used for Last Call issues tracking. A list of substantive changes since the publication of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-20051103/" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc> of 03 November 2005 can be found in <specref ref="id-revisions-log"/>.</p>

<p>Comments on this document are invited and should be made in W3C's 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc> 
(instructions can be found at 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>). 
If access to that system is not feasible, you may send your comments to 
the W3C XSLT/XPath/XQuery mailing list, 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. 
It will be very helpful if you include the string 
<phrase role="xquery">[XQuery]</phrase>
 
in the subject 
line of your comment, whether made in Bugzilla or in email. Each Bugzilla 
entry and email message should contain only one comment.  Archives of the 
comments and responses are available at 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/ </loc>.</p>
<p>This document was produced by  
 operating under the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 
2004 W3C Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2002/08/xmlquery-IPR-statements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
patent disclosures</loc> made in connection with the deliverables of the 
XML Query Working Group  instructions for 
disclosing a patent. An individual who has actual knowledge of a patent 
which the individual believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential 
Claim(s)</loc> with respect to this specification should disclose the 
information in accordance with  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 
6 of the W3C Patent Policy</loc>.</p>

</status>

<abstract id="id-abstract"> 
<p role="xquery">XMLはさまざまな目的に利用できるマークアップ言語であり、
種々のデータ源の情報内容をラベル付けする能力を持つ。ここでデータ源には
構造文書や半構造文書、関係データベース、オブジェクトレポジトリなどが
含まれる。XMLの構造を利用する問合せ言語は、これらの種類のデータすべてに
またがる問合せをうまく表現することができる。データが物理的にXMLとして
格納されているか、ミドルウェアを通してXMLのビューとして見えているかには
よらない。この仕様書は、XQueryと呼ばれる問合せ言語について記述する。
これは、多くの型のXMLデータ源にまたがって広く適用可能であるように
設計されている。</p>
</abstract>

<langusage>
<language id="JA">Japanese</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>Working Draft. (2001;06;07)</sitem>
</slist>
</revisiondesc>
</header>
<body>

<div1 id="id-introduction">

	<head>まえがき</head> 

	<p role="xquery">XMLを用いて蓄積されたり、交換されたり、表現
	されている情報の量が増えており、XMLデータ源に対してうまく問合せを
	行う機能がますます重要になっている。XMLの素晴らしい利点の一つは、
	種々のデータ源から得られる多くの異なる種類の情報を表現する際の
	柔軟性である。この柔軟性を活用するため、XML問合せ言語は、これらの
	種々のデータ源から情報を検索したり、その情報を解釈する機能を
	用意しなければならない。</p> 

	<p role="xquery">XQueryは、W3C XML Queryワーキンググループ
	<bibref ref="Requirements"/>によって認識された要求や
	<bibref ref="UseCases"/>にある利用例に応えるように設計されている。
	この言語は、問合せが簡潔で、容易に理解できるように設計されている。
	また、広範囲のXML情報源に問合せが行えるよう、充分な柔軟性も
	持っている。W3C XML Queryワーキンググループでは、非XML形式の
	問合せ構文とXMLによる問合せ構文の両方についての要求を認識して
	いる。XQueryはこれらの要求のうち、最初の2つに応えるように設計
	されている。XQueryは、Quilt<bibref ref="Quilt"/>と呼ばれる
	XML問合せ言語に由来している。この言語はさらに、他の多くの言語から
	機能を借用している。XPath 1.0 <bibref ref="XPath"/>, 
	XQL <bibref ref="XQL"/>, XML-QL <bibref ref="XML-QL"/>, 
	SQL <bibref ref="SQL"/>, OQL <bibref ref="ODMG"/> などである。</p>

	

<p><termdef id="dt-datamodel" term="data model">XQueryは、XML文書の抽象
的かつ論理的な構造に適用され、XML文書の表面上の構文には適用されない。こ
の論理的な構造は<term>データモデル</term>と呼ばれ、<bibref ref="datamodel"/>で定義されている。</termdef></p>

	

	<p>XQueryバージョン1.0はXPathバージョン2.0の拡張である。XPath2.0でもXQuery 1.0でも構文的に正しく、かつ正常に実行される式はすべて、いずれの言語でも同じ結果を返す。これらの言語は非常に密接に関連しているため、これらの言語の文法や言語記述は、一貫性を保つために共通のソースから生成されており、これらの仕様書の編者は密に協力して作業を進めている。</p>


	<p>またXQueryは、以下の仕様書に依存しており、密接に関連している。</p>

	<ulist>
	  <item>
            <p><bibref ref="datamodel"/>では、すべてのXQuery式の基礎となるデータモデルを定義する。</p>
	  </item>

	  <item>
	  <p><bibref ref="XQueryFormalSemantics"/>では、XQueryの静的な意味を定義する。また動的な意味に関して、形式的ではあるが規範ではない記述を含んでいる。これは、実装を行う人や形式的定義を必要とする人に有用である。</p></item>

          <item>
	  <p>XQueryの型システムは<bibref ref="XMLSchema"/>に基づいている。</p>
	  </item>

	  <item>
	  <p>XQueryで支援されている組み込み関数ライブラリや演算子は<bibref ref="FunctionsAndOperators"/>で定義される。</p>
	  </item>

	  <item role="xquery">
	  <p><bibref ref="Requirements"/>にある要求の一つに、XML問合せ
	  言語は人間に読みやすい構文とXMLに基づく構文の両方を持つ、と
	  いうものがある。XMLに基づくXQueryについては、
	  <bibref ref="XQueryX"/>で記述されている。</p> 
          </item>
	  
        </ulist>
		
	
	<p>この文書は<bibref ref="XML"/>で用いられているのと同じ基本的なEBNF記法を用いて、XQueryの文法を規定する。特に注釈を加えない限り(<specref ref="lexical-structure"/>)、空白は<phrase role="xquery">問合せ</phrase>中では意味を持たない。文法の生成規則は、それが記述している特徴とともに紹介される。また、完全な文法は付録 [<specref ref="nt-bnf"/>]で示される。この付録は規定版である。</p>
<p>この文書中の文法の生成規則では、名前を持つ記号には下線を引き、リテラルテキストは二重引用符で囲む。例えば、次の生成規則は関数呼び出しの構文を記述している:</p><scrap headstyle="show"> 
		  <head/> 
		   
		  <prod num="93" id="fakeid_doc-xquery-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		</scrap><p>この生成規則は次のように読むべきである: 関数呼び出しは、一つの開き括弧が続く一つのQNameからなる。その開き括弧の次には、省略可能な引数リストが続く。引数リストは(もし存在するならば)1つ以上の式からなり、それらはコンマで区切られる。省略可能な引数リストの次には、1つの閉じ括弧が続く。</p>

		<p>この仕様書では、言語処理のいくつかの面について、<term>実装定義</term>または<term>実装依存</term>という言葉で記述している。</p>

<ulist>
  <item>
    <p><termdef id="dt-implementation-defined" term="implementation defined"><term>実装定義</term>とは、実装によって異なるかもしれないが、個々の実装に対して実装者が指定しなければならない面を表す。</termdef></p>
  </item>
  <item>
    <p>
      <termdef id="dt-implementation-dependent" term="implementation dependent"><term>実装依存</term>とは、実装によって異なるかもしれず、この仕様書やW3Cのどの仕様書でも指定されず、どの実装でも実装者が指定する必要のない面を表す。</termdef></p>
  </item>
</ulist>



<p>この文書はXQueryの動的な意味を規定として定義する。XQueryの静的な意味は<bibref ref="XQueryFormalSemantics"/>において規定として定義されている。この文書では、例、および「Note:」というラベルの付けられた資料は説明の目的で用意されたものであり、参考(not normative)である。</p></div1>


<!--
====================================================================
 $Log: xpath20.xml,v $
 Revision 1.3  2006/06/08 17:22:41  matthieu
 updated

 Revision 1.60  2006/06/01 21:31:05  NormanWalsh
 Updated for publication

 Revision 1.59  2006/05/10 11:21:31  NormanWalsh
 Updates from Don (unchecked)

 Revision 1.58  2005/10/25 20:27:38  sboag
 Removed role-"parse-test" from element that holds a clearly incomplete expression.

 Revision 1.57  2005/10/21 04:27:02  sboag
 Don's latest changes.

 Revision 1.56  2005/09/01 20:36:35  NormanWalsh
 Edits from Don

 Revision 1.55  2005/07/27 02:47:41  sboag
 Added a validate of the unassembled doc for target xquery.html, as a sanity check,
 Removed <nt> brackets around QName and NCName, since the don't work and
 I'm not sure how to fix them, of if they should be fixed, at the moment, and
 added xpath- prefix to to id's that were xpath only, but had xquery equivelents
 elsewhere (escapeQuot and escapeAPos).

 Revision 1.54  2005/07/10 07:13:41  sboag
 July 10 draft.

 Revision 1.52  2005/07/08 16:53:30  sboag
 Don's latest edits.  See changes.txt for details.

 Revision 1.51  2005/03/28 14:16:14  NormanWalsh
 Updates from DC

 Revision 1.42  2004/10/26 17:23:48  NormanWalsh
 Pubrules tweaks

 Revision 1.41  2004/10/18 14:56:39  sboag
 Don's checkin.  See changes.txt (1.5) for this checkin for more info.

 Revision 1.40  2004/07/14 21:02:20  NormanWalsh
 Updated function/datatype namespaces; tweaked status; 23 July draft, pubrules clean

 Revision 1.39  2004/07/13 12:20:39  NormanWalsh
 Log update, I think. Not signficant anyway.

 Revision 1.35  2004/06/07 08:27:13  sboag
 Change of Validation stuff, according to request note from Don.

 Revision 1.33  2004/05/31 18:32:21  sboag
 Latest grammar changes, part of last call comments response.  (Sorry for lack
 of fine-grained detail, but CVS has been down for a week.)  The EBNF is a proposal,
 with change markings.

 Revision 1.31  2004/05/14 20:15:52  sboag
 Latest integration effort between Don and Scott.

 Revision 1.27  2003/12/05 01:04:09  sboag
 Change name of Predicates production to PredicateList.  Approved at Oracle F2F, 11/5/03

 Revision 1.26  2003/12/04 21:54:00  sboag
 Global search-replace: DC requests to change the production-names of
 SchemaMode and SchemaContext to ValidationMode and ValidationContext, to more closely match the explanatory text. Editorial change only. Names of other related productions (SchemaContextLoc etc.) remain unchanged.

 Revision 1.25  2003/12/04 16:45:21  sboag
 Change FilterStep to FilterExpr as per http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Nov/0014.html

 Revision 1.24  2003/11/07 01:58:07  NormanWalsh
 Added xpath-dt-static-typing-feature link

 Revision 1.23  2003/11/04 19:23:32  NormanWalsh
 Added required class attributes; added new informative bibl entries

 Revision 1.22  2003/10/30 04:25:50  sboag
 Changed ComputedXMLComment to CompXMLComment, as per http://lists.w3.org/Archives/Public/public-qt-comments/2003Oct/0056.html (editorial discretion taken)

 Revision 1.21  2003/10/28 19:29:20  NormanWalsh
 Tweaked document order per Jeni

 Revision 1.20  2003/10/28 19:25:16  NormanWalsh
 Ran through crlf to get rid of DOS line breaks...sigh.

 Revision 1.19  2003/10/28 13:55:28  NormanWalsh
 Final edits from Don

 Revision 1.16  2003/08/27 01:52:17  sboag
 Fed through dos2unix, to clean up extra CRs.

 Revision 1.15  2003/08/13 18:31:47  NormanWalsh
 Updates from Don on 7 Aug

 Revision 1.13  2003/07/31 18:09:48  sboag
 Don's latest edits, along with the module namespace changed originally outlined in http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0218.html, and approved by XQuery July 30.

 Revision 1.12  2003/07/22 17:59:09  sboag
 Reduce production names to max 20:
 Original Name	Len	New Name	Len
 MustUnderstandExtension	23	MUExtension	11
 QuoteAttributeContentChar	25	QuotAttrContentChar	18
 AposAttributeContentChar	24	AposAttrContentChar	18
 AbbreviatedForwardStep	22	AbbrevForwardStep	17
 AbbreviatedReverseStep	22	AbbrevReverseStep	17
 ComputedDocumentConstructor	27	CompDocConstructor	18
 ComputedElementConstructor	26	CompElemConstructor	19
 ComputedAttributeConstructor	28	CompAttrConstructor	19
 ComputedNamespaceConstructor	28	LocalNamespaceDecl	17
 ComputedXmlProcessingInstruction	32	CompPIConstructor	9
 ComputedTextConstructor	23	CompTextConstructor	19
 XmlProcessingInstruction	24	DirPIConstructor	5
 QuoteAttributeValueContent	26	QuotAttrValueContent	20
 AposAttributeValueContent	25	AposAttrValueContent	20
 ProcessingInstructionTest	25	PITest	6
 SchemaContextLocation	21	SchemaContextLoc	16
 
 Revision 1.11  2003/07/22 14:26:31  sboag
 Latest edits from Don.  Pre production name reduction.

 Revision 1.10  2003/07/08 15:59:35  sboag
 Fixed 2 obvious expression bugs.

 Revision 1.9  2003/07/01 15:21:19  sboag
 Fixed validation, which includes fixing LF problems, termref/termdef attribute mess, and nt fixes.  (stylesheet fix needs to come with this).

 Revision 1.8  2003/06/30 16:18:23  sboag
 Fix double-dash problems inside comments that Mary entered.

 Revision 1.7  2003/06/26 02:37:00  mfernand

 June 25, 2003 - Mary

 Changes to documents:
 =========================
   Modified files:
     lang/XPathXQuery.xml
     lang/expressions.xml
     lang/introduction.xml
     lang/query-prolog.xml
     lang/shared.html
     lang/xquery.html
     lang/xpath.html

   Added file:
     lang/errors.xml

   o Added markup for error definitions and references in all sections.

     - Error definitions are in new file: lang/errors.xml.

   o Added term definitions and references.

     - Additions required some minor editing to sentences/paragraphs so
       that term definitions were self-contained in Glossary.

     - All term definitions in Secs 1 & 2 should be complete.

       Exceptions: definitions of "Optional Features" are not pithy, thus
       not amenable to definition in a glossary.

     - All references in Secs 1 - 4 to terms defined in Secs 1 and 2
       are marked-up.

     - A smattering of term definitions in Secs 3 & 4 are done.
       Whomever continues with term markup should begin here.

     NB: I did not add any new term definitions - - I simply converted as
     many <term> elements as possible to <termdef>s or <termref>s.
     I did not change any term definitions other than to make them
     self-contained.

 Known styling problems (need help from Norm):
 =============================
   o Need to add "spec" attribute to <termdef> to scope term
     definitions within a particular document (e.g., "XP" or "XQ")

     - Current bug: terms that should only be defined in XQuery book
       also appear in XPath book.

   o Glossary should probably be emitted in alphabetic order.

   o Not sure what to do about errors of this kind:

     "style/issues-spec.xsl:248:20: Warning! Cannot point to resolved
     issue: #xquery-abstract-syntax"

 Issues/Questions:
 =============================
   o Should Glossary be labeled as normative?

   o Should Summary of Error Codes be labeled as normative?

 Revision 1.6  2003/06/12 22:31:50  jrobie

 Made the documents consistent with the following grammar changes:

 (a) Use "declare" consistently in prolog (replacing "define") and get
 rid of all uses of "=" except between prefix and URI. See Issue
 547. Changed terminology accordingly - "function definitions" are now
 "function declarations", "user-defined functions" are now
 "user-declared functions", etc.


 (b) Limit comments, pragmas, and extensions to places inside XQuery
 expressions where insignificant whitespace is allowed. See Issue 550.

 (c) Change if-expr so both then-clause and else-clause take ExprSingle,
 not Expr. See Query/May/0006.

 (d) New clause in Prolog: "declare" "base-uri" StringLiteral
 Scope is the module in which it is declared. Proposed by M. Rys in
 Query/Apr/0001 and adopted by Query WG telcon, 5/7/03.


 (h) Change "." to be a primary expr rather than an abbreviated step.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0200.html.

 (i) Change to PITest so it allows an NCName as well as a
 StringLiteral, as proposed by JR.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0256.html.

 (16) Change to Prolog syntax: function declarations can now be mixed
 with variable and other declarations. Approved, Query WG F2F, 5/16/03.

 Revision 1.5  2003/06/10 20:53:47  jrobie
 Processing model diagrams.

 Revision 1.4  2003/06/10 20:48:09  jrobie
 *** empty log message ***

 Revision 1.3  2003/04/18 22:01:52  NormanWalsh
 Editorial nits for pubrules

 Revision 1.2  2003/04/18 19:22:04  sboag
 Don's latest revisions, responding to comments from the working groups.

 Revision 1.1  2003/04/07 22:18:05  sboag
 Initial checkin of language build and parser build.

 Revision 1.29  2002/11/07 21:45:36  sboag
 Integrated new XSL from http://www.w3.org/2002/xmlspec/html/1.4/xmlspec.xsl,
 Fixed a couple minor bugs that this helpful stylesheet flagged.

 Revision 1.28  2002/11/07 19:30:56  sboag
 changed to 2.2 xmlspec, and deleted all xmlspec-v21.xxx.  Fixed BNF
 problem with OcurrenceIndicator.  Fixed prevdoc problem.

 Revision 1.27  2002/11/07 00:27:14  sboag
 Minor changes specified by today's editorial meeting, dictated by Don to me over the phone.

 Revision 1.24  2002/11/05 16:18:45  sboag
 Minor parse test fixes.

 Revision 1.23  2002/11/05 16:13:01  sboag
 Don's final Nov. 15 drafts.

 Revision 1.20  2002/08/14 16:06:35  sboag
 Fixed up example URLs to use example.org.

 Revision 1.18  2002/08/12 03:02:22  sboag
 Fixed problems with comments from previous check-in.

 Revision 1.17  2002/08/12 02:40:48  sboag
 Check for role="parse-test" for all legitimate expression examples.  ***status: Did the best I could with <code> and <eg> examples.
 -> fixed discovered bug in grammar where document {...} constructor did not work.
 -> fixed bug with processing instruction content... I had to add a PROCESSING_INSTRUCTION_CONTENT state.
 -> fixed minor bug with end tag not being closed in expressions.xml (ugh, took me 30 minutes to track down).
 -> in section on "Other Constructors", broke samples into separate <eg>s, so they will parse (otherwise they expect an operator between them).
 -> fixed problem with CDataSection outside of element content.  (...if PI, XMLComments work, so should CDataSection, I guess).
 -> broke some/every examples in section on "Quantified Expressions" into two <eg> tags, since they can process sequentially.
      -> Also had to conditionalize these examples for XPath, so that the TypeDeclaration wasn't
           used (actually, it seems useless here).
 -> Fixed many problems with "validate".  However, see note on '"validate" seems to be reserved'.  Two of the fragments currently won't parse.

 Revision 1.15  2002/08/10 22:01:47  sboag
 Changed "default collation at" to "default collation ="

 Revision 1.14  2002/08/04 21:06:21  sboag
 The following changes from the last F2F:

 (1) Delete "precedes" and "follows" operators from OrderComp.

 (2) Change name of TypeAssertion production to TypeDeclaration.

 (3) Add the following new production:

 DefaultCollationDecl ::= "default" "collation" StringLiteral

 (A collation is identified by a URI, so you can use a more specific symbol in place of StringLiteral that indicates that a URI is expected, if you want to.)

 (4) Delete the production for ResultTypeDecl.

 (5) QueryProlog should now include DefaultCollationDecl but not ResultTypeDecl, as follows:

 QueryProlog ::= (NamespaceDecl | DefaultNamespaceDecl | SchemaImport | XMLSpaceDecl
    | DefaultCollationDecl)* FunctionDefn*

 Revision 1.13  2002/07/28 19:53:05  sboag
 Don's new documents.

 Revision 1.12  2002/07/04 18:29:22  sboag
 Simply made prerecap ref refer to itself.  This was a regression, because at one
 point I had deleted this production.

 Revision 1.11  2002/06/28 09:02:07  sboag
 Merged Don's latest work with new grammar proposal.  Changes too numerous
 to detail.

 Revision 1.10  2002/04/24 22:48:30  sboag
 Fixed minor problem with lists-within-lists-within-paragraphs.

 Revision 1.9  2002/04/24 22:21:18  sboag
 Don's changes assigned to him by this morning's telcon.

 Revision 1.8  2002/04/24 02:48:08  sboag
 CSS, HTML, Link validation passes.  Parser tests pass.  Updated to target
 pub date of April 30.

 Revision 1.6  2002/04/23 17:20:33  sboag
 Removed DocumentElement from production 61, as per WG decision.
 Fixed Dana's company and email address.
 Added section on reserved words (list is mechanically generated).
 Addressed the following issues in the lexical section from
 (http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Jan/0002.html),
 lengthy Michael Dyck.  Not all issues have been addressed yet.
 <item priority="2" status="done"> <description>para 1: "Whitespace may be
 		  freely added within patterns" What do you mean by "patterns"? Presumably,
 		  you're either talking about adding the symbol 'Whitespace' to grammar
 		  productions, or adding whitespace (i.e., sequences of characters) to queries.
 		  Don't confuse the two.</description></item>
 <item priority="2" status="done"> <description>"before or after any
 		  token" But you never actually define what a token is. It's not even clear what
 		  the set of token-types is. (Is it the set of left-hand-sides of producbtions 75
 		  through 216? Is it the set of symbols that appear in the "tokens" column of the
 		  TRANITION STATES table? The two are different, and both contain symbols that
 		  probably shouldn't be considered token-types.)</description></item>
 <item status="done"> <description>para 1 and bullets 1 and 2: Note that
 		  the Whitespace symbol derives the empty string, but phrases like "must always
 		  be followed by whitespace" and "whitespace may not occur" obviously mean
 		  "whitespace" in the sense of "a non-empty string of whitespace-characters". I
 		  think this shows correct usage, and there's no reason for Whitespace to be
 		  nullable. (That is, it should be the same as S.)</description></item>
 <item status="done"> <description>bullet 3: "A space" We're interested in
 		  whitespace, not just a space.</description></item>
 <item status="done"> <description>"may be significant" Don't tell us that
 		  it *may* be significant. Tell us exactly when it *is*
 		  significant.</description></item>
 <item status="done"> <description>para 2: "Tokens may be often only
 		  recognized" "may be often only" is clunky.</description></item>
 <item status="done"> <description>"in a specific state" You haven't
 		  defined states yet.</description></item>
 <item status="done"> <description>"within the evaluation": Does
 		  evaluation of a query include its parsing/lexing?</description></item>
 <item status="done"> <description>"may cause the grammar to transition to
 		  a different state" Grammars don't have states or transitions. Automata
 		  do.</description></item>
 <item status="done"> <description>"following the enumeration of tokens"
 		  Change "tokens" to "token-types".</description></item>
 <item status="done"> <description>para 3: "When tokenizing, the longest
 		  possible token is always returned" Issue 109 says this means "the longest
 		  sequence that would form a token in the token-space of the grammar, not the
 		  longest that would be valid in the current syntactic context." Does
 		  it?</description></item>
 <item status="done"> <description>"If there is an ambiguity between two
 		  tokens, ..." Presumably, you mean an ambiguity that isn't resolved by the
 		  longest-match rule.</description></item>
 <item status="done"> <description>"the token that an lower grammar
 		  number" Change "an" to "a".</description></item>
 <item status="done"> <description>is more specific than" Why do we care
 		  which is "more specific"? We want to know which is the right one. I'll assume
 		  that's what you mean.</description></item>

 Revision 1.5  2002/04/22 15:23:24  sboag
 Don says: I believe that these drafts contain all the substantive comments
 that were raised at the Cambridge task force meetings and subsequent
 telcons. These are the drafts that will be reviewed for publication. Additional
 minor editorial changes may be made before the documents are actually
 submitted to w3c.

 Revision 1.1  2002/04/01 20:10:30  sboag
 Jonathan Robie changes, including removal of fragment.xml and inclusion of
 expressions.xml, etc.
 Merge of his grammar with latest.


 Revision 1.42  2001/12/17 20:27:29  sboag
 Fixes for every-header-has-to-have-an-id.

 Revision 1.41  2001/12/16 06:31:59  sboag
 Minor fix to the comment ednote.

 Revision 1.37  2001/12/14 20:47:43  sboag
 Fixed some bad links.

 Revision 1.36  2001/12/14 17:21:26  sboag
 Fixed link.

 Revision 1.28  2001/12/11 17:09:44  sboag
 Don's suggested modifications to the grammar.  Also temporarily commented
 out the pathx1 build, 'till I get it fixed.

 Revision 1.27  2001/12/10 02:45:49  sboag
 Fixed some of the code examples that read <p><code>some example</code></p>.

 Revision 1.25  2001/12/09 22:07:16  sboag
 Fixed problem with comments from previous checkin.

 Revision 1.24  2001/12/09 21:39:37  sboag
 [batch checkin] Added {- - comment - -} type comments.  Added ";" list 
 query processing.  Added some stuff for ^char handling in reg 
 expressions, in order to support CharData better, but backed 
 out of this (but left some of the support in.  Removed old type def 
 and group stuff (can look to previous versions if we want to add this 
 back in).  Changed to case sensitivity in grammar, and updated 
 fragment.xml.  Added optional (AT schemaLocation)? to SchemaImport.  
 Other minor changes in support of WG decisions.

 Revision 1.23  2001/12/08 15:15:25  sboag
 Jonathan and Scott tweaked paragraph about QName escape.

 Revision 1.22  2001/12/07 23:34:28  sboag
 Add note about escaping QNames in the Basics section, pending resolution
 of the issue about what to do about possible EQName token.  Don needs to review.
 Removed paragraph again about enclosed expressions in element constructors. 

 Revision 1.20  2001/12/07 08:55:45  sboag
 Made rule about space before "<" be xquery spec only.

 Revision 1.19  2001/12/07 08:29:26  sboag
 Added ednote about space before "<" rule.

 Revision 1.18  2001/12/07 08:19:17  sboag
 Add <{foo}/> syntax, as per direction of XQuery WG.  Need to check about the
 enclosed expression syntax for attribute names, which I also added.

 Revision 1.17  2001/12/07 07:36:15  sboag
 Fix data-type section for XPath (remove Typeswitch, CaseClause).

 Revision 1.16  2001/12/07 07:06:38  sboag
 Changed BuiltInType to SimpleType in grammar and text.
 Removed Remove *:*.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral.
 Took a shot at fixing the "-" lexical rule in arithmatic section.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral. 

==================================================================== 
-->
<!-- 

float*date

send a value to a function that is expecting a node

"make a list of the errors that can be determined statically"

-->
<div1 id="id-basics">
  <head>基本事項</head> 
	 <p>XQueryの基本的な構成ブロックは<term>式</term>である。これは<bibref ref="Unicode"/>文字(使用されるUnicodeの版は<termref def="dt-implementation-defined">実装定義</termref>である。)の列である。この言語には、キーワード、記号、演算数などから構成される様々な種類の式が用意されている。一般的に、式の演算数は別の式である。XQueryでは、式は完全に一般的な入れ子であってもよい。<phrase role="xquery">(しかし、純粋な関数型言語とは異なり、変数の定義が新しい節点の構成からなっているならば、その変数への代入は許されない。)</phrase></p>
	 <note><p>この仕様書では、<bibref ref="Unicode"/>文字の文字列の文字符号化方式に関して、何も仮定しないし、何も要求しない。</p></note><p>XMLと同様に、XQueryは大文字小文字を区別する言語である。XQueryのキーワードは小文字を用い、かつ予約されていない。すなわち、XQuery式に出現する名前はXQuery言語のキーワードと同じであってもよい。ただし<specref ref="id-reserved-fn-names"/>に挙げられている接頭語なし関数名を除く。</p> 
	  
	 <p><termdef term="value" id="dt-value"><termref def="dt-datamodel">データモデル</termref>では、<term>値</term>は常に<termref def="dt-sequence">列</termref>である。</termdef> <termdef id="dt-sequence" term="sequence">
<term>列</term>は0個以上の<termref def="dt-item">項目</termref>の順序付きコレクションである。</termdef>
<termdef id="dt-item" term="item">
	 <term>項目</term>は<termref def="dt-atomic-value">原子値</termref>か<termref def="dt-node">節点</termref>である。</termdef>
<termdef id="dt-atomic-value" term="atomic value"><term>原子値</term>は<bibref ref="XMLSchema"/>で定義される<term>原子型</term>の値空間に含まれる値である。</termdef>
<termdef id="dt-node" term="node"><term>節点</term>は<bibref ref="datamodel"/>で定義されている<term>節点の種類</term>のいずれかのインスタンスである。</termdef>
各節点は唯一の<term>節点識別性</term>、1つの<term>型付けされた値</term>、そして1つの<term>文字列値</term>を持つ。これに加え、いくつかの節点は<term>名前</term>を持つ。節点の<term>型付けされた値</term>は0個以上の原子値からなる列である。節点の<term>文字列値</term>は<code>xs:string</code>型の値である。節点の<term>名前</term>は<code>xs:QName</code>型の値である。</p> 
	 <p><termdef id="dt-singleton" term="singleton">ただ一つの項目しか含まない列を<term>単一値列</term>という。</termdef>項目は、その項目を含む単一値列と同一である。列が入れ子になることは決してない。例えば1, (2, 3), () という値を一つの列に結合した結果は (1, 2, 3)になる。<termdef id="dt-empty-sequence" term="empty sequence">0個の項目を含む列を<term>空列</term>という。</termdef></p>
	  <p><termdef id="dt-data-model-instance" term="XDM instance"><term>XDMインスタンス</term>という用語は<term>値</term>という用語と同義であり、<termref def="dt-datamodel">データモデル</termref>中の<termref def="dt-node">節点</termref>や<termref def="dt-atomic-value">原子値</termref>からなる制約なしの列を表す。</termdef> </p>
	  <p>XQueryにおける名前は<term>QName</term>と呼ばれ、<bibref ref="XMLNAMES"/>中の文法に従う。<termdef id="dt-qname" term="QName">字句としては、<term>QName</term>は、省略可能な名前空間接頭辞1つと局所名1つからなる。名前空間接頭辞があるなら、局所名と名前空間接頭辞はコロンで区切られる。</termdef> 字句としてのQNameは、<termref def="dt-static-namespaces">静的既知名前空間</termref><errorref code="0081" class="ST"/>を用いて名前空間接頭辞を名前空間URIに解決することにより、<term>展開済QName</term>に変換することができる。 <termdef id="dt-expanded-qname" term="expanded QName"><term>展開済QName</term>は、省略可能な名前空間URIと局所名からなる。また展開済QNameは、元の名前空間接頭辞を(もしあるなら)保存し、展開済QNameを文字列に型変換することを可能とする。</termdef>名前空間URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>のためのルールに従って、空白に関して正規化される。2つの展開済QNameが等しいとは、それらの名前空間URIが等しく、かつそれらの局所名が等しいときである(それらの名前空間接頭辞が等しくなくてもよい)。名前空間URIと局所名はコード位置に基づいて比較され、それ以上の正規化は行われない。</p>
<p role="xquery">ある名前空間接頭辞は XQuery であらかじめ宣言されており、固定された名前空間URIに束縛されている。これらの名前空間接頭辞は以下の通りである。</p>
	  <p/>
	  <ulist>
<item role="xquery"><p><code>xml = http://www.w3.org/XML/1998/namespace</code></p></item>
<item><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></item>
<item role="xquery"><p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p></item>
<item><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></item>

<item role="xquery"><p><code>local = http://www.w3.org/2005/xquery-local-functions</code> (<specref ref="FunctionDeclns"/>を見よ。)</p></item>
</ulist>
<p role="xquery">上のリスト中の接頭辞に加え、この文書では接頭辞<code>err</code>を名前空間URI<code>http://www.w3.org/2005/xqt-errors</code>を表すものとして用いる (<specref ref="id-identifying-errors"/>を見よ)。この名前空間接頭辞はあらかじめ宣言されてはおらず、この文書中での使用は参考である。</p>
	 <p>要素節点は<term>有効範囲内名前空間</term>と呼ばれる性質を持つ。<termdef term="in-scope namespaces" id="dt-in-scope-namespaces">要素節点の<term>有効範囲内名前空間</term>性質は、<term>名前空間束縛</term>の集合である。それぞれの名前空間束縛は名前空間接頭辞とURIを関連づけており、したがって有効範囲内名前空間は、その要素の有効範囲内でQNameを解釈するときに用いることのできる名前空間接頭辞の集合を定義する。ある要素が与えられると、名前空間束縛のうち1つは空の接頭辞を持っていてもよい。この名前空間束縛のURIは、その要素の有効範囲におけるデフォルト名前空間である。</termdef></p>
<note role="xquery"><p><bibref ref="XPath"/>では、ある要素節点の有効範囲内名前空間は<term>名前空間軸</term>上に置かれた<term>名前空間節点</term>のコレクションとして表現される。<bibref ref="XPath20"/>では、これは省略可能であり、推奨されない。XQueryは名前空間軸を支援せず、名前空間の束縛を節点の形式で表現することはない。しかし、<bibref ref="serialization"/>のように別の仕様書が名前空間節点を参照している場合には、これらの節点が要素節点の有効範囲内名前空間から合成される。これは、それぞれの名前空間束縛を名前空間節点と解釈することで行われる。</p></note>
	 
<p><termdef term="URI" id="dt-URI">この仕様書では、<term>URI</term>という用語は、<bibref ref="RFC3986"/>で定義され<bibref ref="RFC3987"/>で新しい名前<term>IRI</term>として拡張されたUniversal Resource Identifierを表す。</termdef> ただし、IRIよりもURIという用語を好んで残している。"Base URI"のように、すべてのXML関連の仕様書で定義され、また参照されてきた概念に新しい名前を与えることを避けるためである。</p>
	 <div2 id="context"> 
	   <head>式文脈</head>
	   <p>
	     <termdef id="dt-expression-context" term="expression context">ある式に対する<term>式文脈</term>は、その式の結果に影響を与えうるすべての情報からなる。</termdef> この情報は<termref def="dt-static-context">静的文脈</termref>と<termref def="dt-dynamic-context">動的文脈</termref>という2種類に分けられる。</p>
		 
		<div3 id="static_context"> 
		  <head>静的文脈</head> 
		  <p><termdef id="dt-static-context" term="static context">式の<term>静的文脈</term>は、その式の評価よりも静的解析において有効である情報である。</termdef> この情報は、式が<termref def="dt-static-error">静的エラー</termref>を含むかどうか決定するのに用いることができる。もし式の解析が、<termref def="dt-static-context">静的文脈</termref>中の値を割り当てられていない構成要素に依存するならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref code="0001" class="ST"/>。</p> 
		  <p><termref def="dt-static-context">静的文脈</termref>の構成要素を以下にまとめる。<phrase role="xquery">有効範囲を管理したり、これらの構成要素を初期化するルールは、<specref ref="id-xq-static-context-components" role="xquery"/>にある。</phrase> </p>
		   
		  <ulist> 
		    <item><p><termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode"><term>XPath 1.0互換モード</term>。<phrase role="xquery">この構成要素は、XPath 2.0 を部分集合として含むようなすべてのホスト言語で設定されなければならない。この構成要素により、XPath 1.0 との互換性のためのルールが有効であるかどうかを示す。XQuery では、この構成要素の値を<code>false</code>に設定している。</phrase></termdef></p></item> 
			 <item> 
				<p><termdef id="dt-static-namespaces" term="statically known namespaces"><term>静的既知名前空間</term>。これは、組(接頭辞, URI)の集合であり、与えられた式の静的処理の間分かっているすべての名前空間を定義している。</termdef> URIの値は<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>と<termref def="dt-static-namespaces">静的既知名前空間</termref>の違いに注意せよ。前者は要素節点の動的性質であり、後者は式の静的性質である。</p>
<p role="xquery">いくつかの名前空間はあらかじめ定義されている。付加的な名前空間を静的既知名前空間に加えることができる。これは、<termref def="dt-prolog">前書き</termref>中の<termref def="dt-namespace-declaration">名前空間宣言</termref>による方法や、<termref def="dt-direct-elem-const">直接要素構成子</termref>中の<termref def="dt-namespace-decl-attr">名前空間定義属性</termref>による方法がある。</p>
			 </item> 
			 <item> 
				<p><termdef id="dt-def-elemtype-ns" term="default element/type namespace"><term>デフォルト要素/型名前空間</term>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち要素や型名が期待される場所に出現するもののために用いられる。</termdef> URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			 </item> 
			 <item> 
				<p><termdef id="dt-def-fn-ns" term="default function namespace"><term>デフォルト関数名前空間</term>。これは名前空間URIか"none"である。名前空間URIは、もしあれば、接頭辞のないQNameのうち関数名が期待される場所に出現するもののために用いられる。</termdef> URIの値は、<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			  </item> 
			 <item> 
				<p><termdef id="dt-issd" term="in-scope schema definitions"><term>有効範囲内スキーマ定義</term>。これは、式の処理の間有効範囲内にあるすべての要素定義、属性定義、およびスキーマ定義を表す総称的用語である。</termdef> 次の3つの部分を含む。</p><ulist><item><p>

			        <termdef id="dt-is-types" term="in-scope schema type"><term>有効範囲内スキーマ型</term>。各スキーマ型定義は、 <termref def="dt-expanded-qname">展開済QName</termref> (<term>名前付けされた型</term>に対して) か<termref def="dt-implementation-dependent">実装依存</termref>の型識別子 (<term>無名型</term>に対して)のいずれかで識別される。有効範囲内スキーマ型は<specref ref="id-predefined-types"/>で述べられる既定義スキーマ型を含む。

<phrase role="xquery">もし<termref def="dt-schema-import-feature">スキーマ輸入機能</termref>が支援されていれば、有効範囲内スキーマ型には、輸入されたスキーマ中にある型定義がすべて含まれる。</phrase>

                         </termdef></p>

</item>


<item><p><termdef id="dt-is-elems" term="in-scope element declarations"><term>有効範囲内要素定義</term>。各要素定義は、<termref def="dt-expanded-qname">展開済QName</termref> (最上位要素定義に対して)か<termref def="dt-implementation-dependent">実装依存</termref>の要素識別子 (局所要素定義に対して)のいずれかで識別される。<phrase role="xquery">もし<termref def="dt-schema-import-feature">スキーマ輸入機能</termref>が支援されていれば、有効範囲内要素定義には、輸入されたスキーマ定義中にある要素定義がすべて含まれる。</phrase></termdef> 要素定義は、その要素の<termref def="dt-substitution-group">置換グループ</termref>の加入に関する情報を含む。</p>
<p><termdef term="substitution group" id="dt-substitution-group"><term>置換グループ</term>は<bibref ref="XMLSchema"/>第1部, 2.2.2.2節で定義されている。直観的には、与えられた要素(<term>先導要素</term>という)を先頭とする置換グループは、スキーマ妥当性検証の結果に影響を与えることなく先導要素に対して置換することのできる要素集合からなる。</termdef></p></item>

<item><p><termdef id="dt-is-attrs" term="in-scope attribute declarations"><term>有効範囲内属性定義</term> 各属性定義は<termref def="dt-expanded-qname">展開済QName</termref> (最上位属性定義に対して) か<termref def="dt-implementation-dependent">実装依存</termref>の属性識別子 (局所属性定義に対して)のいずれかで識別される。<phrase role="xquery">もし<termref def="dt-schema-import-feature">スキーマ輸入機能</termref>が支援されていれば、有効範囲内属性定義には、輸入されたスキーマ中にある属性定義がすべて含まれる。</phrase></termdef></p></item></ulist></item>
<item> <p> <termdef id="dt-in-scope-variables" term="in-scope variables"><term>有効範囲内変数</term>。これは組 (展開済QName, 型) の集合であり、式中で参照可能な変数の集合を定義する。<termref def="dt-expanded-qname">展開済QName</termref>は変数名、型はその変数の<termref def="dt-static-type">静的型</termref>である。</termdef></p>
<p><phrase role="xquery"><termref def="dt-prolog">前書き</termref>中の変数定義は<termref def="dt-in-scope-variables">有効範囲内変数</termref>に加えられる。</phrase> 変数を束縛する式 (<phrase role="xquery"><code>let</code>式, </phrase><code>for</code>式, <code>some</code>式, <code>every</code>式など)は、その式の部分式の<termref def="dt-in-scope-variables">有効範囲内変数</termref>を新しく束縛された変数とその型によって拡張する。<phrase role="xquery"><term>関数定義</term>中では、<termref def="dt-in-scope-variables">有効範囲内変数</termref>は<term>関数の引数</term>の名前と型によって拡張される。</phrase></p>
<p role="xquery">変数の静的型は、問合せ内で宣言されていてもよいし、(<termref def="dt-static-typing-feature">静的型付け機能</termref>が有効になっているなら) <bibref ref="XQueryFormalSemantics"/>で記述されている静的型推論ルールによって推論されてもよい。</p>
			 </item><item><p><termdef term="context item static type" id="dt-context-item-static-type"><term>文脈項目の静的型</term>。この構成要素は、与えられた式の有効範囲内における、その文脈項目の<termref def="dt-static-type">静的型</termref>を定義する。</termdef></p></item> 
			 <item> 
				<p><termdef id="dt-function-signature" term="function signature"><term>関数のシグネチャ</term>。この構成要素は、式中で呼び出し可能な関数の集合を定義する。関数はそれぞれ、その<termref def="dt-expanded-qname">展開済QName</termref>と次数 (引数の数) によって一意に識別される。</termdef> 名前と次数に加え、関数のシグネチャはそれぞれ、その関数の引数と結果の<termref def="dt-static-type">静的型</termref>を指定する。</p>

                         <p><termref def="dt-function-signature">関数のシグネチャ</termref>は、<termref def="dt-constructor-function">構成子関数</termref>のシグネチャを含む。これについては<specref ref="id-constructor-functions"/>で議論する。</p>

			 </item> 
			 <item> 
				<p> <termdef id="dt-static-collations" term="statically known collations"><term>静的既知照合順序</term>。これは組 (URI, 照合順序)の<termref def="dt-implementation-defined">実装定義</termref>の集合である。<phrase role="xquery">問合せや</phrase>式の処理に用いることのできる照合順序の名前を定義する。</termdef> <termdef term="collation" id="dt-collation"><term>照合順序</term>は、文字列とURIを比較し、その延長として、順序づける方法の仕様である。照合順序のより完全な定義については<bibref ref="FunctionsAndOperators"/>を見よ。</termdef></p> 
			 </item> 
			 <item> 

				<p> <termdef id="dt-def-collation" term="default collation"><term>デフォルト照合順序</term>。これは、明示的に照合順序が指定されていないときに、<termref def="dt-static-collations">静的既知照合順序</termref>に含まれる照合順序の一つを、<code>xs:string</code>型と<code>xs:anyURI</code>型 (およびこれらから導出される型) の値を比較したり順序付けしたりする関数や演算子で用いられる照合順序として識別する。</termdef></p>

			 </item> 
<item role="xquery"><p><termdef id="dt-construction-mode" term="construction mode"><term>構成モード</term>。 構成モードは、要素や文書節点の構成子の振舞いを決定する。構成モードが<code>preserve</code>であれば、構成された要素節点の型は<code>xs:anyType</code>であり、節点構成において複製された属性節点や要素節点はすべて、元の型を保存する。構成モードが<code>strip</code>であれば、構成された要素節点の型は<code>xs:untyped</code>であり、節点構成において複製された要素節点はすべて型<code>xs:untyped</code>を受け取り、節点構成において複製された属性節点はすべて型<code>xs:untypedAtomic</code>を受け取る。</termdef></p></item>
<item role="xquery"><p><termdef id="dt-ordering-mode" term="ordering mode"><term>順序付けモード</term>。 順序付けモードは<code>ordered</code>か<code>unordered</code>という値を取り、ある種の<termref def="dt-path-expression">経路式</termref>, <code>union</code>式, <code>intersect</code>式, <code>except</code>式, <code>order by</code>節を持たないFLWOR式などによって生成される結果列の順序付けに影響を与える。</termdef> 詳細は、これらの式の記述の中で与える。</p></item>
<item role="xquery"><p><termdef id="dt-default-empty-order" term="default order for empty sequences"><term>空列のデフォルト順序</term>。 この構成要素は、FLWOR式中の<code>order by</code>節中の順序付けキーとしての空列や値<code>NaN</code>の処理を制御する。これについての記述は<specref ref="id-orderby-return"/>にある。</termdef>  この値は<code>greatest</code>または<code>least</code>であってもよい。</p></item>
<item role="xquery">
<p><termdef id="dt-boundary-space-policy" term="boundary-space policy"><term>境界空白ポリシー</term>。この構成要素は、<termref def="dt-direct-elem-const">直接要素構成子</termref>による<termref def="dt-boundary-whitespace">境界空白</termref>の処理を制御する。これについての記述は<specref ref="id-whitespace"/>にある。</termdef> この値は<code>preserve</code>または<code>strip</code>であってもよい。</p></item>
<item role="xquery"><p><termdef id="dt-copy-namespaces-mode" term="copy-namespaces mode"><term>名前空間複製モード</term>。この構成要素は、すでにある要素節点が要素構成子によって複製されるときに割り当てられる名前空間束縛を制御する。これについての記述は<specref ref="id-element-constructor"/>にある。この値は2つの部分からなる: <code>preserve</code>または<code>no-preserve</code>、そして<code>inherit</code>または<code>no-inherit</code>である。</termdef></p></item>
			 <item> 
		<p><termdef id="dt-base-uri" term="base URI"><term>基底URI</term>。 これは絶対URIであり、 (例えば<code>fn:resolve-uri</code>関数によって)相対URIを解決するのに必要なときに用いられる。</termdef> URIの値は<bibref ref="XMLSchema"/>中の<code>xs:anyURI</code>型のためのルールに従って、空白に関して正規化される。</p> 
			 </item>
<item><p> <termdef id="dt-known-docs" term="statically known documents"><term>静的既知文書</term>。 これは文字列から型への写像である。文字列は資源の絶対URIを表しており、<code>fn:doc</code>関数を用いて得られる可能性がある。型は、与えられたURIをリテラル引数とする<code>fn:doc</code>呼び出しの<termref def="dt-static-type">静的型</termref>である。</termdef> 
<code>fn:doc</code>の引数が<term>静的既知文書</term>にはない文字列リテラルであるとき、<code>fn:doc</code>の<termref def="dt-static-type">静的型</termref>は<code>document-node()?</code>である。</p>
<note><p><term>静的既知文書</term>の目的は静的型情報を提供することであり、どの文書が利用可能かを決定することではない。URIが<term>静的既知文書</term>中になくても、<code>fn:doc</code>を用いてアクセスできる。</p></note>
</item>

<item><p><termdef id="dt-known-collections" term="statically known  collections"><term>静的既知コレクション</term>。これは文字列から型への写像である。文字列は資源の絶対URIであり、<code>fn:collection</code>関数を用いて得られる可能性がある。型は節点列型であり、このURIを引数として<code>fn:collection</code>関数を呼び出した結果となる。</termdef> <code>fn:collection</code>の引数が<term>静的既知コレクション</term>にない文字列リテラルであるとき、<code>fn:collection</code>の<termref def="dt-static-type">静的型</termref>は<code>node()*</code>である。</p>
<note><p><term>静的既知コレクション</term>の目的は静的型情報を提供することで、どのコレクションが利用可能かを決定することではない。URIが<term>静的既知コレクション</term>になくても、<code>fn:collection</code>を用いてアクセスできる。</p></note></item>

<item><p><termdef id="dt-known-default-collection" term="statically known default collection type"><term>静的既知デフォルトコレクション型</term>。これは節点列型であり、<code>fn:collection</code>関数を引数なしで呼び出した結果となる。</termdef> 実装によって他の値に初期化されない限り、<term>静的既知デフォルトコレクション型</term>の値は<code>node()*</code>である。</p></item>
</ulist> 


</div3>
<div3 id="eval_context"> <head>動的文脈</head> <p><termdef id="dt-dynamic-context" term="dynamic context">式の<term>動的文脈</term>は、その式が評価されているときに利用可能な情報として定義される。</termdef> 式の評価が<termref def="dt-dynamic-context">動的文脈</termref>のうち値が割り当てられていない部分に依存するとき、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0002"/>。</p>
<p><termref def="dt-dynamic-context">動的文脈</termref>の個々の構成要素を以下にまとめる。これらの構成要素の意味を支配する詳細なルールは<specref ref="id-xq-evaluation-context-components" role="xquery"/>にある。</p>
<p><termref def="dt-dynamic-context">動的文脈</termref>は<termref def="dt-static-context">静的文脈</termref>の部分要素すべて、および以下に列挙する追加構成要素を含む。</p>
<p><termdef id="dt-focus" term="focus"><termref def="dt-dynamic-context">動的文脈</termref>の最初の3つの構成要素 (文脈項目、文脈位置、文脈サイズ)を、式の<term>焦点</term>という。</termdef> 焦点を用いると、処理器はどの項目が式によって処理されているかを追跡することができる。</p>
<p>ある種の言語の構成要素、すなわち<termref def="dt-path-expression">経路式</termref> <code role="parse-test">E1/E2</code>と<termref def="dt-predicate">述語</termref> <code role="parse-test">E1[E2]</code>は、部分式の評価の際に新しい焦点を作成する。これらの構成要素では、<code role="parse-test">E1</code>を評価した結果の列中の項目それぞれに対し、<code role="parse-test">E2</code>が1回評価される。 <code role="parse-test">E2</code>が評価されるたびに、異なる焦点で評価が行われる。<code role="parse-test">E2</code>を評価する焦点を<term>内部焦点</term>、<code role="parse-test">E1</code>を評価する焦点を<term>外部焦点</term>という。内部焦点は、<code role="parse-test">E2</code>が評価されている間のみ存在する。この評価が終了するとき、含むほうの式の評価が元の焦点のまま行われる。</p>
<ulist>
  <item> <p><termdef id="dt-context-item" term="context item"><term>文脈項目</term>は現在処理している項目である。項目は原子値か節点である。</termdef><termdef id="dt-context-node" term="context node">文脈項目が節点であるとき、<term>文脈節点</term>と呼ぶこともできる。</termdef> 文脈項目は1つのドット(<code role="parse-test">.</code>)からなる式によって得られる。式<code role="parse-test">E1/E2</code>または<code role="parse-test">E1[E2]</code>が評価されるとき、<code role="parse-test">E1</code>を評価して得られる列中の項目それぞれが、<code role="parse-test">E2</code>の評価に対する内部焦点の文脈項目となる。</p> </item>
 <item> <p><termdef id="dt-context-position" term="context position"><term>文脈位置</term>は、現在処理されている項目列中での文脈項目の位置である。</termdef>文脈項目が変化するたび、文脈位置も変化する。焦点が定義されているとき、文脈位置の値は0より大きい整数である。式<code>fn:position()</code>によって文脈位置が返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点での文脈位置は、<code>E1</code>を評価して得られる列中の文脈項目の位置である。列の最初の項目の位置は常に1である。文脈位置は常に、文脈サイズより小さいか等しい。</p> </item>

<item><p><termdef id="dt-context-size" term="context size"><term>文脈サイズ</term>は、現在処理されている項目列に含まれる項目数である。</termdef> 文脈サイズの値は常に0より大きい整数である。式<code>fn:last()</code>によって文脈サイズが返される。式<code>E1/E2</code>または<code>E1[E2]</code>が評価されるとき、<code>E2</code>の評価に対する内部焦点の文脈サイズは、<code>E1</code>の評価で得られる列に含まれる項目数である。</p>
 </item>
			  
<item> 
<p> <termdef id="dt-variable-values" term="variable values"><term>変数の値</term>。これは、組 (展開済QName, 値)の集合である。式の<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-in-scope-variables">有効範囲内変数</termref>と同じ<termref def="dt-expanded-qname">展開済QName</termref>を含む。展開済QNameは変数名であり、値はその変数の動的値である。動的値には、その<termref def="dt-dynamic-type">動的型</termref>が含まれる。</termdef></p>
</item>
<item><p><termdef term="function implementation" id="dt-function-implementation"><term>関数の実装</term>。<termref def="dt-function-signature">関数のシグネチャ</termref>に含まれる各関数は、引数型のインスタンスから結果型のインスタンスへ写像する関数を利用可能にする関数の実装を持つ。<phrase role="xquery"><termref def="dt-udf">利用者定義関数</termref>については、関数の実装はXQuery式である。<termref def="dt-built-in-function">組み込み関数</termref>や<termref def="dt-external-function">外部関数</termref>については、関数の実装は<termref def="dt-implementation-dependent">実装依存</termref>である。</phrase></termdef></p></item>
<item> 
<p> <termdef id="dt-date-time" term="current dateTime"><term>現在のdateTime</term>。この情報は<phrase role="xquery">問合せ</phrase>の処理の間のある<termref def="dt-implementation-dependent">実装依存</termref>の瞬間を表す情報であり、明示的なタイムゾーンを含む。これは<code>fn:current-dateTime</code>関数によって検索することができる。もし<phrase role="xquery">問合せ</phrase>の実行の最中に複数回呼び出されると、この関数は常に同じ結果を返す。</termdef></p>
</item>
<item><p><termdef id="dt-timezone" term="implicit timezone"><term>暗黙タイムゾーン</term>。これは、タイムゾーンを持たない data, time, dateTimeなどの値が比較演算や算術演算の中で用いられるときに用いられるタイムゾーンである。暗黙タイムゾーンは<code>xs:dayTimeDuration</code>型の<termref def="dt-implementation-defined">実装定義</termref>の値である。タイムゾーンの正しい値の範囲については<bibref ref="XMLSchema"/>を見よ。</termdef></p></item>
<item><p><termdef id="dt-available-docs" term="available documents"><term>利用可能文書</term>。これは、文字列から文書節点への写像である。文字列は資源の絶対URIを表す。文書節点は、<termref def="dt-datamodel">データモデル</termref>を用いて資源を表現する木における根である。<code>fn:doc</code>関数をURIに適用すると、文書節点が返ってくる。</termdef> 利用可能文書の集合は<termref def="dt-known-docs">静的既知文書</termref>の集合に限定されず、また空集合でもよい。</p></item>
<item><p><termdef id="dt-available-collections" term="available collections"><term>利用可能コレクション</term>。これは、文字列から節点列への写像である。文字列は資源の絶対URIを表す。節点列は、そのURIを引数として与えたときの<code>fn:collection</code>関数の結果を表す。</termdef> 利用可能コレクションの集合は<termref def="dt-known-collections">静的既知コレクション</termref>の集合に限定されず、また空集合でもよい。</p></item>
<item><p><termdef id="dt-default-collection" term="default collection"><term>デフォルトコレクション</term>。これは、<code>fn:collection</code>関数を引数なしで呼び出したときに結果として得られる節点列である。</termdef> <term>デフォルトコレクション</term>の値は実装によって初期化されてもよい。</p></item>
</ulist> </div3> </div2>
<div2 id="id-processing-model">
<head>処理モデル</head>
<p>XQueryは<termref def="dt-datamodel">データモデル</termref>と<termref def="dt-expression-context">式文脈</termref>に基づいて定義される。</p>
<graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XQuery.gif" alt="Processing                          Model Overview" role="xquery" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>

<p>図1: 処理モデルの概要</p>

<p>図1は、この後詳細を述べる処理段階の概要を図で示したものである。このうちいくつかの段階は完全にXQueryの範疇外である。図1では、これらの段階は言語の境界を表す実線の外側、<term>外部処理</term>とラベル付けされた領域に描かれている。外部処理域には、問合せが行われるデータを表現する<termref def="dt-data-model-instance">XDMインスタンス</termref>の生成(<specref ref="id-data-model-generation"/>を見よ)、スキーマの輸入処理(<specref ref="id-schema-import-processing"/>を見よ)、直列化(<specref ref="id-serialization"/>を見よ)などが含まれる。言語の境界の内側は<phrase role="xquery"><term>問合せ処理域</term></phrase>と呼ばれ、静的解析段階と動的評価段階(<specref ref="id-expression-processing"/>を見よ)が含まれる。
<phrase role="xquery">問合せ</phrase>処理域上の無矛盾性制約は<specref ref="id-consistency-constraints"/>で定義される。</p>


<div3 id="id-data-model-generation"><head>データモデルの生成</head>

<p><phrase role="xquery">問合せ</phrase>が処理できるようになる前に、式の入力データが<termref def="dt-data-model-instance">XDMインスタンス</termref>として表現されなければならない。この処理はXQueryの範囲外で発生し、そのため図1ではこの処理を外部処理域に置いている。以下にXML文書を<termref def="dt-data-model-instance">XDMインスタンス</termref>に変換する段階を示す。</p>

<olist><item><p>文書が、<term>XML情報集合</term>(<bibref ref="XINFO"/>を見よ)を生成するXMLパーザによって解析される。解析された文書は1つ以上のスキーマに対して妥当性検証されてもよい。この処理は<bibref ref="XMLSchema"/>に記述されているが、この結果、<term>検証後情報集合</term>(Post-Schema Validation Infoset, PSVI)と呼ばれる抽象情報構造が得られる。もし文書に関連するスキーマがなければ、文書の情報集合が保存される。(図1のDM1を見よ。)</p>
</item>
<item><p>情報集合もしくはPSVIが、<bibref ref="datamodel"/>に書かれている処理によって<termref def="dt-data-model-instance">XDMインスタンス</termref>に変換される。(図1のDM2を見よ。)</p>
</item></olist>
<p>上に述べた段階は<termref def="dt-data-model-instance">XDMインスタンス</termref>がどのように構築されるかという一例を提供している。XDMインスタンスは関係データベースから直接合成されるかもしれないし、他の方法(図1のDM3を見よ)で構築されるかもしれない。XQueryは<termref def="dt-datamodel">データモデル</termref>に基づいて定義されるが、XDMインスタンスがどのように構築されるかについては、制約を何も置かない。</p>

<p><termdef term="type annotation" id="dt-type-annotation"> <termref def="dt-data-model-instance">XDMインスタンス</termref>中の要素節点や属性節点はそれぞれ<term>型注釈</term>(<bibref ref="datamodel"/>では<code>type-name</code>性質として参照されている)を持つ。節点の型注釈は<termref def="dt-schema-type">スキーマ型</termref>であり、節点の<termref def="dt-string-value">文字列値</termref>と<termref def="dt-typed-value">型付けされた値</termref>の関連を記述する。</termdef> <termref def="dt-data-model-instance">XDMインスタンス</termref>が<xspecref spec="DM" ref="const-psvi"/>に述べられているように妥当なXML文書から導出されたならば、要素節点や属性節点の型注釈はスキーマ妥当性検証から導出される。
  XQueryは要素節点や属性節点の型注釈に直接アクセスする方法は用意しない。</p>
<p>属性の値は属性節点によって直接表される。型が不明な属性節点(スキーマのない文書に出現する場合など)には<termref def="dt-type-annotation">型注釈</termref> <code>xs:untypedAtomic</code>が与えられる。</p>

<p>要素の値はその要素の子たちによって表される。子にはテキスト節点やほかの要素節点が含まれてもよい。要素節点の<termref def="dt-type-annotation">型注釈</termref>は、その子テキスト節点の値がどのように解釈されるかを示す。妥当性検証されていない要素(スキーマのない文書中に出現する場合など)には、<code>xs:untyped</code>というスキーマ型が注釈付けされる。妥当性検証されて部分的に妥当だとされた要素には<code>xs:anyType</code>というスキーマ型が注釈付けされる。もし要素が<code>xs:untyped</code>と注釈付けされているなら、そのすべての子孫要素節点もまた<code>xs:untyped</code>と注釈付けされる。しかし、もし要素が<code>xs:anyType</code>と注釈付けされているなら、その子孫要素節点のいくつかには、より詳細な<termref def="dt-type-annotation">型注釈</termref>が付けられるかもしれない。</p>


</div3><div3 id="id-schema-import-processing"><head>スキーマの輸入処理</head>
<p role="xquery"><termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-issd">有効範囲内スキーマ定義</termref>は、<bibref ref="XQueryFormalSemantics"/>で記述されているように実際のXMLスキーマから展開されてもよい (図1の段階SI1を見よ)し、他の何らかの機構によって生成されてもよい (図1の段階SI2を見よ)。いずれの場合も、結果は、<specref ref="id-consistency-constraints"/>で定義されている無矛盾性制約を満たさなければならない。</p>


</div3><div3 id="id-expression-processing"><head>式の処理</head>
<p>XQueryは、<termref def="dt-static-analysis">静的解析相</termref>と<termref def="dt-dynamic-evaluation">動的評価相</termref>という2つの処理相を定義する(図1を参照)。静的解析相では、<termref def="dt-static-error">静的エラー</termref>、<termref def="dt-dynamic-error">動的エラー</termref>、または<termref def="dt-type-error">型エラー</termref>が発生することがある。動的評価相では、<termref def="dt-dynamic-error">動的エラー</termref>と<termref def="dt-type-error">型エラー</termref>のみ発生することがある。これらの種類のエラーは<specref ref="id-kinds-of-errors"/>で定義される。</p>
<p>それぞれの相について、実装はこの文書の仕様に従う結果を得る戦略やアルゴリズムを自由に使ってよい。</p>

<div4 id="id-static-analysis"><head>静的解析相</head>
<p><termdef id="dt-static-analysis" term="static analysis phase"><term>静的解析相</term>は式自身と<termref def="dt-static-context">静的文脈</termref>に依存する。<term>静的解析相</term>は入力データ(スキーマを除く)には依存しない。</termdef></p>
<p>静的解析相では、<phrase role="xquery">問合せ</phrase>は構文解析され、<term>演算木</term>と呼ばれる内部表現となる(図1の段階SQ1)。構文解析エラーは<termref def="dt-static-error">静的エラー</termref>として発生する <errorref class="ST" code="0003"/>。次に<termref def="dt-static-context">静的文脈</termref>が実装によって初期化される(段階SQ2)。<phrase role="xquery">次に<termref def="dt-static-context">静的文脈</termref>は、<term>prolog</term>中の情報に基づいて変更されたり拡大されたりする (段階SQ3)。もし<termref def="dt-schema-import-feature">スキーマ輸入機能</termref>が支援されているならば、<termref def="dt-issd">有効範囲内スキーマ定義</termref>に輸入されたスキーマからの情報が加えられる。<termref def="dt-module-feature">モジュール機能</termref>が支援されているならば、輸入されたモジュールからの関数定義や変数定義により、静的文脈が拡張される。</phrase><termref def="dt-static-context">静的文脈</termref>はスキーマ型名、関数名、名前空間接頭辞、変数名などを解決するのに用いられる(段階SQ4)。もし、<term>演算木</term>中のこれらの種類のいずれかの名前が<termref def="dt-static-context">静的文脈</termref>になければ、<termref def="dt-static-error">静的エラー</termref>(<errorref class="ST" code="0008"/>もしくは<errorref class="ST" code="0017"/>)が発生する(ただし、<specref ref="id-element-test"/>および<specref ref="id-attribute-test"/>にあるこのルールの例外を見よ)。</p>

<p>次に、<term>演算木</term>は、<termref def="dt-atomization">原子化</termref>、あるいは<termref def="dt-ebv">有効ブール値</termref>の展開といった暗黙的演算を明示化することで、<term>正規化</term>される。正規化処理については<bibref ref="XQueryFormalSemantics"/>で記述されている。</p>

<p>次に、各式に<termref def="dt-static-type">静的型</termref>が付与される(段階SQ6)。<termdef id="dt-static-type" term="static type">式の<term>静的型</term>は型であり、その式が評価されたときに得られる値は必ず静的型に従う。</termdef> もし<termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が支援されているなら、<bibref ref="XQueryFormalSemantics"/>に書かれているルールに従って、さまざまな式の<termref def="dt-static-type">静的型</termref>が推論される。もし<termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が支援されていないなら、割り当てられる静的型は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p><termref def="dt-static-analysis">静的解析相</termref>では、もし<termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が機能しており、かつ式の演算数が、その演算数に適切でない<termref def="dt-static-type">静的型</termref>を持つと分かったならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。静的型検査でエラーが発生せず<termref def="dt-static-type">静的型</termref>Tが式に割り当てられたならば、正当な入力データに対しその式を実行すると、型Tの値が生成されるか<termref def="dt-dynamic-error">動的エラー</termref>となることが保証される。</p>
<p><termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>の目的は、<termref def="dt-type-error">型エラー</termref>の早期検出を提供し、式評価の最適化に役立つ型情報を推論することである。</p>
</div4>
<div4 id="id-dynamic-evaluation"><head>動的評価相</head>
<p><termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase"><term>動的評価相</term>は式の値を計算する相である。</termdef> 動的評価相は<termref def="dt-static-analysis">静的解析相</termref>が完了した後に行われる。</p>
<p>動的評価相は、<termref def="dt-static-analysis">静的解析相</termref>でエラーが検出されなかった場合に限り行うことができる。もし<termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が機能しているなら、静的解析の間にすべての<termref def="dt-type-error">型エラー</termref>が検出され、動的評価相の実行を妨げるのに役立つ。</p>
<p>動的評価相は、評価している式の<term>演算木</term>(段階DQ1)、入力データ(段階DQ4)、<termref def="dt-dynamic-context">動的文脈</termref>(段階DQ5)に依存し、さらに外部環境(段階DQ3)や<termref def="dt-dynamic-context">静的文脈</termref>(段階DQ2)から情報を引き出す。動的評価相は新しいデータモデル値を生成したり(段階DQ4)、値を変数に束縛するなどによりそれを<termref def="dt-dynamic-context">動的文脈</termref>に展開してもよい(段階DQ5)。</p>

<p><termdef term="dynamic type" id="dt-dynamic-type"><term>動的型</term>は、計算されるそれぞれの値に対応づけられる。値の動的型は、その値を計算した式の<termref def="dt-static-type">静的型</termref>よりも詳細であってもよい(例えば、式の静的型が<code>xs:integer*</code>、すなわち0以上の整数の列であっても、評価時には、その式の値が動的型<code>xs:integer</code>、すなわちただ1つの整数であってもよい)。</termdef></p>
<p>もし式の演算数が、その演算数に適切でない<termref def="dt-dynamic-type">動的型</termref>を持っていると分かったならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p>式が評価される前に静的型付けで多くの<termref def="dt-type-error">型エラー</termref>がとらえられるとしても、静的解析では検出されなかったエラーが評価時に発生することはあり得る。例えば、式に文字列から整数への型変換が含まれているかもしれない。これは静的には正しい。しかし、もし実行時の実際の文字列の値が整数に変換できないならば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。同様に、式中で<termref def="dt-static-type">静的型</termref>が<code>xs:untypedAtomic</code>であるような値に算術演算子を適用しているかもしれない。これは<termref def="dt-static-error">静的エラー</termref>ではない。しかし実行時では、もしその値が<termref def="dt-numeric">数</termref>型にうまく変換できなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。</p>
<p><termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が有効であるとき、式の静的解析において<termref def="dt-type-error">型エラー</termref>を発生させることは、たとえある入力に対してその式が正常に実行されるとしても、可能である。例えば、引数として要素を要求する関数が式に含まれており、静的解析相でその関数の引数の<termref def="dt-static-type">静的型</termref>が省略可能な要素であると推論されたとする。この場合は、たとえ省略可能な要素が存在するような入力データに対してこの関数呼び出しが正常に行われるとしても、<termref def="dt-type-error">型エラー</termref>として扱われ、評価が妨げられる。</p>
</div4></div3>
<div3 id="id-serialization"><head>直列化</head>
<p><termdef id="dt-serialization" term="serialization"><term>直列化</term>は<termref def="dt-data-model-instance">XDMインスタンス</termref>をオクテット列に変換する処理である(図1の段階DM4)。</termdef> 直列化の一般的な枠組は<bibref ref="serialization"/>に記述されている。</p>
<p role="xquery">XQueryの実装は、直列化インタフェースを提供する必要はない。例えば、実装は単にDOMインタフェース (<bibref ref="DOM"/>を見よ)やイベント系列に基づくインタフェースを用意するだけでもよい。これらの場合、直列化はこの仕様書の範囲外である。</p>
<p role="xquery"><bibref ref="serialization"/>では、直列化のプロセスを決定する<term>直列化特性</term>の集合を定義している。XQueryの実装が直列化インタフェースを用意しているならば、<specref ref="id-xq-serialization-parameters"/>で(デフォルト値とともに)列挙されている任意の直列化特性を支援し(また利用者に見せ)てもよい。直列化インタフェースを用意しているXQueryの実装は、<code>method = "xml"</code>かつ<code>version = "1.0"</code>であるような直列化特性の組み合わせを支援しなければならない。</p>
<note role="xquery"><p><termref def="dt-datamodel">データモデル</termref>では、要素節点の持つ<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>がその親よりも少ないことを許している。このような要素節点に対して正しく直列化を行うには、名前空間の "定義解除" が必要である。これは<bibref ref="XMLNAMES11"/>の機能である。<bibref ref="XMLNAMES11"/>を支援しない実装では、名前空間の "定義解除" を行うことなくこのような要素を直列化することが許される。結果として、その要素は、親の有効範囲内名前空間を事実上継承することになる。</p></note>

</div3>
<div3 id="id-consistency-constraints">

<head>無矛盾性制約</head>
<p>XQueryが明確に定義されるためには、入力となる<termref def="dt-data-model-instance">XDMインスタンス</termref>、<termref def="dt-static-context">静的文脈</termref>、<termref def="dt-dynamic-context">動的文脈</termref>が互いに無矛盾でなければならない。以下に列挙する無矛盾性制約はXQueryの実装が正しく動作するための前提条件である。これらの無矛盾性制約をどのように強制させるかはこの仕様書の範囲外である。この仕様書は、これらの制約が1つ以上満たされない条件の下での<phrase role="xquery">問合せ</phrase>の結果を定義しない。</p>
<p>無矛盾性制約のいくつかでは<term>データモデルスキーマ</term>という用語を用いる。<termdef id="dt-data-model-schema" term="data model schema"><termref def="dt-data-model-instance">XDMインスタンス</termref>中のある節点に対して、<term>データモデルスキーマ</term>は、その節点の<termref def="dt-type-annotation">型注釈</termref>が導出されたスキーマとして定義される。</termdef> スキーマ妥当性検証以外の処理によって構成された節点に対しては、<term>データモデルスキーマ</term>は、単に、その節点の<termref def="dt-type-annotation">型注釈</termref>によって表現されるスキーマ型定義から成る。</p>
<ulist>



<item><p>型注釈を持つ各節点について、その型注釈が<termref def="dt-issd">有効範囲内スキーマ定義</termref>(ISSD)中にあるなら、ISSD中の定義は<termref def="dt-data-model-schema">データモデルスキーマ</termref>中の定義と等価でなければならない。さらに、<termref def="dt-data-model-schema">データモデルスキーマ</termref>中のある型から拡張によって導出されるすべての型は、それと等価な定義がISSD中にもなければならない。</p>
</item>
<item><p><termref def="dt-data-model-instance">XDMインスタンス</termref>中と<termref def="dt-issd">有効範囲内スキーマ定義</termref>(ISSD)中の両方にある要素名<emph>EN</emph>のそれぞれについて、<emph>EN</emph>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあると分かっている<termref def="dt-data-model-schema">データモデルスキーマ</termref>中のすべての要素は、また<emph>EN</emph>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあると分かっているISSD中の要素でなければならない。</p>
</item>
<item><p>要素名、属性名、<termref def="dt-in-scope-variables">有効範囲内変数</termref>や<termref def="dt-function-signature">関数のシグネチャ</termref>から参照されているスキーマ型名は、いずれも<termref def="dt-issd">有効範囲内スキーマ定義</termref>中になければならない。ただし、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>の部分から参照されている要素名、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>の部分から参照されている属性名は除く。</p>
</item>
<item><p><termref def="dt-issd">有効範囲内スキーマ定義</termref>中に、大域的要素、属性、型名に対する参照がある場合は、対応する要素、属性、型の定義を<termref def="dt-issd">有効範囲内スキーマ定義</termref>中に持っていなければならない。</p>
</item>

<item><p>文字列から<termref def="dt-available-docs">利用可能な文書</termref>中の文書節点への写像それぞれについて、もし同じ文字列から<termref def="dt-known-docs">静的既知文書</termref>中の文書型への写像が存在するなら、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、文書節点はその文書型に照合されなければならない。</p>
</item>
<item><p>文字列から<termref def="dt-available-collections">利用可能コレクション</termref>中の節点列への写像それぞれについて、もし同じ文字列から<termref def="dt-known-collections">静的既知コレクション</termref>中の型への写像が存在するなら、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、節点列はその型に照合されなければならない。</p>
</item>
<item><p><termref def="dt-default-collection">デフォルトコレクション</termref>中の節点列は、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、<termref def="dt-known-default-collection">静的既知デフォルトコレクション</termref>に照合されなければならない。</p>
</item>
<item><p><termref def="dt-context-item">文脈項目</termref>の値は、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、<termref def="dt-context-item-static-type">文脈項目静的型</termref>に照合されなければならない。</p>
</item>
<item><p><termref def="dt-in-scope-variables">有効範囲内変数</termref>中の2つ組 (変数, 型)のそれぞれと、<termref def="dt-variable-values">変数の値</termref>中で対応する2つ組 (変数, 値)のうち変数名が等しいものについて、<specref ref="id-sequencetype-matching"/>にある照合ルールを用いて、値と型が照合されなければならない。</p>
</item>
<item role="xquery"><p><code>external</code>と宣言されている変数それぞれについて: 変数の宣言に宣言済の型が含まれているならば、外部環境は、その変数に対する値として宣言済の型に照合されるものを用意しなければならない。このとき<specref ref="id-sequencetype-matching"/>にある照合ルールが用いられる。変数の宣言に宣言済の型が含まれていないならば、外部環境は、型とそれに照合される値を用意しなければならない。このときも同じ照合ルールが用いられる。</p></item>
<item role="xquery"><p>外部と宣言されている関数それぞれについて: <termref def="dt-function-implementation">関数の実装</termref>は、<specref ref="id-sequencetype-matching"/>中の照合ルールを用いて、宣言されている結果の型と照合される値を返すか、<termref def="dt-implementation-defined">実装定義</termref>のエラーを発生させるか、いずれかでなければならない。</p></item>
<item role="xquery"><p>与えられた問合せに対し、<term>関与中ISSD</term>を、その問合せを評価するのに用いられるモジュールの<termref def="dt-issd">有効範囲内スキーマ定義</termref>として定義する。2つの関与中ISSDが同じスキーマ型、要素名、属性名に対する定義を含むならば、その定義はいずれのISSDでも等価でなければならない。さらに、2つの関与中ISSDのそれぞれにスキーマ型<emph>T</emph>の定義が含まれているならば、<emph>T</emph>から拡張によって導出される型の集合もまた、いずれのISSDでも等価でなければならない。また、2つの関与中ISSDのそれぞれに要素名<emph>E</emph>の定義が含まれているならば、<emph>E</emph>を先頭とする置換グループもまたいずれのISSDでも等価でなければならない。</p></item>
<item><p><termref def="dt-static-namespaces">静的既知名前空間</termref>の中で、接頭辞<code>xml</code>は<code>http://www.w3.org/XML/1998/namespace</code>以外の名前空間URIに束縛されてはならず、またこの名前空間URIには<code>xml</code>以外の接頭辞が束縛されてはならない。</p>
</item>
</ulist>
</div3></div2>

<div2 id="errors">
<head>エラー処理</head>

<div3 id="id-kinds-of-errors"><head>エラーの種類</head>
<p><specref ref="id-expression-processing"/>で述べたように、XQueryは入力データに依存しない<termref def="dt-static-analysis">静的解析相</termref>と入力データに依存する<termref def="dt-dynamic-evaluation">動的評価相</termref>を定義する。エラーはいずれの相でも発生してよい。</p>

<p><termdef id="dt-static-error" term="static error"><term>静的エラー</term>は静的解析相で検出されなければならないエラーである。構文エラーは<termref def="dt-static-error">静的エラー</termref>の例である。</termdef></p>
<p><termdef id="dt-dynamic-error" term="dynamic error"><term>動的エラー</term>は動的評価相で検出されなければならず、静的解析相で検出されてもよいエラーである。数値あふれは動的エラーの例である。</termdef></p>
<p><termdef id="dt-type-error" term="type error"><term>型エラー</term>は静的解析相、動的評価相のいずれでも発生してもよい。静的解析相では、式の<termref def="dt-static-type">静的型</termref>とその式の出現する文脈から期待される型とが一致しないとき、<termref def="dt-type-error">型エラー</termref>が発生する。動的評価相では、値の<termref def="dt-dynamic-type">動的型</termref>とその値の出現する文脈から期待される型とが一致しないとき、<termref def="dt-type-error">型エラー</termref>が発生する。</termdef></p>

<p><termref def="dt-static-analysis">静的解析相</termref>の結果は、成功か、1つ以上の<termref def="dt-type-error">型エラー</termref>、<termref def="dt-static-error">静的エラー</termref>、静的に検出される<termref def="dt-dynamic-error">動的エラー</termref>のいずれかである。<termref def="dt-dynamic-evaluation">動的評価相</termref>の結果は、結果の値か、1つの<termref def="dt-type-error">型エラー</termref>か、1つの<termref def="dt-dynamic-error">動的エラー</termref>のいずれかである。</p>
<p>1つ以上のエラーが現れたり、エラー条件がこの仕様で定義される1つ以上のエラーの範囲内に入ったりすると、これらのエラーの空でない集合が報告されてもよい。</p>

<p><termref def="dt-static-analysis">静的解析相</termref>では、<termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が機能しており、かつ<code>()</code>もしくは<code>data(())</code>以外の式に割り当てられる<termref def="dt-static-type">静的型</termref>が<code>empty-sequence()</code>であるならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0005"/>。これにより、<termref def="dt-issd">有効範囲内スキーマ定義</termref>に存在しない要素や属性を問合せが参照している場合がとらえられる。これは綴りの誤りの可能性があるためである。</p>
<p><termref def="dt-static-typing-feature" role="xquery">静的型付け機能</termref>が機能しているかどうかに関わらず、もし<termref def="dt-static-analysis">静的解析相</termref>で、ある式が評価されると<termref def="dt-type-error">型エラー</termref>や<termref def="dt-dynamic-error">動的エラー</termref>を発生する必要がある、ということを実装が決定できるならば、実装は<termref def="dt-static-analysis">静的解析相</termref>でエラーを通知してもよい(しかし通知することを要求されるわけではない)。しかし、<code>fn:error()</code>関数は<termref def="dt-static-analysis">静的解析相</termref>では評価されてはならない。</p>
<p><termdef id="dt-warning" term="warning"><termref def="dt-static-error">静的エラー</termref>、<termref def="dt-dynamic-error">動的エラー</termref>、<termref def="dt-type-error">型エラー</termref>に加えて、XQueryの実装は、<termref def="dt-static-analysis">静的解析相</termref>、<termref def="dt-dynamic-evaluation">動的評価相</termref>のいずれかで<term>警告</term>を発生してもよい。警告が発生する状況や、警告を処理する方法は<termref def="dt-implementation-defined">実装定義</termref>である。</termdef></p>
<p>この仕様書で定義されるエラーに加えて、実装は、この仕様書の範囲外の理由により<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。例えば、さまざまなオブジェクトの最大数や最大サイズに制限があってもよい。このような制限や、これらを越えることによる結果は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
</div3>
<div3 id="id-identifying-errors"><head>エラーの識別と報告</head>
<p>この仕様書で定義されるエラーは、<code role="xquery">err:XXYYnnnn</code>という形式を持つQNameで識別される。ここで:</p>
<ulist>
<item><p><code>err</code>はXPathおよびXQueryのエラーのための名前空間、<code>http://www.w3.org/2005/xqt-errors</code>を表す。この名前空間接頭辞<code>err</code>の束縛はこの文書内の便宜上用いており、参考である。</p>
</item>

<item role="xquery"><p><code>XX</code>は、そのエラーが定義されている言語を表しており、次の符号を用いる。</p><ulist role="xquery"><item><p><code>XP</code>はXPathで定義されるエラーを表す。このようなエラーはXQueryでも発生する。なぜならXQueryはXPathを部分集合として含むからである。</p></item><item><p><code>XQ</code>はXQueryで定義されるエラーを表す。</p></item></ulist></item>
<item><p><code>YY</code>はエラーの分類を示し、次のような符号化を用いる:</p>
<ulist>
<item><p><code>ST</code>は静的エラーを表す。</p></item>
<item><p><code>DY</code>は動的エラーを表す。</p></item>
<item><p><code>TY</code>は型エラーを表す。</p></item>
</ulist>
</item>
<item><p><code>nnnn</code>は一意に決まる数字コードである。</p></item>
</ulist>
<note><p>XQueryのバージョンが変わっても、XPathとXQueryのエラーのための名前空間URIが変わることは期待されない。しかし、この名前空間の内容は、エラー定義が追加されることによって拡張されてよい。</p></note>
<p>XQuery処理器がエラー情報を外部環境に報告する方法は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
<p>エラーは、エラーQNameから導出されるURI参照によって次のように表すことができる。名前空間URI<emph><code>NS</code></emph>と局所名<emph><code>LP</code></emph>を持つエラーは、URI参照<emph><code>NS</code></emph><code>#</code><emph><code>LP</code></emph>で表すことができる。例えば、QNameが<code>err:XPST0017</code>であるエラーは<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>で表せる。</p>
<note><p>エラーを識別するコードとともに、実装は、エラーの場所やエラーが検出された処理相などの付加的な情報を返してもよい。実装が付加的な情報を返すことを選択する場合は、この情報を返すのに用いられる機構は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
</note></div3>

<div3 id="id-handling-dynamic"><head>動的エラーの処理</head>
<p>この文書で示した以外に、もし式の演算数が<termref def="dt-dynamic-error">動的エラー</termref>を発生するならば、その式もまた<termref def="dt-dynamic-error">動的エラー</termref>を発生する。もし式が正常に値を返すことも動的エラーを発生することもできるのであれば、実装は、値を返すか動的エラーを発生するか選択してよい。例えば、論理式<code>expr1 and expr2</code>は、いずれかの演算数が<code>false</code>を返すならば値<code>false</code>を返してもよい。またいずれかの演算数が動的エラーを発生すれば動的エラーを発生してもよい。</p>
<p>もし式中の1つ以上の演算数がエラーを発生するならば、実装は、どのエラーがその式によって発生するかを選択してよい。例えば、次の式を考える:</p>
<eg role="parse-test" xml:space="preserve">($x div $y) + xs:decimal($z)</eg>
<p>部分式<code>($x div $y)</code>と<code>xs:decimal($z)</code>はともにエラーを発生するかもしれない。実装は式"<code>+</code>"によってどちらのエラーが発生するか選択してよい。いったん1つの演算数がエラーを発生すれば、実装が他の演算数を評価することは要求されないが、評価してもよい。</p>

<p><termdef id="dt-error-value" term="error value">識別可能なQNameに加え、動的エラーは、説明的な文字列や、<term>エラー値</term>と呼ばれる1つ以上の付加的な値を伴ってもよい。</termdef> 実装は、アプリケーションで定義されるエラー処理器がエラー値を処理し診断メッセージを生成する機構を提供してもよい。</p>

<p>動的エラーは<termref def="dt-built-in-function">組み込み関数</termref>や演算子によって発生してもよい。例えば<code>div</code>演算子は、その演算数が<code>xs:decimal</code>値でかつ第2演算数が0に等しいならば、例外を発生する。組み込み関数や演算子によって発生するエラーは<bibref ref="FunctionsAndOperators"/>で定義されている。</p>

<p>動的エラーは明示的に<code>fn:error</code>関数を呼び出すことによっても発生する。この関数はエラーを1つ発生させるだけで、値は返さない。この関数は<bibref ref="FunctionsAndOperators"/>で定義されている。例えば、次に示す関数呼び出しは動的エラーを発生する。発生する動的エラーは、エラーを識別するQName、説明的な文字列、診断値からなる(接頭辞<code>app</code>が、アプリケーションで定義されるエラーコードを含む名前空間に束縛されていると仮定している)。</p>

<eg role="parse-test" xml:space="preserve">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</eg>

</div3>
<div3 id="id-errors-and-opt"><head>エラーと最適化</head>
<p>実装が異なると、式を評価したり最適化したりする方法として異なるものを選ぶかもしれないので、この節で述べるように、<termref def="dt-dynamic-error">動的エラー</termref>の検出や報告についてのある側面は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p>実装は常に、演算子の演算数をどのような順序で評価しても自由である。</p>
<p>場合によっては、処理器は、形式的な式の意味によって内含されるすべてのデータにアクセスすることなく、式の結果を決定することができる。例えば、<termref def="dt-filter-expression">選別式</termref>の形式的記述では、<code>$s[1]</code>は列<code>$s</code>のすべての項目を検査し、述語<code>position()=1</code>を満たす項目をすべて選ぶことによって評価されるべきであると推奨している。実際は、多くの実装は、列の最初の項目を取ってきて終了してもこの式を評価することができる、と認識している。もし<code>$s</code>が<code>//book[author eq 'Berners-Lee']</code>と言った式で定義されるならば、この戦略は大きな文書全体の走査を避け、性能を大幅に改善するかもしれない。しかし、この戦略の結果として、式の評価が早く終了してしまうと、式の意味に厳密に従っていれば検出できたであろう動的エラーや型エラーが全く検出できないかもしれない。この例では、もし1個以上の<code>author</code>部分要素を持つ<code>book</code>要素が入力中にあると、このようなエラーが発生するかもしれない。</p>
<p>エラーを検出しないコストに関して、処理器がデータへのアクセスを最適化するかもしれない外延は、次のルールで定義される。</p>
<p>演算数(部分式)に<emph>E</emph>を持つ式<emph>Q</emph>を考えよう。一般には<emph>E</emph>の値は列である。列の評価の中間段階では、その項目のいくつかは分かっているが、残りは未知である。もし、評価の中間段階で、処理器が<emph>Q</emph>を評価した結果として2つの可能性しかない、すなわち値<emph>V</emph>かエラーの可能性しかないと証明できるならば、処理器は、演算数<emph>E</emph>の残りの項目を評価することなく結果<emph>V</emph>を出してもよい。この目的のために、2つの項目の節点と値がともに同一であるならば、2つの値は同じ結果を表現していると考えられる。ここで、節点が同じ識別子を持っているならば、それらの節点は同一である。また、2つの値が等値でかつ全く同じ型を持っているならば、それらの値は同一である。</p>
<p>このルールには例外がある。もし処理器が演算数 <emph>E</emph> を (その全体であれ部分的にであれ) 評価するならば、処理器は、<emph>E</emph>の演算数の実際の値が濃度に関するどんな制約にも反しないことを証明する必要がある。例えば、式<code>$e eq 0</code>は、<code>$e</code>の値が2個以上の項目を含んでいれば、型エラーという結果になる。処理器は、<code>$e</code>の値の最初の項目を評価した後、可能な結果は、値<code>true</code>か、濃度の違反による型エラーだけである、と決定することは許されない。<code>$e</code>の値が1個以下の項目しか含まないことを証明しなければならない。</p>
<p>このルールは、式の演算数として考えられるすべての組み合わせに適用される。したがって、式が2つの演算数<emph>E1</emph>と<emph>E2</emph>を持っているならば、上のルールを満たすそれぞれの列のどんな例を用いて評価されてもよい。</p>
<p>このルールは連鎖する。<emph>A</emph>が<emph>B</emph>の演算数で、<emph>B</emph>が<emph>C</emph>の演算数であるならば、処理器は<emph>C</emph>の値を決めるために充分な数の<emph>B</emph>の例だけを評価すればよく、さらに<emph>B</emph>の例を決めるために充分な数の<emph>A</emph>の例だけを評価すればよい。</p>
<p>これらのルールの効果として、処理器は、列中のあるところより先の項目が、エラーを発生させるかもしれないということ以外に結果に影響を及ぼさないと証明できれば、直ちにその先の項目の検査を止めても構わない。例えば、処理器は、2つの列から等しい値の2つ組を見つければ、直ちに<code>S1 = S2</code>の結果として<code>true</code>を返してもよい。</p>
<p>これらのルールのもう一つの結果として、列中のどの項目も式の結果に貢献しないとき、処理器はその列のどの部分も評価する義務を負わない。しかし、繰り返すが、処理器は要求される濃度の検査は、せずに済ますことができない。対象とする文脈で空列が許されなければ、処理器は、演算数が空列でないことを保証しなければならない。</p>
<p>例:</p>

<ulist>
<item><p>下の例において、実装が<code>$expr1</code>によって返される項目のうち少なくとも1つが<code>47</code>という値を持つと知ることができる(例えば索引を用いて)ならば、<code>some</code>式の結果として<code>true</code>を返すことが許される。このとき、<code>$expr1</code>によって返される他の項目に、評価するとエラーを発生させるものがあるか探す必要はない。</p>
<eg role="parse-test" xml:space="preserve">some $x in $expr1 satisfies $x = 47</eg></item>
<item><p>以下の例において、実装が、値が<code>47</code>であるような子節点<code>id</code>を持つ<code>product</code>要素節点を見つけられれば(例えば索引を用いて)、<termref def="dt-path-expression">経路式</termref>の結果としてこれらの節点を返すことが許される。このとき、他の<code>product</code>節点に、整数を値としない<code>id</code>子節点があるためにエラーを発生させるものがあるか探す必要はない。</p>
<eg role="parse-test" xml:space="preserve">//product[id = 47]</eg>
</item>
</ulist>
<p>最適化など、さまざまな理由により、実装は式を等価な式に書き換えることは自由である。エラーを発生させるか発生させないかという点を除いて、等価な式を評価した結果は、元の式を評価した結果と等しくなければならない。式の書換えを以下の例で説明する。</p>

<ulist><item><p>式<code>//part[color eq "Red"]</code>を考えよう。実装はこの式を<code>//part[color = "Red"][color eq "Red"]</code>と書き換えることを選択するかもしれない。この実装では、この式を次のように処理するかもしれない。まず part に関する索引を color によって引き、color が Red であるような part すべてを素早く見つけ、"<code>=</code>" 述語を処理する。次にこれらの part それぞれについて "<code>eq</code>" 述語を処理し、確かに一つの color しか持っていないか検査する。結果は以下のようになる。
<ulist><item><p>Redという1つの color しか持っていない part が返される。</p></item>
<item><p>ある part が Red という color と他の color を共に持っていれば、エラーが発生する。</p></item>
<item><p>Red という color を持たず Red でない color を複数持つ part が存在してもエラーは引き起こさない。</p></item></ulist>
</p></item>
<item><p>以下の例の式は、書かれている順に(すなわち左から右へ)正確に評価されれば、型変換エラーを起こすことはできない。どちらの述語も文脈位置に依存しているので、実装は、(例えば索引を利用することで)よりよい性能を得るために、述語を並び替えることを選択するかもしれない。述語を並べ替えることで、式がエラーを引き起こすかもしれない。</p>
<eg role="parse-test" xml:space="preserve">$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</eg>
<p>式の書き換えによって引き起こされる想定外のエラーを避けるために、動的エラーを防ぐために設計されたテストを、条件<phrase role="xquery">式または<code>typeswitch</code></phrase>式を用いて表現するべきである。条件<phrase role="xquery">式や<code>typeswitch</code></phrase>式は、実際に選択された分岐中で発生する動的エラーのみ引き起こす。したがって、前の例とは異なり、以下の例では<code>@x</code>が<code>xs:date</code>に型変換されなくても動的エラーは起こらない。</p>
<eg role="parse-test" xml:space="preserve">$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</eg></item></ulist>






</div3></div2>
<div2 id="id-important-concepts"><head>概念</head>

<p>この節では、XQuery式の処理で重要な概念をいくつか説明する。</p>

<div3 id="id-document-order"><head>文書順</head>

<p><term>文書順</term>と呼ばれる順序は、ある<phrase role="xquery">問合せ</phrase>の処理中にアクセス可能なすべての節点の間で定義され、1つ以上の<term>木</term>(文書もしくはその一部)から構成されていてもよい。文書順は<bibref ref="datamodel"/>で定義されているが、便宜上その定義をここでも繰り返す。<termdef id="dt-reverse-document-order" term="reverse document order">文書順の逆順であるような節点の順序を<term>逆文書順</term>という。</termdef></p>

<p>文書順は全順序である。ただし、節点間の相対順序は<termref def="dt-implementation-dependent">実装依存</termref>である。<termdef id="dt-document-order" term="document order"> 直観的には、<term>文書順</term>は直列化されたXML文書中で節点が出現する順序である。</termdef> <termdef id="stable" term="stable">文書順は<term>安定</term>である。ここで安定とは、ある<phrase role="xquery">問合せ</phrase>の処理中、2節点間の相対順序が変化しない(たとえこの順序が<termref def="dt-implementation-dependent">実装依存</termref>であっても)ことを意味する。</termdef></p>

<p>木では、文書順は次の制約を満たす。</p>

<olist>
<item><p>根節点は最初の節点である。</p></item>

<item><p>いずれの節点も、その子および子孫のどれよりも前に出現する。</p></item>



<item><p>属性節点は、それが関連づけられている要素節点のの直後に出現する。属性節点の相対順序は安定であるが<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
</item>

<item><p>兄弟間の相対順序は、親節点の性質<code>children</code>中で出現する順序である。</p></item>
<item><p>子および子孫は、弟よりも先に出現する。</p></item>
</olist>

<p>異なる木の節点間の相対順序は安定であるが<termref def="dt-implementation-dependent">実装依存</termref>であり、次の制約に従う。与えられた木T1中のある節点が、別の木T2中のすべての節点より前に出現するならば、木T1中のすべての節点が木T2のすべての節点より前に出現する。</p>

        </div3>

	 <div3 id="id-atomization"><head>原子化</head>
<p>いくつかのXQuery演算子の意味は<termref def="dt-atomization">原子化</termref>という処理に依存している。原子化がある値に対して適用されるのは、原子値の列が必要となる文脈でその値が用いられるときである。原子化の結果は、原子値の列か<termref def="dt-type-error">型エラー</termref> [err:FOTY0012] のいずれかである。<termdef id="dt-atomization" term="atomization">列の<term>原子化</term>は、<bibref ref="FunctionsAndOperators"/>で定義されている通り、その列に<code>fn:data</code>関数を実行した結果として定義される。</termdef></p>
<p>便宜上、<code>fn:data</code>の意味を繰り返す。<code>fn:data</code>の結果は、入力列中の各項目に以下のルールを適用して生成される原子値の列である。</p>
<ulist>
 <item><p>その項目が原子値であれば、その項目を返す。</p></item>
<item><p>その項目が節点であれば、その<termref def="dt-typed-value">型付けされた値</termref>を返す。(もしその節点が型付けされた値を持たないならば、err:FOTY0012が発生する。)</p></item>
			  
</ulist>
<p>原子化は以下の式の型を処理するのに用いられる。</p>
<ulist>
<item><p>算術式</p></item>
<item><p>比較式</p></item>
<item><p>関数呼び出しと関数からの戻り</p></item>
<item><p>型変換式</p></item>
<item role="xquery"><p>さまざまな種類の節点に対する構成子式</p></item>
<item role="xquery"><p>FLWOR式の<code>order by</code>節</p></item>
</ulist>
</div3>
<div3 id="id-ebv"><head>有効ブール値</head>
<p>ある状況の下では(以下に列挙する)、値の<termref def="dt-ebv">有効ブール値</termref>を得る必要がある。<termdef id="dt-ebv" term="effective boolean value">ある値の<term>有効ブール値</term>は、<bibref ref="FunctionsAndOperators"/>で定義されているように、その値に<code>fn:boolean</code>関数を適用して得られる結果として定義される。</termdef></p>

<p>便宜上、<code>fn:boolean</code>の動的意味を繰り返す。</p>
<olist>
<item><p>演算数が空列であれば、<code>fn:boolean</code>は<code>false</code>を返す。</p></item>
<item><p>演算数が、最初の項目が節点であるような列であれば、<code>fn:boolean</code>は<code>true</code>を返す。</p></item>
<item><p>演算数が<code>xs:boolean</code>型もしくは<code>xs:boolean</code>から導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は演算数の値を変化せずに返す。</p></item>
<item><p>演算数が<code>xs:string</code>型、<code>xs:untypedAtomic</code>型、もしくはこれらのいずれかから導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は、演算数の値の長さが0の場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p></item>
<item><p>演算数が<termref def="dt-numeric">数</termref>型、もしくは数型から導出される型の<termref def="dt-singleton">単一値列</termref>であれば、<code>fn:boolean</code>は、演算数の値が<code>NaN</code>もしくは数として0に等しい場合は<code>false</code>を、そうでない場合は<code>true</code>を返す。</p>
</item><item><p>これ以外のすべての場合について、<code>fn:boolean</code>は型エラー [err:FORG0006]を引き起こす。</p>
</item>
</olist>
<note><p><code>fn:boolean</code>の静的意味は<xspecref spec="FS" ref="sec_fn_boolean"/>で定義されている。</p>
</note>
<note role="xquery"><p><termref def="dt-ordering-mode">順序付けモード</termref>が<code>unordered</code>であるような問合せに対しては、節点と原子値をそれぞれ1つ以上含む列の<termref def="dt-ebv">有効ブール値</termref>は非決定的であってもよい。</p></note>
<p>列の<termref def="dt-ebv">有効ブール値</termref>は、以下のような式の型の処理で暗黙的に計算される。</p>
<ulist>
<item><p>論理式(<code>and</code>, <code>or</code>)</p></item>
<item><p><code>fn:not</code>関数</p></item>
<item role="xquery"><p>FLWOR式の<code>where</code>節</p></item>
<item><p>ある形式の<termref def="dt-predicate">述語</termref>。例えば<code>a[b]</code></p></item>
<item><p>条件式(<code>if</code>)</p></item>
<item><p>限量式(<code>some</code>, <code>every</code>)</p></item>

</ulist>
<note><p><termref def="dt-ebv">有効ブール値</termref>の定義は、例えば<code>cast</code>式のような<code>xs:boolean</code>型への型変換、あるいは引数として<code>xs:boolean</code>型を期待する関数に値を渡すときには、<emph>使わない</emph>。</p>
</note></div3>
<div3 id="id-input-sources"><head>入力源</head>
<p>XQueryは、入力データへのアクセスを提供する関数集合を持っている。これらの関数は、式が文書や文書の集まりを参照できる方法を用意しているため、特に重要である。ここでは、入力関数について直観的に記述する。これらは<bibref ref="FunctionsAndOperators"/>で定義されている。</p>

<p>式が入力データにアクセスするには、入力関数の一つを呼び出すか、外部環境によって初期化される<termref def="dt-dynamic-context">動的文脈</termref>の一部、例えば<termref def="dt-variable-values">変数</termref>や<termref def="dt-context-item">文脈項目</termref>を参照するか、いずれかによる。</p>

<p>XQueryで支援されている入力関数は以下の通りである:</p>

    <ulist><item><p><code>fn:doc</code>関数はURIを含む文字列を受け取る。そのURIが<termref def="dt-available-docs">有効文書</termref>中の文書と関連づけられていれば、<code>fn:doc</code>はその文書の<termref def="dt-datamodel">データモデル</termref>表現を内容とするような文書節点を返す。それ以外の場合、<termref def="dt-dynamic-value">動的エラー</termref>を引き起こす(詳細は<bibref ref="FunctionsAndOperators"/>を見よ)。</p></item>
<item><p>1引数の<code>fn:collection</code>関数は、URIを含む文字列を受け取る。そのURIが<termref def="dt-available-collections">有効コレクション</termref>中のコレクションと関連づけられていれば、<code>fn:collection</code>はそのコレクションのデータモデル表現を返す。それ以外の場合、<termref def="dt-dynamic-error">動的エラー</termref>を引き起こす(詳細は<bibref ref="FunctionsAndOperators"/>を見よ)。コレクションは任意の節点列であってもよい。例えば、式<code>fn:collection("http://example.org")//customer</code>は、URIが<code>http://example.org</code>であるようなコレクション中の節点の子孫である<code>customer</code>要素すべてを指し示す。</p></item>
<item><p>引数を持たない<code>fn:collection</code>関数は、<termref def="dt-default-collection">デフォルトコレクション</termref>を返す。これは<termref def="dt-implementation-dependent">実装依存</termref>の節点列である。</p>
</item></ulist>

    
</div3>
<div3 id="id-uri-literals" role="xquery"><head>URIリテラル</head>
<p>XQueryの文法のいくつかの箇所で、正当な静的既知絶対URIが要求される。このような箇所は、文法記号<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>によって記述される。例えば、URILiteral は名前空間や照合順序を指定するのに用いられる。これらはいずれも静的に既知でなければならない。</p><scrap headstyle="show"> 
		  <head/> <prod num="140" id="doc-xquery-URILiteral"><lhs>URILiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod> 
		   
		   
		   
		   
		   
		</scrap>
<p>構文的には、URILiteralは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>に等しい: すなわち、0個以上の文字の並びであり、一重引用符または二重引用符によって囲まれたものである。しかし、実装は、URILiteralの値の長さが0以外であり、かつ<code>xs:anyURI</code>の字句領域に含まれないか、<bibref ref="RFC3986"/>で定義されている "相対参照" を表す文字列であるならば、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0046"/>を発生<termref def="may">させてもよい</termref>。</p>
<p>文字列リテラル中のように、<termref def="dt-predefined-entity-reference">既定義実体参照</termref>  (例えば <code>&amp;amp;</code>), <termref def="dt-character-reference">文字参照</termref> (例えば <code>&amp;#x2022;</code>), あるいは <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt> や <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt> (例えば <code>""</code>) はすべて、適切な展開を行うことによって置き換えられる。ある種の文字、特にアンパサンドは、<termref def="dt-predefined-entity-reference">既定義実体参照</termref>あるいは<termref def="dt-character-reference">文字参照</termref>を用いてしか表現することができない。</p>
<p>URILiteral は、<bibref ref="XMLSchema"/>中で <code>xs:anyURI</code> 型に対して定義される空白の正規化に従っている: この意味するところは、先頭と末尾の空白は除去され、それ以外の空白文字の列はいずれも、空白 (#x20) 文字1つに置き換えられる、ということである。空白の正規化は<termref def="dt-character-reference">文字参照</termref>の展開の後で行われる。したがって (例えば) <code>$#xA;</code> として表現されている改行は、空白文字に正規化されることを妨げない。</p>
<p>URILiteral は、<bibref ref="RFC3986"/> に定義されているようなパーセント符号化やパーセント復号化に自動的に従うことはない。しかし、基礎 URI に従って URI を解決したり URI を逆参照したりしようと試みる処理はいずれも、関連する RFC 中で定義されているパーセント符号化や復号化を適用してもよい。</p>
<note><p><code>xs:anyURI</code>型は、<bibref ref="RFC3987"/>で定義される Internationalized Resource Identifier (IRI) の導入を予想して設計されている。<bibref ref="RFC3987"/></p></note>
<p>以下に示すのは、正当な URILiteral の例である。</p><eg xml:space="preserve">"http://www.w3.org/2005/xpath-functions/collation/codepoint"</eg></div3>
</div2>
	 <div2 id="id-types"> 
		<head>型</head> 
<p>XQueryの型システムは<bibref ref="XMLSchema"/>に基づいており、<bibref ref="XQueryFormalSemantics"/>で形式的に定義されている。</p>
<p><termdef id="dt-sequence-type" term="sequence type"><term>列型</term>(sequence type)は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>の構文を用いて表現することのできる型である。列型は、XQuery式で型を参照する必要があるときにはいつでも用いられる。<term>列型</term>という用語は、この構文がXQueryの値の型を記述するのに用いられる、ということを示唆している。この値は常に列である。</termdef></p>
<p><termdef id="dt-schema-type" term="schema type"><term>スキーマ型</term>(schema type)は<bibref ref="XMLSchema"/>の機能(<bibref ref="XMLSchema"/>の組み込み型を含む)を用いて定義された(または定義できる)型である。スキーマ型は要素節点や属性節点の型注釈として用いることができる(ただし、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>といった実体化不能型は除く。このような型の場合は、その導出型を用いることができる)。スキーマ型は<term>複合型</term>か<term>単純型</term>のいずれかである。単純型はさらに<term>リスト型</term>、<term>共用体型</term>、<term>原子型</term>に分けられる(これらの用語の定義と説明は<bibref ref="XMLSchema"/>を見よ)。</termdef></p>
<p>原子型は<termref def="dt-sequence-type">列型</termref>と<termref def="dt-schema-type">スキーマ型</termref>という種類の間の集合積を表現している。原子型、例えば<code>xs:integer</code>や<code>my:hatsize</code>は<termref def="dt-sequence-type">列型</termref>でもあり<termref def="dt-schema-type">スキーマ型</termref>でもある。</p>
	
		<div3 id="id-predefined-types"><head>既定義スキーマ型</head>



<p role="xquery"><termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-is-types">有効範囲内スキーマ型</termref>は、あらかじめ定義されているあるスキーマ型によって初期化される。このスキーマ型には、<bibref ref="XMLSchema"/>の組み込みスキーマ型が含まれる。これらの組み込みスキーマ型は、名前空間<code>http://www.w3.org/2001/XMLSchema</code>に属する。この名前空間は既定義名前空間接頭辞<code>xs</code>を持つ。組み込みスキーマ型の例には、<code>xs:integer</code>,
                   <code>xs:string</code>, 
		   <code>xs:date</code>などがある。<code>xs</code>名前空間中の要素や属性の定義は、静的文脈に明示的には含まれていない。</p>
<p role="xquery">加えて、XQueryの既定義スキーマ型には、名前空間<code>http://www.w3.org/2005/xpath-datatypes</code>で定義されているスキーマ型が含まれる。この名前空間は既定義名前空間接頭辞<code>xdt</code>を持つ。この名前空間中のスキーマ型は<bibref ref="datamodel"/>で定義されている。以下にその概要を示す。</p>
<olist>
<item><p><termdef term="xs:untyped" id="dt-untyped"><code>xs:untyped</code>は、妥当性検証されていない要素節点、あるいは<code>skip</code>モードで妥当性検証された要素節点の<termref def="dt-type-annotation">型注釈</termref>として用いられる。</termdef> <code>xs:untyped</code>からは既定義スキーマ型は何も導出されない。</p></item>
<item><p><termdef id="dt-untypedAtomic" term="xs:untypedAtomic"><code>xs:untypedAtomic</code>は、より詳細な型が割り当てられていないテキストなど、型付けされていない原子データを示すのに用いられる原子型である。</termdef> <code>skip</code>モードで妥当性検証された属性は、<termref def="dt-datamodel">データモデル</termref>中では<code>xs:untypedAtomic</code>という<termref def="dt-type-annotation">型注釈</termref>のついた属性節点として表現される。<code>xs:untypedAtomic</code>からは、既定義スキーマ型は何も導出されない。</p></item>
<item><p><termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration"><code>xs:dayTimeDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:dayTimeDuration</code>の字句表現は、日、時、分、秒の部分だけを含むように制限されている。</termdef></p></item>
<item><p><termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration"><code>xs:yearMonthDuration</code>は<code>xs:duration</code>から制限によって導出される。<code>xs:yearMonthDuration</code>の字句表現は、年と月の部分だけを含むように制限されている。</termdef></p></item>
<item><p><termdef term="xs:anyAtomicType" id="dt-anyAtomicType"><code>xs:anyAtomicType</code>はすべての原子値を含む(そして原子値以外の値は含まれない)原子型である。この基礎型は、原子型を含むすべての単純型、リスト型、および共用体型が導出される<code>xs:anySimpleType</code>である。<code>xs:integer</code>, <code>xs:string</code>, <code>xs:untypedAtomic</code>など、すべての原始的原子型は基礎型として<code>xs:anyAtomicType</code>を持つ。</termdef></p>
<note><p><code>xs:anyAtomicType</code>は<termref def="dt-data-model-instance">XDMインスタンス</termref>中の実際の値の型には出現しない。</p></note></item>
</olist>
<p><code>xs</code>名前空間中のスキーマ型の間の関連を図2に示す。XQueryの型階層のより完全な記述は<bibref ref="FunctionsAndOperators"/>にある。</p>
<graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="types.jpg" alt="Type Hierarchy Diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
<p>図2: XQueryで用いられるスキーマ型の階層</p></div3>

<div3 id="id-typed-value"><head>型付けされた値と文字列値</head>

<p>すべての節点は<term>型付けされた値</term>と<term>文字列値</term>とを持っている。<termdef term="typed value" id="dt-typed-value">節点の<term>型付けされた値</term>は原子値の列であり、その節点に<code>fn:data</code>関数を適用することで得ることができる。</termdef> <termdef id="dt-string-value" term="string value">節点の<term>文字列値</term>は文字列であり、その節点に<code>fn:string</code>関数を適用することで得ることができる。</termdef> <code>fn:data</code>と<code>fn:string</code>の定義は<bibref ref="FunctionsAndOprators"/>にある。</p>

<p>実装は、節点の<termref def="dt-typed-value">型付けされた値</termref>と<termref def="dt-string-value">文字列値</termref>をともに格納してもよいし、これらの一方だけを格納して、必要なときにもう一方を導出してもよい。節点の文字列値は、その節点の型付けされた値の正しい字句表現でなければならないが、その節点は元のソース文書から文字列表現を保存している必要はない。例えば、ある節点の型付けされた値が<code>xs:integer</code>の値<code>30</code>であったとすると、その文字列値は "<code>30</code>" でも "<code>0030</code>" でもよい。</p>

<p role="xquery">節点の<termref def="dt-typed-value">型付けされた値</termref>, <termref def="dt-string-value">文字列値</termref>, <termref def="dt-type-annotation">型注釈</termref>は密接に関連しており、以下の場所にあるルールによって定義される:</p>
<ulist role="xquery"><item><p>節点が情報集合またはPSVIからの写像によって生成されたのであれば、<bibref ref="datamodel"/>のルールを見よ。</p></item><item><p>節点が XQuery の節点構成子によって生成されたのであれば、<specref ref="id-element-constructor"/>, <specref ref="id-computedElements"/>, あるいは<specref ref="id-computedAttributes"/>のルールを見よ。</p></item><item><p>節点が<code>validate</code>式によって生成されたのであれば、<specref ref="id-validate"/>のルールを見よ。</p></item></ulist>
<p>読者の便宜のため、さまざまな種類の節点の<termref def="dt-typed-value">型付けされた値</termref>と<termref def="dt-string-value">文字列値</termref>の関連について以下にまとめ、例を用いて説明する。</p>

<olist>
<item><p>テキスト節点と文書節点では、型付けされた値と文字列値は等しく、<code>xs:untypedAtomic</code>型のインスタンスである。文書節点の文字列値は、そのすべての子孫のテキスト節点の文字列値を<termref def="dt-document-order">文書順</termref>に連接して得られる。</p></item>
<item><p>コメント、、処理命令節点について、型付けされた値は文字列値に等しい。<code>xs:string</code>型のインスタンスである。</p></item>
<item><p><termref def="dt-type-annotation">型注釈</termref><code>xs:anySimpleType</code>または<code>xs:untypedAtomic</code>のついた属性節点の型付けされた値は、文字列値に等しく、<code>xs:untypedAtomic</code>型のインスタンスである。その他の型注釈のついた属性節点の型付けされた値は、対応する型に関して<bibref ref="XMLSchema"/>第2部で定義される字句から値空間への写像を用いて、文字列値や型注釈から導出される。</p>
<p>例: A1 は文字列値<code>"3.14E-2"</code>と型注釈<code>xs:double</code>を持つ属性である。A1の型付けされた値は、字句表現として<code>3.14E-2</code>を持つ<code>xs:double</code>の値である。</p>
<p>例: A2 は型注釈<code>xs:IDREFS</code>を持つ属性であり、各項目の型が原子データ型<code>xs:IDREF</code>であるようなリストデータ型である。A2の文字列値は"<code>bar baz faz</code>"である。A2の型付けされた値は、それぞれ<code>xs:IDREF</code>型である3つの原子値("<code>bar</code>", "<code>baz</code>", "<code>faz</code>")の列である。節点の型付けされた値は、名前付けされたリスト型のインスタンスとは決して扱われない。そのかわり、節点の型注釈がリスト型(<code>xs:IDREFS</code>など)であれば、型付けされた値は、それが導出される原子型(<code>xs:IDREF</code>など)の列として扱われる。</p>
</item>
<item><p>要素節点については、型付けされた値と文字列値の関連はその要素の<termref def="dt-type-annotation">型注釈</termref>に依存する。以下の通り:</p>
<olist>

<item>

<p>型注釈が<code>xs:untyped</code>、<code>xs:anySimpleType</code>、もしくは混在内容を伴う複合型(<code>xs:anyType</code>を含む)を表していれば、その節点の型付けされた値は文字列値に等しく、<code>xs:untypedAtomic</code>のインスタンスである。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列である。</p>

<p>例: E1 は型注釈<code>xs:untyped</code>と文字列値"<code>1999-05-31</code>"を持つ要素節点である。E1の型付けされた値は"<code>1999-05-31</code>"であり、<code>xs:untypedAtomic</code>のインスタンスである。</p>


<p>例: E2は、型注釈<code>formula</code>を持つ要素節点である。この型注釈は混在内容を伴う複合型である。E2の内容は文字"<code>H</code>"、<code>subscript</code>と名付けられ文字列値"<code>2</code>"を持つ子要素、文字"<code>O</code>"からなる。E2の型付けされた値は"<code>H2O</code>であり、<code>xs:untypedAtomic</code>の印寸タンスである。</p></item>

<item><p>型注釈が単純型、もしくは単純内容を伴う複合型を表していれば、その節点の型付けされた値は、スキーマ妥当性検証と同じ方法で、文字列値と型注釈から導出される。しかし、その節点の<code>nilled</code>性質が<code>true</code>であれば、型付けされた値は空列になる。</p>
<p>例: E3は型注釈<code>cost</code>を持つ要素節点である。この型はいろいろな属性を持ち、かつ<code>xs:decimal</code>型の単純内容を持つ複合型である。E3の文字列値は"<code>74.95</code>"である。E3の型付けされた値は<code>74.95</code>であり、<code>xs:decimal</code>のインスタンスである。</p>
<p>例: E4は型注釈<code>hatsizelist</code>を持つ要素節点である。この型は原子型<code>hatsize</code>から導出された単純型であり、<code>hatsize</code>はさらに<code>xs:integer</code>から導出されている。E4の文字列値は"<code>7 8 9</code>"である。E4の型付けされた値は3つの値(<code>7</code>, <code>8</code>, <code>9</code>)からなる列であり、3つの値はいずれも<code>hatsize</code>型である。</p>
<p>例: E5は、メンバの型が<code>xs:integer</code>と<code>xs:string</code>の共用体型<code>my:integer-or-string</code>という型注釈を持つ要素節点である。E5の文字列値は"<code>47</code>"である。E5の型付けされた値は、<code>xs:integer</code>としての<code>47</code>である。なぜならば、E5の内容を妥当性検証したメンバ型が<code>xs:integer</code>であるからである。一般的に、節点の型注釈が共用体型であるときは、その節点の型付けされた値は、共用体のいずれかのメンバ型のインスタンスである。</p>
<note><p>実装が節点の文字列値しか格納しておらず、その節点の型注釈が共用体型であるならば、実装はその節点の型付けされた値を適切なメンバ型のインスタンスとして配布しなければならない。</p></note></item>
<item><p>型注釈が空内容を伴う複合型を表していれば、その節点の型付けされた値は空列であり、文字列値は長さ0の文字列である。</p>
</item>
<item><p>型注釈が要素だけからなる内容を伴う複合型を表していれば、その節点の型付けされた値は未定義である。<code>fn:data</code>関数は、このような節点に対して適用されると<termref def="dt-type-errro">型エラー</termref> [err:FOTY0012]を引き起こす。このような節点の文字列値は、すべての子孫テキスト節点の文字列値を文書順に連接した文字列値と等しい。</p>
<p>例: E6は型注釈が<code>weather</code>である要素節点である。この型は、内容型が<code>element-only</code>と指定されている複合型である。E6は<code>temperature</code>および<code>precipitation</code>と名付けられた2つの子節点を持つ。E6の型付けされた値は未定義であり、<code>fn:data</code>関数をE6に適用するとエラーを引き起こす。</p>
</item></olist></item></olist></div3>
<div3 id="id-sequencetype-syntax"><head>SequenceTypeの文法</head>
<p>XQuery式中の型を参照する必要があるときはいつでも、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>の文法が用いられる。</p>
		  <scrap headstyle="show">
			 <head/> 
			  
			 <prod num="119" id="doc-xquery-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod> 
			  			 <prod num="121" id="doc-xquery-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="120" id="doc-xquery-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs></prod><prod num="122" id="doc-xquery-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod> 
			  
			 <prod num="123" id="doc-xquery-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod> 
			  
			 <prod num="125" id="doc-xquery-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod> 
			  
			  
			 <prod num="133" id="doc-xquery-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod> 
		         
		         <prod num="135" id="doc-xquery-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="136" id="doc-xquery-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="129" id="doc-xquery-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod>

                  
                  

                  
                  <prod num="131" id="doc-xquery-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="132" id="doc-xquery-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="134" id="doc-xquery-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod>
                  
                  <prod num="138" id="doc-xquery-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="130" id="doc-xquery-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod>
                  
                  <prod num="137" id="doc-xquery-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>

                         
			 
			 
			 		 

                             
 
<prod num="139" id="doc-xquery-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="128" id="doc-xquery-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod> 
			  
			 <prod num="127" id="doc-xquery-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod> 
			 
			 <prod num="126" id="doc-xquery-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod>
			 
			 <prod num="124" id="doc-xquery-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod></scrap> 


<p>特別な型<code>empty-sequence()</code>を除き、<termref def="dt-sequence-type">列型</termref>は、列中の各項目の型に制約を加える<term>項目型</term>、および列の項目数に制約を加える<term>濃度</term>からなる。項目型<code>item()</code>は任意の種類の項目を許すが、これを除き、項目型は<term>節点型</term>(<code>element()</code>など)と<term>原子型</term>(<code>xs:integer</code>など)に分けられる。</p>
<p>要素節点や属性節点を表す項目型は、これらの節点の必要な<termref def="dt-type-annotation">型注釈</termref>を、<termref def="dt-schema-type">スキーマ型</termref>の形式で指定してもよい。したがって、項目型<code>element(*, us:address)</code>は、<code>us:address</code>と名付けられたスキーマ型(あるいはこの型から導出される型)を型注釈とする要素節点を表す。</p>
<p>以下に、XQuery式で用いられる<termref def="dt-sequence-type">列型</termref>の例をいくつか示す。</p>
		  <ulist> 
			 <item> 
<p><code>xs:date</code>は、<code>xs:date</code>と名付けられた組み込み原子スキーマ型を参照する。</p>
			 </item> 
			 <item> 
<p><code>attribute()?</code>は省略可能な属性節点を参照する。</p>
			 </item> 
			 <item> 
<p><code>element()</code>は任意の要素節点を参照する。</p>
			 </item> 
			 <item> 
<p><code>element(po:shipto, po:address)</code>は、<code>po:shipto</code>という名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
			 </item><item> 
<p><code>element(*, po:address)</code>は、任意の名前を持ち、かつ<code>po:address</code>(もしくは<code>po:address</code>から導出されるスキーマ型)を型注釈に持つ要素節点を参照する。</p>
			 </item><item>
<p><code>element(customer)</code>は、<code>customer</code>と名付けられ、かつ任意の型注釈を持つ要素節点を参照する。</p>
</item> 
			  
			 <item><p><code>schema-element(customer)</code>は、名前が<code>customer</code>であり(もしくは<code>customer</code>を先頭とする置換グループの中にあり)、かつ型注釈が、<termref def="dt-is-elems">有効範囲内要素定義</termref>中の<code>customer</code>要素のために定義されたスキーマ型に照合するような要素節点を参照する。</p>
</item><item> 
<p><code>node()*</code>は、任意の種類の節点0個以上からなる列を参照する。</p>
			 </item> 
			 <item> 
<p><code>item()+</code>は、1個以上の節点もしくは原子値からなる列を参照する。</p>
			 </item> 
		  </ulist></div3><div3 id="id-sequencetype-matching"> 
		  <head>SequenceTypeの照合</head> 
<p><termdef id="dt-sequencetype-matching" term="SequenceType matching">式の評価の間、既知の<termref def="dt-dynamic-type">動的型</termref>が期待される<termref def="dt-sequence-type">列型</termref>に「照合」されるか決定する必要があることがある。この処理を<term>SequenceTypeの照合</term>という。</termdef> 例えば、式<code>instance of</code>は、与えられた値の<termref def="dt-dynamic-type">動的型</termref>が与えられた<termref def="dt-sequence-type">列型</termref>に照合されれば<code>true</code>を返し、照合されなければ<code>false</code>を返す。</p>





<p><termref def="dt-sequence-type">列型</termref>中に出現するQNameは、<termref def="dt-static-namespace">静的既知名前空間</termref>と(もし適用可能であれば)<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>を用いて名前空間URIに展開される接頭辞を持つ。接頭辞のない属性 QName はどの名前空間にも属さない。QName の等価性は <code>eq</code> 演算子によって定義される。</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールは、値の<termref def="dt-dynamic-type">動的型</termref>を、期待される<termref def="dt-sequence-type">列型</termref>と比較する。これらのルールは<bibref ref="XQueryFormalSemantics"/>で定義される、値と期待される型との照合を行う形式的ルールの部分集合である。なぜなら、Formal Semanticsは、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>の文法を用いて表現できない型に対して値を照合することができなければならないからである。</p>


<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールのいくつかでは、与えられたスキーマ型が期待されるスキーマ型と同じかまたは導出されるかを決定する必要がある。与えられたスキーマ型は"既知"(<termref def="dt-issd">有効範囲内スキーマ定義</termref>で定義されている)か、または"未定義"(<termref def="dt-issd">有効範囲内スキーマ定義</termref>で定義されていない)のいずれかであってもよい。未定義スキーマ型は、例えば、ソース文書が<termref def="dt-static-context">静的文脈</termref>に輸入されていないスキーマを用いて妥当性検証されている場合などに現れるかもしれない。この場合、実装は、未定義のスキーマ型が期待されるスキーマ型から導出されるか決定する<termref def="dt-implementation-dependent">実装依存</termref>の機構を用意することが許される(しかし用意しておく必要はない)。
例えば、実装は型階層に関する情報を含むデータ辞書を管理していてもよい。</p>
<p><termdef term="subtype substitution" id="dt-subtype-substitution"><termref def="dt-dynamic-type">動的型</termref>が期待される型から導出されるような値を用いることを<term>部分型置換</term>という。</termdef> 部分型置換は、値の実際の型は変更しない。例えば、<code>xs:integer</code>の値を<code>xs:decimal</code>の値が期待される場所で用いても、その値の型は<code>xs:integer</code>のまま保たれる。</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>の定義は、<code>derives-from(</code><emph>AT, ET</emph><code>)</code>という名前の擬似関数に頼っている。この関数は、実際の単純スキーマ型もしくは複合スキーマ型<emph>AT</emph>と、期待される単純スキーマ型もしくは複合スキーマ型<emph>ET</emph>をとり、ブール値を返すか、<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。
擬似関数<code>derives-from</code>は以下で定義され、また<bibref ref="XQueryFormalSemantics"/>で形式的に定義されている。</p>

		  
		  <ulist>
<item><p><emph>ET</emph>が既知の型で、以下の3つの条件のいずれかが真であるとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<code>true</code>を返す。</p>
<olist>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>中にあるスキーマ型で、<emph>ET</emph>と同じか、<emph>ET</emph>から制限もしくは拡張によって導出される。</p>
</item>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>には含まれないスキーマ型で、<termref def="dt-implementation-dependent">実装依存</termref>の機構により<emph>AT</emph>が<emph>ET</emph>から制限により導出されると決定できる。</p>
</item>
<item><p><code>derives-from(</code><emph>IT, ET</emph><code>)</code>と<code>derives-from(</code><emph>AT, IT</emph><code>)</code>が真であるようなスキーマ型<emph>IT</emph>が存在する。</p>
</item></olist></item>
<item><p><emph>ET</emph>が既知の型で、以下の条件のうち1番目と3番目、もしくは2番目と3番目が真であるとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<code>false</code>を返す。</p>
<olist><item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>中にあるスキーマ型で、<emph>ET</emph>と等しくなく、<emph>ET</emph>から制限または拡張によって導出されない。</p>
</item>
<item><p><emph>AT</emph>が<termref def="dt-issd">有効範囲内スキーマ定義</termref>にないスキーマ型で、<termref def="dt-implementation-dependent">実装依存</termref>の機構により<emph>AT</emph>が制限によって<emph>ET</emph>から導出されない。</p>
</item>
<item><p><code>derives-from(</code><emph>IT, ET</emph><code>)</code>と<code>derives-from(</code><emph>AT, IT</emph><code>)</code>がともに真であるようなスキーマ型<emph>IT</emph>が存在しない。</p>
</item></olist></item>
<item><p>以下のとき、<code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code>は<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。</p>
<olist><item><p><emph>ET</emph>が未定義の型である。もしくは</p>
</item><item><p><emph>AT</emph>が未定義の型で、実装は、<emph>AT</emph>が制限によって<emph>ET</emph>から導出されるか決定できない。</p>
</item></olist></item></ulist>

<note role="xquery"><p><code>derives-from</code>擬似関数は実際の XQuery 関数としては書くことができない。なぜなら型は関数の引数としては正当でないからである。</p></note>

<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールを以下に述べ、例を示す(例は説明が目的であり、可能な場合をすべて網羅しているわけではない)。</p>

		   
		   
		  <div4 id="id-matching-value"><head>SequenceTypeと値の照合</head>
<ulist><item><p><termref def="dt-sequence-type">列型</termref> <code>empty-sequence()</code>は、空列である値と照合される。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>のない<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>がただ1つの項目を含む任意の値と照合されるのは、その<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>がその項目と照合されるときである(<specref ref="id-matching-item"/>を見よ)。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>のある<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>が値と照合されるのは、その値の項目の数が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>と照合され、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>がその値の各項目と照合されるときである。</p>
</item></ulist>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>は列中の項目数を以下のように指定する。</p>

		  <ulist> 
			 <item> 
			   <p><code>?</code>は0個もしくは1個の項目と照合される</p>
			 </item> 
			 <item> 
			   <p><code>*</code>は0個以上の項目と照合される</p>
			 </item> 
			 <item> 
			   <p><code>+</code>は1個以上の項目と照合される</p>
			 </item> 
		  </ulist>

<p>これらのルールの結果として、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>が<code>*</code>もしくは<code>?</code>であるような任意の<termref def="dt-sequence-type">列型</termref>は、空列である値と照合される。</p>
</div4>
<div4 id="id-matching-item"><head>ItemTypeと項目の照合</head>
<ulist>
<item><p>QNameのみからなる<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>と解釈される。AtomicType <emph>AtomicType</emph>が実際の型が<emph>AT</emph>である原子値と照合されるのは、<code>derives-from(</code><emph>AT, AtomicType</emph><code>)</code>が<code>true</code>の場合である。もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>として用いられているQNameが<termref def="dt-is-types">有効範囲内スキーマ定義</termref>中の原子型として定義されていないならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0051"/>。</p>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt> <code>xs:decimal</code>は値<code>12.34</code> (実数リテラル)と照合される。もし<code>shoesize</code>が<code>xs:decimal</code>から制限によって導出される原子型であれば、<code>xs:decimal</code>はまた、型が<code>shoesize</code>であるような値とも照合される。</p>

<note><p><code>xs:IDREFS</code>のように原子型でない型の名前は、この文脈では認められないが、しばしば、<code>xs:IDREF+</code>のように出現標識を伴った原子型によって置き換えることができる。</p>
</note>
</item>
<item><p><code>item()</code>は任意の単一項目と照合される。</p>
<p>例: <code>item()</code>は、原子値<code>1</code>や要素<code>&lt;a/&gt;</code>と照合される。</p>
</item>
<item><p><code>node()</code>は任意の節点と照合される。</p>
</item>
<item><p><code>text()</code>は任意のテキスト節点と照合される。</p>
</item>
<item><p><code>processing-instruction()</code>は任意の処理命令節点と照合される。</p>
</item>
<item><p><code>processing-instruction(</code><emph>N</emph><code>)</code>は、処理命令節点のうち名前(XMLでは処理命令の"PITarget"という)が<emph>N</emph>に等しいものに照合される。ここで<emph>N</emph>はNCNameである。</p>
<p>例: <code>processing-instruction(xml-stylesheet)</code>は、処理命令のうちPITargetが<code>xml-stylesheet</code>であるものに照合される。</p>

<p>XPath1.0との後方互換性のため、処理命令のPITargetは文字列リテラルとしても表されてもよい。例えばこの例の通り: <code>processing-instruction("xml-stylesheet")</code></p>
</item>
<item><p><code>comment()</code>は任意のコメント節点に照合される。</p>
</item>

<item><p><code>document-node()</code>は任意の文書節点に照合される。</p>
</item>
<item><p><code>document-node(</code><emph>E</emph><code>)</code>は、文書節点のうちただ1つの要素節点を含むものに照合される。1つ以上のコメント節点や処理命令節点が含まれていてもよい。ここで<emph>E</emph>は、その要素節点に照合される<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>または<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>である(<specref ref="id-element-test"/>および<specref ref="id-schema-element-test"/>を見よ)。</p>
<p>例: <code>document-node(element(book))</code>は、文書節点のうち、ElementTest <code>element(book)</code>によって照合されるようなただ1つの文書節点を含むものに照合される。</p>
</item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>、または<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>であるような<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>は、以下の節で述べる要素節点または属性節点に照合される。</p>
</item></ulist></div4>

<div4 id="id-element-test"><head>要素テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>は、要素節点をその名前や<termref def="dt-type-annotation">型注釈</termref>と照合するのに用いられる。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>は以下の形式のどれをとってもよい。これらの形式では、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>は<termref def="dt-is-elems">有効範囲内要素定義</termref>中にある必要はないが、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>は<termref def="dt-is-types">有効範囲内スキーマ型</termref>中になければならない。なお、<termref def="dt-substitution-group">置換グループ</termref>は、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>の意味には影響を及ぼさない。</p>
<olist><item><p><code>element()</code>と<code>element(*)</code>は任意の単一要素節点に照合され、その名前や型注釈とは関係しない。</p>
</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt><code>)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>であるようなものに照合され、その型注釈や<code>nilled</code>性質とは関係しない。</p>
<p>例: <code>element(person)</code>は、要素節点のうち名前が<code>person</code>のものと照合される。</p>







</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt><code>,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>のものに照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。</p>
<p>例: <code>element(person, surgeon)</code>は、nilledでない要素節点のうち名前が<code>person</code>であり、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</item>
<item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>?)</code>は、要素節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>のものに照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>が<code>true</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>
<p>例: <code>element(person, surgeon?)</code>は、nilledもしくはnilledでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合される。</p>
</item>



<item><p><code>element(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であり、その節点の<code>nilled</code>性質が<code>false</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。</p>

<p>例: <code>element(*, surgeon)</code>は、nilledでない要素節点のうち、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item>
<item><p><code>element(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt> <code>?)</code>は、名前に関係なく要素節点に照合される。ただし照合されるのは<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であるときである。ここで<emph>AT</emph>はその要素節点の型注釈である。その節点の<code>nilled</code>性質は<code>true</code>でも<code>false</code>でもよい。</p>

<p>例: <code>element(*, surgeon?)</code>は、nilledであるかnilledでない要素節点のうち、型注釈が<code>surgeon</code>である (もしくは<code>surgeon</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item></olist>

</div4>



<div4 id="id-schema-element-test"><head>スキーマ要素テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>は、要素節点のうち、<termref def="dt-is-elems">有効範囲内要素定義</termref>中にある対応する要素定義に対して照合される。これは次のような形式をとる。</p>
<p><code>schema-element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt><code>)</code></p>
<p>もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>中で指定されている<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>が<termref def="dt-is-elems">有効範囲内要素定義</termref>にないならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0008"/>。</p>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>は、以下の3つの条件がすべて満たされるとき、候補要素節点に照合される。</p>
<olist>
<item><p>候補節点の名前が、指定された<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>に照合されるか、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>と名付けられた要素を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中の要素名に照合される。</p>
</item>
<item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code>が<code>true</code>である。ここで<emph>AT</emph>はその候補節点の型注釈、<emph>ET</emph>は<termref def="dt-is-elems">有効範囲内要素定義</termref>中で要素<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>のために定義されたスキーマ型である。</p>
</item>
<item><p><termref def="dt-is-elems">有効範囲内要素定義</termref>中の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementName" xlink:type="simple">ElementName</nt>のための要素定義が<code>nillable</code>でないならば、その候補節点の<code>nilled</code>性質は<code>false</code>である。</p>
</item>
</olist>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> <code>schema-element(customer)</code>は候補要素節点に照合される。ただし照合されるのは<code>customer</code>が<termref def="dt-is-elems">有効範囲内要素定義</termref>中の最上位要素定義であり、候補節点の名前が<code>customer</code>であるか<code>customer</code>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>中にあり、候補節点の型注釈が<code>customer</code>要素のために定義されたスキーマ型と同じか導出されており、候補節点が<code>nilled</code>であるか<code>customer</code>が<code>nillable</code>と定義されているときである。</p>
</div4>
<div4 id="id-attribute-test"><head>属性テスト</head>




<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>は、属性節点をその名前や<termref def="dt-type-annotation">型注釈</termref>と照合するのに用いられる。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>は以下の形式のどれをとってもよい。これらの形式で、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>は<termref def="dt-is-attrs">有効範囲内属性定義</termref>中にある必要はないが、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt>は<termref def="dt-is-types">有効範囲内スキーマ型</termref>中にはなければならない。</p>
<olist>

<item><p><code>attribute()</code>と<code>attribute(*)</code>は任意の単一属性節点に照合され、その名前や型注釈とは関係しない。</p>
</item>

<item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code>は、属性節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>のものに照合され、その型注釈とは関係しない。</p>
<p>例: <code>attribute(price)</code>は、名前が<code>price</code>である任意の属性節点に照合される。</p>
</item>
<item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、属性節点のうち名前が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>であり、<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt> <code>)</code>が<code>true</code>であるようなものに照合される。ここで<emph>AT</emph>はその属性節点の型注釈である。</p>

<p>例: <code>attribute(price, currency)</code>は、属性節点のうち名前が<code>price</code>で型注釈が<code>currency</code>である (もしくは<code>currency</code>から導出される)ものに照合される。</p>
</item>
<item><p><code>attribute(*,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>は、名前に関係なく属性節点のうち<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeName" xlink:type="simple">TypeName</nt><code>)</code>が<code>true</code>であるようなものに照合される。ここで<emph>AT</emph>はその属性節点の型注釈である。</p>
<p>例: <code>attribute(*, currency)</code>は、属性節点のうち型注釈が<code>currency</code>である (もしくは<code>currency</code>から導出される)ものに照合され、その名前とは関係しない。</p>
</item>

</olist></div4>
<div4 id="id-schema-attribute-test"><head>スキーマ属性テスト</head>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>は、属性節点のうち、<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の対応する属性定義に対する属性節点に照合される。これは次のような形式をとる。</p>
<p><code>schema-attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code></p>
<p>もし<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>中で指定される<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>が<termref def="dt-is-attrs">有効範囲内属性定義</termref>になければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0008"/>。</p>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>は、以下の条件が2つとも満たされるとき、候補属性に照合される。</p>
<olist><item><p>候補節点の名前が指定された<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>に照合される。</p>
</item>
<item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code>が<code>true</code>である。ここで<emph>AT</emph>は候補節点の型注釈、<emph>ET</emph>は<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の属性<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeName" xlink:type="simple">AttributeName</nt>に対して定義されるスキーマ型である。</p>
</item></olist>
<p>例: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> <code>schema-attribute(color)</code>は候補属性節点に照合される。ただし照合されるのは<code>color</code>が<termref def="dt-is-attrs">有効範囲内属性定義</termref>中の最上位属性定義であり、候補節点の名前が<code>color</code>であり、候補節点の型注釈が<code>color</code>属性に対して定義されたスキーマ型と等しいか、それから導出されるときである。</p>
</div4></div3>
		 
		
		 
	 </div2> 

<div2 id="comments"><head>コメント</head>
<scrap headstyle="suppress"><head/>

<prod num="151" id="doc-xquery-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs></prod>

<prod num="159" id="doc-xquery-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod>
</scrap>

<p>コメントは<phrase role="xquery"><termref def="dt-prolog">前書き</termref>または<termref def="dt-queryBody">問合せ本体</termref>のいずれに出現してもよく、問合せ</phrase>のための参考的注釈を提供するのに用いてもよい。コメントは字句的な構成要素だけであり<phrase role="xquery">問合せ</phrase>の処理には影響を与えない。</p>
<p>コメントは文字列であり、記号<code>(:</code>と<code>:)</code>によって区切られる。コメントは入れ子になってもよい。</p>
<p>コメントは<termref def="IgnorableWhitespace">無視できる空白記号</termref>が許されるところにはどこで用いてもよい(<specref ref="DefaultWhitespaceHandling"/>を見よ)。</p>
<p>以下がコメントの例である。</p>
		<eg xml:space="preserve">(: Houston, we have a problem :)</eg></div2></div1>  
  
<div1 id="id-expressions">
 <head>式</head>  
<p>この章では、基本的な式の種類について一つ一つ議論する。それぞれの式の種類は<code>PathExpr</code>のような名前を持つ。この名前は、式を定義する文法生成規則の左辺に導入される。XQueryは構成可能な言語なので、それぞれの種類の式は、演算子がより高い優先度を持つような別の式を用いて定義される。このようにして、演算子の優先度は、文法中で明示的に表される。</p>
<p>この文書中で式が議論される順番は、演算子の優先度の順番を反映していない。一般に、この文書では、最も単純な種類の式を最初に導入し、続いて、より複雑な式を導入する。完全な文法については、付録を見よ [<specref ref="nt-bnf"/>]。</p>
<p>
<phrase role="xquery"><termdef id="dt-query" term="query"><term>問合せ</term>は1つ以上の<termref def="dt-module">モジュール</termref>から構成される。</termdef> もし問合せが実行可能であるならば、そのモジュールのうちいずれか1つが<termref def="dt-queryBody">Query Body</termref>を持つ。これに含まれる式の値が問合せの結果となる。式は XQuery の文法中の記号<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>によって表現される。</phrase>
</p>
<scrap headstyle="show"> 
		<head/>  
		<prod num="31" id="doc-xquery-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod>
	 
	 <prod num="32" id="doc-xquery-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FLWORExpr" xlink:type="simple">FLWORExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod>
</scrap>
<p>最も優先度の低いXQuery演算子は<termref def="dt-comma-operator">コンマ演算子</termref>である。これは、2つの演算数をつないで1つの列を作るのに用いられる。文法に示す通り、一般の式(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>)は複数の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>演算数から構成することができる。このとき演算数はコンマで区切られる。名前<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>は最上位の<termref def="dt-comma-operator">コンマ演算子</termref>を含まない式を表す。(その名前に反して、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>は1つ以上の項目を含む列を評価してもよい。)</p>
<p>シンボル<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>は、文法中で式の最上位にコンマを含むことが許されないようなあちこちの場所で使われている。例えば、関数呼び出しの各引数は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>でなければならない。なぜなら、関数呼び出しの引数を区切るのにコンマが使われているからである。</p>
<p>コンマの次に低い優先度を持つ式は<phrase role="xquery"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FLWORExpr" xlink:type="simple">FLWORExpr</nt>,</phrase> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>, <phrase role="xquery"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IfExpr" xlink:type="simple">IfExpr</nt>, そして<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrExpr" xlink:type="simple">OrExpr</nt>である。これらの式は各々、この文書の別の節で述べる。</p>
	 <div2 id="id-primary-expressions"> 
	 <head>基本式</head> 
<p><termdef id="dt-primary-expression" term="primary expression"><term>基本式</term>(primary expression)はXQuery言語の基本原式である。これにはリテラル、変数参照、文脈項目式、<phrase role="xquery">構成子、</phrase>関数呼び出しなどが含まれる。また、任意の式を括弧でくくって基本式を作ってもよい。これは演算子の優先度を制御するのに有用な場合もある。</termdef> <phrase role="xquery">構成子についての記述は<specref ref="id-constructors"/>にある。</phrase></p>

	 <scrap headstyle="show"> 
		<head/>  
<prod num="84" id="doc-xquery-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderedExpr" xlink:type="simple">OrderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Constructor" xlink:type="simple">Constructor</nt></rhs></prod>
	 </scrap> 
	 <div3 id="id-literals"> 
		<head>リテラル</head> 
<p><termdef id="dt-literal" term="literal"><term>リテラル</term>は原子値の直接的構文表現である。</termdef> XQueryは2種類のリテラルを支援する。数リテラルと文字列リテラルである。</p>
		<scrap headstyle="show"> 
		  <head/>  
		  <prod num="85" id="doc-xquery-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
		   
		  <prod num="86" id="doc-xquery-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod> 
		   
		  <prod num="141" id="doc-xquery-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		   
		  <prod num="142" id="doc-xquery-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs></prod> 
		   
		  <prod num="143" id="doc-xquery-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		   
		  <prod num="144" id="doc-xquery-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs></prod> 
		
		<prod num="145" id="doc-xquery-PredefinedEntityRef"><lhs>PredefinedEntityRef</lhs><rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs></prod><prod num="158" id="doc-xquery-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod>
</scrap> 
<p><term>数リテラル</term>の値のうち"<code>.</code>"と文字<code>e</code>, <code>E</code>を含まないものは<code>xs:integer</code>型の原子値である。数リテラルの値のうち、"<code>.</code>"を含むが文字<code>e</code>も<code>E</code>も含まないものは<code>xs:decimal</code>型の原子値である。数リテラルの値のうち、文字<code>e</code>か<code>E</code>を含むものは<code>xs:double</code>型の原子値である。これらの数リテラルの値は、<xspecref spec="FO" ref="casting-from-strings"/>で指定されているように、<code>xs:untypedAtomic</code>から数型へ型変換するためのルールにしたがって、適切な型へ変換することにより決定される。</p>
<p><term>文字列リテラル</term>の値は、 <code>xs:string</code>を型とし、区切りの一重引用符または二重引用符の間の文字によって表される文字列を値とするような原子値である。リテラルが一重引用符で区切られているとき、リテラル中で隣り合った2つの一重引用符は1つの一重引用符と解釈される。同様に、リテラルが二重引用符で区切られているとき、リテラル中で隣り合った2つの二重引用符は1つの二重引用符と解釈される。</p>
<p role="xquery">文字列リテラルには<term>既定義実体参照</term>が含まれていてもよい。<termdef term="predefined entity reference" id="dt-predefined-entity-reference"><term>既定義実体参照</term>は短い文字列であり、&amp;記号で始まる。これは単一の文字のうち、他の場合には構文上の目印となるものを表す。</termdef> 既定義実体参照はそれぞれ、文字列リテラルが生成されるときには、それが表現する文字に置き換えられる。XQuery で認識される既定義実体参照は以下の通りである:</p>
<table width="60%" border="1" role="xquery" summary="Special characters"><tbody><tr><td align="center" rowspan="1" colspan="1">実体参照</td><td align="center" rowspan="1" colspan="1">表現される文字</td></tr><tr><td align="center" rowspan="1" colspan="1"><code>&amp;lt;</code></td><td align="center" rowspan="1" colspan="1"><code>&lt;</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>&amp;gt;</code></td><td align="center" rowspan="1" colspan="1"><code>&gt;</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>&amp;amp;</code></td><td align="center" rowspan="1" colspan="1"><code>&amp;</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>&amp;quot;</code></td><td align="center" rowspan="1" colspan="1"><code>"</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>&amp;apos;</code></td><td align="center" rowspan="1" colspan="1"><code>'</code></td></tr></tbody></table>
<p role="xquery">文字列リテラルは<term>文字参照</term>を含んでもよい。<termdef term="character reference" id="dt-character-reference"><term>文字参照</term>は<bibref ref="Unicode"/>文字のXML形式の参照であり、10進または16進のコード位置で識別される。</termdef> 例えば、ユーロ記号 (€) は文字参照<code>&amp;#8364;</code>によって表現することができる。文字参照はXMLの仕様の 4.1 節で規格として定義されている (<bibref ref="XML"/>のルールを適用するか<bibref ref="XML1.1"/>のルールを適用するかは<termref def="dt-implementation-defined">実装定義</termref>である)。文字参照が、使用している XML の版での正しい文字を識別しないならば、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0090"/> が発生する。</p>
<p>リテラル式の例をいくつか示す。</p>
		<ulist> 
		  <item> 
		    <p><code>"12.5"</code>は、文字 '1', '2', '.', '5'からなる文字列を表す。</p>
		  </item> 
		  <item> 
		    <p><code>12</code>は<code>xs:integer</code>の値12を表す。</p>
		  </item> 
		  <item> 
		    <p><code>12.5</code>は<code>xs:decimal</code>の値12.5を表す。</p>
		  </item> 
		  <item> 
		    <p><code>125E2</code>は、<code>xs:double</code>の値12500を表す。</p>
		  </item>
		  <item>
<p><code>"He said, ""I don't like it."""</code>は2つの二重引用符と1つの
一重引用符を含む文字列を表す。</p>
</item> 
<item role="xquery"><p><code>"Ben &amp;amp; Jerry&amp;apos;s"</code>は<code>xs:string</code>の値 "<code>Ben &amp; Jerry's</code>" を表す。</p> </item>
<item role="xquery"><p><code>"&amp;#8364;99.50"</code> は<code>xs:string</code>の値 "<code>€99.50</code>" を表す。</p></item>
		</ulist> 
<p><code>xs:boolean</code>の値<code>true</code>と<code>false</code>は、それぞれ<termref def="dt-built-in-function">組み込み関数</termref> <code>fn:true()</code>と<code>fn:false()</code>の呼び出しによって表現することができる。</p>
<p>その他の原子型の値は、与えられた型に対する<termref def="dt-constructor-function">構成子関数</termref>を呼び出すことにより構成することができる。XML Schemaの組み込み型に対する構成子関数は<bibref ref="FunctionsAndOperators"/>で定義されている。一般的に、ある型の構成子関数の名前は、その型の名前(名前空間を含む)と等しい。例えば:</p>
		<ulist> 
		   
		  <item> 
		    <p><code>xs:integer("12")</code>は整数値12を返す。</p>
		  </item> 
		  <item> 
		    <p><code>xs:date("2001-08-25")</code>は、型が<code>xs:date</code>で、値が2001年8月25日という日付を表す項目を返す。</p>
		  </item>
		  <item><p><code>xs:dayTimeDuration("PT5H")</code>は、型が<code>xs:dayTimeDuration</code>で、値が5時間という時間を表す項目を返す。</p>
		  </item> 
		</ulist> 
<p>また構成子関数は、以下の例のように、リテラル表現を持たない特別な値を生成することもできる。
<ulist><item><p><code>xs:float("NaN")</code>は、"数でない"(Not a Number)という特別な浮動小数点数の値を返す。</p>
</item>
<item><p><code>xs:double("INF")</code>は"正の無限大"という特別な二倍長浮動小数点数の値を返す。</p>
</item></ulist></p>
<p>また、<code>cast</code>式を用いてさまざまな型の値を構成することもできる。例えば以下の通り。</p>
		<ulist> 
		  <item> 
		    <p><code>9 cast as hatsize</code>は、型が<code>hatsize</code>である原子値<code>9</code>を返す。</p>
		  </item> 
		</ulist> 
	 </div3> 
	 <div3 id="id-variables"> 
		<head>変数参照</head> 
		<scrap headstyle="show"> 
		<head/>  
	 
<prod num="87" id="doc-xquery-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod>
	
<prod num="88" id="doc-xquery-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod>
</scrap>
<p><termdef id="dt-variable-reference" term="variable reference"><term>変数参照</term>は$記号にQNameを続けたものである。</termdef> 2つの変数参照が同値であるとは、それらの局所名が等しく、かつそれらの名前空間接頭辞が<termref def="dt-static-namespaces">静的既知名前空間</termref>中の同じ名前空間URIに束縛されていることである。接頭辞のない変数参照はどの名前空間にも属さない。</p>
<p>変数参照はそれぞれ<termref def="dt-in-scope-variables">有効範囲内変数</termref>内の名前に照合されなければならない。有効範囲内変数には以下の出所からの変数が含まれる。
<olist>
<item role="xquery"><p>変数は<termref def="dt-prolog">前書き</termref>で宣言されていてもよいし、現在の<termref def="dt-module">モジュール</termref>や<term>輸入モジュール</term>中で宣言されていてもよい。モジュールや前書きに関する議論は<specref ref="id-query-prolog"/>を見よ。</p></item>
<item><p><termref def="dt-in-scope-variables">有効範囲内変数</termref>は<termref def="dt-implementation-defined">実装定義</termref>の変数によって拡大されてもよい。</p>
</item>
<item><p>変数はXQuery式によって束縛されてもよい。<phrase role="xquery">変数を束縛できる式の種類は、FLWOR式 (<specref ref="id-flwor-expressions"/>), 限量式 (<specref ref="id-quantified-expressions"/>), <code>typeswitch</code>式 (<specref ref="id-typeswitch"/>) である。関数呼び出しもまた、関数の本体を実行する前に関数の仮引数に値を束縛する。</phrase></p>
</item></olist></p> 
		 
		 
		 
		 
<p>変数束縛はそれぞれ静的有効範囲を持つ。有効範囲は、変数への参照が正しく出現できる場所を定義する。有効範囲の中にない変数を参照すると、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0008"/> である。ある式に対して、変数が<termref def="dt-static-context">静的文脈</termref>内で束縛されれば、その変数は式全体に対する有効範囲に含まれる。</p>
<p>変数参照が有効範囲内の2つ以上の変数束縛に照合されたときは、その参照は、より内側の束縛、すなわち有効範囲がより小さいほうの束縛を参照すると解釈される。評価時には、変数参照の値は、対応する変数が束縛されている式の値である。変数束縛の有効範囲は、変数を束縛することのできる式それぞれについて個別に定義される。</p>
	 </div3> 
	 <div3 id="id-paren-expressions"> 
		<head>括弧式</head> 
		<scrap headstyle="show"> 
<head/>  
<prod num="89" id="doc-xquery-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod> 
</scrap><p>括弧は、複数の演算子を含む式の評価順序をある順に強制するのに用いてもよい。例えば、式<code role="parse-test">(2 + 4)
		    * 5</code>を評価すると30になる。なぜなら括弧式<code role="parse-test">(2 + 4)</code>が最初に評価され、その結果に5が掛けられるからである。括弧をつけなければ、式<code role="parse-test">2 + 4 * 5</code>を評価すると22になる。なぜなら乗算演算子は加算演算子より優先度が高いからである。</p> 
		 
		<p>空の括弧は、<specref ref="construct_seq"/>にある通り、空列を表すのに用いられる。</p> 
	 </div3> 

         <div3 id="id-context-item-expression">
              <head>文脈項目式</head>
              <scrap headstyle="show"> <head/>
	      <prod num="90" id="doc-xquery-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod>
 </scrap>

              <p><term>文脈項目式</term>を評価すると<termref def="dt-context-item">文脈項目</termref>が得られる。これは節点(式<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>中のように)か、原子値(式<code>(1 to
              100)[. mod 5 eq 0]</code>中のように)のいずれかである。</p>
<p><termref def="dt-context-item">文脈項目</termref>が未定義であれば、文脈項目式は動的エラーを引き起こす<errorref class="DY" code="0002"/>。</p>

         </div3>

	 <div3 id="id-function-calls"> 
		<head>関数呼び出し</head> 
		<p> <termdef term="built-in function" id="dt-built-in-function">XQueryで支援されている<term>組み込み関数</term>は<bibref ref="FunctionsAndOperators"/>で定義されている。</termdef> 
<phrase role="xquery">追加の関数が<termref def="dt-prolog">前書き</termref>で宣言されたり、<termref def="dt-library-module">ライブラリモジュール</termref>から輸入されたり、<termref def="dt-static-context">静的文脈</termref>の一部として外部環境によって用意されたりしてもよい。</phrase>
		</p><scrap headstyle="show"> 
		  <head/> 
		   
		  <prod num="93" id="doc-xquery-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		</scrap><p><term>関数呼び出し</term>は、QNameの後ろに0個以上の式の括弧付きリストが続くような構成をしている。この括弧付きリストを<term>引数</term>という。関数呼び出しのQNameが名前空間接頭辞を持っていなければ、<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>に属するとみなす。</p>
<p>関数呼び出しの<termref def="dt-expanded-qname">展開済QName</termref>や引数の数が<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-function-signature">関数シグネチャ</termref>の名前や次数に照合されなければ、<termref def="dt-static-error">静的エラー</termref>が発生する<errorref class="ST" code="0017"/>。</p> 
		 
		 

		


		<p>関数呼び出しは次のように評価される。</p> 
		<olist> 
		  <item> 
			 <p>引数の式が評価され、引数値を生成する。引数の評価順序は<termref def="dt-implementation-dependent">実装依存</termref>であり、ある引数を評価することなく関数の本体が評価できるならば、関数はその引数を評価する必要はない。</p> 
		  </item> 
		  <item> 
			 <p>以下に挙げる関数変換ルールを適用して、引数値がそれぞれ変換される。</p> 
		  </item> 
<item role="xquery"><p>関数が組み込み関数であれば、変換された引数値を用いて評価される。結果はその関数の宣言済戻り型のインスタンスであるか、動的エラーである。組み込み関数によって発生するエラーは<bibref ref="FunctionsAndOperators"/>で定義されている。</p></item>
<item role="xquery"> 
			 <p>関数が本体を持つ利用者定義関数であれば、変換された引数値が関数の仮引数に束縛され、関数の本体が評価される。次に、関数変換ルールを用いて、関数の本体によって返される値がその関数の宣言済戻り型に変換される。</p><p>変換された引数値が関数の引数に束縛されるとき、引数の値はその最も具体的な<termref def="dt-dynamic-type">動的型</termref>を保つ。この型が仮引数の型から導出されてもよいとしても、このようになる。例えば、<code>xs:decimal</code> 型の引数 <code>$p</code> を持つ関数は <code>xs:integer</code> 型の引数とともに呼び出すことができる。<code>xs:integer</code> 型は <code>xs:decimal</code> 型から導出される。この関数呼び出しの処理の間、関数の本体の内部では <code>$p</code> の<termref def="dt-dynamic-type">動的型</termref>は <code>xs:integer</code> だとみなされる。同様に、関数による戻り値はその最も具体的な型を保つ。その型は、関数の宣言済戻り型から導出されてもよい。例えば、<code>xs:decimal</code> を宣言済戻り型として持つ関数は、実際には動的型 <code>xs:integer</code> の値を返してもよい。</p><p>関数本体の評価では、式評価の<termref def="dt-static-context">静的文脈</termref>や<termref def="dt-dynamic-context">動的文脈</termref>は、その関数が宣言されている<termref def="dt-module">モジュール</termref>によって定義される。このモジュールが関数の呼び出される<termref def="dt-module">モジュール</termref>と同じである必要はない。例えば、関数の本体を評価する間有効範囲中にある変数は、関数が呼び出されるモジュールではなく、関数を宣言するモジュールの有効範囲内変数によって定義される。関数本体を評価する間、<termref def="dt-focus">焦点</termref>
		  (文脈項目、文脈位置、文脈サイズ)は定義されない。ただし関数本体の内部の式によって焦点が定義される場合を除く。</p> 
		  </item>		   
<item role="xquery"><p>関数がユーザ定義の外部関数であれば、その<termref def="dt-function-implementation">関数の実装</termref>が、変換された引数の値を伴って呼び出される。結果は、宣言された型の値か、<termref def="dt-implementation-defined">実装定義</termref>のエラーである (<specref ref="id-consistency-constraints"/>を見よ)。</p></item>
		</olist> 
		<p><term>関数変換ルール</term>は、引数値<phrase role="xquery">もしくは戻り値</phrase>を、引数として期待される型に変換するのに用いられる。すなわち、関数の<phrase role="xquery">引数もしくは戻り値</phrase>の定義済型に変換するのに用いられる。期待される型は<termref def="dt-sequence-type">列型</termref>として表現される。与えられた値に対して、関数変換ルールは以下のように適用される。</p> 
		<ulist>
<item><p>期待される型が原子型の列 (出現標識<code>*</code>, <code>+</code>, <code>?</code>を伴っていてもよい)であるならば、以下の変換が適用される。</p>
<olist><item><p>与えられた値に<termref def="dt-atomization">原子化</termref>が行われ、原子値の列が結果として得られる。</p></item>
<item><p>原子列の項目のうち<code>xs:untypedAtomic</code>型のものそれぞれに対し、期待される原子型への型変換が行われる。<termref def="dt-built-in-function">組み込み関数</termref>のうち期待される型が<termref def="dt-numeric">数</termref>と指定されているものについて、<code>xs:untypedAtomic</code>型の引数が<code>xs:double</code>に型変換される。</p></item><item><p>原子列中の<termref def="dt-numeric">数</termref>項目のうち、<specref ref="promotion"/>に書かれている数昇格を用いて期待される原子型に<termref def="dt-type-promotion">昇格</termref>できるものについて、昇格が行われる。</p></item>
<item><p>原子列中の<code>xs:anyURI</code>型の項目のうち、<specref ref="promotion"/>に書かれているURI昇格を用いて期待される原子型に<termref def="dt-type-promotion">昇格</termref>できるものについて、昇格が行われる。</p></item></olist></item>
<item><p>上記の変換を行った後、結果の値が、<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールに従って期待される型に照合されないときは、<termref def="dt-type-error">型エラー</termref>が発生する<errorref class="TY" code="0004"/>。
<phrase role="xquery">関数呼び出しが、その関数が定義されている<termref def="dt-module">モジュール</termref>ではない<termref def="dt-module">モジュール</termref>に置かれているならば、このルールは、関数が呼び出されるモジュール、関数が定義されているモジュールの両方で満たされなければならない。 (このためのテストは繰り返される。というのは、2つのモジュールは異なる<termref def="dt-issd">有効範囲内スキーマ定義</termref>を持っていてもよいからである。)</phrase>
<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のためのルールは、導出された型の値を基礎型の値として置換することを許していることに注意せよ。</p></item></ulist>

		 
<p>関数呼び出しの引数はコンマで区切られているので、最上位の<termref def="dt-comma-operator">コンマ演算子</termref>を含む引数式は、括弧で囲まなければならない。以下は、関数呼び出しの例とその説明である。</p>
		<ulist> 
		  <item> 
			 <p> <code role="parse-test">my:three-argument-function(1,
			2, 3)</code>は3つの引数を持つ関数呼び出しである。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function((1,
			2), 3)</code>は2つの引数を持つ関数呼び出しであり、1つ目の引数は2つの値の列である。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function(1,
			())</code>は2つの引数を持つ関数呼び出しであり、2つ目の引数は空列である。</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:one-argument-function((1, 2,
			3))</code>は1つの引数を持つ関数呼び出しであり、その引数は3つの値の列である。</p> 
		  </item> 
		<item> 
			 <p> <code role="parse-test">my:one-argument-function(( ))</code>は1つの引数を持つ関数呼び出しであり、その引数は空列である。</p> 
		  </item><item> 
			 <p> <code role="parse-test">my:zero-argument-function( )</code>は引数のない関数呼び出しである。</p> 
		  </item></ulist> 
	 </div3> 
	  
  </div2> 
  <div2 id="id-path-expressions"> 
	 <head>経路式</head> 
	  
	 <scrap headstyle="show"> 
		<head/> 
<prod num="68" id="doc-xquery-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs></prod>
 
<prod num="69" id="doc-xquery-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod>		   
	 </scrap> 
	 <p><termdef id="dt-path-expression" term="path expression"><term>経路式</term>は、木の節点の位置を指し示すのに用いることができる。経路式は1つ以上の
<termref def="dt-step">ステップ</termref>の並びからなり、各ステップは "<code>/</code>" または 
"<code>//</code>", で区切られている。また、経路式は
	 "<code>/</code>" または "<code>//</code>"で始まる場合もある。</termdef>先頭の
	 "<code>/</code>" または "<code>//</code>" は、以下に述べるように、経路式の先頭に暗黙的に追加される1つ以上の初期ステップの省略形である。</p><p>単一のステップからなる経路式は<specref ref="id-steps"/>に述べるように評価される。</p>
<p>経路式の先頭にある "<code>/</code>" は初期ステップ<code>fn:root(self::node()) treat as
	 document-node()/</code>の省略形である (ただし、もし
	 "<code>/</code>" が経路式全体であるならば、末尾の "<code>/</code>" は展開から省かれる)。この初期ステップの効果は、その経路が文脈節点を含む木の根節点から始まる、ということである。文脈項目が節点でない場合は、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。評価時に、文脈節点より上にある根節点が文書節点でなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p>

	 <p>経路式の先頭にある "<code>//</code>" は初期ステップ<code>fn:root(self::node()) treat as
	 document-node()/descendant-or-self::node()/</code>の省略形である (ただし、"<code>//</code>" それ自身は正しい経路式ではない <errorref class="ST" code="0003"/>)。これらの初期ステップの効果は、文脈節点の存在する木の根を含み、この根の子孫にすべての節点があるような初期節点列を確立するということである。この節点列は、経路式中の次のステップの入力として用いられる。文脈項目が節点でなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。評価時に、文脈節点より上にある根節点が文書節点でなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p>
	  
	 <note><p>節点の子孫には属性節点は含まれない。</p></note><p>経路式中の先頭ではない場所に出現する "<code>//</code>" は<specref ref="abbrev"/>に述べるように展開され、
"<code>/</code>" で区切られるステップの列になる。次に、このステップ列が左から右へ評価される。それぞれの演算
<code role="parse-test">E1/E2</code>は次のように評価される: 
式<code role="parse-test">E1</code>が評価され、結果が(空かもしれない)節点列でなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0019"/>。
	 次に、<code>E1</code>の評価の結果得られる節点それぞれが、<specref ref="eval_context"/>にあるように、さらに<code>E2</code>の評価のための<term>内部焦点</term>を提供する。
<code>E2</code>の評価すべてから得られた列が以下のように結合される:</p>
<olist><item><p><code>E2</code>の評価それぞれが(空かもしれない)節点列を返すなら、これらの列が結合され、節点の識別性に基づき、重複する節点が除去される。<phrase role="xquery">もし<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば、結果の節点列は<termref def="dt-document-order">文書順</termref>で返される。そうでない場合は、<termref def="dt-implementation-dependent">実装依存</termref>の順序で返される。</phrase></p></item>
<item><p><code>E2</code>の評価それぞれが(空かもしれない)原子値列を返すなら、これらの列が連接され、返される。<phrase role="xquery">もし<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば、結果の列は<code>E2</code>を評価した結果生成される部分列中および部分列間の順序を保存する。そうでない場合は、結果の列の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。</phrase></p></item>
<item><p>複数の<code>E2</code>の評価の結果、節点と原子値が少なくとも1つずつ返ってきたならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0018"/>。</p></item></olist>
<note><p>経路の各ステップが次のステップのための文脈節点を用意するため、その結果、経路の最後のステップしか、原子値列を返すことは許されない。</p></note>
<p>経路式の例として、<code role="parse-test">child::div1/child::para</code>は、文脈節点の子要素<code>div1</code>の子要素<code>para</code>を選択する。言い換えれば、文脈節点の孫要素<code>para</code>のうち<code>div1</code>を親として持つものが選択される。 </p>
	  
	 <note><p id="Chg-slash-note">文字 "<code>/</code>" は、完全な経路式としても、"<code>/*</code>" のようなさらに長い経路式の先頭としても用いることができる。また、"<code>*</code>" は、乗算演算子であるとともに経路式のワイルドカードでもある。このことにより、"<code>/</code>" が "<code>*</code>" の左側に出現するとき、構文解析が難しくなる。これは、<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">leading-lone-slash </loc>制約を用いることにより、解決できる。例えば、"<code>/*</code>" と "<code>/ *</code>" はワイルドカードを含む正しい経路式であるが、"<code>/*5</code>" と "<code>/ * 5</code>" は構文エラーを引き起こす。<code>/</code>" を演算子の左側で用いる時は、"<code>(/) * 5</code>" のように、括弧をつけなければならない。同様に、"<code>4 + / * 5</code>" は構文エラーを引き起こすが、"<code>4 + (/) * 5</code>" は正しい式である。式 "<code>4 + /</code>" もまた正しい。なぜなら<code>/</code>が演算子の左側に出現していないからである。</p></note><div3 id="id-steps"> 
		<head>ステップ</head> 
		<scrap headstyle="show"> 
		  <head/>  
<prod num="70" id="doc-xquery-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod>
			 
<prod num="71" id="doc-xquery-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>
 
<prod num="72" id="doc-xquery-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod>
			  
			 <prod num="75" id="doc-xquery-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod>
		
		<prod num="82" id="doc-xquery-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod></scrap> 
		<p><termdef term="step" id="dt-step"><term>ステップ</term>は<termref def="dt-path-expression">経路式</termref>の一部であり、項目の列を生成し、その列を0個以上の<termref def="dt-predicate">述語</termref>により選別する。ステップの値は、述語を左から右に適用し、これらを満たす項目からなる。ステップは<termref def="dt-axis-step">軸ステップ</termref>または<termref def="dt-filter-expression">選別式</termref>のいずれかである。</termdef> 選別式の説明は<specref ref="id-filter-expr"/>にある。</p>
<p><termdef term="axis step" id="dt-axis-step"><term>軸ステップ</term>は、指定された軸を通して文脈節点から到達可能な節点の列を返す。このステップは2つの部分からなる。<term>軸</term>はステップでの "移動方向" を定義し、<termref def="dt-node-test">節点テスト</termref>は節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>により節点を選択する。</termdef> 文脈項目が節点であれば、軸ステップは0個以上の節点からなる列を返す。それ以外の場合は、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0020"/>。<phrase role="xquery">もし<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば、結果の節点列は<termref def="dt-document-order">文書順</termref>で返される。そうでない場合は、<termref def="dt-implementation-dependent">実装依存</termref>の順序で返される。</phrase>  軸ステップは<term>前向きステップ</term>かまたは<term>逆向きステップ</term>のいずれかであり、0個以上の<termref def="dt-predicate">述語</termref>がそれに続く。</p>
		 
		<p>ステップの<term>省略構文</term>では、軸は省略可能であり、また<specref ref="abbrev"/>にあるように、その他の短縮記法も利用できる。</p> 
		<p>軸ステップの非省略構文は軸名と節点テストからなり、これらは2つのコロンで区切られる。ステップの結果は、指定された軸を通して文脈節点から到達可能な節点のうち、節点テストで指定される節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>を持つものからなる。例えば、ステップ<code>child::para</code>は、文脈節点の子要素<code>para</code>を選択する。ここで<code>child</code>が軸の名前であり、<code>para</code>がこの軸上で選択される要素節点の名前である。利用できる軸の説明は<specref ref="axes"/>にある。利用できる節点テストの説明は<specref ref="node-tests"/>にある。ステップの例は<specref ref="unabbrev"/>や<specref ref="abbrev"/>で示されている。</p> 

		<div4 id="axes"> 
		  <head>軸</head> 
		  <scrap headstyle="show"> 
			 <head/>  
<prod num="73" id="doc-xquery-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs></prod>
				 
				<prod num="76" id="doc-xquery-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod>
		  </scrap> 




<p role="xquery">XQueryは次の軸を支援する (ただし、<specref ref="id-full-axis-feature"/>にある制限を仮定している):</p>
		   

		  

		  <ulist> 
		    <item> 

		      <p><code>child</code>軸は文脈節点の子を含む。これらの節点は<bibref ref="datamodel"/>にある<code>dm:children</code>アクセサにより返される。</p>
		      <note>
						     
			<p>子を持つのは文書節点と要素節点だけである。文脈節点がこれ以外の種類の節点であるか、文脈節点が空の文書節点もしくは要素節点であったならば、child軸は空列である。文書節点や要素節点の子は、要素節点、処理命令節点、コメント節点、テキスト節点のいずれかである。属性節点、文書節点は決して子として出現することはない。</p></note>

		    </item>
		    <item> <p><code>descendant</code>軸はchild軸の推移的閉包として定義される。この軸には文脈節点の子孫 (子、子の子、など) が含まれる。</p>

		    </item> 
		    
		    <item> 

		      <p><code>parent</code>軸は<bibref ref="datamodel"/>にある<code>dm:parent</code>アクセサにより返される列を含む。このアクセサは文脈節点の親を返す。ただし、文脈節点が親を持たない場合は空列を返す。</p>

		    <note><p>属性節点はその親として要素節点を持っていてもよい。ただしその場合も、その属性節点はその要素節点の子ではない。</p></note></item> 

		    <item> <p><code>ancestor</code>軸はparent軸の推移的閉包として定義される。この軸には文脈節点の先祖 (親、親の親、など) が含まれる。</p>

		    <note><p>ancestor軸には、文脈節点のある木の根節点が含まれる。ただし、文脈節点が根節点の場合は含まれない。</p></note>

		    </item> 


		    <item> <p><code>following-sibling</code>軸は文脈節点の後に続く兄弟を含む。すなわち文脈節点の親の子のうち、<termref def="dt-document-order">文書順</termref>で文脈節点の後ろに出現する節点を含む。もし文脈節点が属性節点であれば、<code>following-sibling</code>軸は空である。</p>
		    </item>

		    <item> <p><code>preceding-sibling</code>軸は文脈節点の前にある兄弟を含む。すなわち文脈節点の親の子のうち、<termref def="dt-document-order">文書順</termref>で文脈節点より前に出現する節点を含む。もし文脈節点が属性節点であれば、<code>preceding-sibling</code>軸は空である。</p>
		    </item>

			 <item> 

				<p><code>following</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<termref def="dt-document-order">文書順</termref>で文脈節点より後ろに出現するものすべてを含む。</p>

			 </item> 

			 <item> 

				<p><code>preceding</code>軸は、文脈節点がある木の根の子孫のうち、文脈節点の子孫ではなく、<termref def="dt-document-order">文書順</termref>で文脈節点より前に出現するものすべてを含む。</p>

			 </item> 

			 <item> <p><code>attribute</code>軸は、文脈節点の属性を含む。これらは<bibref ref="datamodel"/>にある<code>dm:attributes</code>アクセサによって返される節点である。文脈節点が要素でなければ、この軸は空である。</p>

			 </item> 
			  
			 <item> 
				<p><code>self</code>軸は文脈節点自身のみを含む。</p> 
			 </item> 
			 <item> 
				<p><code>descendant-or-self</code>軸は、文脈節点と、文脈節点の子孫を含む。</p> 
			 </item> 
			 <item> 
				<p><code>ancestor-or-self</code>軸は、文脈節点と、文脈節点の先祖を含む。したがって、ancestor-or-self軸は常に根節点を含む。</p> 
			 </item> 

		  </ulist> 
		  <p>軸は<term>前向き軸</term>と<term>逆向き軸</term>とに分類することができる。文脈節点または<termref def="dt-document-order">文書順</termref>で文脈節点より後ろの節点のみ含む軸は、前向き軸である。文脈節点または<termref def="dt-document-order">文書順</termref>で文脈節点より前の節点のみ含む軸は、逆向き軸である。</p> 
		  <p><code>parent</code>軸, <code>ancestor</code>軸, <code>ancestor-or-self</code>軸, <code>preceding</code>軸, <code>preceding-sibling</code>軸は逆向き軸である。それ以外の軸はすべて前向き軸である。<code>ancestor</code>軸, <code>descendant</code>軸, <code>following</code>軸, <code>preceding</code>軸, <code>self</code>軸は文書を分割する (属性節点は無視する)。これらの軸は互いに重複がなく、すべてを合わせると文書中のすべての節点を含む。</p> 
		   
		<p><termdef id="dt-principal-node-kind" term="principal node kind">軸はそれぞれ<term>主要節点種類</term>を持つ。ある軸が要素を含んでいれば、主要節点種類は要素である。そのほかの場合は、その軸が含むことのできる節点の種類である。</termdef> したがって:</p> 
		  <ulist> 
			 <item> 
				<p>attribute軸に対しては、主要節点種類は属性である。</p> 
			 </item> 
			  
			 <item> 
				<p>それ以外のすべての軸に対しては、主要節点種類は要素である。</p> 
			 </item> 
		 </ulist>

		</div4> 
		<div4 id="node-tests"> 
		  <head>節点テスト</head> 
		  <p><termdef id="dt-node-test" term="node test"><term>節点テスト</term>は、<termref def="dt-step">ステップ</termref>によって選択された節点それぞれについて真にならなければならない条件である。</termdef> 
この条件は、節点の種類 (要素、属性、テキスト、文書、コメント、処理命令)、節点の名前、(要素節点、属性節点、文書節点の場合には) 節点の<termref def="dt-type-annotation">型注釈</termref>に基づいていてもよい。</p>
		  <scrap headstyle="show"> 
			 <head/>  
<prod num="78" id="doc-xquery-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NameTest" xlink:type="simple">NameTest</nt></rhs></prod>
				 
				<prod num="79" id="doc-xquery-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod>
				 
				<prod num="80" id="doc-xquery-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>)</rhs></prod> 
		  </scrap> 
		   
		  <p><termdef id="dt-name-test" term="name test">QNameまたはワイルドカードのみからなる節点テストを<term>名前テスト</term>という。</termdef> 名前テストが真になるのは、節点の<term>種類</term>がそのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>であり、節点の<termref def="dt-expanded-qname">展開済QName</termref>が節点テストで指定されている<termref def="dt-expanded-qname">展開済QName</termref>と (<code>eq</code> 演算子で定義されているように) 一致するとき、かつそのときに限る。例えば、<code role="parse-test">child::para</code>は、文脈節点の<code>para</code>子要素を選択する。文脈節点の子に<code>para</code>要素がなければ、節点の空集合を選択する。<code role="parse-test">attribute::abc:href</code>は、QName<code>abc:href</code>を持つ文脈節点の属性を選択する。文脈節点がそのような属性を持たなければ、節点の空集合を選択する。</p>
		  <p>節点テスト中のQNameは、式文脈の<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて<termref def="dt-expanded-qname">展開済QName</termref>に解決される。QNameの接頭辞が静的既知名前空間のどれにも一致しなければ、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0081"/>である。接頭辞のないQNameは、<termref def="dt-principal-node-kind">主要節点種類</termref>が要素である軸上で名前テストとして用いられると、式文脈の<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>の名前空間URIを持つ。これ以外の用いられ方の場合、名前空間URIを持たない。</p>
<p>名前テストの<termref def="dt-expanded-qname">展開済QName</termref>と名前が一致しないような要素節点に対しては、その名前テストは満たされない。たとえその名前がその名付けられた節点を先頭とするような<termref def="dt-substitution-group">置換グループ</termref>中にあったとしても、その名前テストは満たされない。</p> 
		  <p>節点テスト<code>*</code>は、そのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>であるような任意の節点に対して、真である。例えば、<code role="parse-test">child::*</code>は文脈節点のすべての子要素を選択する。また<code role="parse-test">attribute::*</code>は、文脈節点のすべての属性を選択する。</p> 
		  <p>節点テストは<code>NCName:*</code>という形式を持つことができる。この場合、接頭辞はQNameと同じ方法で展開される。このとき、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いる。その接頭辞が静的既知名前空間中になければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0081"/>。このような形式の節点テストが真になるのは、ステップの軸のうち<termref def="dt-expanded-qname">展開済QName</termref>が接頭辞の束縛されている名前空間URIを持っているものについて、その軸の<termref def="dt-principal-node-kind">主要節点種類</termref>の任意の節点に対してである。その名前の局所部分には関係しない。</p>
 <p>節点テストは<code>*:NCName</code>という形式を持つこともできる。この場合、節点テストが真になるのは、そのステップの軸の<termref def="dt-principal-node-kind">主要節点種類</termref>の節点のうち、局所名が与えられたNCNameに一致するものに対してである。節点の名前空間や、節点の名前空間の有無には関係しない。</p>
 <p><termdef term="kind test" id="dt-kind-test">節点テストのもう一つの形式は<term>種類テスト</term>と呼ばれる。これは、節点の種類、名前、<termref def="dt-type-annotation">型注釈</termref>に基づき、節点を選択することができる。</termdef> 種類テストの構文と意味についての記述は<specref ref="id-sequencetype-syntax"/>と<specref ref="id-sequencetype-matching"/>にある。種類テストが<termref def="dt-node-test">節点テスト</termref>内で用いられるとき、指定された軸上の節点のうち、その種類テストに照合されるものだけが選択される。以下に示すのは、経路式中で用いられている種類テストの例のいくつかである。</p>
<ulist><item><p><code>node()</code>は任意の節点に照合される。</p></item>
<item><p><code>text()</code>は任意のテキスト節点に照合される。</p></item>
<item><p><code>comment()</code>は任意のコメント節点に照合される。</p></item>
<item><p><code>element()</code>は任意の要素節点に照合される。</p></item>
<item><p><code>schema-element(person)</code>は、要素節点のうち、名前が<code>person</code> (または<code>person</code>を先頭とする<termref def="dt-substitution-group">置換グループ</termref>に含まれる)であり、型注釈が<termref def="dt-is-elems">有効範囲内要素定義</termref>中の<code>person</code>要素の定義型と同じ(もしくは導出される)であるようなものに照合される。</p></item>
<item><p><code>element(person)</code>は、要素節点のうち、名前が<code>person</code>であるようなものに照合される。その節点の型注釈には関係しない。</p></item>
<item><p><code>element(person, surgeon)</code>は、nillでない要素節点のうち、名前が<code>person</code>であり、型注釈が<code>surgeon</code>または<code>surgeon</code>から導出されるものに照合される。</p></item>
<item><p><code>element(*, surgeon)</code>は、nillでない要素節点のうち、型注釈が<code>surgeon</code> (または<code>surgeon</code>から導出される)であるようなものに照合される。その節点の名前には関係しない。</p></item>

                  

                  <item><p><code>attribute()</code>は任意の属性節点に照合される。</p></item>

                  <item><p><code>attribute(price)</code>は、属性節点のうち名前が<code>price</code>であるものに照合される。その節点の型注釈には関係しない。</p></item>
<item><p><code>attribute(*, xs:decimal)</code>は属性節点のうち型注釈が<code>xs:decimal</code>である (または<code>xs:decimal</code>から導出される) ものに照合される。その節点の名前には関係しない。</p></item>
<item><p><code>document-node()</code>は任意の文書節点に照合される。</p></item>
<item><p><code>document-node(element(book))</code>は、文書節点のうち内容が<termref def="dt-kind-test">種類テスト</termref> <code>element(book)</code>を満たす単一要素節点と、0個以上のコメントや処理命令が交差しているようなものに照合される。</p></item></ulist>
</div4> </div3>
	  
  <div3 id="id-predicates"> 
	 <head>述語</head> 
	  
	 <scrap headstyle="show"> 
		<head/>  
	 
	 <prod num="83" id="doc-xquery-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod>
</scrap> 
	 <p><termdef term="predicate" id="dt-predicate"><term>述語</term>は式からなり、角括弧で囲まれる。この式のことを<term>述語式</term>という。述語は、列を選別し、いくつかの項目を残し他の項目を捨てる機能を提供する。</termdef> 複数の隣接する述語の場合は、述語が左から右に適用され、それぞれの述語を適用した結果が次に続く述語の入力列になる。</p>
<p>入力列のそれぞれの項目に対して、述語式は <term>内部焦点</term> を用いて以下のように評価される: 文脈項目は、その述語によって現在評価されている項目である。文脈サイズは入力列中の項目数である。文脈位置は、入力列中の文脈項目の位置である。述語中での文脈位置を評価する目的で、入力列は以下のように整列されているとみなす: 述語が前向き軸のステップ中にあるなら文書順、述語が後ろ向き軸のステップ中にあるなら逆文書順、述語がステップ内にないなら元の順である。</p>
<p>入力列の項目それぞれに対して、
述語式の結果は<code>xs:boolean</code>の値に強制される。この値を<term>述語真偽値</term>といい、以下の通りになる。述語真偽値が<code>true</code>であるような項目が残され、述語真偽値が<code>false</code>であるような項目が捨てられる。</p> 
		<p>述語真偽値は以下のルールを順に適用することで導出される。</p> 
		<olist> 
		   
		  <item> 
			 <p>述語式の値が<termref def="dt-numeric">数</termref>型または<termref def="dt-numeric">数</termref>型から導出される型の<termref def="dt-singleton">単一値列</termref>原子値であるなら、述語真偽値は次のようになる。述語式の値が(<code>eq</code>演算子によって)<term>文脈位置</term>と等しい場合は<code>true</code>、それ以外の場合は<code>false</code>になる。 <termdef term="numeric predicate" id="dt-numeric-predicate">述語式が数型を返す述語を<term>数述語</term>という。</termdef></p> 
<note role="xquery"><p>問合せ中で<termref def="dt-ordering-mode">順序付けモード</termref>が<code>unordered</code>であるような領域では、<specref ref="id-unordered-expressions"/>に説明がある通り、数述語の結果は非決定的である。</p></note>
		  </item> 
		  <item> 
			 <p>これ以外の場合は、述語真偽値は、その述語式の<termref def="dt-ebv">有効ブール値</termref>である。</p> 
		  </item> 
		   
		</olist> 


		 
		<p>以下に、述語を含む<termref def="dt-axis-step">軸ステップ</termref>の例をいくつか示す。</p> 
		<ulist> 
		  <item> 
			 <p>この例は、文脈節点の子要素のうち、2番目の<code>chapter</code>要素を選択する。</p> 
			 <eg role="parse-test" xml:space="preserve">child::chapter[2]</eg> 
		</item> 
		<item> 
		  <p>この例は、文脈節点の子孫のうち、名前が<code>"toy"</code>であり、その<code>color</code>属性の値が<code>"red"</code>であるような要素を選択する。</p>
		  <eg role="parse-test" xml:space="preserve">descendant::toy[attribute::color = "red"]</eg> 
	 </item> 
	 <item> 
		<p>この例は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>子要素と<code>assistant</code>子要素をともに持つものを選択する。</p> 
		<eg role="parse-test" xml:space="preserve">child::employee[secretary][assistant]</eg> 
  </item> 
</ulist> 




 
 
<note><p><term>逆向き軸</term>を用いて選択された節点列に<termref def="dt-predicate">述語</termref>を用いる場合、このような列の文脈位置は<termref def="dt-reverse-document-order">逆文書順</termref>に割り当てられることを覚えておくことが重要である。例えば、<code>preceding::foo[1]</code>は<termref def="dt-reverse-document-order">逆文書順</termref>に最初に限定される<code>foo</code>要素を返す。なぜなら、この述語は逆向き軸を用いた<termref def="dt-axis-step">軸ステップ</termref>の一部であるからである。一方、<code>(preceding::foo)[1]</code>は<termref def="dt-document-order">文書順</termref>に最初に限定される<code>foo</code>要素を返す。なぜなら、括弧によって<code>(preceding::foo)</code>が<termref def="dt-primary-expression">優先式</termref>と解釈され、この式の中で文脈位置が文書順に割り当てられるからである。同様に、<code>ancestor::*[1]</code>は最も近い先祖要素を返す。なぜなら<code>ancestor</code>軸は逆向き軸であるからである。一方<code>(ancestor::*)[1]</code>は根要素 (文書順で最初の先祖) を返す。</p>
<p>後ろ向き軸のステップでは述語を評価する目的で文脈位置が逆文書順で割り当てられているという事実があっても、ステップの最終結果は常に文書順であるという事実は変わらない。</p>
</note>
</div3> 
<div3 id="unabbrev"> 
<head>非省略構文</head> 
<p>この節では経路式の例をいくつか出すが、これらは、各<termref def="dt-step">ステップ</termref>で軸が明示的に指定されている。これらの例で用いられている構文は<term>非省略構文</term>と呼ばれる。多くの場合に共通して、<term>省略構文</term>を用いて経路式をより簡潔に書くことが可能である。この構文については<specref ref="abbrev"/>で説明する。</p> 
<ulist> 
<item> 
<p> <code role="parse-test">child::para</code>は文脈節点の子である<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*</code>は文脈節点の子である要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::text()</code>は文脈節点の子であるテキスト節点すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::node()</code>は、文脈節点の子すべてを選択する。属性節点は返されないことに注意すること。なぜなら属性は子ではないからである。</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::name</code>は文脈節点の<code>name</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::*</code>は、文脈節点の属性すべてを選択する。</p> 
</item><item><p><code>parent::node()</code>は、文脈節点の親を選択する。文脈節点が属性節点であれば、この式はその属性が付けられている要素節点 (もしあれば) を返す。</p></item> 
<item> 
<p> <code role="parse-test">descendant::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor-or-self::div</code>は、文脈節点の先祖の<code>div</code>要素すべてを選択する。さらに文脈節点が<code>div</code>要素であれば、文脈節点自身も選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">descendant-or-self::para</code>は、文脈節点の子孫の<code>para</code>要素すべてを選択する。さらに文脈節点が<code>para</code>要素であれば、文脈節点自身も選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">self::para</code>は、文脈節点が<code>para</code>要素である場合は文脈節点自身を選択する。それ以外の場合には空列を返す。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::chapter/descendant::para</code>は、文脈節点の<code>chapter</code>子要素の子孫の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*/child::para</code>は、文脈節点の孫の<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/</code>は、文脈節点の含まれる木の根を選択する。ただし、この根が文書節点でなければ動的エラーを発生する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::para</code>は、文脈節点と同じ文書中にある<code>para</code>要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::list/child::member</code>は、<code>list</code>要素を親とする<code>member</code>要素で、文脈節点と同じ文書中にあるものすべてを選択する。</p> 
 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 1]</code>は、文脈節点の子のうち最初の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()]</code>は、文脈節点の子のうち最後の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()-1]</code>は、文脈節点の子のうち最後から2番目の<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() &gt; 1]</code>は、文脈要素の子の<code>para</code>要素のうち、1番目以外のものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">following-sibling::chapter[fn:position() = 1]</code>は、文脈要素の弟の<code>chapter</code>のうち、最初に出現するものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">preceding-sibling::chapter[fn:position() = 1]</code>は、文脈要素の兄の<code>chapter</code>のうち、直前に出現するものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::figure[fn:position() = 42]</code>は、文脈要素を含む文書中で42番目に出現する<code>figure</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code>は、文脈要素を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq "warning"]</code>は、文脈要素の子の<code>para</code>のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。 </p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq 'warning'][fn:position() = 5]</code>は、文脈節点の<code>para</code>子要素で、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの5番目のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 5][attribute::type eq "warning"]</code>は、文脈節点の子のうち5番目の<code>para</code>要素を選択する。ただし、その要素が<code>type</code>属性を持ち、その値が<code>warning</code>である場合に限られる。 </p> 
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title = 'Introduction']</code>は、文脈節点の子の<code>chapter</code>のうち、<termref def="dt-typed-value">型付けされた値</termref>が文字列<code>Introduction</code>に等しいような<code>title</code>子要素を1つ以上持つようなものを選択する。</p>
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1つ以上の<code>title</code>子要素を持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or self::appendix]</code>は、文脈節点の子の<code>chapter</code>と<code>appendix</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code>は、文脈節点の子の<code>chapter</code>または<code>appendix</code>のうち、最後のものを選択する。</p> 
</item> 
</ulist> 
</div3> 
<div3 id="abbrev"> 
<head>省略構文</head> 
<scrap headstyle="show"> 
<head/>  
<prod num="74" id="doc-xquery-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod>

<prod num="77" id="doc-xquery-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod>
</scrap> 
<p>省略構文では、次の省略記法が認められる。</p> 
<olist> 
<item> 
<p>attribute軸<code>attribute::</code>は<code>@</code>と略記できる。例えば、経路式<code role="parse-test">para[@type="warning"]</code>は<code role="parse-test">child::para[attribute::type="warning"]</code>の短縮形であり、<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものを選択する。</p> 
</item><item> 
<p><termref def="dt-axis-step">軸ステップ</termref>から軸名が省略されると、軸ステップが<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>または  を含まない限り、デフォルトの軸は<code>child</code>になる。AttributeTestを含む場合は、デフォルトの軸は<code>attribute</code>になる。例えば、経路式<code role="parse-test">section/para</code>は<code role="parse-test">child::section/child::para</code>の省略形であり、経路式<code>section/@id</code>は<code>child::section/attribute::id</code>の省略形である。同様に、<code>section/attribute(id)</code>は<code>child::section/attribute::attribute(id)</code>の省略形である。後者の式は軸指定と<termref def="dt-node-test">節点テスト</termref>をともに含んでいることに注意せよ。</p> 
</item> 
 
<item> 
<p>経路式の処理中、先頭以外に出現する<code>//</code>は<code>/descendant-or-self::node()/</code>に置き換えられる。例えば、<code role="parse-test">div1//para</code>は<code role="parse-test">child::div1/descendant-or-self::node()/child::para</code>の短縮形であり、<code>div1</code>子要素の<code>para</code>子孫要素を選択する。</p> 
<note><p>経路式<code role="parse-test">//para[1]</code>は、経路式<code role="parse-test">/descendant::para[1]</code>と同じであるということを意味<emph>しない</emph>。後者は、最初の<code>para</code>子孫要素を選択する。前者は<code>para</code>子孫要素のうち、その親の最初の<code>para</code>子要素であるものをすべて選択する。</p></note> 
</item> 
<item> 
<p><code role="parse-test">..</code>からなるステップは<code role="parse-test">parent::node()</code>の短縮形である。例えば、<code role="parse-test">../title</code>は<code role="parse-test">parent::node()/child::title</code>の短縮形であり、文脈節点の親の<code>title</code>子要素を選択する。</p> 
<note>
   <p>式<code>.</code>は、<term>文脈項目式</term>と呼ばれ、<termref def="dt-primary-expression">基本式</termref>である。これについての説明は<specref ref="id-context-item-expression"/>にある。</p>
</note></item> 
</olist>



<p>以下に示すのは、省略構文を用いた経路の例である。</p> 
<ulist> 
<item> 
<p> <code>para</code>は、文脈節点の<code>para</code>子要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">*</code>は、文脈節点の子要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">text()</code>は、文脈節点の子であるテキスト節点すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">@name</code>は、文脈節点の<code>name</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">@*</code>は、文脈節点の属性すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[1]</code>は、文脈節点の<code>para</code>子要素のうち最初のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[fn:last()]</code>は、文脈節点の<code>para</code>子要素のうち最後のものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">*/para</code>は、文脈節点の<code>para</code>孫要素すべてを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">/book/chapter[5]/section[2]</code>は、文脈節点を含む文書節点を親とする<code>book</code>の5番目の<code>chapter</code>の2番目の<code>section</code>を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter//para</code>は、文脈節点の<code>chapter</code>子要素の子孫である<code>para</code>要素を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">//para</code>は、根である文書節点の子孫の<code>para</code>をすべて選択する。すなわち、文脈節点と同じ文書内にあるすべての<code>para</code>要素を選択する。</p> 
</item><item><p><code>//@version</code>は、文脈節点と同じ文書内にあるすべての<code>version</code>属性を選択する。</p></item> 
<item> 
<p> <code role="parse-test">//list/member</code>は、文脈節点と同じ文書内にある<code>member</code>要素のうち、<code>list</code>を親に持つものをすべて選択する。</p> 
 
</item> 
 
<item> 
<p> <code role="parse-test">.//para</code>は、文脈節点の子孫の<code>para</code>要素をすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">..</code>は文脈節点の親を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">../@lang</code>は、文脈節点の親の<code>lang</code>属性を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"][5]</code>は、文脈節点の<code>para</code>子要素のうち、<code>type</code>属性を持ち、その値が<code>warning</code>であるようなものの中から5番目を選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">para[5][@type="warning"]</code>は、文脈節点の5番目の<code>para</code>子要素が、<code>type</code>属性を持ち、その値が<code>warning</code>であるなら、それを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title="Introduction"]</code>は、文脈節点の<code>chapter</code>子要素のうち、<termref def="dt-typed-value">型付けされた値</termref>が文字列<code>Introduction</code>であるような<code>title</code>子要素を1つ以上持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title]</code>は、文脈節点の<code>chapter</code>子要素のうち、1個以上の<code>title</code>子要素を持つものを選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">employee[@secretary and @assistant]</code>は、文脈節点の<code>employee</code>子要素のうち、<code>secretary</code>属性と<code>assistant</code>属性をともに持つものをすべて選択する。</p> 
</item> 
<item> 
<p> <code role="parse-test">book/(chapter|appendix)/section</code>は、<code>section</code>要素のうち親が<code>chapter</code>要素か<code>appendix</code>要素のいずれかであり、さらにそれが文脈節点の子の<code>book</code>の子であるようなものを選択する。</p> 
</item> 
<item><p><code>E</code>が節点列を返す式であるとき、式<code>E/.</code>は同じ節点列を<termref def="dt-document-order">文書順</termref>で返す。ただし、節点の識別性に基づき重複が除去される。</p></item> 
</ulist> 
</div3>	
</div2>	
<div2 id="id-sequence-expressions"> 
<head>列式</head> 
<p>XQueryは<termref def="dt-item">項目</termref>の<termref def="dt-sequence">列</termref>を構成したり選別したり結合したりする演算を支援している。列は決して入れ子にならない。例えば、値<code>1</code>, <code>(2, 3)</code>, <code>( )</code>を結合して1つの列にすると、結果は列<code>(1, 2, 3)</code>になる。</p> 
<div3 id="construct_seq"> 
<head>列の構成</head> 
<scrap headstyle="show"> 
<head/>  
 
<prod num="31" id="noid_N12B67.doc-xquery-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
 
<prod num="49" id="doc-xquery-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod>
</scrap> 
<p><termdef term="comma operator" id="dt-comma-operator">列を構成する1つの方法は、<term>コンマ演算子</term>を用いるというものである。この演算子は演算数をそれぞれ評価し、結果の列を順に連接し、1つの列を結果とする。</termdef> 空の括弧は空列を表すのに用いることができる。</p>
<p>列は原子値や節点を重複して含んでいてもよいが、列が別の列の項目になることは決してない。2つ以上の入力列を連接して新たな列を生成する場合、新たな列は、入力列の項目すべてを含み、かつその長さは入力列の長さの総和になる。</p> 
<note><p>関数呼び出しの引数など、文法中で<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>が必要とされる場所では、最上位のコンマ演算子を含む式はすべて括弧で囲まなければならない。</p></note>
<p>列を構成する式の例をいくつか示す。</p>
<ulist> 
<item> 
<p>この式の結果は、5つの整数の列である。</p> 
<eg role="parse-test" xml:space="preserve">(10, 1, 2, 3, 4)</eg> 
</item> 
<item> 
<p>この式はそれぞれ長さ1, 2, 0, 2である4つの列を結合し、長さ5の1つの列にする。この式の結果は列<code>10, 1, 2, 3, 4</code>になる。</p> 
<eg role="parse-test" xml:space="preserve">(10, (1, 2), (), (3, 4))</eg> 
 
 
</item> 
<item> 
<p>この式の結果は、文脈節点のすべての<code>salary</code>子節点の後ろにすべての<code>bonus</code>子節点が続くような列である。</p> 
<eg role="parse-test" xml:space="preserve">(salary, bonus)</eg> 
</item> 
<item> 
<p><code>$price</code>が値<code>10.50</code>に束縛されているとすると、この式の結果は列<code>10.50, 10.50</code>である。</p> 
<eg role="parse-test" xml:space="preserve">($price, $price)</eg> 
 
 
</item> 
</ulist> 
<p><term>範囲式</term>は連続した整数の列を構成するのに用いることができる。<code>to</code>演算子の演算数はそれぞれ、期待される引数の型が<code>xs:integer?</code>であるような関数の引数であるかのように、変換される。いずれかの演算数が空列であるか、第1演算数から導出される整数が第2演算数から導出される整数より大きければ、範囲式の結果は空列である。2つの演算数の変換結果が同じ整数になれば、範囲式の結果はその整数である。それ以外の場合は、結果は、2つの整数演算数、および2つの演算数の間の整数すべてからなる列であり、昇順に並べられる。</p> 
<ulist> 
<item> 
<p>この例では、列を構成する演算数の1つに範囲式を用いている。これを評価すると列<code>10, 1, 2, 3, 4</code>になる。</p> 
<eg role="parse-test" xml:space="preserve">(10, 1 to 4)</eg> 
 
</item><item><p>この例では、1つの整数<code>10</code>を含む長さ1の列を構成している。</p><eg role="parse-test" xml:space="preserve">10 to 10</eg></item>
<item><p>この例の結果は長さ0の列である。</p><eg role="parse-test" xml:space="preserve">15 to 10</eg></item>
<item><p>この例では、<code>fn:reverse</code>を用いて6つの整数の降順列を構成している。これを評価すると列<code>15, 14, 13, 12, 11, 10</code>となる。</p><eg role="parse-test" xml:space="preserve">fn:reverse(10 to 15)</eg></item> 
</ulist> 
</div3> 
<div3 id="id-filter-expr"><head>選別式</head>
<scrap headstyle="show"><head/>

<prod num="81" id="doc-xquery-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod>

<prod num="82" id="noid_N12C0E.doc-xquery-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod>
</scrap>
<p><termdef id="dt-filter-expression" term="filter expression"><term>選別式</term>は、単に、1つの<term>基本式</term>の後ろに0個以上の<termref def="dt-predicate">述語</termref>が続くものである。選別式の結果は、基本式によって返される項目のうち、それぞれの述語を左から右に順に適用することで選別を行ったものである。</termdef> 述語が全く指定されなければ、結果は単に基本式の結果である。選別式によって返される項目の順序は、基本式の結果の順序と同じである。項目に割り当てられる文脈位置は、結果の列中の順序位置に基づいて決められる。最初の文脈位置は1である。</p>
<p>選別式の例を以下に示す。</p>
<ulist>
<item><p>productsの列が変数で与えられているとすると、これらのproductsのうちpriceが100以上のものを返す。</p><eg role="parse-test" xml:space="preserve">$products[price gt 100]</eg></item>
<item><p>1から100までの整数のうち5で割り切れるものをすべて列挙する(<code>to</code>演算子についての説明は<specref ref="construct_seq"/>を見よ)。</p><eg role="parse-test" xml:space="preserve">(1 to 100)[. mod 5 eq 0]</eg></item>
<item><p>以下の式の結果は整数25である。</p><eg role="parse-test" xml:space="preserve">(21 to 29)[5]</eg></item>
<item><p>以下の例は、変数 <code>$orders</code> に束縛されている列の5番目から9番目までを返す。</p><eg role="parse-test" xml:space="preserve">$orders[fn:position() = (5 to 9)]</eg></item>
<item><p>次に示すのは、選別式を<termref def="dt-path-expression">経路式</termref>の<termref def="dt-step">ステップ</termref>として用いている例である。これは、変数<code>$book</code>に束縛されている本の中からchapterまたはappendixのうち最後のものを返す。</p><eg role="parse-test" xml:space="preserve">$book/(chapter | appendix)[fn:last()]</eg></item>
<item><p>次に示すのも、選別式を<termref def="dt-path-expression">経路式</termref>の<termref def="dt-step">ステップ</termref>として用いている例である。これは、指定された文書中の要素節点のうち、IDの値が<code>tiger</code>であるようなものを返す。</p><eg role="parse-test" xml:space="preserve">fn:doc("zoo.xml")/fn:id('tiger')</eg></item></ulist></div3><div3 id="combining_seq"> 
<head>節点列の結合</head> 
<scrap headstyle="show"> 
<head/>  
<prod num="52" id="doc-xquery-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod>
 
<prod num="53" id="doc-xquery-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod>
</scrap> 
<p>XQueryでは、節点列を結合する演算として次のようなものを用意している。</p>
<ulist>
<item><p><code>union</code>演算子と<code>|</code>演算子は等価である。これらは2つの節点列を演算数として取り、いずれかの演算数中に出現するすべての節点を含む列を返す。</p></item>
<item><p><code>intersect</code>演算子は2つの節点列を演算数として取り、どちらの演算数にも出現するすべての節点を含む列を返す。</p></item>
<item><p><code>except</code>演算子は2つの節点列を演算数として取り、第1演算数には出現するが第2演算数には出現しない節点をすべて含む列を返す。</p></item></ulist>
<p>これらの演算子はすべて、節点の識別性に基づき結果の列から重複した節点を取り除く。<phrase role="xquery">もし<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば、結果の列は<termref def="dt-document-order">文書順</termref>で返される。そうでない場合は、<termref def="dt-implementation-dependent">実装依存</termref>の順序で返される。</phrase></p>
<p><code>union</code>, <code>intersect</code>, <code>except</code>の演算数が節点でない項目を含んでいたならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<p>以下に、列を結合する式の例をいくつか示す。3つの要素節点が存在すると仮定しよう。これらをA, B, Cという記号名で参照する。また、変数<code>$seq1</code>,  <code>$seq2</code>, <code>$seq3</code>が、先に挙げた節点からなる以下のような列に束縛されていると仮定する。</p>
<ulist><item><p><code>$seq1</code>は (A, B) に束縛されている</p></item>
<item><p><code>$seq2</code>は (A, B) に束縛されている</p></item>
<item><p><code>$seq3</code>は (B, C)に束縛されている</p></item></ulist>
<p>このとき:</p> 
<ulist> 
<item> 
<p> <code role="parse-test">$seq1 union $seq2</code>を評価すると列 (A, B) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 union $seq3</code>を評価すると列 (A, B, C) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 intersect $seq2</code>を評価すると列 (A, B) になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 intersect $seq3</code>を評価すると B のみを含む列になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 except $seq2</code>を評価すると空列になる。</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 except $seq3</code>を評価すると A のみを含む列になる。</p> 
</item> 
</ulist> 
<p>ここで述べた列に関する演算子に加えて、<bibref ref="FunctionsAndOperators"/>には、添字を通して項目や列の部分列にアクセスするための関数、添字を通して列中から項目を削除したり列中に項目を挿入するための関数、列から重複した項目を削除するための関数がある。</p> 
</div3>	
</div2><div2 id="id-arithmetic"> 
<head>算術式</head> 
<p>XQueryは、加算、減算、乗算、除算、法などの算術演算子を、通常の単項や二項の形で用意している。</p> 
<scrap headstyle="show"> 
<head/> 
 
<prod num="50" id="doc-xquery-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod>
 
<prod num="51" id="doc-xquery-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod>
 
<prod num="58" id="doc-xquery-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod>

<prod num="59" id="doc-xquery-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt></rhs></prod>
</scrap> 
<p>減算演算子の前には空白を置かなければならない。そうしなければ、直前の字句の一部と解釈されることがある。例えば、<code role="parse-test">a-b</code>は1つの名前と解釈されるが、<code role="parse-test">a - b</code>や<code>a -b</code>は算術式と解釈される。(空白処理の詳細は<specref ref="whitespace-rules"/>を見よ。)</p>
<p>算術式の評価は、まず演算数を評価することから始まる。演算数を評価する順番は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>


<p><phrase role="xquery">各</phrase>演算数は以下のステップを順に適用することで評価される。</p><olist>
<item><p><termref def="dt-atomization">原子化</termref>が演算数に適用される。この操作の結果は<term>原子化済演算数</term>と呼ばれる。</p></item>
<item><p>原子化済演算数が空列であれば、算術式の結果は空列であり、実装は他の演算数を評価したり、演算子を適用したりする必要はない。しかし実装は、エラーが発生するか決めるために他の演算子を評価することを選択してもよい。</p></item>
<item><p>原子化済演算数が長さ1より大きい列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:double</code>に型変換される。型変換に失敗すれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。 [err:FORG0001]</p></item></olist>
<p>演算数の評価の後、演算数の型が与えられた算術演算子について正しい組み合わせであれば、演算子が演算数に適用される。結果は、原子値または<termref def="dt-dynamic-error">動的エラー</termref>となる。 (例えば、0で除算を行った結果はエラーになるかもしれない。) さまざまな算術演算子に受け入れられる原子型の組み合わせ、算術演算子の結果として期待される型については<specref ref="mapping"/>に列挙されている。ここには、それぞれの型の組み合わせに対して演算子の意味を定義する<termref def="dt-operator-function">演算子関数</termref>についても記述がある。演算子関数の定義は<bibref ref="FunctionsAndOperators"/>にある。</p>
<p>演算数の型が、評価の後、与えられた演算子について正しい組み合わせでないならば、<specref ref="mapping"/>のルールに従って、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p>XQueryは<code>div</code>と<code>idiv</code>という2種類の除算演算子を支援する。これらの演算子は、2つの演算数として任意の<termref def="dt-numeric">数</termref>型の値を許す。<bibref ref="FunctionsAndOperators"/>の説明の通り、<code>$arg1 idiv $arg2</code>は<code>($arg1 div $arg2) cast as xs:integer?</code>と等しい。ただしエラーの場合は除く。</p><p>以下に、算術式の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>以下の最初の式は<code>xs:decimal</code>の値<code role="parse-test">-1.5</code>を返し、2番目の式は<code>xs:integer</code>の値<code role="parse-test">-1</code>を返す。</p> 
<eg role="parse-test" xml:space="preserve">-3 div 2
-3 idiv 2</eg> 
 </item> 
<item> 
<p>2つの日付値の差の結果は<code>xs:dayTimeDuration</code>型の値になる。</p> 
<eg role="parse-test" xml:space="preserve">$emp/hiredate - $emp/birthdate</eg> 
</item> 
 
<item> 
<p>この例は減算演算子とハイフンの違いを示している。</p> 
<eg role="parse-test" xml:space="preserve">$unit-price - $unit-discount</eg> 
</item> 
<item> 
<p>単項演算子は二項演算子より優先度が高い。もちろんこれは、括弧の利用に左右される。従って、次の2つの例は異なる意味となる。</p> 
<eg xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</eg> 
</item> 
</ulist>	
<note><p id="note-consecutive-unary-ops"><bibref ref="XPath"/>との互換性のため、XQueryでは複数の単項算術演算子が連続して出現することが許される。</p></note></div2>	
<div2 id="id-comparisons"> 
<head>比較式</head> 
<p>比較式は、2つの値を比較することを許す。XQueryは、3種類の比較式を用意している。それぞれ、値比較、汎用比較、節点比較という。</p> 
<scrap headstyle="show"> 
<head/> 
<prod num="48" id="doc-xquery-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod>
 
<prod num="61" id="doc-xquery-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="60" id="doc-xquery-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod>
 
<prod num="62" id="doc-xquery-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod>
</scrap> 




<div3 id="id-value-comparisons"> 
<head>値比較</head> 
<p>値比較演算子は<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>である。値比較は単一値を比較するのに用いられる。</p> 
<p>値比較の評価で最初に行われるのは演算数の評価である。演算数が評価される順番は<termref def="dt-implementation-dependent">実装依存</termref>である。各演算数は以下のステップを順に適用することで評価される。</p>
<olist>
<item><p><termref def="dt-atomization">原子化</termref>が演算数に対して適用される。この操作の結果は<term>原子化済演算数</term>と呼ばれる。</p></item>
<item><p>原子化済演算数が空列であれば、値比較の結果は空列であり、実装は、他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p></item>
<item><p>原子化済演算数が長さ1より大きい列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化済演算数が<code>xs:untypedAtomic</code>型であれば、<code>xs:string</code>に型変換される。</p>
<note><p>このルールの目的は、値比較を推移的にするためである。利用者は、汎用比較演算子は<code>xs:untypedAtomic</code>演算数に関する別の型変換ルールを持っていることに気づくべきである。また利用者は、型変換での正確さを犠牲にすることで、値比較の推移性が妥協されてもよいということにも気づくべきである (例えば、ほんの少し異なる2つの<code>xs:integer</code>の値は、<code>xs:float</code>が<code>xs:interger</code>よりも正確さに欠けるために、同じ<code>xs:float</code>の値だとみなされてもよい)。</p></note></item></olist>
<p>次に、可能ならば、<termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって2つの演算数がそれらの最小共通型に変換される。例えば、演算数が <code>hatsize</code> 型 (<code>xs:integer</code> から導出される) と <code>shoesize</code> 型 (<code>xs:float</code> から導出される) であれば、それらの最小共通型は <code>xs:float</code> である。</p>
<p>最後に、演算数の型が与えられた演算子について正しい組み合わせであれば、演算子が演算数に対して適用される。さまざまな値比較演算子について、認められる原子型の組み合わせや、その演算子の結果として期待される型は<specref ref="mapping"/>にある。ここではまた<termref def="dt-operator-function">演算子関数</termref>についても記述されている。これは、型の組み合わせそれぞれに対して演算子の意味を定義するものである。演算子関数の定義は<bibref ref="FunctionsAndOperators"/>にある。</p>
<p>直観的には、2つの原子化済演算数がともにまったく1つの原子値からなっているならば、比較の結果は次のようになる。もし第1演算数の値が第2演算数の値 (に等しい, に等しくない, より小さい, より小さいか等しい, より大きい, より大きいか等しい) ならば、結果は<code>true</code>である。それ以外の場合には、比較の結果は<code>false</code>である。</p>
<p>演算数を評価した後、その演算数の型が与えられた演算数について正しくない組み合わせであれば、<specref ref="mapping"/>のルールに従って、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<p>以下に、値比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>次の比較は、式<code>$book/author</code>によって返される節点を原子化する。比較が真になるのは、原子化の結果が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての値 "Kennedy" である場合だけである。原子化の結果が空列であれば、比較の結果は空列になる。原子化の結果が2個以上の値を含む列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
<eg role="parse-test" xml:space="preserve">$book1/author eq "Kennedy"</eg> 
</item>
<item><p>次の<termref def="dt-path-expression">経路式</termref>は、重さが100以上の製品を選択する述語を含む。<code>weight</code>部分要素を持たない製品については、この述語の値は空列であり、その製品は選択されない。この例では、<code>weight</code> は検証された要素であり、数型であると仮定している。</p><eg role="parse-test" xml:space="preserve">//product[weight gt 100]</eg></item>
<item role="xquery"><p>以下の比較は true である。なぜなら、それぞれの場合で、構成された2つの節点は、異なる識別性や名前を持つが、原子化すると同じ値を持つからである:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</eg><eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</eg></item>
<item><p>次の比較が真になるのは、<code>my:hatsize</code>と<code>my:shoesize</code>がともに、原子型<termref def="dt-numeric">numeric</termref>から制限によって導出されるユーザ定義型である場合である。</p><eg role="parse-test" xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</eg></item> 
<item><p>以下の比較は true である。<code>eq</code> は2つの QName について、それらの名前空間 URI と局所名をコード位置により比較を行うことにより、比較する。名前空間接頭辞は無視する。</p><eg role="parse-test" xml:space="preserve">fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")</eg></item>
</ulist> 
</div3> 
<div3 id="id-general-comparisons"> 
<head>汎用比較</head> 
<p>汎用比較演算子は<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>である。汎用比較は存在限量比較であり、任意の長さの列の演算数に適用してもよい。汎用比較の結果は、エラーが発生しないときは常に<code>true</code>か<code>false</code>である。</p>


<p><phrase role="xquery"/>汎用比較は以下のルールを順に適用することで評価される。</p>
<olist><item><p><termref def="dt-atomization">原子化</termref>が各演算数に適用される。原子化の結果、各演算数は原子値の列になる。</p></item>
<item><p>比較の結果が<code>true</code>になるのは、原子値の組が存在し、その1つは第1演算数の列、もう一方が第2演算数の列であり、それらが要求された<term>大小関係</term>を持っているとき、かつその時に限る。それ以外の場合には、比較の結果は<code>false</code>になる。2つの原子値間の<term>大小関係</term>は、以下のルールを順に適用することで決定される。これらのルールによって呼び出される<code>cast</code>演算子が成功しなければ、動的エラーが発生する。 [err:FORG0001]</p>
<note role="xquery"><p>これらのルールの目的は、XPath 1.0 との互換性を保つためである。XPath 1.0 では (例えば) <code>x &lt; 17</code>は、<code>x</code>が型付けされていない値であれば、数比較である。ユーザは、値比較演算子では<code>xs:untypedAtomic</code>の演算数を型変換するためのルールが異なることに注意すべきである。</p></note>
<olist><item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<termref def="dt-numeric">数</termref>型のインスタンスであれば、<code>xs:untypedAtomic</code>の値が<code>xs:double</code>型に型変換される。</p></item>
<item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:untypedAtomic</code>または<code>xs:string</code>のインスタんであれば、<code>xs:untypedAtomic</code>の値 (または両方) が<code>xs:string</code>型に型変換される。</p></item>
<item><p>原子値のいずれか1つが<code>xs:untypedAtomic</code>のインスタンスであり、もう一方が<code>xs:string</code>, <code>xs:untypedAtomic</code>, または任意の<termref def="dt-numeric">数</termref>型のどれでもなければ、<code>xs:untypedAtomic</code>の値がもう一方の<termref def="dt-dynamic-type">動的型</termref>に型変換される。</p></item>
<item><p>上に述べた変換を行った後、値比較演算子<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>のいずれかを用いて原子値が比較される。どれを用いるかは、汎用比較演算子が<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, <code>&gt;=</code>のどれであったかに依存する。値が、要求される<term>大小関係</term>を持つのは、この値比較の結果が<code>true</code>である場合、かつその時に限る。</p></item></olist></item></olist>
<p>いずれかの演算数が項目の列である汎用比較を評価するとき、実装は、第1演算数と第2演算数から、要求される<term>大小関係</term>を持つ項目を1つずつ見つけると直ちに<code>true</code>を返してもよい。同様に、汎用比較は、いずれかの演算数を評価しているときや2つの演算数から選んだ項目の組を比較するときにエラーが生じれば、直ちに<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。これらのルールの結果として、エラーが存在するときには、汎用比較の結果は決定的ではない。</p> 
 
 
<p>以下に、汎用比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>以下の比較は、<code>$book1</code>の任意の部分要素<code>author</code>について、その<termref def="dt-typed-value">型付けされた値</termref>が<code>xs:string</code>または<code>xs:untypedAtomic</code>のインスタンスとしての "Kennedy" であるとき、trueになる。</p>
<eg role="parse-test" xml:space="preserve">$book1/author = "Kennedy"</eg> 
</item>
<item><p>以下の例は3つの汎用比較を含む。初めの2つの比較の値は<code>true</code>であり、3つ目の比較の値は<code>false</code>である。この例は、汎用比較は推移的ではないという事実を示している。</p>
<eg xml:space="preserve">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</eg></item>
<item><p>以下の例は2つの汎用比較を含む。これらはいずれも<code>true</code>である。この例は、<code>=</code>と<code>!=</code>は互いに逆ではないという事実を示している。</p><eg xml:space="preserve">(1, 2) = (2, 3)
(1, 2) != (2, 3)</eg></item>
<item><p><code>$a</code>, <code>$b</code>, <code>$c</code>がそれぞれ、型注釈<code>xs:untypedAtomic</code>を持ち、<termref def="dt-string-value">文字列値</termref> "<code>1</code>", "<code>2</code>"、および"<code>2.0</code>" を持つ要素節点に束縛されているとする。このとき <code>($a, $b) = ($c, 3.0)</code>は<code>false</code>を返す。なぜなら<code>$b</code>と<code>$c</code>は文字列として比較されるためである。しかし<code>($a, $b) = ($c, 2.0)</code>は<code>true</code>を返す。なぜなら<code>$b</code>と<code>2.0</code>は数として比較されるためである。</p></item> 
</ulist> 
</div3> 
<div3 id="id-node-comparisons"> 
<head>節点比較</head> 
<p>節点比較は、2つの節点を識別性または<termref def="dt-document-order">文書順</termref>に基づいて比較するのに用いられる。節点比較の結果は以下のルールにより定義される。</p> 
<olist> 
<item> 
<p>節点比較の演算数が<termref def="dt-implementation-dependent">実装依存</termref>の順で評価される。</p></item>
<item><p>各演算数は単一の節点か空列でなければならない。そうでない場合は<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
</item> 
<item> 
<p>いずれかの演算数が空列であれば、比較の結果は空列であり、実装は他の演算数を評価したり演算子を適用したりする必要はない。しかし実装は、エラーが発生するかどうかを決定するために他の演算数を評価することを選択してもよい。</p> 
</item> 
<item> 
<p><code>is</code>演算子による比較が<code>true</code>を返すのは、2つの演算数が同じ識別性を持っており、したがって同じ節点である場合である。そうでない場合は<code>false</code>を返す。節点の識別性の定義は<bibref ref="datamodel"/>を見よ。</p> 
</item> 
<item> 
<p><code>&lt;&lt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<termref def="dt-document-order">文書順</termref>で前にある場合である。そうでない場合は<code>false</code>を返す。</p> 
</item> 
<item> 
<p><code>&gt;&gt;</code>演算子による比較が<code>true</code>を返すのは、左側の演算数が右側の演算数より<termref def="dt-document-order">文書順</termref>で後ろにある場合である。そうでない場合は<code>false</code>を返す。</p>
</item></olist> 
<p>以下に、節点比較の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>次の比較が真になるのは、左辺と右辺を評価した結果がそれぞれ完全に同じ単一節点になる場合のみである。</p> 
<eg role="parse-test" xml:space="preserve">/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</eg> 
</item> 
<item role="xquery"><p>以下の比較は false である。なぜなら構成された節点はそれぞれ固有の識別性を持っているからである。</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</eg></item>
<item> 
<p>次の比較が真になるのは、左辺によって識別される節点が、右辺によって識別される節点よりも文書順で前に出現する場合のみである。</p>
<eg role="parse-test" xml:space="preserve">/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]</eg> 
</item></ulist> 
</div3> 
	
</div2>	
<div2 id="id-logical-expressions"> 
<head>論理式</head> 
<p><term>論理式</term>は<term>and式</term>か<term>or式</term>のいずれかである。ある論理式がエラーを発生しない場合、結果は常にブール値<code>true</code>か<code>false</code>のいずれかである。</p> 
<scrap headstyle="show"> 
<head/>  
<prod num="46" id="doc-xquery-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod>
 
<prod num="47" id="doc-xquery-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod>
</scrap> 
<p>論理式の評価は、まず各演算数の<termref def="dt-ebv">有効ブール値</termref>を見つけることから始まる (<specref ref="id-ebv"/>を見よ)。</p> 
 
<p>and式の値は、演算数の有効ブール値 (EBV) により、次の表のように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV"><tbody><tr><td rowspan="1" colspan="1">AND:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub>でエラー
</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">エラー</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>
= <code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><phrase role="xquery"><code>false</code>かエラー</phrase></td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>でエラー
</td><td rowspan="1" colspan="1">エラー</td><td rowspan="1" colspan="1"><phrase role="xquery"><code>false</code>かエラー</phrase></td><td rowspan="1" colspan="1">エラー</td></tr></tbody></table>
<p>or式の値は、演算数の有効ブール値 (EBV) により、次の表にあるように決定される。</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV"><tbody><tr><td rowspan="1" colspan="1">OR:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub>でエラー</td></tr>
<tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><phrase role="xquery"><code>true</code>かエラー</phrase></td></tr>
<tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>false</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">エラー</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>でエラー</td><td rowspan="1" colspan="1"><phrase role="xquery"><code>true</code>かエラー</phrase></td><td rowspan="1" colspan="1">エラー</td><td rowspan="1" colspan="1">エラー</td></tr></tbody></table>

<p><phrase role="xquery">論理式の演算数が評価される順序は<termref def="dt-implementation-dependent">実装依存</termref>である。上の表では、次のように定義されている。</phrase>or-式は、1番目の式を評価するとtrueになれば、<code>true</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。同様に、and式は、1番目の式を評価するとfalseになれば、<code>false</code>を返すことができる。また1番目の式を評価するとエラーが発生した場合、エラーを発生することができる。これらのルールの結果として、論理式は、エラーが存在する場合、非決定的である。その例を以下に示す。</p>
<p>以下に、論理式の例をいくつか示す。</p>
 
<ulist>
<item><p>次の式は<code>true</code>を返す。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 and 2 eq 2</eg><eg role="parse-test" xml:space="preserve">1 eq 1 or 2 eq 3</eg></item>
<item><p>次の式は<code>false</code>を返すか<termref def="dt-dynamic-error">動的エラー</termref>を発生する。</p>
<eg role="parse-test" xml:space="preserve">1 eq 2 and 3 idiv 0 = 1</eg></item>
<item><p>次の式は<code>true</code>を返すか<termref def="dt-dynamic-error">動的エラー</termref>を発生する。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 or 3 idiv 0 = 1</eg></item>
<item><p>次の式は<termref def="dt-dynamic-error">動的エラー</termref>を発生しなければならない。</p>
<eg role="parse-test" xml:space="preserve">1 eq 1 and 3 idiv 0 = 1</eg></item></ulist>

<p>and式、or式に加え、XQueryは<code>fn:not</code>という関数を用意している。これは引数として一般の列をとり、ブール値を返す。<code>fn:not</code>関数の定義は<bibref ref="FunctionsAndOperators"/>にある。<code>fn:not</code>関数は、引数を<termref def="dt-ebv">有効ブール値</termref>に縮退する。そして、引数の有効ブール値が<code>false</code>であれば<code>true</code>を返し、引数の有効ブール値が<code>true</code>であれば<code>false</code>を返す。引数の有効ブール値を求める際にエラーが起これば、<code>fn:not</code>は同じエラーを発生する。</p>

	
</div2>	
	

<div2 role="xquery" id="id-constructors"> 
<head role="xquery">構成子</head> 
<p>XQueryは、XMLの構造を問合せ中で生成できる構成子を用意している。
構成子は、要素節点、属性節点、文書節点、テキスト節点、コメント節点、処理命令節点に対して用意されている。2種類の構成子が用意されている: <term>直接構成子</term>と<term>被計算構成子</term>である。前者はXMLに似た記法を用い、後者は囲まれた式に基づいた記法を用いる。</p> 
<scrap headstyle="show"> 
<head/> <prod num="94" id="doc-xquery-Constructor"><lhs>Constructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt></rhs></prod> 
<prod num="95" id="doc-xquery-DirectConstructor"><lhs>DirectConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt></rhs></prod><prod num="96" id="doc-xquery-DirElemConstructor"><lhs>DirElemConstructor</lhs><rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs></prod> 
<prod num="101" id="doc-xquery-DirElemContent"><lhs>DirElemContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CDataSection</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt></rhs></prod><prod num="148" id="doc-xquery-ElementContentChar"><lhs>ElementContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs></prod> 
<prod num="102" id="doc-xquery-CommonContent"><lhs>CommonContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt></rhs></prod><prod num="107" id="doc-xquery-CDataSection"><lhs>CDataSection</lhs><rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs></prod><prod num="108" id="doc-xquery-CDataSectionContents"><lhs>CDataSectionContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs></prod><prod num="97" id="doc-xquery-DirAttributeList"><lhs>DirAttributeList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs></prod> 
<prod num="98" id="doc-xquery-DirAttributeValue"><lhs>DirAttributeValue</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs></prod> 
 
<prod num="99" id="doc-xquery-QuotAttrValueContent"><lhs>QuotAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod><prod num="100" id="doc-xquery-AposAttrValueContent"><lhs>AposAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod><prod num="149" id="doc-xquery-QuotAttrContentChar"><lhs>QuotAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs></prod><prod num="150" id="doc-xquery-AposAttrContentChar"><lhs>AposAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs></prod><prod num="146" id="doc-xquery-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="147" id="doc-xquery-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="29" id="doc-xquery-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod> 
</scrap> 
	
<p>この節は、さまざまな種類の構成子式の意味についての概念的説明を含む。XQuery の実装は、この節で述べた処理ステップと同じ結果を生成する任意の実装技術を自由に用いてよい。</p>
<div3 id="id-element-constructor"><head>直接要素構成子</head><p><term>要素構成子</term>は要素節点を生成する。 <termdef term="direct element constructor" id="dt-direct-elem-const"><term>直接要素構成子</term>は、構成される要素の名前が定数であるような要素構成子の形式である。</termdef> 直接要素構成子は標準的なXMLの記法に基づいている。例えば、以下の式は直接要素構成子であり、属性一つおよび入れ子になった要素をいくつか含む<code>book</code>要素を生成する。</p> 
<eg role="parse-test" xml:space="preserve">&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</eg> 
<p>直接要素構成子中の要素名が名前空間接頭辞を持っていれば、その名前空間接頭辞は<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて名前空間URIに解決される。もし要素名が名前空間接頭辞を持たないならば、<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>により暗黙的に修飾される。静的既知名前空間もデフォルト要素/型名前空間も、<termref def="dt-namespace-decl-attr">名前空間定義属性</termref>から影響を受けてもよいことに注意すること。要素名の名前空間接頭辞は、QNameを展開した後も保持される。これについては<bibref ref="datamodel"/>に記述されている通りである。結果として得られる<termref def="dt-expanded-qname">展開済QName</termref>が、構成された要素節点の<code>node-name</code>性質になる。</p><p>直接要素構成子では、終了タグ中で用いられる名前は、対応する開始タグ中で用いられる名前と、接頭辞や接頭辞のあるなしを含めて、完全に一致しなければならない。</p> 
 
<p>直接要素構成子では、波括弧 { } は<term>囲まれた式</term>を区切り、リテラルテキストから区別する。囲まれた式は、評価された後その値と置き換えられる。以下の例の通りである:</p> 
<eg role="parse-test" xml:space="preserve">&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;</eg> 
<p>上の問合せは、次のような結果を生成するかもしれない (読みやすくするために、この結果には空白を加えている。この文書中の他の例でも同様である):</p> 
<eg role="parse-test" xml:space="preserve">
&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;</eg><p>XQuery では囲まれた式を表すのに波括弧を用いるため、通常の文字として用いられる波括弧を表すにはある種の約束が必要である。この目的のため、要素や属性の内容中に現れる二重の波括弧は、XQuery では一重の波括弧として解釈される。 (すなわち、組 "<code>{{</code>" は文字 "<code>{</code>" を、組 "<code>}}</code>" は文字 "<code>}</code>"を表す。) 代替案として<termref def="dt-character-reference">文字参照</termref> <code>&amp;#x7b;</code>と<code>&amp;#x7d;</code>も波括弧文字を表すのに用いることができる。一重の左波括弧 ("<code>{</code>") は、囲まれた式の開始区切り記号と解釈される。一重の右波括弧 ("<code>}</code>")
は、左波括弧と対応しない場合<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0003"/>として扱われる。</p>
<p>要素構成子の結果は新しい要素節点であり、固有の節点識別性を持つ。新たな要素節点の属性や子孫節点もまた新たな節点であり、固有の識別性を持つ。すでに存在する節点の複製であっても、このようになる。</p>
<div4 id="id-attributes"><head>属性</head>
<p>直接要素構成子の開始タグには1つ以上の属性が含まれていてもよい。XMLと同様に、属性はそれぞれ名前と値によって指定される。直接要素構成子では、各属性の名前は定数のQNameで指定され、属性の値は一重引用符または二重引用符で囲まれた文字列によって指定される。要素構成子の主内容と同様に、属性の値には波括弧で囲まれた式が含まれていもよい。これは要素構成子の処理において、評価された後、その値によって置き換えられる。</p>
<p>直接要素構成子中の各属性は新たな属性節点を生成する。生成された節点は固有の節点識別性を持ち、その親は構成された要素節点である。しかし、<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref> (<specref ref="id-namespaces"/>を見よ) は属性節点を生成しないことに注意せよ。</p>
<p>属性名が名前空間接頭辞を持つならば、その接頭辞は、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて名前空間URIに解決される。属性名が名前空間接頭辞を持たないならば、その属性はどの名前空間にも属さない。属性名を解決するのに用いられる静的既知名前空間は、その要素構成子中にある<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>から影響を受けてもよいことに注意せよ。属性名の名前空間接頭辞は、QNameを展開した後も保持される。これについては<bibref ref="datamodel"/>に記述されている通りである。結果として得られる<termref def="dt-expanded-qname">展開済QName</termref>は、構成された属性節点の<code>node-name</code>性質となる。</p>
<p>直接要素構成子中の属性が、それぞれの<code>node-name</code>性質として、互いに区別される<termref def="dt-expanded-qname">展開済QName</termref>を持たないならば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0040"/>。</p>
<p>概念的には、直接要素構成子中の属性 (名前空間宣言属性を除く) は以下のステップによって処理される。</p>
<olist>
<item><p>属性の内容中のリテラル文字の連続列それぞれが、それらの文字を含む文字列として扱われる。次に属性値の正規化が適用され、空白の正規化、および<termref def="dt-character-reference">文字参照</termref>や<termref def="dt-predefined-entity-reference">定義済実体参照</termref>の展開が行われる。XML 1.0 を支援する XQuery 処理器は、<bibref ref="XML"/>の 3.3.3節にある属性値の正規化のルールを用いる。XML 1.1 を支援する XQuery 処理器は、<bibref ref="XML1.1"/>の 3.3.3 節にある属性値の正規化のルールを用いる。いずれの場合も、正規化ルールは、その属性の型が CDATA (先頭及び末尾の空白文字は取り除かれない。) であるかのように適用される。XML 1.0 のルールと XML 1.1 のルールのどちらを選択するかは<termref def="dt-implementation-defined">実装定義</termref>である。</p></item>
<item><p>以下のように、囲まれた式がそれぞれ文字列に変換される:</p>
<olist>
<item><p>囲まれた式の値に対して<termref def="dt-atomization">原子化</termref>が適用され、原子値列に変換される。</p></item>
<item><p>原子化の結果が空列であれば、結果は長さ0の文字列である。そうでない場合、原子化された列中の原子値がそれぞれ文字列に型変換される。</p></item>
<item><p>前のステップから結果として得られる個々の文字列が、間に1つの空白文字を置きながら連接され、1つの文字列にまとめられる。</p></item>
</olist></item>
<item><p>前のステップの結果得られる隣接する文字列が、間に空白を挟まずに連接される。結果の文字列は、属性節点の<code>string-value</code>性質となる。属性節点には<termref def="dt-type-annotation">型注釈</termref> (<code>type-name</code>性質) <code>xs:untypedAtomic</code> が与えられる (この型注釈は、親要素が妥当性検証されれば変更されてもよい)。属性節点の<code>typed-value</code>性質は<code>string-value</code>と同じであり、<code>xs:untypedAtomic</code>のインスタンスである。</p></item>
<item><p>属性節点の<code>parent</code>性質は、この属性を含み、直接要素構成子によって構成された要素節点に設定される。</p></item>
<item><p>属性名が<code>xml:id</code>であるならば、その属性の文字列値と型付けされた値はさらに正規化される。すなわち、先頭と末尾の空白文字 (#x20) が削除され、空白文字 (#x20) の列が単一の空白文字 (#x20) に置き換えられる。</p>
<note><p>このステップで、<bibref ref="XMLID"/>で定義されている<code>xml:id</code>の処理が完結する。</p></note></item>
<item><p>属性名が<code>xml:id</code>であるならば、結果として得られる属性節点の<code>is-id</code>性質が<code>true</code>に設定される。そうでない場合は、<code>is-id</code>性質は<code>false</code>に設定される。属性節点の<code>is-idrefs</code>性質は無条件に<code>false</code>に設定される。</p></item>
</olist>
<ulist>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;shoe size="7"/&gt;</eg><p><code>size</code>属性の文字列値は "<code>7</code>" である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;shoe size="{7}"/&gt;</eg><p><code>size</code>属性の文字列値は "<code>7</code>" である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;shoe size="{()}"/&gt;</eg><p><code>size</code>属性の文字列値は長さ0の文字列である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;</eg><p><code>ref</code>属性の文字列値は "<code>[1 5 6 7 9]</code>" である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;shoe size="As big as {$hat/@size}"/&gt;</eg><p><code>size</code>属性の文字列値は "<code>As big as </code>" と式<code>$hat/@size</code>で表される節点の文字列値を連接したものになる。</p></item>
</ulist></div4>
<div4 id="id-namespaces"><head>名前空間宣言属性</head>
<p>構成された要素やその属性の名前は<term>名前空間接頭辞</term>を含む <termref def="dt-qname">QNames</termref> であってもよい。名前空間接頭辞は <termref def="dt-prolog">前書き</termref> や<term>名前空間宣言属性</term>によって名前空間に束縛することができる。名前空間に束縛されていない名前空間接頭辞を用いると、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0081"/>。</p>
<p><termdef term="namespace declaration attribute" id="dt-namespace-decl-attr"><term>名前空間宣言属性</term>は、直接要素構成子の内部で用いられる。その目的は、構成された要素節点やその属性に対して、名前空間接頭辞を束縛したり、<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>を設定することである。</termdef> 構文的には、名前空間宣言属性は、名前空間接頭辞<code>xmlns</code>を持つ属性の形式をしているか、もしくは名前が<code>xmlns</code>で名前空間接頭辞を持たない属性の形式をしている。名前空間宣言属性の値は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>でなければならない。そうでない場合は<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0022"/>。与えられた要素の名前空間宣言属性はすべて、互いに区別される名前を持たなければならない <errorref class="ST" code="0071"/>。それぞれの名前空間宣言属性は次のように処理される:</p>
<ulist>
<item><p>属性名の局所部分は名前空間宣言として解釈される。また、その属性の値は名前空間URIとして解釈される。この接頭辞とURIが構成子式の<termref def="dt-static-namespaces">静的既知名前空間</termref>に追加される (与えられた接頭辞の束縛が存在する場合はそれを上書きする) 。また、構成された要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>にも名前空間束縛として追加される。名前空間URIが長さ0の文字列であり、実装が<bibref ref="XMLNAMES11"/>を支援しているならば、与えられた接頭辞に対する名前空間束縛が、構成された要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>、および構成子式の<termref def="dt-static-namespaces">静的既知名前空間</termref>から削除される。もし名前空間URIが長さ0の文字列で、実装が<bibref ref="XMLNAMES11"/>を支援しないならば、静的エラーが発生する <errorref code="0085" class="ST"/>。実装が<bibref ref="XMLNAMES"/>か<bibref ref="XMLNAMES11"/>のいずれを支援するかは、<termref def="dt-implementation-defined">実装定義</termref>である。</p></item>
<item><p>名前空間宣言属性の名前が<code>xmlns</code>で接頭辞を持たないならば、その属性の値が名前空間URIとして解釈される。このURIは、構成子式の<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>を指定する (すでにデフォルトが存在する場合は上書きする)。また、構成された要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>にも(接頭辞なしで)加えられる (接頭辞なしの名前空間束縛が存在するなら、それを上書きする)。もし名前空間URIが長さ0の文字列であれば、構成子式の<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>が "none" に設定され、接頭辞なしの名前空間束縛が、構成された要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>から削除される。</p></item>
<item><p>名前空間宣言属性が名前空間URIを既定義接頭辞 <code>xml</code> または <code>xmlns</code> に束縛したり、<code>xml</code> 以外の接頭辞を名前空間URI <code>http://www.w3.org/XML/1998/namespace</code> に束縛すると、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0070"/>。</p></item>
</ulist>
<p>名前空間宣言属性は、生成される属性節点には影響を与えない。</p>
<p>以下に、名前空間宣言属性の例を示す:</p>
<ulist>
<item><p>この要素構成子では、名前空間宣言属性を用いて<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>を<code>http://example.org/animals</code>に設定している:<eg role="parse-test" xml:space="preserve">&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;</eg></p></item>
<item><p>この要素構成子では、名前空間宣言属性を用いて、名前空間接頭辞 <code>metric</code> と <code>english</code> を束縛している:</p> 
<eg role="parse-test" xml:space="preserve">&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;</eg></item>
</ulist></div4>
<div4 id="id-content"><head>内容</head>
<p>直接要素構成子のうち、開始タグと終了タグの間の部分を、その要素構成子の<term>内容</term>という。この内容は、テキスト文字 (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt>と構文解析される), 入れ子になった直接構成子, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CdataSections</nt>, 文字参照および<termref def="dt-predefined-entity-reference">既定義実体参照</termref>, 波括弧で囲まれた式から構成されてもよい。一般に、囲まれた式の値は節点や原子値の列であってもよい。囲まれた式は要素構成子の内容の中で用いることができ、構成された節点の内容や属性を計算するのに用いられる。</p> 
 
<p>概念的には、要素構成子の内容は次のように処理される:</p>
<olist>
<item><p>内容が評価され、節点列が以下のように生成される。この列を<term>内容列</term>という:</p>
<olist>
<item><p>もし<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-boundary-space-policy">境界空白ポリシー</termref>が<code>strip</code>であれば、<termref def="dt-boundary-whitespace">境界空白</termref>が識別され、削除される (境界空白の定義は<specref ref="id-whitespace"/>を見よ)。</p></item>
<item><p><termref def="dt-predefined-entity-reference">既定義実体参照</termref>と<termref def="dt-character-reference">文字参照</termref>は、参照している文字列に展開される。これについては<specref ref="id-literals"/>に記述されている通りである。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CDataSection</nt>内部の文字は、<code>&lt;</code> や <code>&amp;</code> のような特殊文字も含め、マークアップ文字ではなくリテラル文字として扱われる (列 <code>]]&gt;</code> を除く。これは CDataSection を終了する)。</p></item>
<item><p>リテラル文字の連続列は、それらの文字を含む単一のテキスト節点として評価される。</p></item>
<item><p>入れ子の直接構成子はそれぞれ、<specref ref="id-element-constructor"/>あるいは<specref ref="id-otherConstructors"/>のルールに従って評価され、その結果は新たな要素節点、コメント節点、処理命令節点いずれか1つになる。次に、結果として得られる節点の <code>parent</code> 性質が、新たに構成された要素節点に設定される。</p></item>
<item><p>囲まれた式は以下のように評価される:</p>
<olist>
<item><p>囲まれた式によって返される1個以上の原子値からなる隣接列それぞれに対して、新たなテキスト節点が構成される。これには、それぞれの原子値を文字列に型変換した結果が含まれるが、隣接した値の間には1つの空白文字が挟まれる。</p>
<note><p>隣接した値の間への空白文字の挿入は、一方、もしくは両方の値が長さ0の文字列であっても適用される。</p></note></item>
<item><p>囲まれた式によって返される節点それぞれに対して、与えられた節点、およびその節点を先祖として持つすべての節点の複製が新たに作られる。これらをまとめて<term>複製された節点</term>と呼ぶ。複製された節点の性質は以下のようになる:</p>
<olist>
<item><p>複製された節点はそれぞれ新しい節点識別性を獲得する。</p></item>
<item><p>複製された節点の<code>parent</code>性質, <code>children</code>性質, <code>attributes</code>性質は、節点間の関連を保存するように設定される。最上位の節点 (囲まれた式によって直接返される節点) に対して、<code>parent</code> 性質は、この構成子によって構成された節点に設定される。</p></item>
<item><p>もし<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-construction-mode">構成モード</termref>が<code>strip</code>であれば:</p>
<olist>
<item><p>複製された節点が要素節点であれば、<code>type-name</code> 性質は <code>xs:untyped</code> に設定される。<code>nilled</code>性質, <code>is-id</code>性質, <code>is-idrefs</code> 性質は<code>false</code>に設定される。</p></item>
<item><p>複製された節点が属性節点であれば、<code>type-name</code> 性質は <code>xs:untypedAtomic</code> に設定される。<code>is-idrefs</code> 性質は <code>false</code> に設定される。<code>is-id</code> 性質は、その属性節点の修飾名が <code>xml:id</code> であれば、<code>true</code> に設定され、そうでなければ <code>false</code> に設定される。</p> </item>
<item><p>複製された要素節点や属性節点それぞれについて、<code>string-value</code> はそのまま変更されない。また <code>typed-value</code> は <code>xs:untypedAtomic</code> のインスタンスとしての <code>string-value</code> に等しい。<note><p>節点の<termref def="dt-typed-value">型付けされた値</termref>のみを保存している実装では、この段階で型付けされた値を文字列形式に変換することが求められる。</p></note></p></item>
</olist>
<p>一方、もし<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-construction-mode">構成モード</termref>が<code>preserve</code>であれば、複製された節点の<code>type-name</code>, <code>nilled</code>, <code>string-value</code>, <code>typed-value</code>, <code>is-id</code>, <code>is-idrefs</code> の各性質は保存される。</p></item>
<item><p>複製された要素節点の<code>in-scope-namespaces</code> 性質は以下のルールによって決定される。これらのルールを適用するとき、デフォルト名前空間や、デフォルト名前空間の欠如はほかの名前空間束縛と同様に扱われる:</p>
<olist>
<item><p>もし<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref> が <code>preserve</code>と指定されていれば、元の要素の有効範囲内名前空間がすべて新しい複製中に保持される。もし<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref> が <code>no-preserve</code>と指定されていれば、新しい複製は、元の要素の有効範囲内名前空間のうち、その要素名や属性に用いられているものしか保持しない。この場合、もし複製された要素や任意の属性の<termref def="dt-typed-value">型付けされた値</termref>が<termref def="dt-namespace-sensitive">名前空間に対して敏感</termref>であれば、<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0086"/> である。<termdef term="namespace-sensitive" id="dt-namespace-sensitive">値が<term>名前空間に対して敏感</term>であるとは、その値に、<termref def="dt-dynamic-type">動的型</termref>が<code>xs:QName</code>または<code>xs:NOTATION</code>、または制限によって<code>xs:QName</code>か<code>xs:NOTATION</code>から導出されるかのいずれかであるような項目が含まれていることである。</termdef></p>
<note><p>エラー <errorref class="TY" code="0086"/> の発生する可能性があるのは、<termref def="dt-construction-mode">構成モード</termref>が<code>preserve</code>の場合のみである。なぜならば、そうでない場合、複製された節点の型付けされた値は決して名前空間に対して敏感ではないからである。</p></note></item>
<item><p>もし<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref> が <code>inherit</code>と指定されていれば、複製された節点は構成された節点の有効範囲内名前空間をすべて継承し、元の要素の有効範囲内名前空間のうち先のルールで保存されたものによって、その拡張や上書きを行う。もし<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref> が <code>no-inherit</code>と指定されていれば、複製された節点は構成された節点からどの有効範囲内名前空間も継承しない。</p></item></olist></item>
<item><p>要素または処理命令節点が複製されたとき、その<code>base-uri</code>性質は、新しい親節点と同じに設定される。ただし、以下の例外がある: 複製された要素節点が<code>xml:base</code>属性を持っていれば、その節点の<code>base-uri</code>性質は、その属性の値に設定される。このとき、この値は(もし相対値であれば)、新しい親節点の<code>base-uri</code>性質によって解決される。</p></item>
<item><p>複製された節点のその他の性質はすべて保存される。</p></item>
</olist></item>
</olist></item>
</olist></item>
<item><p>内容列中の隣接したテキスト節点は、それらの内容を連接することによって、1つのテキスト節点に併合される。このとき、間に空白は挟まれない。連接の後、内容が長さ0の文字列であるテキスト節点は、内容列から取り除かれる。</p></item>
<item><p>内容列が文書節点を含むならば、その文書節点は、その子からなる内容列に置き換えられる。</p></item>
<item><p>内容列に含まれる属性節点について、それが属性節点でない節点の後ろに来るならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0024"/>。</p></item>
<item><p>新しく構成された要素節点の性質は以下のように決定される:</p>
<olist>
<item><p><code>node-name</code>は、開始タグ中の要素名を解決した結果として得られる<termref def="dt-expanded-qname">展開済QName</termref>であり、元の名前空間接頭辞を (もしあるなら) 含む。これについては、<specref ref="id-element-constructor"/>に記述されている通りである。</p></item>
<item><p><code>base-uri</code>は以下のソースのうち存在するものの最初から取ってこられる:<olist>
<item><p>構成された節点の <code>xml:base</code>属性の値。ただしこの属性が存在する場合;</p></item>
<item><p><termref def="dt-base-uri">静的文脈</termref>中の<termref def="dt-base-uri">基礎URI</termref></p></item>
</olist></p></item>
<item><p><code>parent</code>は空に設定される。</p></item>
<item><p><code>attributes</code>は、<specref ref="id-attributes"/>に記述されている通り、開始タグ中に指定されるすべての属性と、内容列中のすべての属性節点からなる。その順序は<termref def="dt-implementation-dependent">実装依存</termref>である。これらのうち2つ以上の属性が同じ<code>node-name</code>を持っていれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0025"/>。これらの属性節点それぞれの<code>parent</code>性質は、新しく構成された要素節点に設定されていることに注意せよ。</p></item>
<item><p><code>children</code>は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点それぞれの<code>parent</code>性質は、新しく構成された要素節点に設定されていることに注意せよ。</p></item>
<item><p><code>in-scope-namespaces</code>は、<specref ref="id-namespaces"/>に記述されているように名前空間宣言属性から得られる名前空間束縛すべて、および<specref ref="id-ns-nodes-on-elements"/>に記述されているように追加される可能性のある名前空間束縛からなる。</p></item>
<item><p><code>nilled</code> 性質は <code>false</code>である。</p></item>
<item><p><code>string-value</code> 性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。もし子孫にテキスト節点がなければ、<code>string-value</code> 性質は長さ0の文字列である。</p></item>
<item><p><code>typed-value</code> 性質は<code>xs:untypedAtomic</code> のインスタンスとしての <code>string-value</code> 性質に等しい。</p></item>
<item><p>もし<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-construction-mode">構成モード</termref>が<code>strip</code>であれば、<code>type-name</code> 性質は <code>xs:untyped</code>である。一方、構成モードが<code>preserve</code>であれば、<code>type-name</code> 性質は <code>xs:anyType</code>である。</p></item>
<item><p><code>is-id</code>性質と<code>is-idrefs</code>性質は<code>false</code>に設定される。</p></item>
</olist></item>
</olist>
<ulist><item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;{1}&lt;/a&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>1</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;{1, 2, 3}&lt;/a&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>1 2 3</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;c&gt;{1}{2}{3}&lt;/c&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>123</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;b&gt;{1, "2", "3"}&lt;/b&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>1 2 3</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>I saw 8 cats.</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;</eg><p>構成された要素節点は子を1つ持っている。値 "<code>I saw 8 cats.</code>" を含むテキスト節点である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;</eg><p>構成された要素節点は子を3つ持っている: "<code>I saw </code> " を含むテキスト節点、<code>howmany</code>と名付けられた子要素節点、それに "<code> cats.</code>" を含むテキスト節点である。子要素節点はさらに、値 "<code>8</code>" を含むテキスト節点を子として持つ。</p></item>
</ulist>
</div4>
<div4 id="id-whitespace"><head>境界空白</head>
<p>直接要素構成子では、構成される要素の内容中に空白文字が出現してもよい。場合によっては、囲まれる式や入れ子要素が空白文字によって飲み区切られてもよい。例えば、以下の式で、終了タグ <code>&lt;/title&gt;</code> と開始タグ <code>&lt;author&gt;</code> は改行文字1つとスペース文字4つで区切られている:</p>
<eg role="parse-test" xml:space="preserve">&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</eg>
<p><termdef term="boundary whitespace" id="dt-boundary-whitespace"><term>境界空白</term>は<termref def="dt-direct-elem-const">直接要素構成子</termref>の文脈に現れる連続した空白文字の列であり、内容の始まりや終わり、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt>、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>のいずれかによって両端を区切られている。この目的のために、<code>&amp;#x20;</code>といった<termref def="dt-character-reference">文字参照</termref>、あるいは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CDataSection" xlink:type="simple">CdataSections</nt>によって生成される文字は空白文字とはみなされない。</termdef></p>
<p><termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-boundary-space-policy">空白境界ポリシー</termref>は、境界空白が要素構成子によって保存されるかどうかを制御する。境界空白ポリシーが<code>strip</code>であれば、境界空白は重要だとは見なされず、捨てられる。一方、境界空白ポリシーが<code>preserve</code>であれば、境界空白は重要だと見なされ、保存される。</p>
<ulist>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;cat&gt; 
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt; 
&lt;/cat&gt;</eg><p>構成された<code>cat</code>要素節点は、2つの子要素節点<code>breed</code>と<code>color</code>を持つ。境界空白ポリシーが<code>strip</code>であれば、子要素を囲む空白は要素構成子によってはぎ取られる。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;  {"abc"}  &lt;/a&gt;</eg><p>境界空白ポリシーが<code>strip</code>であれば、この例は<code role="parse-test">&lt;a&gt;abc&lt;/a&gt;</code>と等価である。しかし、境界空白ポリシーが<code>preserve</code>であれば、この例は<code role="parse-test">&lt;a&gt;  abc  &lt;/a&gt;</code>と等価である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt; z {"abc"}&lt;/a&gt;</eg><p><code>z</code>を取り囲む空白は境界空白ではないので、常に保存される。この例は<code role="parse-test">&lt;a&gt; z abc&lt;/a&gt;</code>と等価である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;</eg><p>この例は、境界空白ポリシーに関わらず<code role="parse-test">&lt;a&gt; abc&lt;/a&gt;</code>と等価である。なぜなら、<termref def="dt-character-reference">文字参照</termref>によって生成されるスペースは空白文字とは扱われないからである。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">&lt;a&gt;{"  "}&lt;/a&gt;</eg><p>この例は、境界空白ポリシーに関わらず、2つのスペース文字を含む要素を構成する。なぜならば、囲まれた式の内部の空白は決して境界空白とは見なされないからである。</p></item>
</ulist>
<note><p>要素構成子は、<code>xml:space</code>と名付けられた属性を通常の属性として扱う。<code>xml:space</code>属性は、要素構成子による空白処理に影響を与えない。</p></note>
</div4>
</div3>
<div3 id="id-otherConstructors"><head>その他の直接構成子</head>
<p>XQueryは、処理命令節点やコメント節点を生成する式を認めている。これらは<term>直接処理命令構成子</term>や<term>直接コメント構成子</term>を用いることで実現される。それぞれの場合について、構成子式の構文は、XMLの同じ構成要素の構文を基にしている。</p> 
<scrap headstyle="show"> 
<head/> 
 
<prod num="105" id="doc-xquery-DirPIConstructor"><lhs>DirPIConstructor</lhs><rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs></prod><prod num="106" id="doc-xquery-DirPIContents"><lhs>DirPIContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs></prod> 
<prod num="103" id="doc-xquery-DirCommentConstructor"><lhs>DirCommentConstructor</lhs><rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs></prod>
<prod num="104" id="doc-xquery-DirCommentContents"><lhs>DirCommentContents</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')))*</rhs></prod><!--prodrecap id="PITarget" ref="PITarget" not included here
because it invalidates the document.--> 
</scrap> 
<p>直接処理命令構成子は、<code>target</code>性質が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>で<code>content</code>性質が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>であるような処理命令節点を生成する。この節点の<code>base-uri</code> 性質は空である。この節点の<code>parent</code>性質は空である。</p>
<p>処理命令の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>には、大文字小文字の組み合わせ方の如何に関わらず、"XML" という文字が含まれてはならない。処理命令の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>には、文字列 "<code>?&gt;</code>" が含まれてはならない。</p>
<p>以下は、直接処理命令構成子の例である:</p> 
<eg role="parse-test" xml:space="preserve">&lt;?format role="output" ?&gt;</eg>
<p>直接コメント構成子は、<code>content</code>性質が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>であるようなコメント節点を生成する。この節点の<code>parent</code>性質は空である。</p>
<p>コメントの<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>には、2つの連続したハイフンが含まれてはならず、またハイフンで終わってはならない。これらのルールは、上に示した文法によって構文的に強要されている。</p> 
<p>以下は、直接コメント構成子の例である:</p>
<eg role="parse-test" xml:space="preserve">&lt;!-- Tags are ignored in the following section --&gt;</eg>
<note><p>直接コメント構成子は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">comment</nt>とは異なる。なぜなら直接コメント構成子は実際にコメント節点を構成するが、一方<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">comment</nt>は単に問合せを文書化するときに用いられるだけで、評価されないからである。</p></note> 
 
 
 
</div3>
<div3 id="id-computedConstructors"><head>被計算構成子</head>
<scrap headstyle="show"><head/><prod num="109" id="doc-xquery-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt></rhs></prod></scrap>
<p>節点を生成するもう一つの方法は<term id="term-elem-ctor">被計算構成子</term>を用いる、というものである。被計算構成子は、生成される節点の型を識別する以下のようなキーワードから始まる: <code>element</code>,
   <code>attribute</code>, <code>document</code>, <code>text</code>, <code>processing-instruction</code>, または<code>comment</code>。</p>
<p>名前を持つ節点の種類 (要素節点、属性節点、処理命令節点) に対して、節点の種類を表すキーワードの次に、生成される節点の名前が続く。この名前は QName として指定されるか、括弧で囲まれた式として指定されるかのいずれであってもよい。<termdef term="name expression" id="dt-name-expression">ある式が、構成された節点の名前を指定するのに用いられるとき、その式は、その構成子の<term>名前式</term>と呼ばれる。</termdef></p>
<p><termdef id="dt-content-expression" term="content expression">被計算構成子の最後の部分は括弧で囲まれた式であり、その節点の内容を生成する。これを、その構成子の<term>内容式</term>と呼ぶ。</termdef></p>
 <p>以下に示すのは、被計算要素構成子および被計算属性構成子を用いた例であり、構成される節点の名前が定数であるような単純な場合である。この例では、<specref ref="id-element-constructor"/>の最初の例と全く同じ結果が生成される:</p>
 <eg role="parse-test" xml:space="preserve">element book { 
   attribute isbn {"isbn-0060229357" }, 
   element title { "Harold and the Purple Crayon"},
   element author { 
      element first { "Crockett" }, 
      element last {"Johnson" }
   }
}</eg>
<div4 id="id-computedElements"><head>被計算要素構成子</head>
<scrap headstyle="show"> <head/> <prod num="111" id="doc-xquery-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs></prod>
    
   <prod num="112" id="doc-xquery-ContentExpr"><lhs>ContentExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod></scrap>
<p><termdef term="computed element constructor" id="dt-computed-elem-const"><term>被計算要素構成子</term>は要素節点を1つ生成する。このとき、節点の名前も内容も計算して得ることができる。</termdef></p>
<p>もしキーワード<code>element</code>の後ろに QName が続いていれば、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて展開され、結果として得られた<termref def="dt-expanded-qname">展開済 QName</termref>が、構成された要素節点の<code>node-name</code>性質として用いられる。QName の展開が成功しなければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref code="0081" class="ST"/>。</p>
<p>キーワード<code>element</code>の次に<termref def="dt-name-expression">名前式</termref>がくれば、その名前式が以下のように処理される:</p>
<olist>
<item><p><termref def="dt-name-expression">名前式</termref>の値に対して<termref def="dt-atomization">原子化</termref>が適用される。原子化の結果が<code>xs:QName</code>型、<code>xs:string</code>型、<code>xs:untypedAtomic</code>型いずれかの原子値1つでなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p><termref def="dt-name-expression">名前式</termref>の値を原子化した結果が<code>xs:QName</code>型であれば、その<termref def="dt-expanded-qname">展開済 QName</termref>が、構成された要素の<code>node-name</code>性質として用いられる。その際、QName の接頭辞部分はそのまま保持される。</p></item>
<item><p><termref def="dt-name-expression">名前式</termref>の値を原子化した結果が<code>xs:string</code>型か<code>xs:untypedAtomic</code>型であれば、その値が<termref def="dt-expanded-qname">展開済 QName</termref>に変換される。文字列値が名前空間接頭辞を含むならば、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて、その接頭辞を名前空間URIに解決する。文字列値が名前空間接頭辞を含まないならば、<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>にある局所名として扱われる。結果として得られる<termref def="dt-expanded-qname">展開済 QName</termref>が、構成された要素の<code>node-name</code>性質として用いられる。その際、QName の接頭辞部分はそのまま保持される。原子化された<termref def="dt-name-expression">名前式</termref>を展開済 QName に変換するのに成功しなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0074"/>。</p></item>
</olist>
<p>被計算要素構成子の<termref def="dt-content-expression">内容式</termref> (もしあれば) は、<termref def="dt-direct-elem-const">直接要素構成子</termref>の内容中にある囲まれた式と全く同じ方法、すなわち<specref ref="id-content"/>の段階1eで記述した方法で処理される。内容式を処理した結果は節点列になる。これを<term>内容列</term>という。<termref def="dt-content-expression">内容式</termref>がなければ、内容列は空列である。</p>
<p>被計算要素構成子の処理は以下のように行われる:</p>
<olist>
<item><p>内容列中の隣接したテキスト節点は、その内容を連接することによって1つのテキスト節点に併合される。このとき、間に空白は挟まれない。連接の後、内容が長さ0の文字列となるようなテキスト節点はいずれも内容列から消去される。</p></item>
<item><p>内容列が文書節点を含むならば、その文書節点は、その子によって内容列中で置き換えられる。</p></item>
<item><p>内容列に含まれる属性節点のうち、属性節点以外の節点に続くものがあれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0024"/>。</p></item>
<item><p>新しく構成された要素節点の性質は以下のように決定される:</p>
<olist>
<item><p><code>node-name</code>は、指定された QName または<termref def="dt-name-expression">名前式</termref>を処理して得られた<termref def="dt-expanded-qname">展開済 QName</termref>である。これについては上で述べた通りである。</p></item>
<item><p><code>base-uri</code>は、以下のソースのうち存在する最初のものから取ってこられる:<olist>
<item><p>構成された節点の<code>xml:base</code>属性の値。ただしこの属性が存在する場合;</p></item>
<item><p><termref def="dt-base-uri">静的文脈</termref>中の<termref def="dt-base-uri">基礎URI</termref>。</p></item>
</olist></p></item>
<item><p><code>parent</code>は空である。</p></item>
<item><p><code>attributes</code>は、内容列中のすべての属性節点からなり、<termref def="dt-implementation-dependent">実装依存</termref>の順に並べられる。2つ以上の属性が同じ<code>node-name</code>を持っていれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0025"/>。これらの属性節点はそれぞれ、<code>parent</code>性質に新たに構成された要素節点が設定されていることに注意せよ。</p></item>
<item><p><code>children</code>は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点はそれぞれ、<code>parent</code>性質に新たに構成された要素節点が設定されていることに注意せよ。</p></item>
<item><p><code>in-scope-namespaces</code>は<specref ref="id-ns-nodes-on-elements"/>に記述されているように計算される。</p></item>
<item><p><code>nilled</code>性質は<code>false</code>である。</p></item>
<item><p><code>string-value</code>性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。</p></item>
<item><p><code>typed-value</code>性質は、<code>xs:untypedAtomic</code>のインスタンスとしての<code>string-value</code>性質に等しい。</p></item>
<item><p><termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-construction-mode">構成モード</termref>が<code>strip</code>であれば、<code>type-name</code>性質は<code>xs:untyped</code>である。一方、構成モードが<code>preserve</code>であれば、<code>type-name</code>性質は<code>xs:anyType</code>である。</p></item>
<item><p><code>is-id</code>性質と<code>is-idrefs</code>性質は<code>false</code>に設定される。</p></item>
</olist></item>
</olist> 
<p>被計算要素構成子は、存在する要素の複製を修正するのに用いられるかもしれない。例えば、変数 <code>$e</code> が<termref def="dt-numeric">数</termref>の内容を持つ要素に束縛されているならば、以下の構成子を用いることにより<code>$e</code>と同じ名前と属性を持ち、かつ<code>$e</code>の値の倍に等しい数の内容を持つ要素が新たに生成される:</p>
<eg role="parse-test" xml:space="preserve">element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}</eg>
<p>この例では、<code>$e</code>が式<code>let $e := &lt;length
   units="inches"&gt;{5}&lt;/length&gt;</code>に束縛されているならば、例の式の結果は要素<code>&lt;length
   units="inches"&gt;10&lt;/length&gt;</code>である。</p>
<note><p>式<code>fn:node-name($e)</code>の<termref def="dt-static-type">静的型</termref>は<code>xs:QName?</code>であり、0個もしくは1個の QName である。したがって、<termref def="dt-static-typing-feature">静的型付け機能</termref>が有効であるならば、上の例は静的型エラーを発生させる。なぜなら、被計算要素構成子中の名前式は正確に1個の文字列またはQNameを返すことが要求されるからである。静的型エラーを避けるためには、名前式<code>fn:node-name($e)</code>を<code>fn:exactly-one(fn:node-name($e))</code>と書き換えればよい。<termref def="dt-static-typing-feature">静的型付け機能</termref>が有効でないならば、上の例は、書かれているように正しく評価することができ、<code>$e</code>には、数の内容を持つ要素が正確に1個だけ束縛される。</p></note>
<p>被計算構成子の重要な目的の一つに、節点の名前を計算することを許す、というものがある。この特徴を例で示そう。これは、要素の名前をある言語から別の言語に翻訳するというものである。変数 <code>$dict</code> は <code>dictionary</code> 要素に束縛されているとしよう。この要素は <code>entry</code> 要素の列を含み、<code>entry</code>要素はそれぞれ指定された語の翻訳を符号化している。これは、語 "address" のドイツ語およびイタリア語の変種を符号化した entry の例である:</p> <eg role="parse-test" xml:space="preserve">
&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt; 
</eg> 
<p>さらに、変数 <code>$e</code> は以下の要素に束縛されているとしよう:</p> 
<eg role="parse-test" xml:space="preserve">&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</eg> 
<p>すると、以下の式は、<code>$e</code>の名前がイタリア語に翻訳され、かつ<code>$e</code>の内容 (属性があるならばそれも含め) が保存されているような新しい要素を生成する。キーワード <code>element</code> の直後にある1つ目の囲まれた式は要素の名前を生成し、2つ目の囲まれた式は内容と属性を生成する:</p> 
<eg role="parse-test" xml:space="preserve">
  element 
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}</eg> 
<p>この式の結果は、次のようになる:</p> 
<eg role="parse-test" xml:space="preserve">&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</eg> 
<note><p>前の例のように、<termref def="dt-static-typing-feature">静的型付け機能</termref>が有効であれば、静的型エラーを避けるために、上の被計算要素構成子中で要素名を計算する囲まれた式は<code>fn:exactly-one</code>関数の呼び出しによって囲まれなければならない。</p></note>
<p>被計算要素構成子の例はさらに<specref ref="id-recursive-transformations"/>にもある。</p></div4>
<div4 id="id-computedAttributes">
<head>被計算属性構成子</head>
<scrap headstyle="show"> <head/> 
   <prod num="113" id="doc-xquery-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod> 
   </scrap>
<p>被計算属性構成子は新しい属性節点を1つ生成する。この節点は固有の節点識別性を持つ。</p>
<p>キーワード<code>attribute</code> の次に QName が続けば、その QName は<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて展開され、結果として得られる<termref def="dt-expanded-qname">展開済 QName</termref> が (その接頭辞も含め) 構成された属性節点の <code>node-name</code> 性質として用いられる。QName の展開が成功しなければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref code="0081" class="ST"/>。</p>
<p>キーワード <code>attribute</code> の次に<termref def="dt-name-expression">名前式</termref>が続けば、その名前式が以下のように処理される:</p>
<olist>
<item><p><termref def="dt-name-expression">名前式</termref>の結果に<termref def="dt-atomization">原子化</termref>が適用される。<termref def="dt-atomization">原子化</termref>の結果が<code>xs:QName</code>型, <code>xs:string</code>型, <code>xs:untypedAtomic</code>型のいずれかの原子値1つでなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化された<termref def="dt-name-expression">名前式</termref>の値の型が<code>xs:QName</code>であれば、その<termref def="dt-expanded-qname">展開済 QName</termref>が (接頭辞も含め) 構成された属性節点の<code>node-name</code> 性質として用いられる。</p></item>
<item><p>原子化された<termref def="dt-name-expression">名前式</termref>の値の型が<code>xs:string</code>もしくは<code>xs:untypedAtomic</code>であれば、その値が<termref def="dt-expanded-qname">展開済 QName</termref>に変換される。文字列値が名前空間接頭辞を含んでいれば、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いてその接頭辞が名前空間URIに解決される。文字列値に名前空間接頭辞が含まれなければ、どの名前空間にも属さない局所名と扱われる。結果として得られる<termref def="dt-expanded-qname">展開済 QName</termref>が (接頭辞も含め) 構成された属性の<code>node-name</code> 性質として用いられる。原子化された<termref def="dt-name-expression">名前式</termref>を<termref def="dt-expanded-qname">展開済 QName</termref>に変換することに成功しなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0074"/>。</p></item>
</olist>
<p>構成された属性の <code>node-name</code> 性質 (<termref def="dt-expanded-qname">展開済 QName</termref>) は以下のように検査される: その URI 部分が <code>http://www.w3.org/2000/xmlns/</code> (名前空間接頭辞 <code>xmlns</code> に一致) であるか、またはその属性がどの名前空間にも属さず局所名が <code>xmlns</code> であれば、<termref def="dt-dynamic-error">動的エラー</termref> <errorref class="DY" code="0044"/> が発生する。</p>
<p>被計算属性構成子の<termref def="dt-content-expression">内容式</termref>は以下のように処理される:</p>
<olist>
<item><p><termref def="dt-content-expression">内容式</termref>の結果に<termref def="dt-atomization">原子化</termref>が適用され、原子値の列に変換される。(<termref def="dt-content-expression">内容式</termref>がなければ、このステップの結果は空列である。)</p></item>
<item><p>原子化の結果が空列であれば、属性の値は長さ0の文字列である。そうでなければ、原子化された列中のそれぞれの原子値が文字列に型変換される。</p></item>
<item><p>前のステップの結果得られる個々の文字列が、それぞれの間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果の文字列が、新しい属性節点の <code>string-value</code> 性質となる。新しい属性節点の<termref def="dt-type-annotation">型注釈</termref> (<code>type-name</code> 性質) は <code>xs:untypedAtomic</code> である。この属性節点の <code>typed-value</code> 性質は <code>string-value</code> と等しく、<code>xs:untypedAtomic</code>のインスタンスである。</p></item>
<item><p>この属性節点の <code>parent</code> 性質は空に設定される。</p></item>
<item><p>この属性の名前が <code>xml:id</code>であれば、この属性の文字列値と型付けされた値がさらに正規化される。すなわち、前後の空白文字が取り除かれ, 空白文字の列がスペース文字 (#x20) 1つに置き換えられる。</p>
<note><p>このステップは、<bibref ref="XMLID"/>で定義されている <code>xml:id</code> の処理を行う。</p></note></item>
<item><p>この属性の名前が <code>xml:id</code>であれば、結果として得られる属性節点の<code>is-id</code>性質が<code>true</code>に設定される。そうでなければ、<code>is-id</code>性質は<code>false</code>に設定される。この属性の<code>is-idrefs</code>性質は無条件に<code>false</code>に設定される。</p></item>
</olist>
<ulist><item><p>例:</p><eg role="parse-test" xml:space="preserve">attribute size {4 + 3}</eg><p><code>size</code>属性の<termref def="dt-string-value">文字列値</termref>は "<code>7</code>" であり、その型は<code>xs:untypedAtomic</code>である。</p></item>
<item><p>例:</p><eg role="parse-test" xml:space="preserve">attribute
   { if ($sex = "M") then "husband" else "wife" }
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }</eg><p>構成された属性の名前は<code>husband</code>か<code>wife</code>である。その<termref def="dt-string-value">文字列値</termref>は "<code>Hello 1 2 3 Goodbye</code>"である。</p></item>
</ulist>
</div4>
<div4 id="id-documentConstructors"><head>文書節点構成子</head>
<scrap headstyle="show"> <head/> 
    <prod num="110" id="doc-xquery-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
   </scrap>
<p>文書節点構成子はすべて被計算構成子である。文書節点構成子の結果は新しい文書節点であり、固有の節点識別性を持つ。</p>
<p>文書節点構成子は、問合せの結果をそれ自身だけで文書としたい場合に有用である。以下の例では、<code>author-list</code>という名前の根要素を含むXML文書を返す問合せを表している:</p>
<eg role="parse-test" xml:space="preserve">document
   {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
   }</eg>
<p>文書節点構成子の<termref def="dt-content-expression">内容式</termref>は、<termref def="dt-direct-elem-const">直接要素構成子</termref>の内容中にある囲まれた式と全く同じように処理される。すなわち、<specref ref="id-content"/>のステップ1eに記述されているように処理される。内容式を処理した結果は節点列になる。これを<term>内容列</term>という。文書節点構成子の処理は、次に以下のように行われる:</p>
<olist>
<item><p>内容列中の隣接するテキスト節点は、それらの内容を連接することによって1つのテキスト節点に併合される。このとき間に空白は挟まれない。連接の後、内容が長さ0の文字列であるようなテキスト節点はいずれも内容列から削除される。</p></item>
<item><p>内容列に文書節点が含まれれば、その文書節点は、内容列中においてその子に置き換えられる。</p></item>
<item><p>内容列に属性節点が含まれれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>新たに構成された文書節点の性質は以下のように決定される:</p>
<olist>
<item><p><code>base-uri</code>は<termref def="dt-base-uri">静的文脈</termref>中の<termref def="dt-base-uri">基礎 URI</termref>から取ってこられる。静的文脈に基礎 URI が定義されていなければ、<code>base-uri</code> 性質は空である。</p></item>
<item><p><code>children</code> 性質は、内容列中のすべての要素節点、テキスト節点、コメント節点、処理命令節点からなる。これらの節点それぞれの<code>parent</code>性質は、新たに構成された文書節点に設定されていることに注意せよ。</p></item>
<item><p><code>unparsed-entities</code>性質と<code>document-uri</code>性質は空である。</p></item>
<item><p><code>string-value</code> 性質は、子孫のテキスト節点の内容を文書順に連接したものに等しい。</p></item>
<item><p><code>typed-value</code> 性質は、<code>string-value</code>性質に等しく、<code>xs:untypedAtomic</code>のインスタンスである。</p></item>
</olist></item>
</olist>
<p>構成された文書節点に対しては妥当性検証は行われない。<bibref ref="XML"/> にある、XML文書の構造を支配するルール (例えば、文書節点は子要素節点をただ1つ持たなければならない、など) は、XQeury の文書節点構成子に対しては強制されない。</p></div4>
<div4 id="id-textConstructors"><head>テキスト節点構成子</head>
<scrap headstyle="show"> <head/> 
    <prod num="114" id="doc-xquery-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
   </scrap>
<p>テキスト節点構成子はすべて被計算構成子である。テキスト節点構成子の結果は新しいテキスト節点であり、固有の節点識別性を持つ。</p>
<p>テキスト節点の<termref def="dt-content-expression">内容式</termref>は以下のように処理される:</p>
<olist>
<item><p><termref def="dt-content-expression">内容式</termref>の値に対して<termref def="dt-atomization">原子化</termref>が適用され、原子値の列に変換される。</p></item>
<item><p>原子化の結果が空列であれば、テキスト節点は構成されない。そうでない場合は、原子化された列中の原子値それぞれが文字列に型変換される。</p></item>
<item><p>前のステップの結果得られる個々の文字列が、間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果の文字列は、構成されたテキスト節点の <code>content</code> 性質となる。</p></item>
</olist>
<p>構成されたテキスト節点の <code>parent</code> 性質は空に設定される。</p>
<note><p>テキスト節点構成子が長さ0の文字列を含むテキスト節点を構成することは可能である。しかし、構成された要素節点や文書節点の文脈で用いられると、このようなテキスト節点は削除されるか、ほかのテキスト節点に併合される。</p></note>
<p>以下に示すのは、テキスト節点構成子の例である:</p>
<eg role="parse-test" xml:space="preserve">text {"Hello"}</eg>
</div4>
<div4 id="id-computed-pis"><head>被計算処理命令構成子</head>
<scrap headstyle="show"> <head/> 
    
   <prod num="116" id="doc-xquery-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod></scrap>
<p>被計算処理命令構成子 (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt>) は新しい処理命令節点を構成する。この節点は固有の節点識別性を持つ。</p>
<p>キーワード <code>processing-instruction</code> の次に NCName が続けば、その NCName が構成された節点の <code>target</code> 性質となる。キーワード <code>processing-instruction</code> の次に<termref def="dt-name-expression">名前式</termref>が続けば、その名前式が以下のように処理される:</p>
<olist>
<item><p><termref def="dt-name-expression">名前式</termref>の値に<termref def="dt-atomization">原子化</termref>が適用される。<termref def="dt-atomization">原子化</termref>の結果が <code>xs:NCName</code>、<code>xs:string</code>、<code>xs:untypedAtomic</code>いずれかの型の原子値1つでなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化された<termref def="dt-name-expression">名前式</termref>の値の型が<code>xs:string</code>もしくは<code>xs:untypedAtomic</code>であれば、その値が<code>xs:NCName</code>型に型変換される。その値が<code>xs:NCName</code>に型変換できなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0041"/>。</p></item>
<item><p>次に、結果として得られる NCName が新たに構成される処理命令節点の <code>target</code> 性質として使われる。しかし、その NCName が "<code>XML</code>" (大文字小文字の組み合わせに関わらず)に等しければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0064"/>。</p></item>
</olist>
<p>被計算処理命令構成子の<termref def="dt-content-expression">内容式</termref>は以下のように処理される:</p>
<olist>
<item><p><termref def="dt-content-expression">内容式</termref>の値に<termref def="dt-atomization">原子化</termref>が適用され、原子値の列に変換される。(<termref def="dt-content-expression">内容式</termref>がなければ、このステップの結果は空列である。)</p></item>
<item><p>原子化の結果が空列であれば、長さ0の文字列に置き換えられる。そうでなければ、原子化された列中の原子値それぞれが文字列に型変換される。結果として得られる文字列のいずれかが "<code>?&gt;</code>" を含むならば、<termref def="dt-dynamic-error">動的エラー</termref> <errorref class="DY" code="0026"/> が発生する。</p></item>
<item><p>前のステップの結果得られる個々の文字列が、間に空白文字1つを挟みながら連接され、1つの文字列に併合される。先頭の空白文字は結果の文字列から削除される。結果として得られる文字列は、構成された処理命令節点の <code>content</code> 性質となる。</p></item>
</olist>
<p>新しく構成された節点の残りの性質は以下のように決定される:</p>
<olist>
<item><p><code>parent</code> 性質は空である。</p></item>
<item><p><code>base-uri</code> 性質は空である。</p></item>
</olist>
<p>以下に示すのは、被計算処理命令構成子の例である:</p>
<eg role="parse-test" xml:space="preserve">let $target := "audio-output",
    $content := "beep" 
return processing-instruction {$target} {$content}</eg>
<p>この例で構成される処理命令節点は以下のように直列化されるかもしれない:</p>
<eg xml:space="preserve">&lt;?audio-output beep?&gt;</eg>
</div4>
<div4 id="id-computed-comments"><head>被計算コメント構成子</head>
<scrap headstyle="show"> <head/> 
    
   <prod num="115" id="doc-xquery-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod></scrap>
<p>被計算コメント構成子 (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt>) は新しいコメント節点を構成する。この節点は固有の節点識別性を持つ。被計算コメント構成子の<termref def="dt-content-expression">内容式</termref>は以下のように処理される:</p>
<olist>
<item><p><termref def="dt-content-expression">内容式</termref>の値に<termref def="dt-atomization">原子化</termref>が適用され、原子値の列に変換される。</p></item>
<item><p>原子化の結果が空列であれば、長さ0の文字列に置き換えられる。そうでなければ、原子化された列中の原子値がそれぞれ文字列に型変換される。</p></item>
<item><p>前のステップの結果得られた個々の文字列は、それぞれの間に空白文字1つを挟みながら連接され、1つの文字列に併合される。結果として得られる文字列は、新しく構成されたコメント節点の <code>content</code> 性質となる。</p></item>
<item><p>被計算コメント構成子の<termref def="dt-content-expression">内容式</termref>の結果が、2つの隣接したハイフン記号を含むか、ハイフン記号1つで終わっていれば、<termref def="dt-dynamic-error">動的エラー</termref>である <errorref class="DY" code="0072"/>。</p></item>
</olist>
<p>構成されたコメント節点の <code>parent</code> 性質は空に設定される。</p>
<p>以下に示すのは、被計算コメント構成子の例である:</p>
<eg role="parse-test" xml:space="preserve">let $homebase := "Houston" 
return comment {fn:concat($homebase, ", we have a problem.")}</eg>
<p>この例で構成されるコメント節点は以下のように直列化されるかもしれない:</p>
<eg xml:space="preserve">&lt;!--Houston, we have a problem.--&gt;</eg>
</div4></div3>
<div3 id="id-ns-nodes-on-elements">
<head>構成された要素の有効範囲内名前空間</head>
<p>直接要素構成子や被計算要素構成子によって構成された要素節点は、<termref def="dt-in-scope-namespaces">名前空間束縛</termref>の集合からなる <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> 性質を持つ。要素節点の有効範囲内名前空間は、その節点を直列化する方法に影響を与えるかもしれず (<specref ref="id-serialization"/>を見よ)、また、<code>fn:name</code>など、節点上で動作するある種の関数の振舞いに影響を与えるかもしれない。<termref def="dt-in-scope-namespaces">in-scope namespaces</termref>と<termref def="dt-static-namespaces">静的既知名前空間</termref>の違いに注意せよ。前者は要素節点の動的性質であり、一方後者は式の静的性質である。また、有効範囲内名前空間中の名前空間束縛のうち1つは接頭辞を持たないかもしれないことにも注意せよ (その要素のデフォルト名前空間を表す)。構成された要素節点の有効範囲内名前空間は以下の名前空間束縛からなる:</p>
<ulist>
<item><p>現在の要素構成子中で<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>によって定義されている名前空間それぞれから名前空間束縛が生成される。</p></item>
<item><p>その構成子を囲む<termref def="dt-direct-elem-const">直接要素構成子</termref>の名前空間宣言属性で定義され、現在の要素構成子もしくは途中の構成子で再定義されていない名前空間それぞれについて、名前空間束縛が生成される。</p></item>
<item><p>接頭辞 <code>xml</code> を名前空間 URI <code>http://www.w3.org/XML/1998/namespace</code> に束縛する名前空間束縛は常に生成される。</p></item>
<item><p>構成された要素の名前もしくはその属性の名前に用いられている名前空間それぞれについて、名前空間束縛が1つ存在しなければならない。これらの名前空間に対する名前空間束縛がまだ存在しない場合は、その名前空間に対する新しい名前空間束縛が生成される。節点の名前が接頭辞を含んでいれば、その接頭辞が名前空間束縛に用いられる。名前が接頭辞を持たなければ、空の接頭辞に対する束縛が生成される。この結果、同じ接頭辞に対する2つの異なる束縛が必要になるなど、矛盾が生じれば、節点の名前に用いられている接頭辞は、矛盾を引き起こさない何らかの<termref def="dt-implementation-dependent">実装依存</termref>の接頭辞に変更され、この新しい接頭辞に対する名前空間束縛が生成される。</p></item>
</ulist>
<note><p><termref def="dt-copy-namespaces-mode">名前空間複製モード</termref>は新しく構成される要素節点の名前空間には影響を及ぼさない。このモードは、構成子式により複製された存在する節点に対してのみ適用される。</p></note>
<p>例として、以下の問合せを示す:</p>
<eg role="parse-test" xml:space="preserve">declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</eg>
<p>結果として得られる <code>p:a</code> 要素の<termref def="dt-in-scope-namespaces">有効範囲内名前空間</termref>は以下の<termref def="dt-in-scope-namespaces">名前空間束縛</termref>からなる:</p>
<ulist>
<item><p><code>p = "http://example.com/ns/p"</code></p></item>
<item><p><code>q = "http://example.com/ns/q"</code></p></item>
<item><p><code>r = "http://example.com/ns/r"</code></p></item>
<item><p><code>xml = "http://www.w3.org/XML/1998/namespace"</code></p></item>
</ulist>
<p><code>p</code> と <code>q</code> に対する名前空間束縛は結果の要素に追加される。なぜなら、これらの名前空間はそれぞれ要素と属性に用いられているからである。名前空間束縛 <code>r="http://example.com/ns/r"</code> は構成された要素の有効範囲内名前空間に追加される。なぜならこれは、名前には用いられていないが、<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>で定義されているからである。</p>
<p><code>f="http://example.com/ns/f"</code> に対応する名前空間束縛は生成されない。なぜなら名前空間接頭辞 <code>f</code> は問合せの前書きにのみ出現し、構成された節点の要素や属性には用いられていないからである。この名前空間束縛は、<termref def="dt-static-namespaces">静的既知名前空間</termref>中にはあり、この問合せの処理の間利用することができるが、問合せの結果には出現しない。</p>
<p>以下の構成された要素は、<code>validate</code> 式の内側に入れ子になっていれば、検証することができないことに注意せよ:</p>
<eg role="parse-test" xml:space="preserve">&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg>
<p>この構成された要素は接頭辞 <code>xsi</code> (名前中で用いられているため) と <code>xml</code> (どの構成された要素節点にも定義されるため) に対する名前空間束縛は持っている。しかし、この構成された要素の検証中、検証器は名前空間接頭辞 <code>xs</code> を解釈することができない。なぜならこれに対する名前空間束縛がないからである。この構成された要素の検証は、<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>を用意することで可能になる。例えば以下の通り:</p>
<eg role="parse-test" xml:space="preserve">&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg></div3></div2>
<div2 id="id-flwor-expressions" role="xquery"> 
<head>FLWOR 式</head> 
<p>XQuery は FLWOR 式と呼ばれる特徴を用意している。これは繰り返しや、中間結果を変数に束縛することを支援する。この種の式は2つ以上の文書の結合を計算したり、データを再構成するときにしばしば有用である。FLWOR という名前は "flower" と発音し、キーワード<code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, および <code>return</code> から示唆を受けた。</p>
<scrap headstyle="show"> 
<head/> 
<prod num="33" id="doc-xquery-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LetClause" xlink:type="simple">LetClause</nt>)+  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-WhereClause" xlink:type="simple">WhereClause</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt>?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 
 
<prod num="34" id="doc-xquery-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
<prod num="36" id="doc-xquery-LetClause"><lhs>LetClause</lhs><rhs>"let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
<prod num="118" id="doc-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod><prod num="35" id="doc-xquery-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="37" id="doc-xquery-WhereClause"><lhs>WhereClause</lhs><rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 
<prod num="38" id="doc-xquery-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpecList" xlink:type="simple">OrderSpecList</nt></rhs></prod><prod num="39" id="doc-xquery-OrderSpecList"><lhs>OrderSpecList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod> 
<prod num="40" id="doc-xquery-OrderSpec"><lhs>OrderSpec</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderModifier" xlink:type="simple">OrderModifier</nt></rhs></prod> 
<prod num="41" id="doc-xquery-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod></scrap> 
<p>FLWOR 式の <code>for</code> 節と <code>let</code> 節は、束縛された変数の組の順序付き列を生成する。これを<term>組ストリーム</term>という。<code>where</code> 節は省略可能で、組ストリームを選別する機能、すなわちある組を残し他を捨てる機能を提供する。<code>order by</code> 節は省略可能で、組ストリームの順序を変更するのに用いることができる。<code>return</code> 節は FLWOR 式の結果を構成する。<code>return</code> 節は組ストリーム中の組それぞれに対して1回評価される。この評価が行われるのは <code>where</code> 節による選別の後である。また、評価の際、それぞれの組中の変数束縛が用いられる。FLWOR 式の結果は、これらの評価の結果を含む順序付き列であり、<termref def="dt-comma-operator">コンマ演算子</termref>を適用したかのように連接される。</p>
<p>以下の FLWOR 式の例には、利用可能なすべての節が含まれている。<code>for</code> 節では、入力文書中のすべての department に対して繰り返しが行われ、変数 <code>$d</code> を各々の department の number に順に束縛する。<code>$d</code> の束縛それぞれに対し、<code>let</code> 節で変数 <code>$e</code> が与えられた department の employee すべてに束縛される。<code>for</code> 節と <code>let</code> 節の結果は組ストリームであり、それぞれの組は <code>$d</code> と <code>$e</code> に対する束縛の2つ組を含む (<code>$d</code> は department の number に束縛され、<code>$e</code> はその department の employee の集合に束縛される)。<code>where</code> 節では、組ストリームに対して選別を行い、10人以上の employee を持つ department を表す束縛の2つ組だけを残す。<code>order by</code> 節では、残った組を、その department 中の employee の salary の平均値の降順で順序付けし直す。<code>return</code> 節では、残った組それぞれに対し新しい <code>big-dept</code> 要素を構成する。この要素は department の number, headcount, salary の平均値を含む。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno = $d]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;</phrase></eg>
<p>FLWOR 式の節に関する詳細は以下で述べる。</p>
<div3 id="id-for-let"><head>For 節と Let 節</head>
<p>FLWOR 式の <code>for</code> 節と <code>let</code> 節の目的は組ストリームを生成することである。この組ストリーム中の各組は、それぞれ1個以上の束縛された変数からなる。</p>
<p><code>for</code> 節の最も簡単な例は、変数1つとそれに関連づけられた式からなる。 <termdef term="binding sequence" id="dt-binding-sequence"><code>for</code> 節中で変数に関連づけられた式の値を、その変数に対する<term>束縛列</term>という。</termdef> <code>for</code> 節では、束縛列中の項目に対する繰り返しを行い、変数を各項目に順に束縛する。<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば、結果として得られる変数束縛の列は、束縛列中の順序に基づいて順序づけられる。そうでない場合は、変数束縛の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p><code>for</code> 節には1つ以上の変数が含まれてもよい。それぞれの変数に式が1つ対応し、その値がその変数に対する束縛列となる。この場合、<code>for</code> 節では、束縛列上の各変数に対して繰り返しが行われる。結果として得られる組ストリームは、それぞれの束縛列中の値からなる組み合わせそれぞれに対し、1つの組を含む。<termref def="dt-ordering-mode">順序付けモード</termref>が <code>ordered</code> であれば、組ストリームの順序は、最も左側にある変数の束縛列の順序によってまず決定され、次に残りの変数の束縛列によって決定される。このとき変数は左から右に使用される。そうでない場合は、変数束縛の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p><code>let</code> 節にも1つ以上の変数が含まれてもよい。それぞれの変数に式が1つ関連づけられる。しかし、<code>for</code> 節とは異なり、<code>let</code> 節ではそれぞれの変数を関連づけられた式の結果に束縛し、繰り返しは行われない。<code>let</code> 節によって生成される変数束縛は、<code>for</code> 節によって生成された束縛の組に追加される。<code>for</code> 節がなければ、<code>let</code> 節はすべての変数束縛を含む1つの組を生成する。</p> 
 
<p><code>for</code> 節と <code>let</code> 節はともに変数を束縛するが、以下の例で示す通り、変数を束縛する方法はかなり異なる。1つめの例は <code>let</code> 節を用いる:</p> 
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">let $s := (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</phrase></eg> 
<p>変数 <code>$s</code> は式 <code role="parse-test">(&lt;one/&gt;,
    &lt;two/&gt;, &lt;three/&gt;)</code> の結果に束縛される。<code>for</code> 節はないので、<code>let</code> 節は <code>$s</code> の束縛を含む組を1つ生成する。
<code>return</code> 節はこの組から起動され、以下のような出力を生成する:</p> 
<eg xml:space="preserve">&lt;out&gt;
   &lt;one/&gt;
   &lt;two/&gt;
   &lt;three/&gt;
&lt;/out&gt;</eg> 
<p>次の例は同じような問合せであるが、<code>let</code> 節の代わりに <code>for</code> 節が含まれる:</p> 
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $s in (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</phrase></eg> 
<p>この例では、変数 <code>$s</code> が与えられた式上で繰り返される。<termref def="dt-ordering-mode">順序付けモード</termref>が<code>ordered</code>であれば,
<code>$s</code> は最初に <code>&lt;one/&gt;</code> に、次に <code>&lt;two/&gt;</code> に、最後に <code>&lt;three/&gt;</code> に束縛される。これらの束縛それぞれに対して組が1つ生成され、それぞれの組に対して <code>return</code> 節が起動され、以下のような出力を生成する:</p> 
<eg xml:space="preserve">&lt;out&gt;
   &lt;one/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;two/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;three/&gt;
&lt;/out&gt;</eg> 
 
 
<p>以下は、<termref def="dt-ordering-mode">順序付けモード</termref>が <code>ordered</code> であるときに、複数の変数を持つ束縛された組がいかにして <code>for</code> 節で生成されるかを示す例である。</p> 
<eg xml:space="preserve">for $i in (1, 2), $j in (3, 4)</eg> 
 
<p>上の <code>for</code> 節で生成される組ストリームは以下の通りである:</p> 
<eg xml:space="preserve">($i = 1, $j = 3)
($i = 1, $j = 4)
($i = 2, $j = 3)
($i = 2, $j = 4)</eg> 
 
 
<p>上の例でもし<termref def="dt-ordering-mode">順序付けモード</termref>が<code>unordered</code>であれば、<code>for</code> 節は同じ組ストリームを生成するが、これらの組の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
<p><code>for</code> 節や <code>let</code> 節で束縛される変数の有効範囲は、それらが含まれる FLWOR 式の部分式のうち、変数束縛の後ろに出現するものすべてからなる。裕広範囲には、変数が束縛される式自体は含まれない。以下に示すのは、<code>for</code> 節や <code>let</code> 節での束縛が、それより前の節で束縛された変数や、FLWOR 式の同じ節中で前に束縛された変数を参照してもよい、という例である:</p>
<eg role="parse-test" xml:space="preserve">for $x in $w, $a in f($x)
let $y := g($a)
for $z in p($x, $y)
return q($x, $y, $z)</eg>
<p>与えられた FLWOR 式の <code>for</code> 節と <code>let</code> 節は同じ変数名を1回以上束縛してもよい。この場合、新しい束縛が前の束縛を塞いでしまい、前の束縛は FLWOR 式の残りの部分から参照不能になる。</p>
<p><code>for</code> 節や <code>let</code> 節で束縛された変数はそれぞれ、省略可能な<term>型宣言</term>を持ってもよい。これは<specref ref="id-sequencetype-syntax"/>の構文を用いて宣言された型である。<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のルールに従って、その変数に束縛された値の型が宣言された型と照合されなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。例えば、以下の式は<termref def="dt-type-error">型エラー</termref>を発生する。なぜなら、変数 <code>$salary</code> が型宣言を持ち、それが変数に束縛された値では満たされないからである:</p>
<eg role="parse-test" xml:space="preserve">let $salary as xs:decimal :=  "cat"
return $salary * 2</eg>
<p><code>for</code> 節で束縛される変数はそれぞれ、関連する<term>位置変数</term>を持っていてもよい、これは元の変数と同時に束縛される。位置変数の名前の先頭にはキーワード<code>at</code>がつく。位置変数は常に暗黙的な型 <code>xs:integer</code> を持つ。変数は<termref def="dt-binding-sequence">束縛列</termref>中の項目上で繰り返されると、その位置変数は、束縛列中での項目の順序位置を表す整数上で、1を起点として繰り返される。位置変数の展開済み QName は、それと関連する変数の展開済 QName と区別されなければならない <errorref class="ST" code="0089"/>。</p>
<p>以下の <code>for</code> 節は位置変数の例を示す:</p>
<eg xml:space="preserve">for $car at $i in ("Ford", "Chevy"),
    $pet at $j in ("Cat", "Dog")</eg>
<p><termref def="dt-ordering-mode">順序付けモード</termref>が <code>ordered</code> であれば、上の <code>for</code> 節によって生成される組ストリームは以下のようになる:</p>
<eg xml:space="preserve">($i = 1, $car = "Ford", $j = 1, $pet = "Cat")
($i = 1, $car = "Ford", $j = 2, $pet = "Dog")
($i = 2, $car = "Chevy", $j = 1, $pet = "Cat")
($i = 2, $car = "Chevy", $j = 2, $pet = "Dog")</eg>
<p><termref def="dt-ordering-mode">順序付けモード</termref>が <code>unordered</code> であれば、組ストリームの順序は<termref def="dt-implementation-dependent">実装依存</termref>である。さらに、<code>for</code> 節中に<termref def="dt-ordering-mode">順序付けモード</termref>に影響を与える部分式が含まれていれば、これらの部分式から返される位置変数と項目との対応付けは、<termref def="dt-ordering-mode">順序付けモード</termref>が <code>unordered</code> であるとき、<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
</div3>
<div3 id="id-where"><head>Where 節</head>
<p><code>where</code> 節は省略可能であり、<code>for</code> 節や <code>let</code> 節で生成された変数束縛の組に対する選別機能を提供する。<code>where</code> 節中の式を<term>where-式</term>といい、これらの組それぞれに対して1回評価される。where-式の<termref def="dt-ebv">有効ブール値</termref>が <code>true</code> であれば、その組は残され、その変数束縛が <code>return</code> 節の実行に用いられる。where-式の<termref def="dt-ebv">有効ブール値</termref>が <code>false</code> であれば、その組は捨てられる。式の<termref def="dt-ebv">有効ブール値</termref>は<specref ref="id-ebv"/>で定義されている。</p>
<p>以下の式は、入力列にサンプリングを行うために、<code>where</code> 節がどのようにして<term>位置変数</term>に適用されるかを示している。この式は100個の入力値から1つをサンプリングすることで列の平均値を近似している。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">fn:avg(for $x at $i in $inputvalues
    where $i mod 100 = 0   
    return $x)</phrase></eg>
</div3>
<div3 id="id-orderby-return"><head>Order By 節と Return 節</head>
<p>FLWOR 式の <code>return</code> 節は組ストリーム中の組それぞれに対して1度評価され、<termref def="dt-comma-operator">コンマ演算子</termref>のようにこれらの評価の結果が連接され、FLWOR 式の結果を形成する。</p>
<p><code>order by</code> 節がなければ、組ストリームの順序は <code>for</code> 節や <code>let</code> 節、および<termref def="dt-ordering-mode">順序付けモード</termref>で決められる。<code>order by</code> 節があれば、組ストリームの組は再び順序づけされ、値を基礎とする新しい順序になる。どちらの場合も、結果の順序によって、それぞれの組について、組中の変数束縛を用いて <code>return</code> 節が評価される順序が決定される。<code>order by</code> 節があれば、<termref def="dt-ordering-mode">順序付けモード</termref>は FLWOR 式には影響を及ぼさないことに注意せよ。なぜなら <code>order by</code> が<termref def="dt-ordering-mode">順序付けモード</termref>に優先するからである。</p> 
<p><code>order by</code> 節は1個以上の順序付け指定を含む。これを、上の文法に示す通り、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderSpec" xlink:type="simple">orderspecs</nt> という。 組ストリーム中の各組に対して、<code>where</code> 節で選別を行った後、その組の変数束縛を用いて orderspec が評価される。2つの組の間の相対順序は、それらの orderspec の値を評価することで決定される。このとき、異なる値の組が得られるまで左から右に処理が行われる。orderspec に <termref def="dt-collation">照合順序</termref>が指定されていれば、<code>xs:string</code>型、<code>xs:anyURI</code>型、およびそれらから導出される型の値を比較するのにその照合順序が用いられる (そうでなければ、<termref def="dt-def-collation">デフォルト照合順序</termref>が用いられる)。相対 URI によって orderspec に照合順序が指定されていれば、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-base-uri">基礎 URI</termref>を用いて、その相対 URI が絶対 URI に解決される。<termref def="dt-static-collations">静的既知照合順序</termref>にない照合順序が orderspec に指定されていれば、エラーが発生する <errorref class="ST" code="0076"/>。</p>
<p>orderspec を評価し比較する処理は以下のルールに基づいている:</p> 
<ulist><item>
<p>それぞれの orderspec 中の式の結果に<termref def="dt-atomization">原子化</termref>が適用される。原子化の結果が原子値1つでも空列でもなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p> 
</item>
<item> 
<p>orderspec の値が<termref def="dt-dynamic-type">動的型</termref> <code>xs:untypedAtomic</code>を持っていれば (スキーマのない文書中の文字データのように)、<code>xs:string</code>型に型変換される。</p> 
<note><p>型付けされていない値を常に文字列と扱うことにより、整列されるべき値すべての型に関する完全な知識がなくても整列を始めることが可能になる。</p></note>
</item>
<item><p>空でない orderspec の値はすべて、<termref def="dt-subtype-substitution">部分型置換</termref>や<termref def="dt-type-promotion">型昇格</termref>により、共通な型に変換しなければならない。順序付けは、<code>gt</code> 演算子を持つ最小の共通型上で行われる。2つ以上の空でない orderspec の値が <code>gt</code> 演算子を持つ共通型に変換できなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<ulist>
<item><p>例: orderdesc の値に <code>hatsize</code> 型の値と <code>shoesize</code> 型の値が含まれていたとする。ここで <code>hatsize</code> 型は <code>xs:integer</code> から、<code>shoesize</code> 型は <code>xs:decimal</code> からそれぞれ導出されているとする。部分型置換や型昇格によって到達可能な最小共通型は <code>xs:decimal</code> である。</p></item>
<item><p>例: orderdesc の値に <code>xs:string</code> 型の値と <code>xs:anyURI</code> 型の値が含まれていたとする。部分型置換や型昇格によって到達可能な最小共通型は <code>xs:string</code> である。</p></item>
</ulist></item>
</ulist>
<p>2つの overspec の値が比較されて順序列中での相対位置が決定されるとき、<emph>greater-than</emph> 関連が以下のように定義される:</p>
<ulist>
<item><p>orderspec が <code>empty least</code> と指定されているとき、値 W が値 V に対して <emph>greater-than</emph> であるのは、以下のいずれかの条件が true のときである:</p>
<ulist>
<item><p>V が空列で W が空列でない。</p></item>
<item><p>V が <code>NaN</code> で、W が <code>NaN</code> でも空列でもない。</p></item>
<item><p>照合順序が指定されておらず、W <code>gt</code> V が true である。</p></item>
<item><p>ある照合順序 C が指定されており、<code>fn:compare(V, W, C)</code> が 0 より小さい。</p></item>
</ulist></item>
<item><p>orderspce が <code>empty greatest</code> と指定されているとき、値 W が値 V に対して <emph>greater-than</emph> であるのは、以下の条件のいずれかが true のときである:</p>
<ulist>
<item><p>W が空列で V が空列でない。</p></item>
<item><p>W が <code>NaN</code> で、V が <code>NaN</code> でも空列でもない。</p></item>
<item><p>照合順序が指定されておらず、W <code>gt</code> V が true である。</p></item>
<item><p>ある照合順序 C が指定されており、<code>fn:compare(V, W, C)</code> が 0 より小さい。</p></item>
</ulist></item>
<item><p>orderspec が <code>empty least</code> とも <code>empty greatest</code> とも指定されていなければ、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-default-empty-order">空列に対するデフォルト順序付け</termref>により、<code>empty least</code> のためのルールと <code>empty greatest</code> のためのルールのいずれが使われるか決定される。</p></item></ulist> 
<p>T1 と T2 を組ストリーム中の2つの組、これらの orderspec について (上で定義したように) いずれかの値が他方の値に対して <emph>greater-than</emph> であるかを左から右に評価したときに得られた最初の値の組を V1 と V2 とする。このとき:</p> 
<olist> 
<item> <p>V1 が V2 に対して <emph>greater-than</emph> であれば: orderspec が <code>descending</code> と指定されていれば、T1 が T2 より組ストリーム中で前に来る。そうでない場合は、T2 が T1 より組ストリーム中で前に来る。</p></item>
<item><p>V2 が V1 に対して <emph>greater-than</emph> であれば: orderspce が <code>descending</code> と指定されていれば、T2 が T1 より組ストリーム中で前に来る。そうでない場合は、T1 が T2 より組ストリーム中で前に来る。</p></item> 
 
 
 
</olist>
<p>組 T1 と T2 の orderspec の任意の2つ組に対し、V1 も V2 も他方に対して <emph>greater-than</emph> でない場合、以下のルールが適用される。</p>
<olist>
<item><p><code>stable</code> が指定されていれば、組ストリーム中での T1 と T2 の元の順序が保存される。</p></item>
<item><p><code>stable</code> が指定されていなければ、組ストリーム中での T1 と T2 の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。</p></item>
</olist> 
<note><p>2つの orderspec が特別な浮動小数点数の値である正負の 0 を返せば、これらの値はいずれも他方に対して <emph>greater-than</emph> ではない。なぜなら <code>+0.0 gt -0.0</code> と <code>-0.0 gt +0.0</code> はいずれも <code>false</code> だからである。</p></note>
<p><code>order by</code> 節は、FLWOR 式の結果の整列を容易に行うことができる。整列のキーがその FLWOR 式の結果に含まれていなくてもよい。例えば、以下の式は employee の名前を salary の降順に返すが、実際の salary の値は返さない:</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $e in $employees 
order by $e/salary descending 
return $e/name</phrase></eg>
<note><p>FLWOR 式中の <code>order by</code> 節は XQuery で値の整列を指定するために提供されている唯一の手段であるため、整列を行わないならば繰り返しが必要ないような問い合わせでも FLWOR 式を用いなければならない。例えば、price が 100 より小さい book のリストは、<code>$books/book[price &lt; 100]</code> といった単純な<termref def="dt-path-expression">経路式</termref>でも得ることができる。しかしこれらの book を title のアルファベット順に返そうとすると、問合せは以下のように表現しなければならない:</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</phrase></eg></note> 
 
 
<p>以下に示すのは、いろいろなオプションを用いた <code>order by</code> 節の例である。この例により、book の集まりについて title を第1順序、price を第2順序として整列した結果が得られる。title の順序付けには特定の<termref def="dt-collation">照合順序</termref>が指定されている。また、price の順序付けでは price のない book が (可能な最小の値段を持つと考え) 最後に出現するように指定されている。同じ title と price を持つ2つの book が出現した場合は、キーワード <code>stable</code> により、入力の順序が保存されることが示されている。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $b in $books/book
stable order by $b/title 
      collation "http://www.example.org/collations/fr-ca",
   $b/price descending empty least
return $b</phrase></eg>
<note><p>コンマ演算子を含む <code>return</code> 節では括弧が役に立つ。なぜなら FLWOR 式はコンマ演算より優先度が高いからである。例えば、以下の問い合わせはエラーを発生する。なぜならコンマの後ろでは、<code>$j</code> は FLWOR 式の内側ではなく、未定義の変数であるからである:</p>
<eg role="parse-test" xml:space="preserve">let $i := 5,
    $j := 20 * $i
return $i, $j</eg>
<p><code>$j</code> を <code>return</code> 式の内側に持ってくるには、プログラマならおそらく意図した通りだろうが、括弧を用いることができる。</p>
<eg role="parse-test" xml:space="preserve">let $i := 5,
    $j := 20 * $i
return ($i, $j)</eg></note>
</div3>
<div3 id="id-flwor-example"><head>例</head>
<p>以下に示すのは、FLWOR 式が入れ子にできるという例や、要素階層の複数の深さで順序付けを指定できるという例である。この例の問合せでは、文書階層を逆順にし、bibliograph を author のリストに変換している。入力 (変数 <code>$bib</code> に束縛されている) は <code>bib</code> 要素であり、これには book のリストが含まれる。それぞれの book にはさらに author のリストが含まれる。この例は以下の入力に基づいている:</p> 
 
<eg xml:space="preserve">&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</eg> 
<p>以下の問合せは、入力文書を著者のリストに変換するものである。それぞれの著者について、名前が1回のみ出現し、次にその著者によって書かれた本のタイトルのリストが続く。<code>fn:distinct-values</code> 関数は、author 節点のリストから (値によって) 重複を取り除く関数である。author のリスト、およびそれぞれの author によって出版された book のリストは、<termref def="dt-def-collation">デフォルト照合順序</termref>を用いてアルファベット順で返される。</p> 
 
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">&lt;authlist&gt;
 {
   for $a in fn:distinct-values($bib/book/author)
   order by $a
   return
     &lt;author&gt;
        &lt;name&gt; {$a} &lt;/name&gt;
        &lt;books&gt;
          {
            for $b in $bib/book[author = $a]
            order by $b/title
            return $b/title 
          }
        &lt;/books&gt;
     &lt;/author&gt;
 }
&lt;/authlist&gt;</phrase></eg> 
 
<p>上の式の結果は次のようになる:</p> 
<eg xml:space="preserve">&lt;authlist&gt;
   &lt;author&gt;
      &lt;name&gt;Abiteboul&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Buneman&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Stevens&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Advanced Programming
                in the Unix Environment&lt;/title&gt;
         &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Suciu&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
&lt;/authlist&gt;</eg></div3></div2>
<div2 role="xquery" id="id-unordered-expressions"> 
<head>順序化式と非順序化式</head> 
<scrap headstyle="show"> 
<head/> <prod num="91" id="doc-xquery-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod> 
<prod num="92" id="doc-xquery-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod></scrap>
<p><code>順序化</code>式と<code>非順序化</code>式の目的は、問合せのある領域に対して<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-ordering-mode">順序付けモード</termref>を <code>ordered</code> や <code>unordered</code> に設定することである。指定された順序付けモードは、波括弧の内側に入れ子になった式に対して適用される。結果の順序付けが明示されていない式に対しては、順序付けモードを <code>unordered</code> に設定し、最も効率的に得られる順序で結果を返すようなシステムの柔軟性を保証することにより、有利な処理性能が実現されるかもしれない。</p>
<p> <termref def="dt-ordering-mode">順序付けモード</termref>は以下の式の振舞いに影響を与える: "<code>/</code>" や "<code>//</code>" 演算子、あるいは<termref def="dt-axis-step">軸ステップ</termref>を含む<termref def="dt-path-expression">経路式</termref>; <code>union</code>, <code>intersect</code>, および <code>except</code> 式; the <code>fn:id</code> and <code>fn:idref</code> functions; <code>order by</code> 節を持たない FLWOR 式。順序付けモードが <code>ordered</code> であれば、経路式, <code>union</code>, <code>intersect</code>, <code>except</code> 式などによって返される節点列は<termref def="dt-document-order">文書順</termref>である。そうでない場合は、これらの結果得られる節点列の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。FLWOR 式上での順序付けモードの効果については<specref ref="id-flwor-expressions"/>で記述されている。重複の除去については、順序付けモードは効果がない。</p>
<note><p>順序付けモードが <code>unordered</code> であるような問合せの領域では、節点列の順序付けに依存するある種の関数は非決定的な結果を返してもよい。このような関数には、<code>fn:position</code>, <code>fn:last</code>, <code>fn:index-of</code>, <code>fn:insert-before</code>, <code>fn:remove</code>, <code>fn:reverse</code>, <code>fn:subsequence</code> がある。また、非順序化領域中の<termref def="dt-path-expression">経路式</termref>では、<termref def="dt-numeric-predicate">数述語</termref>は非決定的である。例えば、順序化領域では、経路式 <code>(//a/b)[5]</code> は<termref def="dt-document-order">文書順</termref>で5番目に限量される <code>b</code> 要素を返す。非順序化領域では、同じ式は<termref def="dt-implementation-dependent">実装依存</termref>で限量される <code>b</code> 要素を返す。</p></note> 
<note><p><bibref ref="FunctionsAndOperators"/>にあるように、<code>fn:id</code> 関数と <code>fn:idref</code> 関数は、結果を<termref def="dt-document-order">文書順</termref>で返す。順序付けモードは XQuery の機能であるので、順序付けモードが <code>unordered</code> のときに関数の結果に対する順序付けの要求を緩めることは、関数自身の機能というよりは XQuery の機能である。</p></note>

<p><code>unordered</code> 式の使い方を以下の例で示す。この例は、2つの文書 <code>parts.xml</code> と <code>suppliers.xml</code> を結合する、というものである。この例は、赤い部品 (part) の部品番号と、これらの部品を供給している供給者 (supplier) の供給者番号を組にして返す。<code>unordered</code> 式を使わないならば、結果として得られる (部品番号, 供給者番号) のリストは、まず <code>parts.xml</code> の<termref def="dt-document-order">文書順</termref>に、次に <code>suppliers.xml</code> の<termref def="dt-document-order">文書順</termref>によって制御された順序付けを持つことが要求される。しかし、結果の順序が重要でないならば、これは、この問合せを処理する最も効率的な方法ではないかもしれない。XQuery の実装は、索引を用いて赤い部品を見つけたり、結果の順序を制御するのに <code>suppliers.xml</code> を <code>parts.xml</code> よりも先に用いたりするなどして、問合せをより効率的に処理することができるかもしれない。<code>unordered</code> 式により、問合せ評価器はこれらの種類の最適化を自由に使える。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno  
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}</phrase></eg>
<p><code>ordered</code> 式と <code>unordered</code> 式に加え、XQuery は <code>fn:unordered</code> という名前の関数を用意している。これは任意の項目列に対して作用し、同じ列を非決定的な順序で返す。<code>fn:unordered</code> 関数の呼び出しは、実体化された引数の式に対して、システムがより効率的な順序を見つけてもよい、というある種の許可と考えてもよい。<code>fn:unordered</code> 関数は、その直接的な演算数の列に対してのみ順序付けを緩める。一方、<code>unordered</code> 式は、その演算数の式および入れ子になったすべての式に対して<termref def="dt-ordering-mode">順序付けモード</termref>を設定する。</p></div2>
<div2 id="id-conditionals"> 
<head>条件式</head> 
<p>XQueryはキーワード<code>if</code>, <code>then</code>, <code>else</code>に基づく条件式を支援する。</p> 
<scrap headstyle="show"> 
<head/>  
<prod num="45" id="doc-xquery-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
</scrap> 
<p>キーワード<code>if</code>に続く式を<term>テスト式</term>という。またキーワード<code>then</code>や<code>else</code>に続く式をそれぞれ<term>then式</term>、<term>else式</term>という。</p> 
<p>条件式を処理する最初の段階は、テスト式の<termref def="dt-ebv">有効ブール値</termref>を求めることである。これは<specref ref="id-ebv"/>に定義されている通りである。</p> 
 
<p>条件式の値は以下のように定義される: テスト式の有効ブール値が<code>true</code>であれば、then式の値が返される。テスト式の有効ブール値が<code>false</code>であれば、else式の値が返される。</p>
<p>条件式には、<termref def="dt-dynamic-error">動的エラー</termref>の伝搬に関する特別なルールがある。テスト式の有効値が<code>true</code>であれば、条件式は、else式から起こる動的エラーをすべて無視する (発生させない)。この場合、else式は観測可能な作用を持たなくてもよいため、評価される必要はない。同様に、テスト式の有効値が<code>false</code>であれば、条件式は、then式から起こる<termref def="dt-dynamic-error">動的エラー</termref>をすべて無視し、then式は評価される必要はない。</p> 
<p>以下に、条件式の例をいくつか示す。</p> 
<ulist> 
<item> 
<p>この例では、テスト式は比較式である。</p> 
<eg role="parse-test" xml:space="preserve">if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2</eg> 
</item> 
<item> 
<p>この例では、テスト式は<code>discounted</code>という属性の有無を調べている。その属性の値には依存しない。</p> 
<eg role="parse-test" xml:space="preserve">if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail</eg> 
</item> 
</ulist>	
</div2>	
<div2 id="id-quantified-expressions">
<head>限量式</head> 
<p>限量式は存在限量子と全称限量子を支援する。限量式の値は常に<code>true</code>か<code>false</code>である。</p>
<scrap headstyle="show">
<head/> 

<prod num="42" id="doc-xquery-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
<prod num="118" id="noid_N145B3.doc-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod>
</scrap>
<p><term>限量式</term>は<term>限量子</term>で始まる。これはキーワード<code>some</code>か<code>every</code>である。これに1つ以上のin節が続き、変数を束縛するのに用いられる。さらにキーワード<code>satisfies</code>とテスト式が続く。各in節は、項目の列を返す式に変数を関連づける。この列のことを、その変数に対する<term>束縛列</term>という。in節は変数束縛の組を生成する。これには、それぞれの変数に対する束縛列中の項目の組み合わせ各々に対応する組が含まれる。概念的には、テスト式は、変数束縛の組それぞれについて評価される。結果はテスト式の<termref def="dt-ebv">有効ブール値</termref>に依存する。これは<specref ref="id-ebv"/>で定義されている通りである。限量式の値は以下のルールによって定義される。</p>
<olist>
<item>
<p>限量子が<code>some</code>であれば、限量式は、テスト式の評価のうち少なくとも1つが<termref def="dt-ebv">有効ブール値</termref> <code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>false</code>であることが分かる。</p>
</item>
<item>
<p>限量子が<code>every</code>であれば、限量式は、テスト式の評価がすべて<termref def="dt-ebv">有効ブール値</termref> <code>true</code>を持つとき<code>true</code>である。そうでない場合、限量式は<code>false</code>である。このルールから、in節が束縛された組を1つも生成しない場合は、限量式の値は<code>true</code>であることが分かる。</p>
</item>
</olist>


<p>限量式中で束縛された変数の有効範囲は、その限量式の部分式のうちその変数束縛の後ろで出現したものすべてから構成される。有効範囲にはその変数が束縛される式は含まれない。</p>
<p role="xquery">限量式の in 節で束縛された変数はそれぞれ、省略可能な<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">型宣言</nt>を持つ。変数に束縛された値の型が、<termref def="dt-sequencetype-matching">SequenceType の照合</termref>のルールに従って、宣言された型と照合されないならば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p>テスト式がさまざまな変数束縛組に対して評価される順序は<termref def="dt-implementation-dependent">実装依存</termref>である。限量子が<code>some</code>であれば、実装は、テスト式が<code>true</code>という<termref def="dt-ebv">有効ブール値</termref>を持つ束縛組を1つ見つけたら直ちに<code>true</code>を返してもよい。また、テスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。同様に、限量式が<code>every</code>であれば、実装は、テスト式が<code>false</code>という<termref def="dt-ebv">有効ブール値</termref>を持つ束縛組を1つ見つけたら直ちに<code>false</code>を返してよい。またテスト式がエラーを発生するような束縛組を1つ見つけたら直ちに、<termref def="dt-dynamic-error">動的エラー</termref>を発生してもよい。これらのルールの結果として、以下の例で示すように、限量式の値は、エラーが存在する場合には決定的ではない。</p>
<p>以下に、限量式の例をいくつか示す。</p>
<ulist>
<item>
<p>この式は、すべての<code>part</code>要素が<code>discounted</code>属性を持つならば (これらの属性の値に関わらず)、<code>true</code>である。</p> 
<eg role="parse-test" xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</eg>
</item> 
<item>
<p>この式は、少なくとも1つの<code>employee</code>要素が与えられた比較式を満たすならば<code>true</code>である。</p> 
<eg role="parse-test" xml:space="preserve">some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)</eg>
</item>
<item>
<p>以下の例では、各限量式がテスト式を9つの変数束縛の組上で評価する。9つの変数束縛とは、列<code>(1, 2, 3)</code>と<code>(2, 3, 4)</code>の直積から構成される。<code>some</code>で始まる式を評価すると<code>true</code>であり、<code>every</code>で始まる式を評価すると<code>false</code>である。</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg>
</item>
<item>
<p>この限量式は<code>true</code>を返すか、<termref def="dt-type-error">型エラー</termref>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>true</code>を返し、別の変数束縛に対して<termref def="dt-type-error">型エラー</termref>を発生するからである。</p>
<eg role="parse-test" xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>
<item>
<p>この限量式は<code>false</code>を返すか<termref def="dt-type-error">型エラー</termref>を発生する。というのは、テスト式が、ある1つの変数束縛に対して<code>false</code>を返し、別の変数束縛に対して<termref def="dt-type-error">型エラー</termref>を発生するからである。</p>
<eg role="parse-test" xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item> 
<item role="xquery">
<p>この限量式は、テスト式中の項目いずれでも満たされない<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">型宣言</nt>を含む。<termref def="dt-static-typing-feature">静的型付け機能</termref>が実装されていれば、この式は、<termref def="dt-static-analysis">静的解析相</termref>で<termref def="dt-type-error">型エラー</termref>を発生する。そうでない場合は、この式は<code>true</code>を返してもよいし、 or raise a <termref def="dt-dynamic-evaluation">動的評価相</termref>で<termref def="dt-type-error">型エラー</termref>を発生してもよい。</p>
<eg role="parse-test" xml:space="preserve">some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>
</ulist>
</div2> 
<div2 id="id-expressions-on-datatypes"> 
<head>SequenceTypes上の式</head> 
<p><phrase role="xquery">関数の引数や結果で使われるのに加えて、</phrase><termref def="dt-sequence-type">列型</termref>は<code>instance of</code>式, <phrase role="xquery"><code>typeswitch</code>,</phrase> <code>cast</code>式, <code>castable</code>式, <code>treat</code>式で使われている。</p> 
 
 
 
 
 
 
 
<div3 id="id-instance-of"><head>Instance Of</head><scrap headstyle="show"> 
<head/> 
    
<prod num="54" id="doc-xquery-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>
</scrap>
<p>ブール演算子<code>instance of</code>は、第1演算数の値が第2演算数の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>に照合されるとき、<code>true</code>を返す。これは<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>にあるルールに従う。そうでない場合は<code>false</code>を返す。例えば:</p> 
<ulist>
<item><p><code role="parse-test">5 instance of xs:integer</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が与えられた型のインスタンスであるからである。</p></item>
<item><p><code>5 instance of xs:decimal</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた値が整数リテラルで、<code>xs:integer</code>が制限によって<code>xs:decimal</code>から導出されるからである。</p></item>
<item role="xquery"><p><code role="parse-test">&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code></p><p>この例は <code>false</code> を返す。なぜなら与えられた値は要素であり整数ではないからである。</p></item>
<item><p><code>(5, 6) instance of xs:integer+</code></p>
<p>この例は<code>true</code>を返す。なぜなら与えられた列は2つの整数を含んでおり、指定された型の正しいインスタンスであるからである。</p></item>
<item><p><code role="parse-test">. instance of element()</code></p>
<p>文脈項目が要素節点のとき、この例は<code>true</code>を返す。文脈項目が定義されているが要素節点ではないとき、この例は<code>false</code>を返す。文脈項目が未定義であれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0002"/>。</p></item></ulist>
</div3>
<div3 id="id-typeswitch" role="xquery"><head>Typeswitch</head><scrap headstyle="show"> 
<head/> 
 <prod num="43" id="doc-xquery-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> <prod num="44" id="doc-xquery-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>  
 <prod num="43" id="doc-xquery-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> <prod num="44" id="doc-xquery-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
</scrap>
<p role="xquery"><term>typeswitch</term> 式は、入力値の<termref def="dt-dynamic-type">動的型</termref>を基に、いくつかの式から評価すべき式を1つ選ぶ。</p> 
<p role="xquery"><code>typeswitch</code> 式では、キーワード <code>typeswitch</code> の次に括弧で囲まれた式が続く。この式を<term>演算数式</term>という。これは、その型がテストされる式である。<code>typeswitch</code> 式の残りの部分は、1つ以上の <code>case</code> 節と <code>default</code> 節1つから成る。</p> 
<p role="xquery"><code>case</code> 節はそれぞれ、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> の次に <code>return</code> 式を1つ指定する。 <termdef term="effective case" id="dt-effective-case"><code>typeswitch</code> 式の<term>有効な case</term>は、演算数式の値が <code>case</code> 節中の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> に照合されるような <code>case</code> 節のうち最初のものである。照合には<termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のルールが用いられる。</termdef> <code>typeswitch</code> 式の値は、有効な case 中の <code>return</code> 式の値である。演算数式の値がどの <code>case</code> 節の <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> にも照合されなければ、<code>typeswitch</code> 式の値は <code>default</code> 節の <code>return</code> 式の値である。</p>
<p><code>case</code> 節や <code>default</code> 節では、返すべき値が演算数式の値に依存していれば、その節は変数名を指定しなければならない。<code>case</code> 節や <code>default</code> 節の <code>return</code> 式中では、この変数名は演算数式の値に束縛される。<code>case</code> 節の中では、変数の<termref def="dt-static-type">静的型</termref>は <code>case</code> 節で名付けられている <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> である。<code>default</code> 節の中では、変数の静的型は演算数式の静的型と等しい。<code>case</code> 節や <code>default</code> 節で返される値が演算数式の値に依存しないならば、その節で変数を指定する必要はない。</p>
<p>The scope of a variable binding in a <code>case</code> 節や <code>default</code> 節中の変数束縛の有効範囲は、その節からなる。同じ <code>typeswitch</code> 式中の2つ以上の <code>case</code> 節や <code>default</code> 節に対して同じ名前の変数を束縛しても、エラーではない。</p> 
 
<p><code>typeswitch</code> 式での<termref def="dt-dynamic-error">動的エラー</termref>を伝搬させる際には特別なルールが適用される。<code>typeswitch</code> 式は<termref def="dt-effective-case">有効な case</termref>以外の <code>case</code> 節で発生する動的エラーをいずれも無視する (発生させない)。<code>default</code> 節で発生する動的エラーは、<termref def="dt-effective-case">有効な case</termref>がない場合にのみ発生する。</p><p role="xquery">以下に示すのは、式の<termref def="dt-dynamic-type">動的型</termref>に依存してその式を処理するのに、<code>typeswitch</code> 式を用いている例である。</p>
<eg role="xquery" xml:space="preserve"><phrase role="parse-test">typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"</phrase>
</eg></div3>
<div3 id="id-cast"><head>Cast</head><scrap headstyle="show"> 
<head/> 
    
   <prod num="57" id="doc-xquery-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod>

<prod num="117" id="doc-xquery-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>
</scrap>
<p>場合によっては、値を指定されたデータ型に変換する必要が生じる。この目的のため、XQueryは<code>cast</code>式を用意している。これは、すでにある値に基づき、指定された型の値を新たに生成する。<code>cast</code>式は2つの演算数を取る。<term>入力式</term>と<term>目的型</term>である。入力式の型を<term>入力型</term>という。目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>に含まれており、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また原子型の後ろに出現標識 "<code>?</code>" を置き、空列を許すということを示してもよい <errorref class="ST" code="0080"/>。目的型が名前空間接頭辞を持たないならば、その目的型は<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>に属するとみなされる。<code>cast</code>式の意味は以下の通りである。</p>
<olist>
<item><p><termref def="dt-atomization">原子化</termref>が入力式に対して行われる。</p></item>
<item><p>原子化の結果が長さ1より大きい原子値の列であれば、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item>
<item><p>原子化の結果が空列であれば:</p>
<olist>
<item><p>目的型の後ろに<code>?</code>が指定してあれば、<code>cast</code>式の結果は空列である。</p></item>
<item><p>目的型の後ろに<code>?</code>が指定してなければ、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p></item></olist>
</item>
<item><p>原子化の結果が単一の原子値であれば、cast式の結果は入力型と目的型に依存する。一般的に、cast式は、入力値に基づき目的型の値を新たに生成しようと試みる。ある種の入力型と目的型の組み合わせだけが支援されている。このルールの概要を以下に列挙する。これらのルールの規範的定義は<bibref ref="FunctionsAndOperators"/>にある。これらのルールの目的のため、実装は、<termref def="dt-issd">有効範囲内スキーマ定義</termref>を検査したり、あるいはその代替としてデータ辞書のような<termref def="dt-implementation-dependent">実装依存</termref>の機構を用いて、ある型が別の型から制限によって導出されると決定してもよい。</p>

<olist><item><p><code>cast</code>は、<xspecref spec="FO" ref="casting-from-primitive-to-primitive"/>に列挙されている入力型と目的型の組み合わせに対して支援される。これらの組み合わせそれぞれについて、入力型と目的型は基本<termref def="dt-schema-type">スキーマ型</termref>である。例えば、<code>xs:string</code>型の値はスキーマ型<code>xs:decimal</code>に型変換することができる。これらの組み込みの組み合わせについては、型変換の意味が<bibref ref="FunctionsAndOperators"/>で指定されている。</p>
<p><code>cast</code>式の目的型が<code>xs:QName</code>であるか、<code>xs:QName</code>または<code>xs:NOTATION</code>から導出される型であるか、入力の基礎型が目的型の基礎型と等しくないならば、入力式は文字列リテラルでなければならない <errorref code="0004" class="TY"/>。</p>
<note><p>このルールの理由は、これらの目的型の1つのインスタンスを文字列から構成するには名前空間の束縛に関する知識が必要になる、ということである。入力式がリテラルでない文字列であれば、名前空間の束縛が<termref def="dt-static-namespaces">静的既知名前空間</termref>と異なる入力文書から導出されるかもしれない。</p></note></item>
<item><p><code>cast</code>は、入力型が基本でない原子型で、目的型から制限によって導出される場合に支援される。この場合、入力値は目的型の値空間に写像され、その型以外には変更されない。例えば、<code>shoesize</code>が制限によって<code>xs:integer</code>から導出されるならば、型<code>shoesize</code>の値はスキーマ型<code>xs:integer</code>に型変換することができる。</p></item>
<item><p><code>cast</code>は、目的型が基本でない原子型で、入力型が<code>xs:string</code>または<code>xs:untypedAtomic</code>である場合に支援される。入力値はまず、目的型に対する空白の正規化ルールを適用する（<bibref ref="XMLSchema"/>で定義されているように）ことで、目的型の字句空間中の値に変換される。結果の字句値が目的型のパターンの相 (facet) を満たさないならば、<termref def="dt-dynamic-error">動的エラー</termref> [err:FORG0001] が発生する。次に字句値は、目的型のスキーマ定義ルールを用いて、目的型の値空間に変換される。結果の値が目的型のすべての相を満たさないならば、<termref def="dt-dynamic-error">動的エラー</termref> [err:FORG0001] が発生する。</p></item>
<item><p><code>cast</code>は、目的型が基本型でない原子型であり、かつ入力型から制限によって導出されるならば、支援される。入力値は目的型のすべての相を満たさなければならない (パターンの相の場合には、これは、<code>xs:string</code>への型変換ルールを用いて、入力値の文字列表現を生成することで検査される)。結果の値は入力値と等しい。ただし<termref def="dt-dynamic-type">動的型</termref>は異なる。</p></item>
<item><p>基本型 P1 が基本型 P2 に型変換されるならば、制限によって P1 から導出される任意の型は、制限によって P2 から導出される任意の型に型変換できる。そして、目的型の相が満たされると規定される。まず、上のルール (b) を用いて、入力値が P1 に型変換される。次に、上のルール (a) を用いて、P1 型の値が P2 型に変換される。最後に、上のルール (d) を用いて、P2 型の値が目的型に変換される。</p></item>
<item><p>上に列挙されていない入力型と目的型の組み合わせに対して、<code>cast</code>式は<termref def="dt-type-error">型エラー</termref> <errorref class="TY" code="0004"/>を発生する。</p></item></olist>

</item></olist>
<p>入力型から目的型への型変換が支援されているが、にもかかわらず入力値を目的型の値空間に型変換することが不可能であれば、<termref def="dt-dynamic-error">動的エラー</termref>が発生する。 [err:FORG0001] これは、目的型のどの相も満たされない場合を含む。例えば、式<code>"2003-02-31" cast as xs:date</code>は<termref def="dt-dynamic-error">動的エラー</termref>を発生する。</p> 
</div3><div3 id="id-castable"><head>Castable</head><scrap headstyle="show"> 
<head/> 
    


<prod num="56" id="doc-xquery-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="117" id="noid_N14900.doc-xquery-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod>
</scrap>
<p>XQueryは、与えられた値が与えられた目的型に型変換可能かテストする式を用意している。目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>に含まれていなければならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。また、空列を許すことを示すために出現標識 "<code>?</code>" を後ろに付けることができる <errorref class="ST" code="0080"/>。式<code>V castable
as T</code>が<code>true</code>を返すのは、<code>cast</code>式を用いて値<code>V</code>が目的型<code>T</code>に型変換することに成功する場合である。そうでない場合は<code>false</code>を返す。<code>castable</code>式を<termref def="dt-predicate">述語</termref>として用い、評価時のエラーを避けることも可能である。また、適切な型を選択して与えられた値を処理することにも利用できる。以下に例を示す。</p>
<eg role="parse-test" xml:space="preserve">
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string</eg></div3>
<div3 id="id-constructor-functions"><head>構成子関数</head>
<p><termref def="dt-is-types">有効範囲内スキーマ型</termref>中の原子型それぞれについて (<code>xs:NOTATION</code>および<code>xs:anyAtomicType</code>を除く。これらはインスタンスを生成できない)、<term>構成子関数</term>が暗黙的に定義される。それぞれの場合について、構成子関数の名前は目的型の名前 (名前空間を含む)と同じである。型<emph>T</emph>の構成子関数のシグネチャは以下の通りである。</p>

<eg xml:space="preserve"><emph>T</emph>($arg as xs:anyAtomicType?) as <emph>T?</emph></eg>

<p> <termdef term="constructor function" id="dt-constructor-function">与えられた型に対する<term>構成子関数</term>は、他の原子型のインスタンスを与えられた型に変換するのに用いられる。構成子関数 <code>T($arg)</code>の意味は式<code>($arg cast as T?)</code>と同じであると定義される。</termdef></p>
<p><code>xs:QName</code>、あるいは<code>xs:QName</code>や<code>xs:NOTATION</code>から導出される型に対する構成子関数では、文字列リテラルの引数か、目的型の基礎型と同じ基礎型を持つ引数を要求する。そうでない場合は型エラー <errorref code="0004" class="ST"/> が発生する。このルールは、<specref ref="id-cast"/>に定義されているこれらの型に対する<code>cast</code>式の意味と一貫している。</p>
<p>構成子関数の使い方を以下の例で示す。</p>
<ulist>
<item><p>この例は<code>("2000-01-01" cast as xs:date?)</code>に等しい。</p>

<eg role="parse-test" xml:space="preserve">xs:date("2000-01-01")</eg></item>
<item><p>この例は<code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>に等しい。</p>
<eg role="parse-test" xml:space="preserve">xs:decimal($floatvalue * 0.2E-5)</eg></item>
<item><p>この例は、21日に等しい<code>xs:dayTimeDuration</code>の値を返す。これは<code>("P21D" cast as xs:dayTimeDuration?)</code>と同値である。</p>
<eg role="parse-test" xml:space="preserve">xs:dayTimeDuration("P21D")</eg></item>
<item><p><code>usa:zipcode</code>がユーザ定義の原子型であり<termref def="dt-is-types">有効範囲内スキーマ型</termref>中にあるならば、以下の式は、式<code>("12345" cast as
usa:zipcode?)</code>と同値である。</p>
<eg role="parse-test" xml:space="preserve">usa:zipcode("12345")</eg></item></ulist>

<note><p>名前空間中にない原子型のインスタンスは、以下のいずれかの方法で構成することができる。</p>
<ulist>
<item><p>もし<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>が "none" であれば、<code>cast</code>式を用いる。<phrase role="xquery">(<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>の定義を取り消す方法については、<specref ref="id-default-namespace"/>を見よ。) </phrase></p><eg role="parse-test" xml:space="preserve">17 cast as apple</eg></item>
<item><p>もし<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>が "none" であれば、構成子関数を用いる。<phrase role="xquery">(<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>を取り消す方法については、<specref ref="id-default-namespace"/>を見よ。)</phrase></p>
<eg role="parse-test" xml:space="preserve">apple(17)
</eg></item>
</ulist></note></div3>
<div3 id="id-treat"><head>Treat</head><scrap headstyle="show"> <head/>  
<prod num="55" id="doc-xquery-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>
</scrap>
<p>XQueryは<code>treat</code>と呼ばれる式を用意している。これは、演算数の<termref def="dt-static-type">静的型</termref>を変更するのに用いることができる。</p>
<p><code>cast</code>のように、<code>treat</code>式は2つの演算数をとる。式と<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>である。しかし、<code>cast</code>とは異なり、<code>treat</code>はその演算数の<termref def="dt-dynamic-type">動的型</termref>や値は変更しない。そのかわり、<code>treat</code>の目的は、式が評価時に期待される動的型を持つことを保証することである。</p>
<p><emph><code>expr1</code></emph><code> treat as </code><emph><code>type1</code></emph>の意味は以下の通りである。</p>
<ulist>
<item><p>静的解析時:</p>
<p><code>treat</code>式の<termref def="dt-static-type">静的型</termref>は<emph><code>type1</code></emph>である。これにより、<emph><code>type1</code></emph>の引数を必要とする関数の引数として、その式を用いることが可能となる。</p></item>
<item><p>式の評価時:</p>
<p><termref def="dt-sequencetype-matching">SequenceTypeの照合</termref>のルールを用いて<emph><code>expr1</code></emph>が<emph><code>type1</code></emph>と照合されるならば、<code>treat</code>式は<emph><code>expr1</code></emph>の値を返す。そうでない場合は<termref def="dt-dynamic-error">動的エラー</termref> <errorref class="DY" code="0050"/>が発生する。<emph><code>expr1</code></emph>の値が返るならば、その識別性は保存される。<code>treat</code>式は、その式の演算数の値が実行時に期待される型にしたがうことを保証する。</p></item>
<item><p>例:</p>
<eg role="parse-test" xml:space="preserve">$myaddress treat as element(*, USAddress)</eg>
<p><code>$myaddress</code>の<termref def="dt-static-type">静的型</termref>は<code>element(*, Address)</code>であってもよい。これは<code>element(*, USAddress)</code>より詳しくない型である。しかし実行時には、<code>$myaddress</code>の値は、<termref def="dt-dynamic-error">SequenceTypeの照合</termref>のルールを用いて、型<code>element(*, USAddress)</code>に照合されなければならない。そうでない場合は<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0050"/>。</p></item></ulist></div3></div2> 
<div2 id="id-validate" role="xquery"><head>検証式</head>

<scrap headstyle="show">

<head/> <prod num="63" id="doc-xquery-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod>
<prod num="64" id="doc-xquery-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod></scrap>
<p><code>validate</code> 式は、<bibref ref="XMLSchema"/>に定義されているスキーマ検証処理を用いて、文書節点や要素節点を<termref def="dt-issd">有効範囲内スキーマ定義</termref>に関して検証するのに用いることができる。<code>validate</code> 式の演算数を評価した結果が正確に1つの文書節点もしくは要素節点にならない場合は、<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0030"/>。この仕様では、<code>validate</code> 式の演算数である節点を<term>演算数節点</term>という。</p>
<p><code>validate</code> 式は新しい節点を1つ返す。この節点は固有の識別性を持ち、また親を持たない。新しい節点とその子孫には、演算数節点に検証処理を適用した結果生成される<termref def="dt-type-annotation">型注釈</termref>が付けられている。ある場合には、検証処理によってデフォルト値も生成されるかもしれない。</p>
<p><code>validate</code> 式は、省略可能な<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>を指定してもよい。デフォルトの<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>は <code>strict</code> である。<code>validate</code> 式の結果は以下のルールによって定義される:</p>
<olist>
<item><p>演算数節点が文書節点であれば、その子は要素節点1つ、および0個以上のコメント節点や処理命令節点から構成されなければならない。それらの順序は任意である。これ以外の場合には、<termref def="dt-dynamic-error">動的エラー</termref> <errorref class="DY" code="0061"/> が発生する。</p></item>
<item><p><bibref ref="datamodel"/>で定義される "情報集合への写像" ルールに従って、演算数節点が XML 情報集合 (<bibref ref="XINFO"/>) に変換される。この処理によって、すでに存在する<termref def="dt-type-annotation">型注釈</termref>はすべて捨てられることに注意せよ。</p></item>
<item><p>結果として得られる情報集合の根要素の情報項目上で、妥当性評価が実行される。このとき、<termref def="dt-issd">有効範囲内スキーマ定義</termref>が有効スキーマとして用いられる。妥当性評価の処理は、有効スキーマによって必要とされる範囲に含まれる要素や属性に対して再帰的に適用される。妥当性評価の間、以下の特別なルールが有効となる:</p>
<olist>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>strict</code> であれば、<termref def="dt-is-elems">有効範囲内要素定義</termref>中の最上位要素定義に、情報集合の根要素の情報項目と照合されるものが存在しなければならない。そしてスキーマ妥当性評価が <bibref ref="XMLSchema"/> Part 1, 5.2節, "スキーマ妥当性の評価" の2項に一致した宣言を用いて実行される。このような要素宣言がなければ、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref code="0084" class="DY"/>。</p></item>
<item><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>lax</code> であれば、<bibref ref="XMLSchema"/> Part 1, 5.2節, "スキーマ妥当性の評価" の3項の通りにスキーマ妥当性評価が実行される。</p>
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>lax</code> であり、根要素の情報項目が最上位要素定義にも <code>xsi:type</code> 属性にもない場合、<bibref ref="XMLSchema"/> では、子や属性を再帰的に検査する方法がオプションとして定義されている。XQuery の <code>validate</code> 式の処理では、この再帰的な検査が必要とされる。</p></item>
<item><p>演算数節点が要素節点であれば、"Validation Root Valid (ID/IDREF)" や "Identity-constraint Satisfied" と名付けられた検証ルールは適用されない。この意味するところは、文書レベルの一意性や参照一貫性に関する制約は強制されない、ということである。</p></item>
<item><p>文書中に含まれる解析対象外実体について、その名前が <code>xs:ENTITY</code> 型もしくは <code>xs:ENTITIES</code> 型の節点の値に照合されるかどうかの検査は行われない。</p></item>
<item><p>文書中に含まれる記法について、その名前が <code>xs:NOTATION</code> 型の節点の値と照合されるかどうかの検査は行われない。</p></item>
</olist>
<note><p>妥当性評価は、検証される要素に <code>xsi:type</code> 属性があるかどうかによって影響を受ける。また妥当性評価によって、デフォルト属性のように新しい情報項目が生成されてもよい。</p></note>
</item>
<item><p>次のステップは、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>、および検証処理の結果として得られる PSVI 中の根要素の情報項目の <code>validity</code> 性質に依存する。</p>
<olist>
<item><p>根要素の情報項目の <code>validity</code> 性質が <code>valid</code> (どの<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>についても) であるか、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>lax</code> かつ根要素の情報項目の <code>validity</code> 性質が <code>notKnown</code> であれば、<bibref ref="datamodel"/> 3.3節, "PSVI からの構成" にある通り、PSVI が <termref def="dt-data-model-instance">XDM インスタンス</termref>に逆変換される。結果として得られる節点 (演算数節点と同じ種類の新しい節点) が <code>validate</code> 式の結果として返される。</p></item>
<item><p>そうでない場合は、<termref def="dt-dynamic-error">動的エラー</termref>が発生する <errorref class="DY" code="0027"/>。</p></item>
</olist></item>
</olist>
<note><p>これらのルールの効果は以下の通りである: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>strict</code> であれば、検証された要素は有効スキーマ中に最上位要素の宣言を持っていなければならず、かつこの宣言に従わなければならない。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>lax</code> であれば、検証された要素は、その最上位要素の宣言が有効スキーマ中にあるならば、それに従わなければならない。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValidationMode" xlink:type="simple">検証モード</nt>が <code>lax</code> であり、かつその要素の最上位要素宣言がなく、かつその要素が <code>xsi:type</code> 属性を持っている場合は、その <code>xsi:type</code> 属性が有効スキーマ中の最上位要素の型定義を名前付けしなければならず、要素はその型に従わなければならない。検証された要素は、演算数節点もしくは (演算数節点が文書節点の場合は) その子要素に一致する。</p></note>
<note><p>検証後に PSVI を <termref def="dt-data-model-instance">XDM インスタンス</termref>に変換するとき、要素の情報項目のうち、その validity 性質が <code>notKnown</code> であるものはいずれも、<termref def="dt-type-annotation">型注釈</termref> <code>xs:anyType</code> のついた要素節点に変換される。また属性の情報項目のうち、その validity 性質が <code>notKnown</code> であるものはいずれも、<termref def="dt-type-annotation">型注釈</termref> <code>xs:untypedAtomic</code> のついた属性節点に変換される。これについては<xspecref spec="DM" ref="PSVI2NodeTypes"/>にある通りである。</p></note></div2>
<div2 id="id-extension-expressions" role="xquery"><head>拡張式</head>
<p><termdef id="dt-extension-expression" term="extension expression"><term>拡張式</term>は、意味が<termref def="dt-implementation-defined">実装定義</termref>であるような式である。</termdef> 通常、拡張は、ある実装では認識されるが、別の実装では認識されない。拡張式の構文は、この式の構文解析はすべての実装で成功し、拡張を認識しない実装に対しては、それを処理できないときの振舞いが定義できるように設計されている。</p>
<scrap headstyle="show">

<head/> <prod num="65" id="doc-xquery-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod>
<prod num="66" id="doc-xquery-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PragmaContents" xlink:type="simple">PragmaContents</nt>  "#)"</rhs></prod><prod num="67" id="doc-xquery-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod></scrap>
<p>拡張式は1個以上の <term>pragmas</term> からなり、これらの後ろには波括弧で囲まれた式が1つ続く。 <termdef term="pragma" id="dt-pragma"><term>pragma</term> は区切り記号 <code>(#</code> と <code>#)</code> によって表され、識別可能な QName の次に<termref def="dt-implementation-defined">実装定義</termref>の内容が続く。</termdef> pragma の内容は終了の区切り記号 <code>#)</code> を含まない任意の文字列からなる。pragma の QName は、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて名前空間 URI と局所名に解決されなければならない <errorref class="ST" code="0081"/>。</p>
<note><p>pragma に対するデフォルト名前空間はない。</p></note>
<p>実装はそれぞれ、pragma を表すのに用いられる名前空間 URI の<termref def="dt-implementation-defined">実装定義</termref>の集合を認識しなければならない。</p>
<p>pragma の QName の名前空間部分が pragma の名前空間として実装に認識されなければ、その pragma は無視される。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>中の pragma がすべて無視されれば、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt>の値は、波括弧で囲まれた式の値に等しい。この式がなければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0079"/>。</p>
<p>実装が <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt> 中の pragma を1個以上認識するならば、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt> の値は、エラーに対する振舞いも含め、<termref def="dt-implementation-defined">実装定義</termref>である。例えば、ある実装が pragma の QName の名前空間は認識するが、その QName の局所名は認識しない場合、エラーを発生させてもよいし、その pragma を無視してもよい。</p><p>実装が pragma を認識するが、その内容が正当でないと決定した場合は、<termref def="dt-static-error">静的エラー</termref> <errorref code="0013" class="ST"/> である。</p>
<p>実装が pragma を認識するならば、実装は、それに続く式中の任意の静的エラーを報告しなければならない。これは、その式が評価されない場合でもあてはまる (ただし静的型エラーを発生させるのは、<termref def="dt-static-typing-feature">静的型付け機能</termref>が有効である場合だけである)。</p>
<note><p>以下に、拡張式が用いられる方法を3通り、例として示す。</p>
<ulist>
<item><p>pragma は以下の式をどのように評価するかについてのヒントを与えるのに用いられる。結果は実際には変更されない。例えば:</p>
<eg role="parse-test" xml:space="preserve">declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</eg>
<p><code>exq:use-index</code> pragma を認識する実装では、以下に続く式を評価するのに索引を用いてもよい。この pragma を認識しない実装では、通常の方法で式が評価される。</p></item>
<item><p>pragma は以下に続く式の意味を、(pragma がなければ) この仕様に適合しないように変更するのに用いられる。例えば、pragma を用いて <code>xs:duration</code> の値の比較を実装定義の意味で行えるようにしてもよい (通常はこれはエラーである)。言語の意味に対するこのような変更の有効範囲は、pragma に続く波括弧の内部に含まれる式に限定されなければならない。</p></item>
<item><p>pragma に、以下の式の場所で評価される構文要素を含めることもできる。この場合、以下の式 (もしあれば) はそれ自身で、pragma が認識されない実装で用いられる失敗用処理を提供する。例えば:</p>
<eg role="parse-test" xml:space="preserve">declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</eg>
<p>ここでは、pragma を認識する実装は、その pragma の持つ構文 <code>exq:distinct //city by
@country</code> を評価した結果を返す。一方、pragma を認識しない実装は、代わりに式 <code>//city[not(@country =
preceding::city/@country)]</code> を評価した結果を返す。失敗用の式が必要とされなかったり、あるいは何も実行されなければ、波括弧の間の式は省略されてもよい。この場合、pragma を認識しない実装では<termref def="dt-static-error">静的エラー</termref>が発生する。</p></item>
</ulist></note></div2>
</div1>

<div1 role="xquery" id="id-query-prolog">	
  <head role="xquery">モジュールと前書き</head>	
  <scrap headstyle="show"> 
	 <head/> <prod num="1" id="doc-xquery-Module"><lhs>Module</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MainModule" xlink:type="simple">MainModule</nt>)</rhs></prod> 
	 <prod num="3" id="doc-xquery-MainModule"><lhs>MainModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QueryBody" xlink:type="simple">QueryBody</nt></rhs></prod><prod num="4" id="doc-xquery-LibraryModule"><lhs>LibraryModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Prolog" xlink:type="simple">Prolog</nt></rhs></prod><prod num="6" id="doc-xquery-Prolog"><lhs>Prolog</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Import" xlink:type="simple">Import</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt>)*</rhs></prod>	
  <prod num="7" id="doc-xquery-Setter"><lhs>Setter</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt></rhs></prod><prod num="8" id="doc-xquery-Import"><lhs>Import</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt></rhs></prod><prod num="9" id="doc-xquery-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod><prod num="30" id="doc-xquery-QueryBody"><lhs>QueryBody</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod></scrap>
<p>問合せは<term>モジュール</term>と呼ばれる1つ以上の断片から組み立てることができる。 <termdef term="module" id="dt-module"><term>モジュール</term>は XQuery コードの断片であり、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Module" xlink:type="simple">Module</nt> の文法に従っており、またそれぞれ独立に<specref ref="id-expression-processing"/>にある<termref def="dt-static-analysis">静的解析相</termref>を受けることができる。各モジュールは<termref def="dt-main-module">主モジュール</termref>か<termref def="dt-library-module">ライブラリモジュール</termref>のいずれかである。</termdef></p>
<p> <termdef id="dt-main-module" term="main module"><term>主モジュール</term>は、<termref def="dt-prolog">前書き</termref>とそれに続く<termref def="dt-queryBody">問合せ本体</termref>から構成される。</termdef> 問合せは主モジュールを1つ持つ。主モジュールでは、<termref def="dt-queryBody">問合せ本体</termref>を評価することができ、その値が問合せの結果になる。</p>
<p><termdef id="dt-library-module" term="library module"><termref def="dt-queryBody">問合せ本体</termref>を持たないモジュールを<term>ライブラリモジュール</term>という。ライブラリモジュールは<termref def="dt-module-declaration">モジュール定義</termref>およびそれに続く<termref def="dt-prolog">前書き</termref>からなる。</termdef> ライブラリモジュールを直接評価することはできない。そのかわり、他のモジュールから輸入できる関数や変数の宣言を提供する。</p>
<p>XQuery の構文では、<termref def="dt-module">モジュール</termref>に<termref def="dt-module-declaration">モジュール宣言</termref>と<termref def="dt-queryBody">問合せ本体</termref>を両方含めることは許されない。</p>
<p><termdef id="dt-prolog" term="Prolog"><term>前書き</term>は一連の宣言や輸入であり、その前書きを含む<termref def="dt-module">モジュール</termref>に対する処理環境を定義する。</termdef> それぞれの宣言や輸入の後ろにはセミコロンが続く。前書きは2つの部分からなる。</p>
<p>前書きの最初の部分は設定子、輸入、名前空間宣言、およびデフォルト名前空間宣言からなる。<termdef term="setter" id="dt-setter"><term>設定子</term>は、問合せ処理に影響を与える性質の値を設定する。このような性質には、構成モード、順序付けモード、デフォルト照合順序などがある。</termdef> 名前空間宣言やデフォルト名前空間宣言は問合せ中の QName の解釈に影響を与える。輸入は、スキーマやモジュールから定義を輸入するのに用いられる。<termdef term="target namespace" id="dt-target-namespace">輸入されたスキーマやモジュールはそれぞれ、その<term>目的名前空間</term>によって識別される。これは、そのスキーマやモジュールで定義されるオブジェクト (要素や関数など) の名前空間である。</termdef> </p>
<p>前書きの2つ目の部分は変数、関数、オプションの宣言からなる。これらの宣言は前書きの最後に現れる。なぜならこれらは、前書きの1つめの部分中にある宣言や輸入の影響を受けるかもしれないからである。</p>
<p><termdef id="dt-queryBody" term="query body"><term>問合せ本体</term>は、もしあれば、問合せの結果を定義する式からなる。</termdef> 式の評価は<specref ref="id-expressions"/>にある。モジュールが評価可能なのは、それが問合せ本体を持つ場合に限る。</p>	
   
   
  <div2 id="id-version-declaration"><head>バージョン宣言</head><scrap headstyle="show"> 
		<head/> <prod num="2" id="doc-xquery-VersionDecl"><lhs>VersionDecl</lhs><rhs>"xquery"  "version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod> 
		 
		 
	 </scrap>
<p><termdef term="version declaration" id="dt-version-declaration"><termref def="dt-module">モジュール</termref>はいずれも<term>バージョン宣言</term>を含んでよい。もしあれば、バージョン宣言は<termref def="dt-module">モジュール</termref>の先頭に出現し、その<termref def="dt-module">モジュール</termref>に対して適用可能な XQuery の構文と意味を識別する。</termdef>
バージョン番号 "1.0" は、その<termref def="dt-module">モジュール</termref>が XQuery バージョン 1.0 を支援する実装によって処理されなければならないという要求を示す。 バージョン宣言がなければ、バージョンは "1.0" であるとみなされる。XQuery の実装は、その実装が支援しないバージョンにラベル付けされた<termref def="dt-module">モジュール</termref>を処理すると、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0031"/> を発生させなければならない。XQuery 作業部会は、この仕様について "1.0" より後の番号を与えることを意図している。しかしこの意図は、将来の XQuery のバージョンを作る約束を意味するわけではないし、もしそれを作ったとしても、特定の番号付けの枠組を用いる約束を意味するわけでもない。</p>
<p><termdef term="encoding declaration" id="dt-encoding-declaration">バージョン宣言は、もしあれば、省略可能な<term>符号化宣言</term>を含んでもよい。キーワード <code>encoding</code> の後に続く文字列リテラルが符号化名であり、<bibref ref="XML"/>で指定される <code>EncName</code> に適合しなければならない <errorref code="0087" class="ST"/>。符号化宣言の目的は、問合せを書くときに、その問合せがどのように符号化されるかを示す文字列を用意することを許すことである。例えば "<code>UTF-8</code>", "<code>UTF-16</code>", "<code>US-ASCII</code>" のような文字列である。</termdef> 問合せをある環境から違う環境に移すと、問合せの符号化は変化するかもしれないので、符号化宣言が正しいという保証はできない。</p>
<p>バージョン宣言の処理方法は<termref def="dt-implementation-dependent">実装依存</termref>である。実装が<emph>あらかじめ</emph>問合せの符号化に関する知識を持っていれば、この知識を用いて、符号化宣言を捨ててもよい。問合せの意味は、符号化宣言があるかないかには影響を受けない。</p>
<p>バージョン宣言があれば、そのバージョン宣言の終わりより前に<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comment</nt>が出現してはならない。このような <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comment</nt> がある場合、結果は<termref def="dt-implementation-dependent">実装依存</termref>である。<note><p>バージョン宣言の終わりより前に Comment が出現すると、その効果は実装依存である。なぜならそのような Comment は符号化宣言の発見を妨げ、問合せ処理を抑制するかもしれないからである。</p></note>
</p>
<p>以下に示すのはバージョン宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">xquery version "1.0";</eg><eg role="frag-prolog-parse-test" xml:space="preserve">xquery version "1.0" encoding "utf-8";</eg></div2>
<div2 id="id-module-declaration"><head>モジュール宣言</head>
<scrap headstyle="show"><head/><prod num="5" id="doc-xquery-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod></scrap>
<p><termdef id="dt-module-declaration" term="module declaration"><term>モジュール宣言</term>は、ある<termref def="dt-module">モジュール</termref>を<termref def="dt-library-module">ライブラリモジュール</termref>として識別する機能を提供する。モジュール宣言はキーワード <code>module</code> で始まり、名前空間接頭辞1つと <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt> 1つを含む。</termdef> URILiteral の長さは0以外でなければならない <errorref class="ST" code="0088"/>。URILiteral はライブラリモジュールの<termref def="dt-target-namespace">目的名前空間</termref>を識別する。これはライブラリモジュールによって輸出される変数や関数すべてに対する名前空間である。ライブラリモジュール中で宣言される変数や関数の名前はそれぞれ、そのモジュールの目的な前空間と同じ名前空間 URI を持っていなければならない。そうでなければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0048"/>。ライブラリモジュールの<termref def="dt-static-namespaces">静的既知名前空間</termref>中では、モジュール宣言で指定された名前空間接頭辞は、そのモジュールの目的名前空間に束縛される。モジュール宣言で指定される名前空間接頭辞は <code>xml</code> や <code>xmlns</code> であってはならない <errorref class="ST" code="0070"/>。</p>
<p>いずれの<termref def="dt-module">モジュール</termref>も、<termref def="dt-module-import">モジュール輸入</termref>の手段によって1つ以上のライブラリモジュールを輸入してもよい。モジュール輸入は、輸入されるライブラリモジュールの目的名前空間を指定する。モジュールが1つ以上のライブラリモジュールを輸入するとき、輸入されるモジュール中で宣言されている変数や関数が、輸入するモジュールの<termref def="dt-static-context">静的文脈</termref>と (適用可能であれば) <termref def="dt-dynamic-context">動的文脈</termref>に追加される。</p>
<p>以下に示すのはモジュール宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">module namespace math = "http://example.org/math-functions";</eg></div2>



<div2 id="id-boundary-space-decls"><head>境界空白宣言</head>
<scrap headstyle="show"> 
		<head/>  
		 
		<prod num="11" id="doc-xquery-BoundarySpaceDecl"><lhs>BoundarySpaceDecl</lhs><rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs></prod> 
	 </scrap>
<p><termdef id="dt-boundary-space-decl" term="boundary-space declaration"><term>境界空白宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-boundary-space-policy">境界空白ポリシー</termref>を設定する。このとき実装定義の任意のデフォルト値を上書きする。境界空白ポリシーは、問合せ処理で要素構成子によって<termref def="dt-boundary-whitespace">境界空白</termref>が保存されるかどうかを制御する。</termdef> 境界空白ポリシーが <code>preserve</code> であれば、境界空白は保存される。境界空白ポリシーが <code>strip</code> であれば、境界空白ははぎ取られる (削除される)。構成される要素中の空白に関する更なる議論は<specref ref="id-whitespace"/>にある。</p>
<p>以下に示すのは境界空白宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare boundary-space preserve;</eg>
<p>前書きに2つ以上の境界空白宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0068"/>。</p>
</div2>
<div2 id="id-default-collation-declaration"><head>デフォルト照合順序宣言</head><scrap headstyle="show"> 
		<head/>  
		 
		<prod num="19" id="doc-xquery-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod> 
	 </scrap>
<p><termdef term="default collation declaration" id="dt-default-collation-decl"><term>デフォルト照合順序宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-def-collation">デフォルト照合順序</termref>の値を設定する。このとき、実装定義の任意のデフォルト値を上書きする。</termdef> デフォルト照合順序は、照合順序を必要とする関数や演算子において、照合順序が他に指定されていないときに用いられる照合順序である。例えば、文字列上の <code>gt</code> 演算子は <code>fn:compare</code> 関数の呼び出しによって定義される。この関数は照合順序を省略可能な引数として取る。<code>gt</code> 演算子は照合順序を指定しないので、<code>fn:compare</code> 関数が <code>gt</code> を実装するときデフォルト照合順序が用いられる。</p>
<p>実装にも前書きにもデフォルト照合順序が指定されていないときは、Unicode コードポイント照合順序 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>) が用いられる。</p>
<p>以下に示すのはデフォルト照合順序の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default collation
	 "http://example.org/languages/Icelandic";</eg>
<p>デフォルト照合順序宣言が相対 URI によって照合順序を指定しているならば、その相対 URI は、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-base-uri">基礎 URI</termref>を用いて絶対 URI に解決される。前書きに2つ以上のデフォルト照合順序宣言が含まれていたり、デフォルト照合順序宣言で指定された値が (必要なら相対 URI を解決した後) <termref def="dt-static-collations">静的既知照合順序</termref>になければ、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0038"/>.</p></div2>
<div2 id="id-base-uri-decl"><head>基礎 URI 宣言</head>
         <scrap headstyle="show">
		<head/> <prod num="20" id="doc-xquery-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod> 
         </scrap>
 
         <p><termdef id="dt-base-uri-decl" term="base URI declaration"><term>基礎 URI 宣言</term>は<termref def="dt-static-context">静的文脈</termref>の<termref def="dt-base-uri">基礎 URI</termref>性質を指定し、実装依存の任意のデフォルト値を上書きする。<termref def="dt-base-uri">基礎 URI</termref> 性質は<termref def="dt-module">モジュール</termref>中の相対 URI を解決するのに用いられる。</termdef> 例えば、<code>fn:doc</code> 関数は呼び出したモジュールの基礎 URI を用いて相対 URI を解決する。</p>

<p>以下に示すのは基礎 URI 宣言の例である:</p><eg role="frag-prolog-parse-test" xml:space="preserve">declare base-uri "http://example.org";</eg>
<p>前書きに2つ以上の基礎 URI 宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0032"/>。</p></div2>

<div2 id="id-construction-declaration"><head>構成宣言</head><scrap headstyle="show"> 
		<head/>  
		 
		<prod num="25" id="doc-xquery-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod> 
	 </scrap>
<p><termdef term="construction declaration" id="dt-construction-decl"><term>構成宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-construction-mode">構成モード</termref>を設定する。このとき任意の実装定義のデフォルト値を上書きする。</termdef> 構成モードは要素構成子や文書節点構成子の振舞いを決定する。構成モードが <code>preserve</code> であれば、構成された要素節点の型は <code>xs:anyType</code> であり、節点の構成中に複製された属性節点や要素節点はすべて、元の型を保つ。構成モードが <code>strip</code> であれば、構成された要素節点の型は <code>xs:untyped</code> である。また、節点の構成中に複製された要素節点にはすべて型 <code>xs:untyped</code> が与えられ、節点の構成中に複製された属性節点にはすべて型 <code>xs:untypedAtomic</code> が与えられる。</p>
<p>以下に示すのは構成宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare construction strip;</eg>
<p>前書きに2つ以上の構成宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0067"/>。</p></div2>
<div2 id="id-default-ordering-decl"><head>順序付けモード宣言</head>
<scrap headstyle="show"> 
		<head/>  
		 
		<prod num="14" id="doc-xquery-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod> 
	 </scrap>
<p><termdef id="dt-ordering-mode-decl" term="ordering mode declaration"><term>順序付けモード宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-ordering-mode">順序付けモード</termref>を設定する。このとき任意の実装依存のデフォルト値を上書きする。</termdef>  この順序付けモードは<termref def="dt-module">モジュール</termref>中 (<termref def="dt-prolog">前書き</termref>も<termref def="dt-queryBody">問合せ本体</termref>も、もしあれば、ともに含む) のすべての式に適用される。ただし <code>ordered</code> 式や <code>unordered</code> によって上書きされた場合を除く。</p>
<p> <termref def="dt-ordering-mode">順序付けモード</termref>は、<termref def="dt-path-expression">経路式</termref>のうち "<code>/</code>" 演算子あるいは "<code>//</code>" 演算子、<termref def="dt-axis-step">軸ステップ</termref>を含むもの、<code>union</code> 式, <code>intersect</code> 式, <code>except</code> 式、<code>order by</code> 節を持たない FLWOR 式の振舞いに影響を及ぼす。順序付けモードが <code>ordered</code> であれば、経路、<code>union</code> 式, <code>intersect</code> 式, <code>except</code> 式によって返される節点列は<termref def="dt-document-order">文書順</termref>である。そうでなければ、これらの結果の列の順序は<termref def="dt-implementation-dependent">実装依存</termref>である。FLWOR 式に対する順序付けモードの影響については、<specref ref="id-flwor-expressions"/>にある。</p>
<p>以下に示すのは、順序付けモード宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare ordering unordered;</eg>
<p>前書きに2つ以上の順序付けモード宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0065"/>。</p>
</div2>
<div2 id="id-empty-order-decl"><head>空順序宣言</head><scrap headstyle="show"> 
		<head/>  
		 
		<prod num="15" id="doc-xquery-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod> 
	 </scrap>
<p><termdef term="empty order declaration" id="dt-empty-order-decl"><term>空順序宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-default-empty-order">空列のためのデフォルト順序</termref>を設定し、実装依存の任意のデフォルト値を上書きする。この宣言は空列や、FLWOR 式の <code>order by</code> 節中の順序付けキーとしての値 <code>NaN</code> の処理を制御する。</termdef> 個々の <code>order by</code> 節は、<code>empty greatest</code> や <code>empty least</code> を指定することで、空列に対するデフォルト順序を上書きしてもよい。</p>
<p>以下に示すのは、空順序宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default order empty least;</eg>
<p>前書きに2つ以上の空順序宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0069"/>。</p>
<note><p><termref def="dt-empty-order-decl">空順序宣言</termref>と<termref def="dt-ordering-mode-decl">順序付けモード宣言</termref>の区別をつけておくことは重要である。<termref def="dt-empty-order-decl">空順序宣言</termref>は <code>order by</code> 節がある場合にのみ適用され、(上書きがなければ) <code>order by</code> 節で空列をどのように扱うかを指定する。一方、<termref def="dt-ordering-mode-decl">順序付けモード宣言</termref>は <code>order by</code> 節がない場合にのみ適用される。</p></note></div2>
<div2 id="id-copy-namespaces-decl"><head>名前空間複製宣言</head><scrap headstyle="show"> 
		<head/>  
		 
		<prod num="16" id="doc-xquery-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InheritMode" xlink:type="simple">InheritMode</nt></rhs></prod><prod num="17" id="doc-xquery-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod> 
	 <prod num="18" id="doc-xquery-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod></scrap>
<p><termdef id="dt-copy-namespaces-decl" term="copy-namespaces declaration"><term>名前空間複製宣言</term>は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref>の値を設定し、実装定義の任意のデフォルト値を上書きする。名前空間複製モードは、すでに存在する要素が要素構成子によって複製されたときに割り当てられる名前空間束縛を制御する。</termdef> 要素構成子による名前空間束縛の処理については、<specref ref="id-element-constructor"/>に記述がある。</p>
<p>以下に示すのは名前空間複製モードの例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare copy-namespaces preserve, no-inherit;</eg>
<p>前書きに2つ以上の名前空間複製宣言が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0055"/>。</p>
</div2>
<div2 id="id-schema-imports"><head>スキーマ輸入</head>
<scrap headstyle="show"> 
		<head/>  
		 
		<prod num="21" id="doc-xquery-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod> 
	 <prod num="22" id="doc-xquery-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod></scrap>


<p><termdef id="dt-schema-import" term="schema import"><term>スキーマ輸入</term>は、1つのスキーマから要素宣言、属性宣言、および型宣言を<termref def="dt-issd">有効範囲内スキーマ定義</termref>に輸入する。</termdef> 輸入されるスキーマは、その<termref def="dt-target-namespace">目的名前空間</termref>によって識別される。スキーマ輸入は輸入されるスキーマの目的名前空間に名前空間接頭辞を束縛してもよい。またその目的名前空間を<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>と宣言してもよい。また、スキーマ輸入は、そのスキーマの場所に対する省略可能なヒントを用意してもよい。スキーマ輸入中で指定される名前空間接頭辞は <code>xml</code> や <code>xmlns</code> であってはならない <errorref class="ST" code="0070"/>。</p>
<p>スキーマ輸入中の最初の <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt> は輸入されるスキーマの目的名前空間を指定する。キーワード <code>at</code> に続く URILiteral は場所のヒントであり、省略可能である。これらは、実装依存の方法により、解釈することも無視することも可能である。場所のヒントを複数用いて、スキーマ、あるいはそのスキーマを組み立てる複数の物理的資源を探す場所の可能性を1つ以上示してもよい。</p>
<p>長さ0の文字列を目的名前空間として指定するスキーマ輸入は、目的名前空間を持たないスキーマを輸入するとみなされる。このようなスキーマ輸入は名前空間接頭辞を束縛してはならない <errorref class="ST" code="0057"/> が、しかしデフォルト要素/型名前空間を長さ0の文字列 ("名前空間なし" を意味する) に設定してもよい。その結果、輸入されたスキーマの定義を参照することができるようになる。デフォルト要素/型名前空間が "名前空間なし" と設定されなければ、目的名前空間のない輸入されたスキーマの定義を参照する方法はない。</p>
<p>同じ<termref def="dt-prolog">前書き</termref>中の2つ以上のスキーマ輸入で同じ目的名前空間が指定されていれば、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0058"/>。実装が、指定された目的名前空間を持つ正しいスキーマを見つけてスキーマ輸入を処理することができなければ、<termref def="dt-static-error">静的エラー</termref> である <errorref class="ST" code="0059"/> 。複数の輸入されたスキーマ、あるいは1つのスキーマ内部の複数の物理的資源が、同じ記号空間中に同じ名前の定義を含んでいれば (例えば、同じ要素名に対する2つの定義があれば、たとえそれらの定義が一貫していたとしても)、<termref def="dt-static-error">型エラー</termref> である <errorref class="ST" code="0035"/>。しかし、目的名前空間 <code>http://www.w3.org/2001/XMLSchema </code> (あらかじめ接頭辞 <code>xs</code> が宣言されている) を持つスキーマを輸入してもエラーではない。たとえ、このスキーマで定義されている組み込み型が暗黙的に<termref def="dt-is-types">有効範囲内スキーマ型</termref>に輸入されたとしても、エラーではない。a</p>



<p>前書きで輸入されたすべてのスキーマに含まれる定義集合が、<bibref ref="XMLSchema"/> Part 1 の 3章と 5章で指定されているスキーマ妥当性の条件を満たさないならば、すなわち定義が妥当で、完全で、唯一でなければならないという条件を満たさないならば、<termref def="dt-static-error">静的エラー</termref> である <errorref code="0012" class="ST"/>。</p>
<p>以下に示す例では、目的名前空間と場所をともに指定してスキーマを輸入し、その目的名前空間に接頭辞 <code>soap</code> を束縛している:</p>
	
	 <eg role="frag-prolog-parse-test" xml:space="preserve">import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";</eg>
<p>以下の例では、目的名前空間だけを指定してスキーマを輸入し、それをデフォルト要素/型名前空間にしている:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "http://example.org/abc";</eg>
<p>以下の例では、目的名前空間を持たないスキーマを輸入し、場所のヒントを与え、デフォルト要素/型名前空間を "名前空間なし" に設定している。その結果、輸入されたスキーマ中の定義が参照可能となる:</p><eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "" 
at "http://example.org/xyz.xsd";</eg>
<p>以下の例では、目的名前空間のないスキーマを輸入し、デフォルト要素/型名前空間を "名前空間なし" に設定している。場所のヒントが用意されていないので、輸入されるスキーマを見つけるのは実装の責任である。</p><eg role="frag-prolog-parse-test" xml:space="preserve">import schema default element namespace "";</eg></div2>
<div2 id="id-module-imports"><head>モジュール輸入</head>
<scrap headstyle="show"> 
		<head/>  
		 
		<prod num="23" id="doc-xquery-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod> 
	 </scrap>
<p><termdef term="module import" id="dt-module-import"><term>モジュール輸入</term>は1つ以上の<termref def="dt-library-module">ライブラリモジュール</termref>から関数宣言や変数宣言を輸入する。輸入の先は、輸入する<termref def="dt-module">モジュール</termref>の<termref def="dt-function-signature">関数シグネチャ</termref>や<termref def="dt-in-scope-variables">有効範囲内変数</termref>である。</termdef> 各モジュール輸入は<termref def="dt-target-namespace">目的名前空間</termref>に名前をつけ、この目的名前空間を共有する<termref def="dt-implementation-defined">実装定義</termref>のモジュール集合を輸入する。モジュール輸入は名前空間接頭辞を目的名前空間に束縛してもよい。また輸入されるモジュールの場所に関する省略可能なヒントを用意してもよい。モジュールで指定される名前空間接頭辞は <code>xml</code> や <code>xmlns</code> であってはならない <errorref class="ST" code="0070"/>。</p>
<p>モジュール輸入中の最初の <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt> は長さが0であってはならず <errorref class="ST" code="0088"/>、輸入されるモジュールの目的名前空間を指定する。キーワード <code>at</code> に続く URILiteral は場所のヒントであり、省略可能である。これらは、<termref def="dt-implementation-defined">実装定義</termref>の方法により、解釈することも無視することも可能である。</p>
<p><termref def="dt-prolog">前書き</termref>中の2つ以上のモジュールが同じ目的名前空間を指定していれば、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0047"/>。実装が、指定された目的名前空間の正しいモジュール定義を見つけてモジュールを処理することができなければ、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0059"/>。輸入されたモジュールで宣言されている関数の<termref def="dt-expanded-qname">展開済 QName</termref>と次数が、輸入するモジュール、もしくは輸入された別のモジュールで宣言されている関数の<termref def="dt-expanded-qname">展開済 QName</termref>と次数にそれぞれ (<code>eq</code> 演算子によって定義される通りに) 等しいならば、(宣言が一貫していても) <termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0034"/>。輸入されたモジュールで宣言されている変数の<termref def="dt-expanded-qname">展開済 QName</termref>が、輸入するモジュール、もしくは輸入された別のモジュールで宣言されている変数の<termref def="dt-expanded-qname">展開済 QName</termref>と等しいならば、(宣言が一貫していても) <termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0049"/>。</p>
<p><termref def="dt-module">モジュール</termref>はそれぞれ、固有の<termref def="dt-static-context">静的文脈</termref>を持つ。<termref def="dt-module-import">モジュール輸入</termref>は関数や変数の宣言のみを輸入し、他のオブジェクト、例えば<termref def="dt-issd">有効範囲内スキーマ定義</termref>や<termref def="dt-static-namespaces">静的既知名前空間</termref>は、輸入されるモジュールから輸入しない。モジュール輸入は推移的ではない。すなわち、あるモジュールを輸入すると、その輸入されたモジュール中に直接含まれる関数や変数の宣言のみにアクセスすることができる。例えば、モジュール A がモジュール B を輸入し、モジュール B がモジュール C を輸入しているならば、モジュール A はモジュール C で宣言されている関数や変数に対してアクセスすることはできない。</p>
<p>モジュールは、それ自身の目的名前空間を輸入してもよい (これは、その目的名前空間を共有する別のモジュールからなる<termref def="dt-implementation-defined">実装定義</termref>の集合を輸入すると解釈される)。しかし、モジュール輸入のグラフが巡回路を持つならば (すなわち、モジュール列 M<sub>1</sub> ... M<sub>n</sub> で M<sub>i</sub> が M<sub>i+1</sub> を輸入し、M<sub>n</sub> が M<sub>1</sub> を輸入するようなものが存在すれば)、巡回路中のモジュールがすべて共通の名前空間を共有しない限り、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0073"/>。</p>
<p>あるモジュールを輸入するとき、輸入するモジュールの<termref def="dt-is-types">有効範囲内スキーマ型</termref>が、輸入されるモジュール中にある変数や関数 (引数の型や返り値の型に関わらず) の宣言のうち輸入するモジュール中で参照されるものに出現するスキーマ型名に対する定義を含まないならば、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0036"/>。</p>
<p>上のルールを示すために、<code>triangle</code> という名前の型を定義するスキーマを考えよう。ライブラリモジュールがこのスキーマを輸入し、その目的名前空間を接頭辞 <code>geometry</code> に束縛し、以下の<termref def="dt-function-signature">関数シグネチャ</termref>を持つ関数を宣言しているとする: <code>math:area($t as geometry:triangle) as xs:double</code>。ある問合せでこの関数を使おうとするならば、ライブラリモジュールと、それの元になっているスキーマの<emph>両方</emph>を輸入しなければならない。ライブラリモジュールだけを輸入すると、<code>area</code> 関数のシグネチャで用いられている型 <code>geometry:triangle</code> の定義にアクセスすることができない。</p>
<p>以下に示すのはモジュール輸入の例である:</p><eg role="frag-prolog-parse-test" xml:space="preserve">import module namespace math = "http://example.org/math-functions";</eg></div2>
<div2 id="id-namespace-decls">
	 <head>名前空間宣言</head> 
	 <scrap headstyle="show"> 
		<head/> <prod num="10" id="doc-xquery-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod> 
		 
		 
	 </scrap> 
	  
	 <p><termdef id="dt-namespace-declaration" term="namespace declaration"><term>名前空間宣言</term>は、名前空間接頭辞を宣言し、それを名前空間 URI と関連づけ、(接頭辞, URI) の組を<termref def="dt-static-namespaces">静的既知名前空間</termref>の集合に加える。</termdef> 名前空間宣言は、<termref def="dt-direct-elem-const">直接要素構成子</termref>中の<termref def="dt-namespace-decl-attr">名前区間宣言属性</termref>によって上書きされない限り、それが宣言されている問合せを通して有効である。</p>
<p>名前空間宣言の URILiteral 部分が長さ0の文字列であれば、与えられた接頭辞に対してすでに存在する名前空間束縛は<termref def="dt-static-namespaces">静的既知名前空間</termref>から削除される。この機能は、<code>local</code> のようにあらかじめ宣言されている名前空間接頭辞を削除する方法を提供する。</p>
<p>以下に示すのは、名前空間宣言の例である:</p> 
	 <eg role="parse-test" xml:space="preserve">declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;</eg> 
	 <p>この問合せの結果、新しく生成された節点は、名前空間 URI <code>http://example.org</code> と関連づけられた名前空間中にある。</p> 
	  
	  
	 <p><termref def="dt-prolog">前書き</termref>中で同じ名前空間接頭辞を複数回宣言すると、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0033"/>。</p> 
	  
	 <p>ある式が名前空間接頭辞を持つ QName を含んでおり、かつその QName が<termref def="dt-static-namespaces">静的既知名前空間</termref>中になければ、<termref def="dt-static-error">静的エラー</termref>である <errorref class="ST" code="0081"/>。</p> 
	  
	 <p>XQuery には、あらかじめ宣言された名前空間接頭辞がいくつかある。これらは、それぞれの問合せを処理する前に<termref def="dt-static-namespaces">静的既知名前空間</termref>中にある。これらの接頭辞は、明示的な宣言をすることなく用いてもよい。これらの接頭辞は<termref def="dt-prolog">前書き</termref>中の<termref def="dt-namespace-declaration">名前空間宣言</termref>や、構成された要素の<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>によって上書きされてもよい (ただし、接頭辞 <code>xml</code> を再宣言することはできない。また接頭辞 <code>xml</code> に関連づけられている名前空間 URI を他の接頭辞に束縛することもできない <errorref class="ST" code="0070"/>)。あらかじめ宣言された名前空間接頭辞は以下の通りである:</p><ulist><item><p><code>xml = http://www.w3.org/XML/1998/namespace</code></p></item><item><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></item><item><p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p></item><item><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></item><item><p><code>xdt = http://www.w3.org/2005/xpath-datatypes</code></p></item><item><p><code>local = http://www.w3.org/2005/xquery-local-functions</code> (<specref ref="FunctionDeclns"/>を見よ。)</p></item></ulist> 
	  
	 
	 	
<p>実装によって、あらかじめ宣言された名前空間接頭辞をさらに<termref def="dt-static-namespaces">静的既知名前空間</termref>に追加してもよい。</p>
<p>名前空間接頭辞 <code>xmlns</code> もまた特別な意味を持ち (<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>を識別する)、再宣言することはできない<errorref class="ST" code="0070"/>。</p> 
	  
	  
	 <p>要素や属性の名前が比較されるとき、局所部と名前空間 URI がそれぞれコードポイントを基礎として照合されるならば、それらは等しいとみなされる。以下の例の通り、照合される2つの名前の名前空間接頭辞は同じである必要はない:</p> 
	 <eg role="parse-test" xml:space="preserve">declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing</eg> 
	 <p>名前空間接頭辞 <code>xx</code> と <code>foo</code> は異なるが、これらはいずれも名前空間 URI <code>"http://example.org"</code> に束縛されている。<code>xx:bing</code> と <code>foo:bing</code> は同じ局所名と同じ名前空間 URI を持っているので、これらは照合される。上の問合せの出力は以下のようになる。</p> 
	 <eg role="parse-test" xml:space="preserve">&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;</eg></div2>
<div2 id="id-default-namespace"><head>デフォルト名前空間宣言</head><scrap headstyle="show"> 
		<head/>  
		<prod num="12" id="doc-xquery-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod> 
		 
	 </scrap><p><term>デフォルト名前空間宣言</term>は<termref def="dt-prolog">前書き</termref>の中で用いることができ、接頭辞のない QName を利用できるようにするためのものである。以下の種類のデフォルト名前空間宣言が支援されている:</p>
<ulist>
<item><p><term>デフォルト要素/型名前空間宣言</term>は、接頭辞のない要素名や型名を関連づける名前空間 URI を宣言する。この宣言は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>として記録される。<termref def="dt-prolog">前書き</termref>には、たかだか1つのデフォルト要素/型名前空間宣言が含まれてもよい <errorref class="ST" code="0066"/>。デフォルト要素/型名前空間宣言中の <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt> が長さ0の文字列であるならば、<termref def="dt-def-elemtype-ns">デフォルト要素/型名前空間</termref>は宣言されず ("none" に設定される)、接頭辞のない要素名や型名はどの名前空間にも属さないとみなされる。以下に示すのは要素名や型名のデフォルト名前空間の宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default element namespace "http://example.org/names";</eg>
<p>デフォルト要素/型名前空間宣言は、<termref def="dt-direct-elem-const">直接要素構成子</termref>中の<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>によって上書きされてもよい。</p>
<p>デフォルト要素/型名前空間宣言がなければ、接頭辞のない要素名や型名はどの名前空間にも属さない (ただし、<specref ref="id-xq-static-context-components"/> にあるように、実装が異なるデフォルト値を定義してもよい)。</p>
</item>
<item><p><term>デフォルト関数名前空間宣言</term>は、関数呼び出しや関数宣言における接頭辞なしの関数名に関連づけられる名前空間 URI を宣言する。この宣言は<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>として記録される。<termref def="dt-prolog">前書き</termref>には、たかだか1つのデフォルト関数名前空間宣言が含まれてもよい <errorref class="ST" code="0066"/>。もしデフォルト関数名前空間宣言中の StringLiteral が長さ0の文字列であるならば，デフォルト関数名前空間は宣言されない ("none" に設定される)。この場合，名前空間に関連づけられる関数はいずれも明示的な名前空間接頭辞を用いてのみ呼び出すことができる。</p>
<p>デフォルト関数名前空間宣言がなければ、デフォルト関数名前空間は XPath/XQeury の関数の名前空間、<code>http://www.w3.org/2005/xpath-functions</code> である (ただし、<specref ref="id-xq-static-context-components"/>にある通り、実装は異なるデフォルト値を定義してもよい)。</p>
<p>以下に示すのは、デフォルト関数名前空間の宣言の例である:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare default function namespace 
     "http://example.org/math-functions";</eg>
<p>デフォルト関数名前空間を宣言することにより、暗黙的に定義される<termref def="dt-constructor-function">構成子関数</termref>を含め、デフォルト関数名前空間に属するすべての関数は、名前空間接頭辞をつけずに起動することができる。接頭辞のない関数名を用いて関数を呼び出すとき、その関数の局所名は、デフォルト関数名前空間中の関数に (暗黙的に宣言される<termref def="dt-constructor-function">構成子関数</termref>を含む) 照合されなければならない <errorref class="ST" code="0017"/>。</p>
<note><p><termref def="dt-constructor-function">構成子関数</termref>だけは、どの名前空間にも属さないことが可能である</p></note>
</item></ulist>
<p>接頭辞のない属性名や変数名は、どの名前空間にも属さない。</p>
</div2>
<div2 id="id-variable-declarations"><head>変数宣言</head>
<scrap headstyle="show"> 
		<head/>  
		 
		<prod num="24" id="doc-xquery-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod> 
	 <prod num="88" id="noid_N15334.doc-xquery-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="118" id="noid_N15336.doc-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod></scrap>
<p><term>変数宣言</term>は、変数の<termref def="dt-static-type">静的型</termref>を<termref def="dt-in-scope-variables">有効範囲内変数</termref>に追加する。また、その変数の値を<termref def="dt-variable-values">変数値</termref>に追加してもよい。その変数の<termref def="dt-expanded-qname">展開済 QName</termref>が<termref def="dt-in-scope-variables">有効範囲内変数</termref>中の別の変数の名前と (<code>eq</code> 演算子によって定義される通り) 等しいならば、<termref def="dt-static-error">静的エラー</termref>が発生する<errorref class="ST" code="0049"/>。</p>
<p>変数宣言に型が含まれていれば、その型が、変数の型として<termref def="dt-static-context">静的文脈</termref>に追加される。変数宣言に式が含まれているが明示的な型が含まれていなければ、その式の静的解析によって変数の型が推論され、<termref def="dt-static-context">静的文脈</termref>に追加される。変数宣言に型と式の両方が含まれていれば、式によって返される値は、<termref def="dt-sequencetype-matching">SequenceType の照合</termref>に対するルールに従って、宣言された型と照合されなければならない。そうでなければ<termref def="dt-type-error">型エラー</termref>が発生する <errorref class="TY" code="0004"/>。</p>
<p><termdef term="initializing expression" id="dt-initializing-expression">変数宣言に式が含まれていれば、その式を<term>初期化式</term>という。</termdef> 与えられた変数に対する初期化式は、その変数を参照するどの式の評価よりも前に評価されなければならない。初期化式の<termref def="dt-static-context">静的文脈</termref>には、<termref def="dt-prolog">前書き</termref>中の任意の場所で宣言されたり輸入されたりする関数がすべて含まれる。しかし、変数や名前空間については、前書きのうち、初期化される変数よりも前で宣言されたり輸入されたりしているものしか含まれない。初期化式が巡回性のために評価できないならば (例えば、初期化式がある関数に依存しており、さらにその関数が初期化される変数の値に依存している、など)、<termref def="dt-static-error">静的エラー</termref>が発生する <errorref class="ST" code="0054"/>。</p>
<p>変数宣言にキーワード <code>external</code> が含まれていれば、その問合せが評価される前に、外部環境によって変数に対する値が提供されなければならない。外部変数宣言に宣言された型も含まれるならば，外部環境によって提供される値は、<termref def="dt-sequencetype-matching">SequenceType の照合</termref>に対するルールに従って，宣言された型に照合されなければならない (<specref ref="id-consistency-constraints"/>を見よ)。外部変数宣言に宣言された型が含まれないならば、評価時に、型とそれに照合される値が外部環境によって提供されなければならない。このような変数の<termref def="dt-static-type">静的型</termref>は <code>item()*</code> であるとみなされる。</p>
<p><termref def="dt-library-module">ライブラリモジュール</termref>で宣言された変数名はすべて、(展開されたときに) そのライブラリモジュールの<termref def="dt-target-namespace">目的名前空間</termref>中になければならない <errorref class="ST" code="0048"/>。ライブラリモジュールが輸入されるとき、輸入されたモジュールで宣言されている変数が、輸入しているモジュールの<termref def="dt-in-scope-variables">有効範囲内変数</termref>に追加される。</p>
<p>名前空間接頭辞のない変数名はどの名前空間にも属さない。名前空間接頭辞のない変数宣言は、主モジュールにしか出現してはならない。</p>
<p><term>変数宣言</term>という用語は、<termref def="dt-prolog">前書き</termref> 中で常に変数の宣言を参照する。FLWOR 式などの問い合せ式中で変数に値を束縛するのは<term>変数束縛</term>として知られており、その変数を輸入されたモジュールから見えるようにすることはしない。</p>
<p>以下に、変数宣言の例をいくつか示す:</p>
<ulist>
<item><p>以下の宣言では、変数の型と値を両方指定している。この宣言では、<termref def="dt-static-context">静的文脈</termref>中で変数 <code>$x</code> に関連づけられる型を <code>xs:integer</code> とし、<termref def="dt-dynamic-context">動的文脈</termref>中で変数 <code>$x</code> に関連づけられる値を <code>7</code> としている。</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x as xs:integer := 7;</eg></item>
<item><p>以下の宣言では、値は指定しているが型は指定していない。変数の<termref def="dt-static-type">静的型</termref>は、値の静的型から推論される。この場合は、変数 <code>$x</code> は <code>xs:decimal</code> という静的型を持つ。これは 7.5 という値から推論される。</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x := 7.5;</eg></item>
<item><p>以下の宣言では、型は指定しているが値は指定していない。キーワード <code>external</code> によって、変数の値は外部環境によって提供されるということが示されている。評価時には、<termref def="dt-dynamic-context">動的文脈</termref>中の変数 <code>$x</code> が <code>xs:integer</code> 型の値を持たなければ、型エラーが発生する。</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x as xs:integer external;</eg></item>
<item><p>以下の宣言では、型も値も宣言されていない。ここでは、単に、問合せが <code>$x</code> と名付けられた変数の存在に依存しており、この変数の型や値は外部環境によって提供されるということが宣言されている。問合せの解析では、<code>$x</code> の型は <code>item()*</code> とみなされる。問合せの評価では、<termref def="dt-dynamic-context">動的文脈</termref>に <code>$x</code> の型と値が含まれていなければならず、その値は型と互換でなければならない。</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $x external;</eg></item>
<item><p>以下の宣言は、ライブラリモジュール中に出現するかもしれないものであり、名前空間接頭辞を含む名前を持つ変数を宣言している:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare variable $math:pi as xs:double := 3.14159E0;</eg></item></ulist></div2> 
<div2 id="FunctionDeclns"> 
<head>関数宣言</head> 
<p><bibref ref="FunctionsAndOperators"/> で述べている組み込み関数に加えて、XQuery ではユーザが独自の関数を宣言することができる。関数宣言は、その関数の名前、引数の名前とデータ型、結果のデータ型を指定する。データ型はすべて、<specref ref="id-types"/> で述べる構文を用いて指定される。関数宣言により、それが出現する<termref def="dt-module">モジュール</termref>の<termref def="dt-function-signature">関数シグネチャ</termref>に、宣言された関数が加えられる。</p>
 
<scrap headstyle="show"> 
<head/> <prod num="26" id="doc-xquery-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod> 
<prod num="27" id="doc-xquery-ParamList"><lhs>ParamList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Param" xlink:type="simple">Param</nt>)*</rhs></prod> <prod num="28" id="doc-xquery-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod>

<prod num="118" id="noid_N15448.doc-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod></scrap>
<p>関数宣言では、関数が<termref def="dt-udf">ユーザ定義</termref>なのか<termref def="dt-external-function">外部</termref>なのかを指定する。<termdef id="dt-udf" term="user-defined function"><term>ユーザ定義関数</term>に対して、関数宣言には<term>関数の本体</term>と呼ばれる式が含まれる。これは、その関数の結果が引数からどのように計算されるかを定義する。</termdef> 関数の本体に対する<termref def="dt-static-context">静的文脈</termref>には、<termref def="dt-prolog">前書き</termref>中のどこかで宣言されたり輸入されたりする関数がすべて含まれる。しかし、変数や名前空間については、定義された関数より前書き中で早く宣言されたり輸入されたりするものしか含まれない。</p>
<p><termdef id="dt-external-function" term="external function"><term>外部関数</term>は、その問合せの環境の外側で実装されている関数である。</termdef> 例えば、XQuery の実装は、<bibref ref="FunctionsAndOperators"/>に述べられているコア関数ライブラリに加えて、外部関数の集合を用意しているかもしれない。外部関数は、キーワード <code>external</code> によって識別される。。外部関数に対する関数宣言の目的は、その関数の引数や結果のデータ型を宣言し、その関数宣言を含んだり輸入する問合せの型検査に用いることである。</p>
<p>XQuery の実装は、ホストプログラミング言語を用いて外部関数を実装できる機能を提供してもよいが、そうすることを要求はされない。このような機能が提供されているならば、引数を外部関数に渡したり、その関数の結果を呼び出しを行った問合せに戻すプロトコルは<termref def="dt-implementation-defined">実装定義</termref>である。XQuery の実装は<bibref ref="datamodel"/>の型システムを、ホストプログラミング言語とデータを交換する機能のために設計された追加型で拡張してもよい。また、ユーザがこのような型を定義することのできる機構を提供してもよい。例えば、SQLデータベースの接続など、外部関数によって返されるオブジェクトをカプセル化する型を提供してもよい。このような追加型は、もし定義されれば、<code>xs:anyAtomicType</code> から制限によって導出されているとみなされる。</p>
<p>ユーザ定義の関数はいずれもある名前空間に属していなければならない -- すなわち、宣言された関数名は (展開した時に) 空でない名前空間 URI を持っていなければならない <errorref class="ST" code="0060"/>。関数宣言中の関数名が名前空間接頭辞を持っていなければ、<termref def="dt-def-fn-ns">デフォルト関数名前空間</termref>に属しているとみなされる。<termref def="dt-library-module">ライブラリモジュール</termref>中で定義される関数名はいずれも (展開した時に) そのライブラリモジュールの<termref def="dt-target-namespace">目的名前空間</termref>に属していなければならない <errorref class="ST" code="0048"/>。関数宣言中の関数名が (展開した時に) 以下の名前空間のいずれかに属していれば、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0045"/> である:</p>
<ulist>
<item><p><code>http://www.w3.org/XML/1998/namespace</code></p></item>
<item><p><code>http://www.w3.org/2001/XMLSchema</code></p></item>
<item><p><code>http://www.w3.org/2001/XMLSchema-instance</code></p></item>
<item><p><code>http://www.w3.org/2005/xpath-functions</code></p></item>
<item><p><code>http://www.w3.org/2005/xpath-datatypes</code></p></item>
</ulist>
<p>宣言された関数の<termref def="dt-expanded-qname">展開済 QName</termref>と次数 (引数の数) が<termref def="dt-function-signature">関数シグネチャ</termref>中の別の関数の<termref def="dt-expanded-qname">展開済 QName</termref>と次数に (<code>eq</code> 演算子によって定義されるように) 等しければ、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0034"/> である。</p>
<p>新しい名前空間を定義することなく、主モジュールがそのモジュール内で局所的に使用する関数を宣言できるようにするために、XQuery では名前空間接頭辞 <code>local</code> を名前空間 <code>http://www.w3.org/2005/xquery-local-functions</code> にあらかじめ定義している。この名前空間は、局所関数を定義するのに用いることが推奨される (しかし要求される訳ではない)。</p> 
 
<p>関数の引数の宣言に名前はあるが型がないならば、そのデフォルト型は <code>item()*</code> である。結果型が関数の宣言から省略されていれば、そのデフォルト結果型は <code>item()*</code> である。</p>
<p>関数宣言の引数は、有効範囲が関数の本体であるような変数とみなされる。2つ以上の引数が同じ名前を持つような関数宣言は<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0039"/> である。関数の引数の型は<termref def="dt-sequence-type">列型</termref>として表現可能な任意の型であってよい。</p>
<p>以下の例では、<code>employee</code> 要素の列を受け取り、それらを部門ごとにまとめ、<code>dept</code> 要素の列を返すような局所変数の宣言と使用を示している。</p> 
<ulist> 
<item>
<p>関数を用いて、Denver にいる従業員に関するまとめを用意する。</p>
<eg role="parse-test" xml:space="preserve">declare function local:summary($emps as element(employee)*) 
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</eg>
 </item>
</ulist>
<p>関数の引数を宣言された引数の型に変換するルールや、関数の結果を宣言された結果の型に変換するルールについては、<specref ref="id-function-calls"/>に述べられている。</p> 
<p>関数宣言は再帰的であってもよい。すなわち、自分自身を参照していてもよい。相互再帰関数、すなわち関数の本体が互いに参照し合うような関数も許される。以下の例では、節点の階層の深さの最大値を計算する再帰関数を定義し、その関数を呼び出してある文書の深さの最大値を求めている。この宣言の中で、ユーザ定義関数 <code>local:depth</code> は組み込み関数 <code>empty</code> と <code>max</code> を呼び出しているが、これらはいずれもデフォルト関数名前空間に属している。</p> 
<ulist> 
<item>
<p><code>partlist.xml</code> という名前の文書の深さの最大値を求める。</p>
<eg role="parse-test" xml:space="preserve">declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</eg>
</item>
</ulist> 
<p><termref def="dt-constructor-function">構成子関数</termref>は<termref def="dt-is-types">有効範囲内スキーマ型</termref>中のユーザ定義の原子型それぞれに効果的に宣言されるため、前書き中でこれらの型のいずれかと同じ<termref def="dt-expanded-qname">展開済 QName</termref>を持つ引数1つの関数が宣言されていれば<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0034"/> が発生する。</p> 
</div2>
<div2 id="id-option-declaration">
<head>オプション宣言</head>
<p><termdef term="option declaration" id="dt-option-declaration"><term>オプション宣言</term>は特定の実装の振舞いに影響を与えるオプションを宣言する。オプションはそれぞれ、識別される QName と StringLiteral 1つずつから構成される。</termdef></p>
<scrap headstyle="show"> 
<head/> <prod num="13" id="doc-xquery-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod> 
 

</scrap>
<p>通常、オプションはある実装には認識されるが他の実装には認識されない。オプション宣言がどの実装でも構文解析に成功するように、構文は設計されている。</p>
<p><termref def="dt-static-namespaces">静的既知名前空間</termref>を用いて、オプションの QName は名前空間 URI と局所名に解決されなければならない <errorref class="ST" code="0081"/>。</p>
<note><p>オプションにはデフォルト名前空間はない。</p></note>
<p>実装はそれぞれ、オプション宣言を表す名前空間 URI の<termref def="dt-implementation-defined">実装定義</termref>の集合を認識する。</p>
<p>QName の名前空間部分が、実装によってオプション宣言を表すと認識される名前空間でないならば、そのオプション宣言は無視される。</p>
<p>そうでない場合、オプション宣言の効果は、エラーに関する振舞いを含め、<termref def="dt-implementation-defined">実装定義</termref>である。例えば、QName の局所名が認識されなかったり、StringLiteral が特定のオプション宣言に対して実装によって定義されるルールに適合しない場合、実装は、エラーを報告する、オプション宣言を無視する、これ以外の動作を行う、などのどれを選択してもよい。</p>
<p>実装は、オプション宣言が変数宣言や関数宣言に対して相対的に出現する位置に関するルールを課してもよい。またオプション宣言の解釈はその位置に依存してもよい。</p>
<p>オプション宣言は、処理器によって受理される構文を変更するのに用いてはならない。また静的エラーの検出の抑制に用いてもならない。しかし、問合せの意味を変更することには制限なしに用いてもよい。オプション宣言の有効範囲は<termref def="dt-implementation-defined">実装定義</termref>である - 例えば、オプション宣言は問合せ全体に適用されてもよいし、現在のモジュールのみに適用されてもよいし、直後に続く関数宣言のみに適用されてもよい。</p>
<p>以下の例では、オプション宣言の使い方としてあり得るものをいろいろ示す:</p>
<ulist>
<item><p>このオプション宣言は直列化のパラメータを設定するのに用いられる:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare namespace exq = "http://example.org/XQueryImplementation";
declare option exq:output "encoding = iso-8859-1";
</eg></item>
<item><p>このオプション宣言は、<code>fn:doc()</code> 関数によって返されるソース文書中のコメントがどのように扱われるかを指定する:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare option exq:strip-comments "true";
</eg></item>
<item><p>このオプション宣言は、関数名中で用いられる名前空間と Java クラスを関連づけるのに用いられる:</p><eg role="frag-prolog-parse-test" xml:space="preserve">declare namespace math = "http://example.org/MathLibrary";
declare option exq:java-class "math = java.lang.Math";
</eg></item></ulist></div2></div1>

<div1 id="id-xquery-conformance" role="xquery">
    <head>適合性</head>
    <p>この節では、XQuery 処理器の適合性規準を定義する。この節では、<bibref ref="RFC2119"/>で定義される要求水準を表すのに以下の用語を用いる。 
        <termdef id="must" term="must"><term>しなければならない</term> (MUST) は、仕様の絶対的な要求である項目を意味する。</termdef>
        <termdef id="may" term="may"><term>してもよい</term> (MAY) は、項目が真に選択可能であることを意味する。</termdef>
        <termdef id="should" term="should">
            <term>べきである</term> (SHOULD) は、特定の状況ではその項目を無視する正当な理由があるかもしれないが、影響を完全に理解しなければならず、異なる選択を選ぶ前に十分慎重に考慮しなければならない、ということを意味する。</termdef>
    </p>
    <p>この仕様に適合することを要求する XQuery 処理器は、<specref ref="id-minimal-conformance"/>で定義される最小適合性の要求を含ま<termref def="must">なければならない</termref>。最小適合性の要求に加え、<specref ref="id-conform-optional-features"/>で定義される省略可能な機能のうち1つ以上に関する適合性を要求<termref def="may">してもよい</termref>。</p>
    <div2 id="id-minimal-conformance">
        <head>最小適合性</head>
        <p>この仕様に対する最小適合性は、以下の項目のすべてを含ま<termref def="must">なければならない</termref>:</p>
        <olist>
            <item>
                <p>この文書で指定されているすべての支援。ただし、<specref ref="id-conform-optional-features"/>で省略可能と指定されている機能を除く。実装がある省略可能な機能を提供しないならば、<specref ref="id-conform-optional-features"/>で指定されている要求のうち、その機能を提供しない実装に対するものをいずれも実装<termref def="must">しなければならない</termref>。</p>
            </item>
            <item>
                <p><termref def="dt-implementation-defined">実装定義</termref>と指定されているすべての項目の定義。ただし、その項目がその実装によって支援されない省略可能な機能の一部でない場合に限る。<termref def="dt-implementation-defined">実装定義</termref>の項目のリストは<specref ref="id-impl-defined-items"/>にある。</p>
                <note>
                    <p>実装は、<termref def="dt-implementation-dependent">実装依存</termref>と指定されている項目を定義することは要求されない。</p>
                </note>
            </item>
            <item>
                <p><specref ref="id-data-model-conformance"/>に指定されている通りに<bibref ref="datamodel"/>を支援すること。</p>
            </item>
            <item>
                <p><bibref ref="FunctionsAndOperators"/>に定義されているすべての関数の支援。</p>
            </item>
        </olist>
    </div2>
    <div2 id="id-conform-optional-features">
        <head>省略可能な機能</head>
        <div3 id="id-schema-import-feature">
            <head>スキーマ輸入機能</head>
            <p><termdef id="dt-schema-import-feature" term="schema import feature"><term>スキーマ輸入機能</term>は問合せの前書きに<termref def="dt-schema-import">スキーマ輸入</termref>を含めることを許す。</termdef>
            </p>
            <p>XQuery の実装がスキーマ輸入機能を支援しないならば、その実装は，スキーマ輸入を発見すると静的エラー <errorref class="ST" code="0009"/> を発生<termref def="must">しなければならない</termref>。</p>
            <note>
                <p>実装がスキーマ輸入機能を支援しないならば、<specref ref="id-xq-static-context-components"/>にある通り，<termref def="dt-is-types">有効範囲内スキーマ型</termref>は組み込みスキーマ型定義と<termref def="dt-implementation-defined">実装定義</termref>のスキーマ型定義のみからなる。</p>
            </note>
        </div3>
        <div3 id="id-schema-validation-feature">
            <head>スキーマ検証機能</head>
            <p>
                <termdef id="dt-schema-validation-feature" term="schema validation feature"><term>スキーマ検証機能</term>は、問合せに <code>validate</code> 式 (<specref ref="id-validate"/>を見よ) を含めることを許す。</termdef>
            </p>
            <p>XQuery の実装がスキーマ検証機能を支援しないならば、その実装は、<code>validate</code> 式を発見すると静的エラー <errorref class="ST" code="0075"/> を発生<termref def="must">しなければならない</termref>。</p>
        </div3>
        <div3 id="id-static-typing-feature">
            <head>静的型付け機能</head>
            <p>
                <termdef id="dt-static-typing-feature" term="static typing feature" role="xquery"><term>静的型付け機能</term>は<bibref ref="XQueryFormalSemantics"/>に定義されている静的意味の支援を提供し、実装に、<termref def="dt-static-analysis">静的解析相</termref>において<termref def="dt-type-error">型エラー</termref>を検出し報告することを要求する。</termdef>
            </p>
            <p>実装が<termref def="dt-static-typing-feature">静的型付け機能</termref>を支援せず、にもかかわらず静的解析相で、ある式が評価されると実行時に型エラーを必ず発生させると決定できるならば、実装は、静的解析相でエラーを発生させ<termref def="may">てもよい</termref>。解析時にこのようなエラーを発生させるかどうかの選択は<termref def="dt-implementation-dependent">実装依存</termref>である。</p>
            <note>
                <p><termref def="dt-static-typing-feature">静的解析相</termref>を支援しない実装は、静的解析相で型エラーを発生させる必要はない。しかし、型に関係しないエラーは静的解析相で検出し発生させ<termref def="must">なければならない</termref>。</p>
            </note>
            <div4 id="id-static-extensions" role="xquery">
                <head>静的型付け拡張</head>
                <p>場合によっては、<bibref ref="XQueryFormalSemantics"/>で定義される静的型付けルールはあまり詳細ではない (例えば、祖先方向の軸 -- つまり parent, ancenstor, ancestor-or-self -- や <code>fn:root</code> 関数に対する型推論ルールを見よ)。実装によっては、より詳細な静的型付けルールを支援することを期待してもよい。</p>
                <p><termref def="dt-static-typing-feature">静的型付け機能</termref>を実装している適合実装は、また1つ以上の<term>静的型付け拡張</term>を提供<termref def="may">してもよい</termref>。<termdef term="static typing extension" id="dt-static-typing-extension"><term>静的型付け拡張</term>は<termref def="dt-implementation-defined">実装定義</termref>の型推論ルールである。これは<bibref ref="XQueryFormalSemantics"/>の型推論ルールによって推論される静的型よりも詳細な静的型を推論する。</termdef> 静的型付け拡張の制約の形式的な定義については <xspecref spec="FS" ref="id-static-extensions"/> を見よ。</p>
            </div4>
        </div3>
        <div3 id="id-full-axis-feature">
            <head>全軸機能</head>
            <p>
                <termdef term="optional axis" id="dt-optional-axis">以下の軸は<term>選択的な軸</term>として設計されている: <code>ancestor</code>,
                        <code>ancestor-or-self</code>, <code>following</code>,
                        <code>following-sibling</code>, <code>preceding</code>, および
                        <code>preceding-sibling</code>。</termdef>
            </p>
            <p>
                <termdef id="dt-full-axis-feature" term="Full Axis Feature"><term>全軸機能</term>を支援する適合 XQuery 実装は、すべての<termref def="dt-optional-axis">選択的な軸</termref>を支援<termref def="must">しなければならない</termref>。</termdef>
            </p>
            <p>全軸機能を支援しない適合 XQuery 実装は、選択的な軸を1つ以上支援<termref def="may">してもよい</termref>。このような実装によってどの軸が支援されるかは<termref def="dt-implementation-defined">実装定義</termref>である。適合実装が、それが支援しない選択的な軸への参照を発見した場合、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0010"/> を発生させ<termref def="must">なければならない</termref>。</p>
            <note>
                <p>XQuery は <code>namespace</code> 軸 (XPath 1.0 で定義され、XPath 2.0 では推奨されない) を認識しない。</p>
            </note>
        </div3>
        <div3 id="id-module-feature">
            <head>モジュール機能</head>
            <p>
                <termdef id="dt-module-feature" term="module feature"><term>モジュール機能</term>を支援する適合 XQuery 実装は、問合せの前書きに<term>モジュール輸入</term>が含まれることを許す。また<term>ライブラリモジュール</term>を生成することを許す。</termdef>
            </p>
            <p>モジュール機能を支援しない適合実装は、<termref def="dt-module-declaration">モジュール定義</termref>や<termref def="dt-module-import">モジュール輸入</termref>を発見した場合、<termref def="dt-static-error">静的エラー</termref> <errorref class="ST" code="0016"/> を発生させ<termref def="must">なければならない</termref>。<termref def="dt-module-declaration">モジュール定義</termref>は<termref def="dt-library-module">ライブラリモジュール</termref>中で必要であるので、モジュール機能は、<termref def="dt-library-module">ライブラリモジュール</termref>を生成するために必要である。</p>
            <note>
                <p>モジュール機能がなければ、各問合せは単一の<termref def="dt-main-module">主モジュール</termref>から構成される。</p>
            </note>
        </div3>
        <div3 id="id-serialization-feature">
            <head>直列化機能</head>
            <p>
                <termdef id="dt-serialization-feature" term="serialization feature"><term>直列化機能</term>を支援する適合 XQuery 実装は、<specref ref="id-serialization"/>で指定されている通りに、問合せの結果を直列化する手段を提供<termref def="must">しなければならない</termref>。</termdef>
            </p>
            <p>直列化機能を支援する適合 XQuery 実装は<specref ref="id-xq-serialization-parameters"/>に適合してい<termref def="must">なければならない</termref>。直列化が実行される方法は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
            <p><bibref ref="serialization"/>に指定されている通りの直列化プロセスでエラーが発生すれば、適合 XQuery 実装は呼び出している環境にエラーを報告し<termref def="must">なければならない</termref>。</p>
            <note>
                <p>すべての実装が直列化を必要とするわけではない。例えば、ある実装は、テキスト表現を生成する代わりに XML API を通して結果を提供するかもしれない。</p>
            </note>
        </div3><div3 id="id-trivial-xml-embedding-feature"><head>自明な XML 埋め込み機能</head>
<p><termdef term="Trivial XML Embedding" id="dt-trivial-xml-embedding"><term>自明な XML 埋め込み機能</term>を支援する適合 XQuery 実装は、<bibref ref="XQueryX"/> 5章, "A Trivial Embedding of XQuery" に指定されている埋め込みを提供<termref def="must">しなければならない</termref>。</termdef></p></div3>
    </div2>
    <div2 id="id-data-model-conformance">
        <head>データモデル適合</head>
        <p>すべての XQuery 実装は<bibref ref="datamodel"/>に指定されている<termref def="dt-datamodel">データモデル</termref>中で表現されているデータを処理する。データモデルの仕様は、対応する環境中でのそのデータモデルに対する適合性水準を指定するのに XQuery のような言語に頼っている。そして、以下の項目を考慮すべきであると提案している:</p>
        <olist>
            <item>
                <p>
                    <emph>情報集合からの規範的な構成の支援。</emph> 適合実装は<xspecref spec="DM" ref="const-infoset"/>への適合を要求することを選択<termref def="may">してもよい</termref>。これは、単なる整形式 XML 文書や DTD によって管理されている XML 文書から<termref def="dt-data-model-instance">XDM インスタンス</termref>を構成する規範的な方法を定義する。</p>
            </item>
            <item>
                <p>
                    <emph>PSVI からの規範的な構成の支援。</emph> 適合実装は<xspecref spec="DM" ref="const-psvi"/>への適合を要求することを選択<termref def="may">してもよい</termref>。これは、W3C XML Schema によって管理されている XML 文書から<termref def="dt-data-model-instance">XDM インスタンス</termref>を構成する規範的な方法を定義する。</p>
            </item>
            <item>
                <p>
                    <emph>XML 1.0 と XML 1.1 に対する支援。</emph> <bibref ref="datamodel"/>は<bibref ref="XML"/>か<bibref ref="XML1.1"/>のいずれか一方を支援する。XQuery では、どちらの XML バージョンを支援するかの選択は<termref def="dt-implementation-defined">実装定義</termref>である。</p>
<p>執筆時点では、XML 1.1 の仕様を参照する XML Schema のバージョンは出版されていない。これにより、<code>xs:NCName</code> や <code>xs:ID</code> といったデータ型は XML 1.0 のルールに制約される。XQuery 1.0 処理器は、XML Schema の将来のバージョンが有効になれば、そのバージョンで定義されるルールを実装するべきである。</p>
            <note><p>XML 1.1 文書の処理に関する示唆については<bibref ref="xml11schema10"/>を見よ。</p></note></item>
<item><p><emph>データ値の範囲。</emph> XQuery では、以下の制限が<termref def="dt-implementation-defined">実装定義</termref>である:</p><olist><item><p><code>xs:decimal</code> 型に対して、10進数の最大値 (<code>totalDigits</code> 相) (少なくとも 18 でなければならない)。</p></item>
<item><p><code>xs:date</code> 型、<code>xs:time</code> 型、<code>xs:dateTime</code> 型、<code>xs:gYear</code> 型、<code>xs:gYearMonth</code> 型に対して: 年の構成要素の最大値と、断片となる秒数 (少なくとも 3 でなくてはならない)。</p></item>
<item><p><code>xs:duration type</code> 型に対して: 年、月、日、時、分の構成要素の最大絶対値。</p></item>
<item><p><code>xs:yearMonthDuration</code> 型に対して: 最大絶対値。これは月の整数値として表現される。</p></item>
<item><p><code>xs:dayTimeDuration type</code> に対して: 最大絶対値。これは秒の10進数として表現される。</p></item>
<item><p><code>xs:string</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>, <code>xs:QName</code>, 
<code>xs:anyURI</code>, <code>xs:NOTATION</code> の各型、およびこれらから導出される型に対して: 値の長さに関して実装によって強いられる制限 (もしあれば)。</p></item>
</olist>
<p>上に列挙した制限は固定されなくてもよい。しかしシステム資源のような環境の要素に依存してもよい。例えば、<code>xs:string</code> 型の値の長さは、使用できるメモリによって制限されてもよい。</p></item>
        </olist>
    </div2>
</div1>
</body>
<back id="id-appendices">

<div1 id="nt-bnf"><head>XQueryの文法</head>
<div2 id="id-grammar">
<head>EBNF</head>


<p>XQueryの文法は、単純な拡張バッカス記法 (EBNF) を用いる。これは<bibref ref="XML"/>と同じものであるが、以下に述べるように、若干の違いがある。</p>
<ulist>
<item><p>名前づけられた記号はすべて、大文字で始まる名前を持つ。</p></item>
<item><p>外部の仕様の生成規則を参照するための記法を加える。</p></item>
<item><p>コメントや、文法の生成規則に関する特別な文法的制限を '/*' と '*/' という記号の間に置く。</p>
<ulist><item><p>'xgc:' 接頭辞は特別な文法的制限であり、その詳細は<specref ref="extra-grammatical-constraints"/>に説明がある。</p></item>
<item><p>'ws:' 接頭辞は生成規則に対する空白のルールであり、その詳細は<specref ref="whitespace-rules"/>に説明がある。</p></item>
<item><p>'gn:' 接頭辞は '文法上の備考' (Grammar Note)の意味であり、ルール解釈を明確にすることを意味する。これについては<specref ref="notes-on-parsing"/>に説明されている。これらの備考は参考である。</p></item></ulist></item></ulist>
<p>この文法の終端記号には、既出の生成規則で用いられた引用符付き文字列や、<specref ref="terminal-symbols"/>で定義された終端記号が含まれる。</p>
<p>EBNF記法についてのより詳しい説明は<specref ref="EBNFNotation"/>にある。</p>
<p>可読性を上げるため、この文書の本体のEBNFでは記法上の特徴をいくつか省略している。この附録はEBNFの参考バージョンである。</p>
<scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head/>

<prod num="1" id="prod-xquery-Module"><lhs>Module</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VersionDecl" xlink:type="simple">VersionDecl</nt>?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-LibraryModule" xlink:type="simple">LibraryModule</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MainModule" xlink:type="simple">MainModule</nt>)</rhs></prod><prod num="2" id="prod-xquery-VersionDecl"><lhs>VersionDecl</lhs><rhs>"xquery"  "version"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>  ("encoding"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod><prod num="3" id="prod-xquery-MainModule"><lhs>MainModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Prolog" xlink:type="simple">Prolog</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QueryBody" xlink:type="simple">QueryBody</nt></rhs></prod><prod num="4" id="prod-xquery-LibraryModule"><lhs>LibraryModule</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ModuleDecl" xlink:type="simple">ModuleDecl</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Prolog" xlink:type="simple">Prolog</nt></rhs></prod><prod num="5" id="prod-xquery-ModuleDecl"><lhs>ModuleDecl</lhs><rhs>"module"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt></rhs></prod><prod num="6" id="prod-xquery-Prolog"><lhs>Prolog</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DefaultNamespaceDecl" xlink:type="simple">DefaultNamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Setter" xlink:type="simple">Setter</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NamespaceDecl" xlink:type="simple">NamespaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Import" xlink:type="simple">Import</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*  ((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarDecl" xlink:type="simple">VarDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FunctionDecl" xlink:type="simple">FunctionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OptionDecl" xlink:type="simple">OptionDecl</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Separator" xlink:type="simple">Separator</nt>)*</rhs></prod><prod num="7" id="prod-xquery-Setter"><lhs>Setter</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-BoundarySpaceDecl" xlink:type="simple">BoundarySpaceDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DefaultCollationDecl" xlink:type="simple">DefaultCollationDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-BaseURIDecl" xlink:type="simple">BaseURIDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ConstructionDecl" xlink:type="simple">ConstructionDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderingModeDecl" xlink:type="simple">OrderingModeDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EmptyOrderDecl" xlink:type="simple">EmptyOrderDecl</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CopyNamespacesDecl" xlink:type="simple">CopyNamespacesDecl</nt></rhs></prod><prod num="8" id="prod-xquery-Import"><lhs>Import</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaImport" xlink:type="simple">SchemaImport</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ModuleImport" xlink:type="simple">ModuleImport</nt></rhs></prod><prod num="9" id="prod-xquery-Separator"><lhs>Separator</lhs><rhs>";"</rhs></prod><prod num="10" id="prod-xquery-NamespaceDecl"><lhs>NamespaceDecl</lhs><rhs>"declare"  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="11" id="prod-xquery-BoundarySpaceDecl"><lhs>BoundarySpaceDecl</lhs><rhs>"declare"  "boundary-space"  ("preserve"  |  "strip")</rhs></prod><prod num="12" id="prod-xquery-DefaultNamespaceDecl"><lhs>DefaultNamespaceDecl</lhs><rhs>"declare"  "default"  ("element"  |  "function")  "namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="13" id="prod-xquery-OptionDecl"><lhs>OptionDecl</lhs><rhs>"declare"  "option"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="14" id="prod-xquery-OrderingModeDecl"><lhs>OrderingModeDecl</lhs><rhs>"declare"  "ordering"  ("ordered"  |  "unordered")</rhs></prod><prod num="15" id="prod-xquery-EmptyOrderDecl"><lhs>EmptyOrderDecl</lhs><rhs>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</rhs></prod><prod num="16" id="prod-xquery-CopyNamespacesDecl"><lhs>CopyNamespacesDecl</lhs><rhs>"declare"  "copy-namespaces"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PreserveMode" xlink:type="simple">PreserveMode</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InheritMode" xlink:type="simple">InheritMode</nt></rhs></prod><prod num="17" id="prod-xquery-PreserveMode"><lhs>PreserveMode</lhs><rhs>"preserve"  |  "no-preserve"</rhs></prod><prod num="18" id="prod-xquery-InheritMode"><lhs>InheritMode</lhs><rhs>"inherit"  |  "no-inherit"</rhs></prod><prod num="19" id="prod-xquery-DefaultCollationDecl"><lhs>DefaultCollationDecl</lhs><rhs>"declare"  "default"  "collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="20" id="prod-xquery-BaseURIDecl"><lhs>BaseURIDecl</lhs><rhs>"declare"  "base-uri"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt></rhs></prod><prod num="21" id="prod-xquery-SchemaImport"><lhs>SchemaImport</lhs><rhs>"import"  "schema"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaPrefix" xlink:type="simple">SchemaPrefix</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="22" id="prod-xquery-SchemaPrefix"><lhs>SchemaPrefix</lhs><rhs>("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")  |  ("default"  "element"  "namespace")</rhs></prod><prod num="23" id="prod-xquery-ModuleImport"><lhs>ModuleImport</lhs><rhs>"import"  "module"  ("namespace"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  "=")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  ("at"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)*)?</rhs></prod><prod num="24" id="prod-xquery-VarDecl"><lhs>VarDecl</lhs><rhs>"declare"  "variable"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ((":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)  |  "external")</rhs></prod><prod num="25" id="prod-xquery-ConstructionDecl"><lhs>ConstructionDecl</lhs><rhs>"declare"  "construction"  ("strip"  |  "preserve")</rhs></prod><prod num="26" id="prod-xquery-FunctionDecl"><lhs>FunctionDecl</lhs><rhs>"declare"  "function"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt>)?  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>  |  "external")</rhs></prod><prod num="27" id="prod-xquery-ParamList"><lhs>ParamList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Param" xlink:type="simple">Param</nt>)*</rhs></prod><prod num="28" id="prod-xquery-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="29" id="prod-xquery-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="30" id="prod-xquery-QueryBody"><lhs>QueryBody</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="31" id="prod-xquery-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="32" id="prod-xquery-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FLWORExpr" xlink:type="simple">FLWORExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeswitchExpr" xlink:type="simple">TypeswitchExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod><prod num="33" id="prod-xquery-FLWORExpr"><lhs>FLWORExpr</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForClause" xlink:type="simple">ForClause</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-LetClause" xlink:type="simple">LetClause</nt>)+  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-WhereClause" xlink:type="simple">WhereClause</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderByClause" xlink:type="simple">OrderByClause</nt>?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="34" id="prod-xquery-ForClause"><lhs>ForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PositionalVar" xlink:type="simple">PositionalVar</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="35" id="prod-xquery-PositionalVar"><lhs>PositionalVar</lhs><rhs>"at"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="36" id="prod-xquery-LetClause"><lhs>LetClause</lhs><rhs>"let"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="37" id="prod-xquery-WhereClause"><lhs>WhereClause</lhs><rhs>"where"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="38" id="prod-xquery-OrderByClause"><lhs>OrderByClause</lhs><rhs>(("order"  "by")  |  ("stable"  "order"  "by"))  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpecList" xlink:type="simple">OrderSpecList</nt></rhs></prod><prod num="39" id="prod-xquery-OrderSpecList"><lhs>OrderSpecList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderSpec" xlink:type="simple">OrderSpec</nt>)*</rhs></prod><prod num="40" id="prod-xquery-OrderSpec"><lhs>OrderSpec</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderModifier" xlink:type="simple">OrderModifier</nt></rhs></prod><prod num="41" id="prod-xquery-OrderModifier"><lhs>OrderModifier</lhs><rhs>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-URILiteral" xlink:type="simple">URILiteral</nt>)?</rhs></prod><prod num="42" id="prod-xquery-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="43" id="prod-xquery-TypeswitchExpr"><lhs>TypeswitchExpr</lhs><rhs>"typeswitch"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CaseClause" xlink:type="simple">CaseClause</nt>+  "default"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>)?  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="44" id="prod-xquery-CaseClause"><lhs>CaseClause</lhs><rhs>"case"  ("$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt>  "as")?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="45" id="prod-xquery-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="46" id="prod-xquery-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="47" id="prod-xquery-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="48" id="prod-xquery-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod><prod num="49" id="prod-xquery-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="50" id="prod-xquery-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="51" id="prod-xquery-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="52" id="prod-xquery-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="53" id="prod-xquery-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="54" id="prod-xquery-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="55" id="prod-xquery-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="56" id="prod-xquery-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="57" id="prod-xquery-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="58" id="prod-xquery-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod><prod num="59" id="prod-xquery-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValidateExpr" xlink:type="simple">ValidateExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PathExpr" xlink:type="simple">PathExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExtensionExpr" xlink:type="simple">ExtensionExpr</nt></rhs></prod><prod num="60" id="prod-xquery-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="61" id="prod-xquery-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="62" id="prod-xquery-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="63" id="prod-xquery-ValidateExpr"><lhs>ValidateExpr</lhs><rhs>"validate"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ValidationMode" xlink:type="simple">ValidationMode</nt>?  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="64" id="prod-xquery-ValidationMode"><lhs>ValidationMode</lhs><rhs>"lax"  |  "strict"</rhs></prod><prod num="65" id="prod-xquery-ExtensionExpr"><lhs>ExtensionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Pragma" xlink:type="simple">Pragma</nt>+  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="66" id="prod-xquery-Pragma"><lhs>Pragma</lhs><rhs>"(#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PragmaContents" xlink:type="simple">PragmaContents</nt>  "#)"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="67" id="prod-xquery-PragmaContents"><lhs>PragmaContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '#)' Char*))</rhs></prod><prod num="68" id="prod-xquery-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: leading-lone-slash</loc></com></prod><prod num="69" id="prod-xquery-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="70" id="prod-xquery-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod><prod num="71" id="prod-xquery-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="72" id="prod-xquery-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod><prod num="73" id="prod-xquery-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</rhs></prod><prod num="74" id="prod-xquery-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod><prod num="75" id="prod-xquery-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod><prod num="76" id="prod-xquery-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="77" id="prod-xquery-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="78" id="prod-xquery-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NameTest" xlink:type="simple">NameTest</nt></rhs></prod><prod num="79" id="prod-xquery-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod><prod num="80" id="prod-xquery-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="81" id="prod-xquery-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="82" id="prod-xquery-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="83" id="prod-xquery-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="84" id="prod-xquery-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OrderedExpr" xlink:type="simple">OrderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-UnorderedExpr" xlink:type="simple">UnorderedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Constructor" xlink:type="simple">Constructor</nt></rhs></prod><prod num="85" id="prod-xquery-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="86" id="prod-xquery-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod><prod num="87" id="prod-xquery-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="88" id="prod-xquery-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="89" id="prod-xquery-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="90" id="prod-xquery-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="91" id="prod-xquery-OrderedExpr"><lhs>OrderedExpr</lhs><rhs>"ordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="92" id="prod-xquery-UnorderedExpr"><lhs>UnorderedExpr</lhs><rhs>"unordered"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="93" id="prod-xquery-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: reserved-function-names</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc></com></prod><prod num="94" id="prod-xquery-Constructor"><lhs>Constructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ComputedConstructor" xlink:type="simple">ComputedConstructor</nt></rhs></prod><prod num="95" id="prod-xquery-DirectConstructor"><lhs>DirectConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirElemConstructor" xlink:type="simple">DirElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirCommentConstructor" xlink:type="simple">DirCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirPIConstructor" xlink:type="simple">DirPIConstructor</nt></rhs></prod><prod num="96" id="prod-xquery-DirElemConstructor"><lhs>DirElemConstructor</lhs><rhs>"&lt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirAttributeList" xlink:type="simple">DirAttributeList</nt>  ("/&gt;"  |  ("&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirElemContent" xlink:type="simple">DirElemContent</nt>*  "&lt;/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "&gt;"))</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="97" id="prod-xquery-DirAttributeList"><lhs>DirAttributeList</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  "="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirAttributeValue" xlink:type="simple">DirAttributeValue</nt>)?)*</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="98" id="prod-xquery-DirAttributeValue"><lhs>DirAttributeValue</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuotAttrValueContent" xlink:type="simple">QuotAttrValueContent</nt>)*  '"')<br/>|  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AposAttrValueContent" xlink:type="simple">AposAttrValueContent</nt>)*  "'")</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="99" id="prod-xquery-QuotAttrValueContent"><lhs>QuotAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod><prod num="100" id="prod-xquery-AposAttrValueContent"><lhs>AposAttrValueContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt></rhs></prod><prod num="101" id="prod-xquery-DirElemContent"><lhs>DirElemContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirectConstructor" xlink:type="simple">DirectConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CDataSection" xlink:type="simple">CDataSection</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommonContent" xlink:type="simple">CommonContent</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt></rhs></prod><prod num="102" id="prod-xquery-CommonContent"><lhs>CommonContent</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  "{{"  |  "}}"  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt></rhs></prod><prod num="103" id="prod-xquery-DirCommentConstructor"><lhs>DirCommentConstructor</lhs><rhs>"&lt;!--"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirCommentContents" xlink:type="simple">DirCommentContents</nt>  "--&gt;"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="104" id="prod-xquery-DirCommentContents"><lhs>DirCommentContents</lhs><rhs>((<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')  |  ('-'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - '-')))*</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="105" id="prod-xquery-DirPIConstructor"><lhs>DirPIConstructor</lhs><rhs>"&lt;?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DirPIContents" xlink:type="simple">DirPIContents</nt>)?  "?&gt;"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="106" id="prod-xquery-DirPIContents"><lhs>DirPIContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* '?&gt;' Char*))</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="107" id="prod-xquery-CDataSection"><lhs>CDataSection</lhs><rhs>"&lt;![CDATA["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CDataSectionContents" xlink:type="simple">CDataSectionContents</nt>  "]]&gt;"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="108" id="prod-xquery-CDataSectionContents"><lhs>CDataSectionContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>* - (Char* ']]&gt;' Char*))</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="109" id="prod-xquery-ComputedConstructor"><lhs>ComputedConstructor</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompDocConstructor" xlink:type="simple">CompDocConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompElemConstructor" xlink:type="simple">CompElemConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompAttrConstructor" xlink:type="simple">CompAttrConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompTextConstructor" xlink:type="simple">CompTextConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompCommentConstructor" xlink:type="simple">CompCommentConstructor</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CompPIConstructor" xlink:type="simple">CompPIConstructor</nt></rhs></prod><prod num="110" id="prod-xquery-CompDocConstructor"><lhs>CompDocConstructor</lhs><rhs>"document"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="111" id="prod-xquery-CompElemConstructor"><lhs>CompElemConstructor</lhs><rhs>"element"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ContentExpr" xlink:type="simple">ContentExpr</nt>?  "}"</rhs></prod><prod num="112" id="prod-xquery-ContentExpr"><lhs>ContentExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="113" id="prod-xquery-CompAttrConstructor"><lhs>CompAttrConstructor</lhs><rhs>"attribute"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="114" id="prod-xquery-CompTextConstructor"><lhs>CompTextConstructor</lhs><rhs>"text"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="115" id="prod-xquery-CompCommentConstructor"><lhs>CompCommentConstructor</lhs><rhs>"comment"  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"</rhs></prod><prod num="116" id="prod-xquery-CompPIConstructor"><lhs>CompPIConstructor</lhs><rhs>"processing-instruction"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  ("{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>  "}"))  "{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="117" id="prod-xquery-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="118" id="prod-xquery-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SequenceType" xlink:type="simple">SequenceType</nt></rhs></prod><prod num="119" id="prod-xquery-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="120" id="prod-xquery-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: occurrence-indicators</loc></com></prod><prod num="121" id="prod-xquery-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="122" id="prod-xquery-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="123" id="prod-xquery-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod><prod num="124" id="prod-xquery-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="125" id="prod-xquery-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="126" id="prod-xquery-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="127" id="prod-xquery-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="128" id="prod-xquery-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="129" id="prod-xquery-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="130" id="prod-xquery-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="131" id="prod-xquery-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="132" id="prod-xquery-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="133" id="prod-xquery-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="134" id="prod-xquery-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="135" id="prod-xquery-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="136" id="prod-xquery-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="137" id="prod-xquery-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="138" id="prod-xquery-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="139" id="prod-xquery-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="140" id="prod-xquery-URILiteral"><lhs>URILiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod>
</scrap>

<div3 id="EBNFNotation"><head>記法</head>
<p>以下の定義は、この解説を正確に定義するのに役立つ。</p>
<p><termdef id="symbol" term="symbol">文法中の各規則は1つの<term>記号</term>を定義する。ここで用いられる形式は以下の通りである。<eg xml:space="preserve">symbol ::= expression</eg></termdef></p>
<p><termdef term="terminal" id="terminal"><term>終端記号</term>は記号、文字列、規則の右辺に出現可能だが主文法の左辺には決して出現しないパターンである。ただし、終端記号のための文法の左辺には出現してよい。</termdef> 以下の構成要素が、長さ1以上の文字からなる文字列で終端記号中にあるものと照合されて用いられる。</p>
<glist><gitem><label>[a-zA-Z]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>で、示された範囲(すべての)中の値であるようなものと照合される。</p></def></gitem>
<gitem><label>[abc]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>で、列挙された文字のどれかの値であるようなものと照合される。<phrase diff="del">列挙と範囲を1つの角括弧の中で混ぜることもできる。</phrase></p></def></gitem>
<gitem><label>[^abc]</label><def><p>任意の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>で、与えられた文字のどれでもない値と照合される。<phrase diff="del">禁止される値の列挙と範囲を1つの角括弧のなかで混ぜることもできる。</phrase></p></def></gitem>
<gitem><label>"string"</label><def><p>二重引用符の中に出現する文字の列と照合される。</p></def></gitem>
<gitem><label>'string'</label><def><p>一重引用符の中に出現する文字の列と照合される。</p></def></gitem>
<gitem><label>	[http://www.w3.org/TR/REC-example/#NT-Example]</label><def><p>用意された参照の通りの外部仕様で定義される生成規則によって照合される文字列と照合される。</p></def></gitem></glist>
<p>パターン (上記の構成要素を含む) を文法構成子で組み合わせ、より複雑なパターンを形成することができる。このようなパターンは文字列の複雑な集合に照合される。以下の例では、AとBは(部分)パターンを表す。</p>
<glist><gitem><label>(A)</label><def><p><code>A</code>は1つの単位として扱われ、このリスト中に記述されているように組み合わせても構わない。</p></def></gitem>
<gitem><label>A?</label><def><p><code>A</code>に照合されるか、何とも照合されない。すなわち省略可能な<code>A</code>と照合される。</p></def></gitem>
<gitem><label>A B</label><def><p><code>A</code>の後ろに<code>B</code>が続くものと照合される。この演算子は代替よりも優先度が高い。従って<code>A B | C D</code>は<code>(A B) | (C D)</code>と同じである。</p></def></gitem>
<gitem><label>A | B</label><def><p><code>A</code>または<code>B</code>に照合される。ただし両方同時には照合されない。</p></def></gitem>
<gitem><label>A - B</label><def><p><code>A</code>に照合されるが、<code>B</code>には照合されないすべての文字列に照合される。</p></def></gitem>
<gitem><label>A+</label><def><p><code>A</code>の1回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A+ | B+</code>は<code>(A+) | (B+)</code>と同じである。</p></def></gitem></glist>
<glist><gitem><label>A*</label><def><p><code>A</code>の0回以上の出現に照合される。連接は代替よりも優先度が高い。従って、<code>A* | B*</code>は<code>(A*) | (B*)</code>と同じである。</p></def></gitem></glist></div3>
<div3 id="extra-grammatical-constraints"><head>特別な文法上の制約</head>
<p>この節はEBNFの生成規則の制約を含む。これらは正当な文を解釈するのに必要となる。以下の備考は、次のような記法で、生成規則の右辺から参照される: <emph>/* xgc: &lt;id&gt; */</emph>。</p>
<constraintnote id="parse-note-leading-lone-slash" type="xgc">
<head>leading-lone-slash</head>
<p>単一のスラッシュは、完全経路式として出現するか、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>の後に続く経路式の最初の部分として出現するかのいずれかである。後者の場合、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NameTest" xlink:type="simple">NameTest</nt> ("*" または QName)の形式を取る。"*", "union" などの演算子が出現しうる文脈では、構文解析器は演算子とNameTestを区別するのが困難であってもよい。例えば、先読みをしなければ、式 "/ * 5" の最初の部分は例えば容易に "/ *" という完全経路式だととられる。これは全く異なる解釈を持つ ("/"の子節点)。</p>
<p>そこで、先読みの必要を削減するため、スラッシュの直後に続くトークンが "*" またはキーワードである場合は、スラッシュは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PathExpr" xlink:type="simple">PathExpr</nt>の先頭でなければならないが、その全体であってはならない (そして、それに続くトークンは<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NameTest" xlink:type="simple">NameTest</nt>でなければならず、演算子であってはならない)。</p>
<p>単一のスラッシュは、括弧で囲むことにより、演算子の左側の引数として用いてもよい: <code>(/) * 5</code>。一方、式<code>5 * /</code>は括弧なしでも正しい式である。</p></constraintnote>
<constraintnote id="parse-note-xml-version" type="xgc"><head>xml-version</head>
<p>実装が<bibref ref="XML"/>と<bibref ref="XMLNAMES"/>の字句定義、あるいは<bibref ref="XML1.1"/>と<bibref ref="XMLNAMES11"/>の字句定義のいずれを支援することを選択するかによって、この生成規則の定義を得る外部文書が決定される。EBNFではバージョン1.0への参照しか持たせていない。ある場合には、XML 1.0とXML 1.1の定義は全く同じであるかもしれない。また、これらの外部定義は、その仕様の空白のルールに従い、この仕様のルール、特に<specref ref="DefaultWhitespaceHandling"/>には従わないことに注意すること。したがって<code>prefix : localname</code>は、XML文書中では許されないのと同様に、この仕様では正しくないQNameである。またコメントはコロンのどちら側にも許されない。また整形式制約のような特別な文法的制約を考慮しなければならない。</p></constraintnote>
<constraintnote id="parse-note-reserved-function-names" type="xgc">
<head>reserved-function-names</head>
<p>言語のキーワードと同じように綴られた接頭辞なしの関数名は、言語の認識を困難にするかもしれない。例えば<code>if(foo)</code>は、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>とも、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IfExpr" xlink:type="simple">IfExpr</nt>の先頭ともとれる。そのため、<specref ref="id-reserved-fn-names"/>中の名前のいずれかと一致する接頭辞なし名前の関数を呼び出すことは、文法的に誤りである。</p>
<p>"if"という名前の関数は、その名前空間をある接頭辞に束縛し、接頭辞付きの形式を用いれば、呼び出すことができる: "if(foo)" の代わりに "library:if(foo)" というようにである。</p></constraintnote>
<constraintnote id="parse-note-occurrence-indicators" type="xgc"><head>occurrence-indicators</head>
<p>すでに書いたように、<specref ref="nt-bnf"/>の文法は '+' と '*' の Kleene 演算子を用いたある種の形式について、曖昧である。この曖昧性は以下のようにして解消される。これらの演算子は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>式と強く結合しており、これらの記号を他の用途で用いた場合より高い優先度を持つ。列型に続いて '?' ばかりでなく '+' や '*' が出現しても、出現標識であると仮定される。すなわち、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ItemType" xlink:type="simple">ItemType</nt>の直後に出現する "+", "*", "?" は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>でなければならない。したがって、<code>4 treat as
       item() + - 5</code>は<code>(4 treat as item()+) - 5</code>と解釈されなければならない。つまり '+' は OccurrenceIndicator として、'-' は減算演算子として解釈されなければならない。"+" を強制的に加算演算子と解釈するには (その結果として "-" は単項のマイナスと解釈される)、括弧を用いてもよい: <code>(4 treat as item()) + -5</code>という形で、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>式を括弧で囲むと、期待される解釈を導く。</p>
<p>このルールの結果として、このルールを用いなければ正しくかつ曖昧性のないある種の形式は、認識されない。"4 treat as item() + 5" では、"+" は<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>ととられ、演算子とは見なされない。そのため、この式は正しい式ではないと解釈される。</p></constraintnote>
</div3>
<div3 id="notes-on-parsing"><head>文法に関する備考</head>
<p>この節は、EBNFの生成規則についての一般的な備考を含む。これらはEBNFをどのように解釈し、またどのように実装するかを理解する助けとなるかもしれない。これらの備考は規範的である。以下の備考は、<emph>/* gn: &lt;id&gt; */</emph>という形式で、生成規則の右辺から参照される。</p>
<note><glist><gitem id="parse-note-parens"><label>grammar-note: parens</label>
<def><p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FunctionCall" xlink:type="simple">FunctionCall</nt>を、<phrase role="xquery"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Pragma" xlink:type="simple">Pragma</nt> or</phrase>の続くQNameやキーワードと区別するには、先読みが必要である。例えば: <code>address (: this may be empty :)</code>は、先読みを用いないと、"address"という名前の関数の呼び出しと間違われるかもしれない。 別の例は<code>for (: whom the bell :) $tolls in 3 return $tolls</code>である。これはキーワード "for" を関数名と間違ってはならない。</p>  </def></gitem>
<gitem id="parse-note-comments"><label>grammar-note: comments</label>
<def><p>コメントは<termref def="IgnorableWhitespace">無視可能な空白</termref>が許される場所にならどこでも許される。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comment</nt>記号は生成規則の右辺に明示的に出現はしない (それ自身の生成規則を除く)。<specref ref="DefaultWhitespaceHandling"/>を見よ。<phrase role="xquery">コメントは直接構成子の内容中には許されないが、入れ子になった<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-EnclosedExpr" xlink:type="simple">EnclosedExprs</nt>中では許されることに注意せよ。</phrase></p>
<p>コメントはコメントを入れ子で含むことができる。ただし、すべての "(:" と ":)" パターンの対応が取れている限りにおいてである。さらに外側のコメントの中で発生するかには関係しない。</p>
<note><p>字句解析では概して、入れ子のコメントを扱うのに各 "(:" パターンでカウンタを1増やし、各 ":)" パターンでカウンタを1減らすという方法を用いるかもしれない。そのコメントは、カウンタが0に戻るまでずっと終了しない。</p></note>
<p>いくつか例で説明する。</p>
<ulist>
<item><p><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code>は正しいコメントである。なぜなら対応の取れたコメントの入れ子は許されるからである。</p></item>
<item><p><code>"this is just a string :)"</code>は正しい式である。しかし、<code>(: "this is just a string :)" :)</code>は構文エラーを引き起こす。同様に<code>"this is another string (:"</code>は正しい式だが、<code>(: "this is another string (:" :)</code>は構文エラーを引き起こす。入れ子のコメントの限界として、リテラル内容により対応の取れない入れ子コメントが生じる。</p></item>
<item><p><code>for (: set up loop :) $i in $x return $i</code>は、コメントを無視すると、構文的には正しい。</p></item>
<item><p><code>5 instance (: strange place for a comment :) of xs:integer</code>もまた構文的に正しい。</p></item>
<item role="xquery"><p><code>&lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;</code> は構文的に正しくない。</p></item>
<item role="xquery"><p><code>&lt;eg&gt; (: an example:) &lt;/eg&gt;</code> は構文的には正しいが、コメントのように見える文字は実際はリテラル要素内容である。</p></item>
</ulist></def></gitem></glist></note>
</div3></div2><div2 id="lexical-structure">
<head>字句構造</head>
<p>上の文法で仮定されている終端記号を、この節で述べる。</p>
<p>生成規則中に出現する引用符つき文字列は終端記号である。</p>
<p>その他の終端記号は<specref ref="terminal-symbols"/>で定義されている。</p>

<p role="xquery"><bibref ref="XML"/>と<bibref ref="XMLNAMES"/>の構文ルールに従うか、それとも<bibref ref="XML1.1"/>と<bibref ref="XMLNAMES11"/>の構文ルールに従うかは<termref def="dt-implementation-defined">実装定義</termref>である。<bibref ref="XML1.1"/>の完全な文字集合を支援する実装は、相互互換性のために、<bibref ref="XML"/>と<bibref ref="XMLNAMES"/>の構文ルールにのみ従うモードを提供す<termref def="should">べきである</termref>。</p>
<p>トークンを切り出すときには、現在の文脈で正しい照合のうち、最長のものが使われる。</p>
<p>すべてのキーワードは大文字小文字を区別する。キーワードは予約されない。すなわち、任意のQNameはキーワードと重複してよい。ただし、<specref ref="id-reserved-fn-names"/>に述べるものを除く。</p>

<div3 id="terminal-symbols"><head>終端記号</head><scrap headstyle="show">
		    
		  <head/> 
		   <prod num="141" id="prod-xquery-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt></rhs></prod><prod num="142" id="prod-xquery-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="143" id="prod-xquery-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="144" id="prod-xquery-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"&amp;])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'&amp;])*  "'")</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="145" id="prod-xquery-PredefinedEntityRef"><lhs>PredefinedEntityRef</lhs><rhs>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="146" id="prod-xquery-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="147" id="prod-xquery-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="148" id="prod-xquery-ElementContentChar"><lhs>ElementContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - [{}&lt;&amp;]</rhs></prod><prod num="149" id="prod-xquery-QuotAttrContentChar"><lhs>QuotAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ["{}&lt;&amp;]</rhs></prod><prod num="150" id="prod-xquery-AposAttrContentChar"><lhs>AposAttrContentChar</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt> - ['{}&lt;&amp;]</rhs></prod><prod num="151" id="prod-xquery-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: comments</loc></com></prod><prod num="152" id="prod-xquery-PITarget"><lhs>PITarget</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-PITarget" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-PITarget]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="153" id="prod-xquery-CharRef"><lhs>CharRef</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-CharRef" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-CharRef]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="154" id="prod-xquery-QName"><lhs>QName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="155" id="prod-xquery-NCName"><lhs>NCName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="156" id="prod-xquery-S"><lhs>S</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="157" id="prod-xquery-Char"><lhs>Char</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod>
		</scrap>
<p>以下の記号は、終端記号の定義中でのみ用いられる。これらは<specref ref="id-grammar"/>の文法の終端記号ではない。</p><scrap headstyle="show">
		    
		  <head/> 
		   <prod num="158" id="prod-xquery-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="159" id="prod-xquery-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod>
		</scrap></div3>
<div3 id="id-terminal-delimitation"><head>終端記号の区切り</head>

<p role="xquery">XQuery 1.0 の式は<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#terminal-symbols" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">終端記号</loc>と<termref def="symbolseparators">記号区切り</termref>からなる。</p>
<p>終端記号には2種類ある。区切り終端記号と非区切り終端記号である。</p>

<p role="xquery"><termdef id="delimiting-token" term="delimiting terminal symbol"><term>区切り終端記号</term>は: "=", ";", ",", "$", ":=", "(", ")", "!=", "&lt;=", "&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?", "-", "+", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PredefinedEntityRef" xlink:type="simple">PredefinedEntityRef</nt>, "{", "}", "{{", "}}", "&lt;", """, "'", "/&gt;", "&lt;/", "(#", "#)", "&lt;?", "?&gt;", "&lt;![CDATA[", "]]&gt;", "&lt;!--", "--&gt;", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Comment" xlink:type="simple">Comment</nt>, "/", "//", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-CharRef" xlink:type="simple">CharRef</nt>, ":", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-S" xlink:type="simple">S</nt></termdef>  </p>

<p role="xquery"><termdef id="non-delimiting-token" term="non-delimiting terminal symbol"><term>非区切り終端記号</term>は:  "xquery", "version", "encoding", "module", "namespace", "declare", "boundary-space", "preserve", "strip", "default", "element", "function", "option", "ordering", "ordered", "unordered", "order", "empty", "copy-namespaces", "no-preserve", "inherit", "no-inherit", "collation", "base-uri", "import", "schema", "at", "variable", "construction", "as", "return", "for", "in", "let", "where", "by", "stable", "some", "every", "satisfies", "typeswitch", "case", "if", "then", "else", "eq", "ne", "lt", "le", "gt", "ge", "is", "validate", "lax", "strict", "child", "descendant", "attribute", "self", "descendant-or-self", "following-sibling", "following", "parent", "ancestor", "preceding-sibling", "preceding", "ancestor-or-self", "document", "text", "comment", "processing-instruction", "empty-sequence", "item", "node", "document-node", "schema-attribute", "schema-element", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-StringLiteral" xlink:type="simple">StringLiteral</nt>, "external", "ascending", "descending", "greatest", "least", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeQuot" xlink:type="simple">EscapeQuot</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-EscapeApos" xlink:type="simple">EscapeApos</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-ElementContentChar" xlink:type="simple">ElementContentChar</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QuotAttrContentChar" xlink:type="simple">QuotAttrContentChar</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-AposAttrContentChar" xlink:type="simple">AposAttrContentChar</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-PITarget" xlink:type="simple">PITarget</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-QName" xlink:type="simple">QName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-NCName" xlink:type="simple">NCName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Char" xlink:type="simple">Char</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xquery-Digits" xlink:type="simple">Digits</nt></termdef>  </p>
<p><termdef id="symbolseparators" term="symbol separators"><term>記号区切り</term>としての<termref def="Whitespace">空白</termref>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comments</nt>関数。多くの場合、これらは文法中では述べられておらず、文法中に述べられている2つの終端記号の間に出現してもよい。ただし<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc>という備考や、<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* xgs: xml-version */</loc>という備考で禁止されている場所を除く。</termdef></p>
<p>通例として、連続した終端記号は<termref def="Whitespace">空白</termref>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comments</nt>で区切る。しかし、このことが要求されるのは、そうしなければ2つの非区切り終端記号が互いに隣接してしまう場合のみである。この例外が2つある。"." と "-" がQNameやNCNameに続くならば、その間に<termref def="symbolseparators">記号区切り</termref>が必要である。</p></div3>
<div3 id="id-eol-handling"><head>行末処理</head>
<p>XQuery処理器は、入力中にあるすべての行末を、構文解析前に正規化するように振る舞わなければならない。正規化は、<bibref ref="XML"/>か<bibref ref="XML1.1"/>かいずれの字句処理を支援すると選択するかに従って行われるべきである。</p>
<div4 id="id-xml10-eol-handling"><head>XML 1.0の行末処理</head>
<p><bibref ref="XML"/>の処理では、以下のすべてが単一の文字 #xA に変換されなければならない。</p>
<olist>
<item><p>2文字の列 #xD #xA</p></item>
<item><p>#xA の直後に続かない #xD 文字</p></item>
</olist></div4>
<div4 id="id-xml11-eol-handling"><head>XML 1.1の行末処理</head>
<p><bibref ref="XML1.1"/>の処理では、以下のすべてが単一の文字 #xA に変換されなければならない。</p>
<olist>
<item><p>2文字の列 #xD #xA</p></item>
<item><p>2文字の列 #xD #x85</p></item>
<item><p>単一の文字 #x85</p></item>
<item><p>単一の文字 #x2028</p></item>
<item><p>#xA または #x85 の直後に続かない #xD 文字</p></item>
</olist>
<p role="xquery">文字 #x85 と #x2028 は、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-VersionDecl" xlink:type="simple">VersionDecl</nt> 宣言が (もしあれば) 読まれるまで、信頼をもって認識したり翻訳したりすることはできない。</p>
</div4></div3>
<div3 id="whitespace-rules"><head>空白規則</head>
<div4 id="DefaultWhitespaceHandling"><head>デフォルト空白処理</head>
<p><termdef id="Whitespace" term="whitespace"><term>空白</term>文字は、<xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml#NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>で定義される任意の文字である。</termdef></p>
<p>  <termdef term="ignorable whitespace" id="IgnorableWhitespace"><term>無視可能な空白</term>は、<termref def="Whitespace">空白</termref>文字のうち<termref def="terminal">終端記号</termref>の間に出現してもよいものである。ただし、これらの文字が<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ExplicitWhitespaceHandling" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws:explicit</loc>という備考で目印づけされた生成規則の文脈に出現する場合を除く。この場合、これらの文字は明示的に指定された場所にしか出現できない (<specref ref="ExplicitWhitespaceHandling"/>を見よ)。</termdef>  無視可能な空白文字は、式の意味には影響しない。空白は、モジュールの最初の終端記号の前や、最後の終端記号の後ろにも許される。空白は、任意の2つの<termref def="terminal">終端記号</termref>の間に許される。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comments</nt>もまた "空白" として振舞い、2つの隣接した終端記号を1つだと認識されることを防いでもよい。いくつか例で説明する。</p>
<ulist>
<item><p><code>foo- foo</code>は構文エラーになる。"foo-" が QName として認識される。</p></item>
<item><p><code>foo -foo</code>は構文的には<code>foo - foo</code>、すなわち減算演算子によって区切られた2つのQNameと同値である。</p></item>
<item><p><code>foo(: This is a comment :)- foo</code>は構文的には<code>foo - foo</code>と等価である。これは、コメントによって、2つの隣接した終端記号が1つのものとして認識されるのが防がれているからである。</p></item>
<item><p><code>foo-foo</code>は構文的には1つのQNameと等価である。これは、"-" がQName中の正しい文字だからである。名前の文字の後ろで演算子として使うときには、"-" は、例えば空白や括弧によって、名前から区切らなければならない。</p></item>
<item><p><code>10div 3</code>は構文エラーになる。</p></item>
<item><p><code>10 div3</code>もまた構文エラーになる。</p></item>
<item><p><code>10div3</code>もまた構文エラーになる。</p></item></ulist></div4>
<div4 id="ExplicitWhitespaceHandling"><head>明示的空白処理</head>
<p>EBNFの生成規則では、空白処理がデフォルトルールと異なる場合、以下に示す記述で明示的空白処理を指定する。この記述は継承されない。言い換えると、EBNFルールが /* ws: explicit */ と目印付けされているならば、この記述は、そのルールの '子' の EBNF 生成規則いずれにも自動的には適用されない。</p>
<glist><gitem id="ws-explicit"><label>ws: explicit</label><def><p>/* ws: explicit */ は、EBNF記述で、<code>S</code>もしくは他の方法により、<termref def="Whitespace">空白文字</termref>の許される場所が明示的に記述されていることを意味している。備考 /* ws: explicit */ を持つ生成規則では、<specref ref="DefaultWhitespaceHandling"/>は適用されない。<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Comment" xlink:type="simple">Comments</nt>もまたこれらの生成規則中では許されない。</p></def></gitem>

</glist>
<p role="xquery" id="ws-explicit-lex-states">例えば、直接構成子の生成規則では空白は自由に許されることはないが、文法中では明示的に指定されている。これは XML との一貫性を高めるためである。</p>
</div4></div3></div2>

<div2 id="id-reserved-fn-names"><head>予約済関数名</head>
<p>以下の名前は、接頭辞のない形式の関数名としては許されない。なぜなら、式の構文のほうが優先するからである。</p>
<ulist>
<item><p><code>attribute</code></p></item>
<item><p><code>comment</code></p></item>
<item><p><code>document-node</code></p></item>
<item><p><code>element</code></p></item>


<item><p><code>empty-sequence</code></p></item><item><p><code>if</code></p></item>
<item><p><code>item</code></p></item>

<item><p><code>node</code></p></item>
<item><p><code>processing-instruction</code></p></item>
<item><p><code>schema-attribute</code></p></item><item><p><code>schema-element</code></p></item><item><p><code>text</code></p></item>
<item><p><code>typeswitch</code></p>
</item>
</ulist>
</div2>
<div2 id="id-precedence-order"><head>優先順位</head>
<p><specref ref="id-grammar"/>中の文法では、XQueryの演算子の間の組み込み優先順位を規定として定義している。これらの演算子をここでまとめ、優先度を低い順から高い順に明らかにする。より低い優先度順位を持つ演算子を、より高い優先度順位を持つ演算子が含むことはできない。結合性の欄は、式中で同じ優先度を持つ演算子が適用される順番を表している。</p>
  <table border="1">
  <tbody>
  
  <tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">演算子</th><th rowspan="1" colspan="1"> 	

結合性</th></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">, (コンマ)</td><td rowspan="1" colspan="1">左から右</td></tr><tr role="xquery"><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">:= (代入)</td><td rowspan="1" colspan="1">右から左</td></tr><tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1"><phrase role="xquery"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-FLWORExpr" xlink:type="simple">for</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-QuantifiedExpr" xlink:type="simple">some, every</nt>, <phrase role="xquery"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TypeswitchExpr" xlink:type="simple">typeswitch</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IfExpr" xlink:type="simple">if</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OrExpr" xlink:type="simple">or</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AndExpr" xlink:type="simple">and</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  
  
  
  
  <tr><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ValueComp" xlink:type="simple">eq, ne, lt, le, gt, ge</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-GeneralComp" xlink:type="simple">=, !=, &lt;, &lt;=, &gt;, &gt;=</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeComp" xlink:type="simple">is</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-NodeComp" xlink:type="simple">&lt;&lt;, &gt;&gt;</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-RangeExpr" xlink:type="simple">to</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AdditiveExpr" xlink:type="simple">+, -</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-MultiplicativeExpr" xlink:type="simple">*, div, idiv, mod</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  
  <tr><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnionExpr" xlink:type="simple">union, |</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-IntersectExceptExpr" xlink:type="simple">intersect, except</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-InstanceofExpr" xlink:type="simple">instance of</nt> </td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">13</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-TreatExpr" xlink:type="simple">treat</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastableExpr" xlink:type="simple">castable</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-CastExpr" xlink:type="simple">cast</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-UnaryExpr" xlink:type="simple"> -(unary),  +(unary)</nt></td><td rowspan="1" colspan="1">右から左</td></tr><tr><td rowspan="1" colspan="1">17</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-OccurrenceIndicator" xlink:type="simple">?, *(OccurrenceIndicator), +(OccurrenceIndicator)</nt></td><td rowspan="1" colspan="1">左から右</td></tr><tr><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-PathExpr" xlink:type="simple">/, //</nt></td><td rowspan="1" colspan="1">左から右</td></tr>
  <tr><td rowspan="1" colspan="1">19</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-Predicate" xlink:type="simple">[ ]</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ParenthesizedExpr" xlink:type="simple">( )</nt>, {}</td><td rowspan="1" colspan="1">左から右</td></tr>
  </tbody>
  </table>
  </div2>
			

</div1>


<div1 id="id-type-promotion-and-operator-mapping">
<head>型の昇格と演算子の写像</head>
<div2 id="promotion">
<head>型の昇格</head>

<p><termdef term="type promotion" id="dt-type-promotion">ある条件の下で、原子値をある型から別の型に昇格させることができる。数や文字列を演算数として許す関数呼び出し (<specref ref="id-function-calls"/>を見よ)<phrase role="xquery">, <code>order by</code> 節 (<specref ref="id-orderby-return"/>を見よ)</phrase>や演算子の評価 (<specref ref="mapping"/>を見よ)のときに、<term>型の昇格</term>が用いられる。</termdef> 以下のような型の昇格が許されている。</p>

<olist><item><p>数型の昇格:</p>
<olist><item><p><code>xs:float</code>型 (もしくは<code>xs:float</code>型から制限によって導出される任意の型) の値は<code>xs:double</code>型に昇格させることができる。結果は、元の値と等しい<code>xs:double</code>の値である。</p></item>

<item><p><code>xs:decimal</code>型 (もしくは<code>xs:decimal</code>から制限によって導出される任意の型) の値は、<code>xs:float</code>型、もしくは<code>xs:double</code>型のいずれかに昇格させることができる。この昇格の結果は、元の値を要求された型に型変換することで生成される。この種の昇格は、正確さを損なうことを引き起こすかもしれない。</p></item></olist></item>
<item><p>URI型の昇格: <code>xs:anyURI</code>型 (もしくは<code>xs:anyURI</code>から制限によって導出される任意の型) の値は、<code>xs:string</code>型に昇格させることができる。この昇格の結果は、元の値を<code>xs:string</code>型に型変換することで生成される。</p>
<note><p><code>xs:anyURI</code>の値は<code>xs:string</code>に昇格させることができるので、<termref def="dt-def-collation">デフォルト照合順序</termref>を用いて文字列を比較する関数や演算子は、<termref def="dt-def-collation">デフォルト照合順序</termref>を用いて<code>xs:anyURI</code>の値も比較する。このことにより、文字列や<code>xs:anyURI</code>の値、またはこれら2つの型の組み合わせを含む順序は、一定でかつはっきり定義されることが保証される。</p></note></item>


</olist>
<p><termref def="dt-type-promotion">型の昇格</termref>は<termref def="dt-subtype-substitution">部分型置換</termref>とは異なることに注意すること。例えば:</p>
<ulist><item><p><code>xs:float</code>型の引数<code>$p</code>を期待する関数は、<code>xs:decimal</code>型の値を与えて呼び出すことができる。これは<termref def="dt-type-promotion">型の昇格</termref>の例である。この値は期待される型に実際に変換される。関数の本体の内部では、<code>$p instance of xs:decimal</code>は<code>false</code>を返す。</p></item>
<item><p><code>xs:decimal</code>型の引数<code>$p</code>を期待する関数は、<code>xs:integer</code>型の値を与えて呼び出すことができる。これは<termref def="dt-subtype-substitution">部分型置換</termref>の例である。この値は元の型のまま残されている。関数の本体の内部では、<code>$p instance of xs:integer</code>は<code>true</code>を返す。</p></item></ulist></div2>

<div2 id="mapping">
<head>演算子の写像</head>
<p>この節の演算子の写像表は、さまざまなXQueryの演算子に対して定義される方の組み合わせを列挙する。<termdef term="operator function" id="dt-operator-function">各演算子、および演算数の型の正しい組み合わせに対して、演算子の写像表は、結果の型と<term>演算子関数</term>を指定する。この関数は、与えられた型に対する演算子の意味を実装する。</termdef> 演算子関数の定義は<bibref ref="FunctionsAndOperators"/>で与えられている。演算子の結果、その演算子関数によってエラーが発生してもよい。これに関する定義は<bibref ref="FunctionsAndOperators"/>にある。ある場合には、演算子関数は与えられた演算子の完全な意味を実装しない。各演算子の定義 (空列や長さが1より大きい列に対する振舞いを含む) については、この文書の主部分中の記述を見よ。</p>
<p><code>and</code>や<code>or</code>演算子は、この文書の主部分に直接定義されており、演算子の写像表には出現していない。</p>
<p>演算子の写像表中の演算子が型 <emph>ET</emph> の演算数を要求するとき、<termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって型 <emph>AT</emph> が型 <emph>ET</emph> に変換されるならば、その演算子は型 <emph>AT</emph> の演算数に適用することができる。
例えば、表のエントリに<code>gt</code>演算子を2つの<code>xs:date</code>演算数に適用してよく、そのとき<code>xs:boolean</code>を返すと示しているものがある。したがって、<code>gt</code>演算子は2つの<code>xs:date</code>の部分型 (これらは異なることもある) に適用してもよく、この場合も<code>xs:boolean</code>を返す。</p>
<p><termdef id="dt-numeric" term="numeric">型を参照するとき、<term>数</term>という用語は<code>xs:integer</code>型, <code>xs:decimal</code>型,
<code>xs:float</code>型, <code>xs:double</code>型を表す。</termdef> 演算数と結果が<termref def="dt-numeric">数</termref>と指定されている演算子は、4つの演算子、すなわち数型それぞれに対し1つの演算子を表していると考えられる。例えば、数型の<code>+</code>演算子は、以下の4つの演算子を表していると考えられる:</p>

<table width="80%" border="1" summary="Operators"><tbody><tr><td align="center" rowspan="1" colspan="1">演算子</td><td align="center" rowspan="1" colspan="1">第1演算数の型</td><td align="center" rowspan="1" colspan="1">第2演算数の型</td><td align="center" rowspan="1" colspan="1">結果の型</td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td></tr></tbody></table>
<p><termref def="dt-type-promotion">型の昇格</termref>や<termref def="dt-subtype-substitution">部分型置換</termref>によって型 <emph>AT</emph> が4つの数型のいずれかに変換可能であれば、
数演算子は型<emph>AT</emph>の演算数に正しく適用してよい。演算子の結果の型が数と列挙されていれば、その意味は "順序リスト <code>(xs:integer, xs:decimal, xs:float, xs:double)</code>のうち、すべての演算数が<termref def="dt-subtype-substitution">部分型置換</termref>や<termref def="dt-type-promotion">型の昇格</termref>により変換することのできる型の最初のもの" である。例として、型<code>hatsize</code>が<code>xs:integer</code>から導出されており、型<code>shoesize</code>が<code>xs:float</code>から導出されているとしよう。このとき、<code>+</code>演算子が、型<code>hatsize</code>と<code>shoesize</code>の演算数を伴って実行されるならば, 型<code>xs:float</code>の結果を返す。同様に、<code>+</code>が型<code>hatsize</code>の2つの演算数を伴って実行されるならば、型<code>xs:integer</code>の結果を返す。</p>
<p><termdef id="dt-gregorian" term="Gregorian">演算子の写像表で、<term>Gregorian</term>という用語は、<code>xs:gYearMonth</code>型, <code>xs:gYear</code>型,
<code>xs:gMonthDay</code>型, <code>xs:gDay</code>型, 
<code>xs:gMonth</code>型を表す。</termdef>  2つのGregorian型の演算数を取ることのできる2項演算子について、演算数はともに同じ型でなければならない。 (例えば、1つの演算数が<code>xs:gDay</code>型であれば、もう一方の演算数も<code>xs:gDay</code>でなければならない。)</p>

<table border="1" summary="Binary operators" role="small">
<caption>2項演算子</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">演算子</th>
<th rowspan="1" colspan="1">型(A)</th>
<th rowspan="1" colspan="1">型(B)</th>
<th rowspan="1" colspan="1">関数</th>
<th rowspan="1" colspan="1">結果の型</th>
</tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-add(A, B)</td><td rowspan="1" colspan="1">数</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td><td rowspan="1" colspan="1">数</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:subtract-dates(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:subtract-times(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:subtract-dateTimes(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td><td rowspan="1" colspan="1">数</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A idiv B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-integer-divide(A, B)</td><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-divide(A, B)</td><td rowspan="1" colspan="1">数; ただし、演算数がともに xs:integer であれば xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr>
<tr><td rowspan="1" colspan="1">A mod B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-mod(A, B)</td><td rowspan="1" colspan="1">数</td></tr>

<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">op:duration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hex-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">op:QName-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">fn:not(op:duration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hex-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:datetime-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:datetime-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A is B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:is-same-node(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>


<tr><td rowspan="1" colspan="1">A &lt;&lt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-before(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A &gt;&gt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-after(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>



<tr><td rowspan="1" colspan="1">A union B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A | B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A intersect B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:intersect(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A except B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:except(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>

<tr><td rowspan="1" colspan="1">A to B</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">op:to(A, B)</td><td rowspan="1" colspan="1">xs:integer*</td></tr>
<tr><td rowspan="1" colspan="1">A , B</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">op:concatenate(A, B)</td><td rowspan="1" colspan="1">item()*</td></tr>

</tbody>
</table>

<table border="1" summary="Unary operators" role="small">
<caption>単項演算子</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">演算子</th>
<th rowspan="1" colspan="1">演算数の型</th>
<th rowspan="1" colspan="1">関数</th>
<th rowspan="1" colspan="1">結果の型</th>
</tr>
<tr><td rowspan="1" colspan="1">+ A</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td><td rowspan="1" colspan="1">数</td></tr>
<tr><td rowspan="1" colspan="1">- A</td><td rowspan="1" colspan="1">数</td><td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td><td rowspan="1" colspan="1">数</td></tr>
</tbody>
</table>


</div2>
</div1>


<div1 role="xquery" id="id-xq-context-components"><head>文脈の構成要素</head>
<p>この節の表は、静的文脈や動的文脈のさまざまな構成要素や、直列化処理を制御するパラメータにどのようにして値が割り当てられるかを記述する。</p>

<div2 id="id-xq-static-context-components"><head>静的文脈の構成要素</head>
<p>以下の表は<term>静的文脈</term>の構成要素について記述している。各構成要素について、以下の面が記述されている:</p>
<ulist>
<item><p><emph>デフォルト初期値:</emph> これは構成要素の初期値である。ただし、実装や問合せによって上書きされたり拡張されたりしない場合に限る。</p> </item>
<item><p><emph>実装によって上書きしたり拡張したりできるかどうか:</emph> XQuery 実装が、その構成要素のデフォルト初期値を異なる<termref def="dt-implementation-defined">実装定義</termref>の値で置き換えたり、デフォルト初期値を追加の<termref def="dt-implementation-defined">実装定義</termref>の値によって拡張したりすることが許されるかどうかを示す。</p></item>
<item><p><emph>問合せによって上書きしたり拡張したりできるかどうか:</emph> 問合せが、デフォルトや実装によって用意される初期値を置き換えたり拡張したりすることを許すかどうかを示す。もし許されるならば、これがどのようにして成し遂げられるか (例えば、前書き中での宣言によって) を示す。</p></item>
<item><p><emph>有効範囲:</emph> その構成要素がどこで使用できるかを示す。"大域" (Global) は、その構成要素が大域的、すなわち問合せ中で用いられるすべてのモジュールを通して使用できることを示す。"モジュール" (Module) は、その構成要素が一つの<termref def="dt-module">モジュール</termref>を通して使用できることを示す。"構文" (Lexical) は、その構成要素が、それが定義されている式の中で使用できることを示す (その構成要素が<termref def="dt-prolog">前書き</termref>中で宣言されていれば、"モジュール" と等しい)。</p></item>
<item><p><emph>整合性ルール:</emph> 構成要素中の値を割り当てるときに従わなければならないルールを示す。これ以外の整合性ルールは<specref ref="id-consistency-constraints"/>にあるかもしれない。</p></item></ulist>
<table width="100%" border="1" summary="Static Context" role="small">
<caption>静的文脈の構成要素</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">構成要素</th>
<th rowspan="1" colspan="1">デフォルト初期値</th>
<th rowspan="1" colspan="1">実装によって上書きしたり拡張したりできるか?</th>
<th rowspan="1" colspan="1">問合せによって上書きしたり拡張したりできるか?</th>
<th rowspan="1" colspan="1">有効範囲</th>
<th rowspan="1" colspan="1">整合性ルール</th>
</tr>
<tr>
<td rowspan="1" colspan="1">XPath 1.0 互換性モード</td>
<td rowspan="1" colspan="1"><code>false</code></td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1"><code>false</code> でなければならない。</td>
</tr><tr>
<td rowspan="1" colspan="1">静的既知名前空間</td>
<td rowspan="1" colspan="1"><code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>, <code>xdt</code>, <code>local</code></td>
<td rowspan="1" colspan="1">上書き可能・拡張可能 (<code>xml</code> を除く)</td>
<td rowspan="1" colspan="1">前書きまたは要素構成子によって上書き可能・拡張可能</td>
<td rowspan="1" colspan="1">構文</td>
<td rowspan="1" colspan="1">1つの名前空間は、構文の有効範囲ごとに、接頭辞1つに割り当てることができる。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">デフォルト要素/型名前空間</td>
<td rowspan="1" colspan="1">名前空間なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きまたは要素構成子によって上書き可能</td>
<td rowspan="1" colspan="1">構文</td>
<td rowspan="1" colspan="1">構文の有効範囲ごとに1つのデフォルト名前空間だけ。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">デフォルト関数名前空間</td>
<td rowspan="1" colspan="1"><code>fn</code></td>
<td rowspan="1" colspan="1">上書き可能 (推奨されない)</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">なし。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">有効範囲内スキーマ型</td>
<td rowspan="1" colspan="1"><code>xs</code> 内の組み込み型</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">スキーマ輸入や前書きによって拡張可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">大域型または局所型ごとに1つの定義のみ。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">有効範囲内要素宣言</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">スキーマ輸入や前書きによって拡張可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">大域要素名や局所要素名ごとに1つの定義のみ。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">有効範囲内属性宣言</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">スキーマ輸入や前書きによって拡張可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">大域属性名や局所属性名ごとに1つの定義のみ。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">有効範囲内変数</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">前書きや変数束縛式により上書き可能・拡張可能</td>
<td rowspan="1" colspan="1">構文</td>
<td rowspan="1" colspan="1">構文の有効範囲ごとに1つの定義のみ。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">文脈項目の静的型</td>
<td rowspan="1" colspan="1"><code>none</code> (アクセスがあるとエラーを発生)</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">明示的には不可。しかし式によって影響を受ける可能性はある</td>
<td rowspan="1" colspan="1">構文</td>
<td rowspan="1" colspan="1">なし。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">関数シグネチャ</td>
<td rowspan="1" colspan="1">名前空間 <code>fn</code> 中の関数、および組み込みの基本型に対する構成子</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">モジュール輸入や、前書き中での関数宣言によって拡張可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">関数はそれぞれ一意の展開済 QName と引数の数とを持っていなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">静的既知照合順序</td>
<td rowspan="1" colspan="1">デフォルト照合順序のみ</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">各 URI は1つの照合順序を一意に識別する。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">デフォルト照合順序</td>
<td rowspan="1" colspan="1">Unicode コードポイント照合順序</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">なし。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">構成モード</td>
<td rowspan="1" colspan="1"><code>preserve</code></td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">値は <code>preserve</code> か <code>strip</code> でなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">順序付けモード</td>
<td rowspan="1" colspan="1"><code>ordered</code></td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きや式によって上書き可能</td>
<td rowspan="1" colspan="1">構文</td>
<td rowspan="1" colspan="1">値は <code>ordered</code> か <code>unordered</code> でなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">空列に対するデフォルト順序</td>
<td rowspan="1" colspan="1">実装定義</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">値は <code>greatest</code> か <code>least</code> でなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">境界空白ポリシー</td>
<td rowspan="1" colspan="1"><code>strip</code></td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">値は <code>preserve</code> か <code>strip</code> でなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">名前空間複製モード</td>
<td rowspan="1" colspan="1"><code>inherit, preserve</code></td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">値は <code>inherit</code> か <code>no-inherit</code>、そして <code>preserve</code> か <code>no-preserve</code> から構成される。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">基礎 URI</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">前書きによって上書き可能</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">値は xs:anyURI 型の正しい構文式でなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">静的既知文書</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">なし。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">静的既知コレクション</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">なし。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">静的既知デフォルトコレクション型</td>
<td rowspan="1" colspan="1"><code>node()*</code></td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">モジュール</td>
<td rowspan="1" colspan="1">なし。</td></tr>
</tbody>
</table></div2>
<div2 id="id-xq-evaluation-context-components">
<head>動的文脈の構成要素</head>
<p>以下の表は<term>動的文脈</term>の構成要素を記述している。各構成要素について、以下の面を記述している:</p>
<ulist>
<item><p><emph>デフォルト初期値:</emph> これは構成要素の初期値である。ただし、実装や問合せによって上書きされたり拡張されたりしない場合に限る。</p> </item>
<item><p><emph>実装によって上書きしたり拡張したりできるか:</emph> XQuery の実装が、その構成要素のデフォルト初期値を異なる<termref def="dt-implementation-defined">実装定義</termref>の値で置き換えたり、<termref def="dt-implementation-defined">実装定義</termref>の値を追加して拡張したりすることが許されるかを示す。</p></item>
<item><p><emph>問合せによって上書きしたり拡張したりできるか:</emph> 問合せが、デフォルトや実装によって提供された初期値を置き換えたり拡張したりすることが許されるかを示す。もし許されるなら、これがどのように成し遂げられるかを示す。</p></item>
<item><p><emph>有効範囲:</emph> その構成要素がどこで使用可能かを示す。"大域" は構成要素が大域的、すなわち問合せで用いられるすべてのモジュールで使用可能であり、問合せを評価する間、定数のままであることを表す。"動的" は、式の評価によって、その式や入れ子の式に対する構成要素の値が影響を受けるかもしれない、ということを表す。</p></item>
<item><p><emph>整合性ルール:</emph> 値を構成要素に割り当てるときに従わなければならないルールを示す。これ以外の整合性ルールが<specref ref="id-consistency-constraints"/>にあるかもしれない。</p></item></ulist>
<table width="100%" border="1" summary="Static Context" role="small">
<caption>動的文脈の構成要素</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">構成要素</th>
<th rowspan="1" colspan="1">デフォルト初期値</th>
<th rowspan="1" colspan="1">実装によって上書きしたり拡張したりできるか?</th>
<th rowspan="1" colspan="1">問合せによって上書きしたり拡張したりできるか?</th>
<th rowspan="1" colspan="1">有効範囲</th>
<th rowspan="1" colspan="1">整合性ルール</th>
</tr>
<tr>
<td rowspan="1" colspan="1">文脈項目</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">経路式や述語の評価の間上書きされる</td>
<td rowspan="1" colspan="1">動的</td>
<td rowspan="1" colspan="1">なし</td>
</tr><tr>
<td rowspan="1" colspan="1">文脈位置</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">経路式や述語の評価の間上書きされる</td>
<td rowspan="1" colspan="1">動的</td>
<td rowspan="1" colspan="1">文脈項目が定義されていれば、文脈位置は &gt;0 かつ &lt;= 文脈サイズでなければならない。そうでない場合は、文脈位置は未定義である。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">文脈サイズ</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">経路式や述語の評価の間上書きされる</td>
<td rowspan="1" colspan="1">動的</td>
<td rowspan="1" colspan="1">文脈項目が定義されていれば、文脈サイズは &gt;0 でなければならない。そうでない場合は文脈サイズは未定義である。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">変数の値</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">前書きや変数束縛式によって上書き可能・拡張可能</td>
<td rowspan="1" colspan="1">動的</td>
<td rowspan="1" colspan="1">名前と値が有効範囲内変数と整合していなければならない。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">関数の実装</td>
<td rowspan="1" colspan="1">名前空間 <code>fn</code> 中の関数、および組み込み原子型に対する構成子</td>
<td rowspan="1" colspan="1">拡張可能</td>
<td rowspan="1" colspan="1">モジュール輸入や、前書き中の関数宣言によって拡張可能</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">関数シグネチャと整合していなければならない</td>
</tr>
<tr>
<td rowspan="1" colspan="1">現在の dateTime</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">実装によって初期化されなければならない</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">タイムゾーンを含んでいなければならない。問合せの評価の間定数のままである。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">暗黙的タイムゾーン</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">実装によって初期化されなければならない</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">問合せの評価の間定数のままである。</td>
</tr>
<tr>
<td rowspan="1" colspan="1">使用可能文書</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">実装によって初期化されなければならない</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">なし</td>
</tr>
<tr>
<td rowspan="1" colspan="1">使用可能コレクション</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">実装によって初期化されなければならない</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">なし</td>
</tr>
<tr>
<td rowspan="1" colspan="1">デフォルトコレクション</td>
<td rowspan="1" colspan="1">なし</td>
<td rowspan="1" colspan="1">上書き可能</td>
<td rowspan="1" colspan="1">不可</td>
<td rowspan="1" colspan="1">大域</td>
<td rowspan="1" colspan="1">なし</td></tr>
</tbody>
</table></div2>
<div2 id="id-xq-serialization-parameters">
<head>直列化パラメータ</head>
<p>以下の表は、<termref def="dt-data-model-instance">XDM インスタンス</termref>を XML 表記 (<code>method = "xml"</code>) に直列化する処理を制御するパラメータのデフォルト値を指定する。さまざまなパラメータの意味は<bibref ref="serialization"/>で定義されている。各パラメータについて、XQuery の実装は、ユーザがデフォルト値を上書きできる方法を提供してもよい (が要求はされない)。</p>
<table border="1" width="60%" summary="Unary operators" role="small">
<caption>直列化パラメータ</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">パラメータ</th>
<th rowspan="1" colspan="1">デフォルト値</th>
</tr>
<tr><td rowspan="1" colspan="1">byte-order-mark</td>
<td rowspan="1" colspan="1">実装定義</td>
</tr>
<tr>
<td rowspan="1" colspan="1">cdata-section-elements</td>
<td rowspan="1" colspan="1">empty</td>
</tr>
<tr>
<td rowspan="1" colspan="1">doctype-public</td>
<td rowspan="1" colspan="1">(なし)</td>
</tr>
<tr>
<td rowspan="1" colspan="1">doctype-system</td>
<td rowspan="1" colspan="1">(なし)</td>
</tr>
<tr>
<td rowspan="1" colspan="1">encoding</td>
<td rowspan="1" colspan="1">"utf-8" もしくは "utf-16" の間で実装定義の選択</td>
</tr>
<tr>
<td rowspan="1" colspan="1">escape-uri-attributes</td>
<td rowspan="1" colspan="1">(method = xml の場合使用できない)</td>
</tr>
<tr>
<td rowspan="1" colspan="1">include-content-type</td>
<td rowspan="1" colspan="1">(method = xml の場合使用できない)</td>
</tr>
<tr>
<td rowspan="1" colspan="1">indent</td>
<td rowspan="1" colspan="1">no</td>
</tr>
<tr>
<td rowspan="1" colspan="1">media-type</td>
<td rowspan="1" colspan="1">実装定義</td>
</tr>
<tr>
<td rowspan="1" colspan="1">method</td>
<td rowspan="1" colspan="1">xml</td>
</tr>
<tr>
<td rowspan="1" colspan="1">normalization-form</td>
<td rowspan="1" colspan="1">実装定義</td>
</tr>
<tr>
<td rowspan="1" colspan="1">omit-xml-declaration</td>
<td rowspan="1" colspan="1">実装定義</td>
</tr>
<tr>
<td rowspan="1" colspan="1">standalone</td>
<td rowspan="1" colspan="1">実装定義</td>
</tr>
<tr>
<td rowspan="1" colspan="1">undeclare-prefixes</td>
<td rowspan="1" colspan="1">no</td>
</tr>
<tr>
<td rowspan="1" colspan="1">use-character-maps</td>
<td rowspan="1" colspan="1">empty</td>
</tr>
<tr>
<td rowspan="1" colspan="1">version</td>
<td rowspan="1" colspan="1">実装定義</td></tr>
</tbody>
</table></div2></div1>
<div1 id="id-impl-defined-items"><head>実装定義の項目</head>
<p>この仕様中の以下の項目は<termref def="dt-implementation-defined">実装定義</termref>である:</p>
<olist>
<item><p>式を構成するUnicodeの版</p></item>
<item><p><termref def="dt-static-collations">静的既知照合順序</termref></p></item>
<item><p><termref def="dt-timezone">暗黙的タイムゾーン</termref></p></item>
<item><p><termref def="dt-warning">警告</termref>が発生する状況、および警告が処理される方法</p></item>
<item><p>エラーが外部処理環境に通知される方法</p></item>
<item><p>実装が<bibref ref="XML"/>や<bibref ref="XMLNAMES"/>のルール、<bibref ref="XML1.1"/>や<bibref ref="XMLNAMES11"/>のルールのいずれに基づいているか。これらのルール集合のうち1つが、実装のすべての局面で常に適用されなければならない。</p></item>

<item role="xquery"><p><termref def="dt-static-context">静的文脈</termref>または<termref def="dt-dynamic-context">動的文脈</termref>の構成要素のうち、実装によって上書きされたり拡張されたりするもの。</p></item>

<item role="xquery"><p><code>order by</code> 節中の順序付けキー (sortspec) によて返される空列のデフォルト処理方法 (<code>empty least</code> または <code>empty greatest</code>)。</p></item>
<item role="xquery"><p>実装によって認識される<termref def="dt-extension-expression">拡張式</termref> (<termref def="dt-pragma">pragmas</termref>) の名前と意味。</p></item>
<item role="xquery"><p>実装によって認識される<termref def="dt-option-declaration">オプション宣言</termref>の名前と意味。</p></item>
<item role="xquery"><p>パラメータを (もしあれば) 外部関数に渡し、関数の結果を呼び出し元の問合せに返すためのプロトコル。</p></item>
<item role="xquery"><p><termref def="dt-module-import">モジュール輸入</termref>によって輸入されると指定されたモジュールを認識する処理方法。ただし<termref def="dt-module-feature">モジュール機能</termref>を支援している場合に限る (場所のヒントがあるならば、その処理を含む)。</p></item>
<item role="xquery"><p>実装によって支援される<termref def="dt-static-typing-extension">静的型付け拡張</termref>。ただし<termref def="dt-static-typing-feature">静的型付け機能</termref>を支援している場合に限る。</p></item>
<item role="xquery"> <p>直列化が呼び出される方法。ただし<termref def="dt-serialization-feature">直列化機能</termref>を支援している場合に限る。</p></item>
<item role="xquery"><p><code>byte-order-mark</code>, <code>encoding</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, および <code>version</code> の各パラメータのデフォルト値。ただし<termref def="dt-serialization-feature">直列化機能</termref>を支援している場合に限る。</p></item>
<item role="xquery"><p>外部関数の呼び出しが成功しなかった場合の結果 (例えば、関数の実装が見つからない場合や宣言された型の値を返さなかった場合など)。</p></item>
<item role="xquery"><p>さまざまなデータ型の値の限度や範囲。これについては<specref ref="id-data-model-conformance"/>に列挙されている通り。</p></item>
</olist><note><p>追加の<termref def="dt-implementation-defined">実装定義</termref>の項目が<bibref ref="datamodel"/>や<bibref ref="FunctionsAndOperators"/>に列挙されている。</p></note></div1>
<div1 id="id-references">
<head>参考文献</head>
<div2 id="id-normative-references">
<head>規格</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. See <loc href="http://rfc.net/rfc2119.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2396" key="RFC2396" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 2396. See <loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2396.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 3986. See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst and M. Suignard.  <emph>Internationalized Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization). <emph>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</emph>, ただし, 日々修正されたり、新しい版に置き換えられたり、新しい部の追加によって拡張されたりする。 [Geneva]: International Organization for Standardization. (最新版については<loc href="http://www.iso.ch" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.ch</loc>を見よ。)</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">The Unicode Consortium. <emph>The Unicode Standard</emph>  Reading, Mass.: Addison-Wesley, 2003, ただし、日々新たな版が公表されることにより更新される。最新版、およびこの標準の版や Unicode Character Databaseに関する追加情報については、<loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/standard/versions</loc>を見よ。使用される Unicode の版は<termref def="dt-implementation-defined">実装定義</termref>である。ただし、実装は最新の Unicode の版を使用することが推奨される。</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.0. (Third Edition)</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML1.1" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.1.</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES" key="XML Names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml-names/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLID" key="XML ID" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph> W3C Proposed Recommendation. See <loc href="http://www.w3.org/TR/xml-id/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-id/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October
2004. See <loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</loc>, <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</loc>, and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery/XPath Data Model (XDM)" id="datamodel" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath
2.0 Data Model (XDM)</emph>. W3C Candidate Recommendation, 03 Nov. 2005. See <loc href="http://www.w3.org/TR/xpath-datamodel/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XQueryFormalSemantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Formal Semantics</emph>.  W3C Candidate Recommendation,
03 Nov. 2005. See <loc href="http://www.w3.org/TR/xquery-semantics/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-semantics/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="FunctionsAndOperators" key="XQuery 1.0 and XPath 2.0 Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Functions and
     Operators</emph> W3C Candidate Recommendation, 03 Nov. 2005. See <loc href="http://www.w3.org/TR/xquery-operators/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-functions/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XSLT 2.0 and XQuery 1.0 Serialization" id="serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium.
<emph>XSLT 2.0 and XQuery 1.0 Serialization</emph>.
W3C Candidate Recommendation, 03 Nov.  2005.
See <loc href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt-xquery-serialization/</loc>.</bibl>

</blist>
</div2>
<div2 id="id-non-normative-references">
<head>参考</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Requirements" key="XML Query 1.0 Requirements" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>XML Query 1.0 Requirements</emph>. W3C Working Draft,
14 Nov 2003. See <loc href="http://www.w3.org/TR/xquery-requirements/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-requirements/</loc>.
</bibl>



<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XPath 2.0" id="XPath20" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>XML Path
Language (XPath) Version 2.0</emph>. W3C Working Draft, 03 Nov. 2005.  See
<loc href="http://www.w3.org/TR/xpath20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQueryX 1.0" id="XQueryX" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
World Wide Web Consortium. <emph>XQueryX, Version
1.0</emph>. W3C Working Draft, 03 Nov. 2005.  See <loc href="http://www.w3.org/TR/xqueryx" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xqueryx</loc>.</bibl>


					

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT" key="XSLT 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.  <emph>XSL
Transformations (XSLT) 2.0.</emph> W3C Candidate Recommendation, 03 Nov. 2005.  See <loc href="http://www.w3.org/TR/xslt20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt20/</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM" key="Document Object Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XINFO" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Information Set.</emph> W3C Recommendation 24 October 2001. See
<loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XPath 1.0" id="XPath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>XML Path
Language (XPath) Version 1.0</emph>. W3C Recommendation, Nov. 16, 1999. See
<loc href="http://www.w3.org/TR/xpath.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath.html</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPTR" key="XPointer" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001. See <loc href="http://www.w3.org/TR/WD-xptr" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/WD-xptr</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UseCases" key="XML Query Use Cases" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>XML Query Use Cases</emph>. W3C Working Draft, 15 Sep. 2005. See <loc href="http://www.w3.org/TR/xquery-use-cases/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-use-cases/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11schema10" key="XML 1.1 and Schema 1.0" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>Processing XML 1.0 Documents with XML Schema 1.0 Processors</emph>. W3C Working Group Note, 11 May 2005. See <loc href="http://www.w3.org/TR/xml11schema10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11schema10/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC1738" key="Uniform Resource Locators (URL)" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Internet Engineering Task Force (IETF).  <emph>Uniform Resource Locators (URL)</emph>. Request For Comment No. 1738, Dec. 1994. See <loc href="http://www.ietf.org/rfc/rfc1738.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc1738.txt</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="ODMG" id="ODMG" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Rick Cattell et al. <emph>The
Object Database Standard: ODMG-93, Release 1.2</emph>. Morgan Kaufmann
Publishers, San Francisco, 1996.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="Quilt" id="Quilt" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Don Chamberlin,
Jonathan Robie, and Daniela Florescu. <emph>Quilt: an XML Query Language for
Heterogeneous Data Sources</emph>.  In <emph>Lecture Notes in Computer
Science</emph>, Springer-Verlag, Dec. 2000.  Also available at <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</loc>.
See also <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML-QL" id="XML-QL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Alin Deutsch, Mary Fernandez, 
Daniela Florescu, Alon Levy, and Dan Suciu. <emph>A Query Language for XML</emph>. See <loc href="http://www.research.att.com/~mff/files/final.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.research.att.com/~mff/files/final.html</loc>
</bibl> 

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="SQL" id="SQL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">International Organization for
Standardization (ISO).  <emph>Information Technology-Database Language
SQL</emph>. Standard No. ISO/IEC 9075:2003.  (Available from American
National Standards Institute, New York, NY 10036, (212)
642-4900.)</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQL" id="XQL" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">J. Robie, J. Lapp, D. Schach. <emph>XML
Query Language (XQL)</emph>. See <loc href="http://www.w3.org/TandS/QL/QL98/pp/xql.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TandS/QL/QL98/pp/xql.html</loc>.</bibl>

</blist>
</div2>

<div2 id="id-background-material"><head>背景資料</head><blist>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CHARMOD" key="Character Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT1" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XSL
Transformations (XSLT) 1.0.</emph> W3C Recommendation. See <loc href="http://www.w3.org/TR/xslt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UseCaseQueries" key="Use Case Sample Queries" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Queries
from the XQuery 1.0 Use Cases, presented in a single file.
See
<loc href="http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt</loc>.
</bibl>
			
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XQueryQueries" key="XQuery Sample Queries" role="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Queries
from this document, presented in a single file.
See
<loc href="http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt</loc>.
</bibl>

</blist>
</div2>
</div1>


<div1 id="id-errors">	
  <head>エラー条件</head>	
<error-list>
<error spec="XP" code="0001" class="ST" type="static">
<p>
<termref def="dt-static-error">静的エラー</termref>であり、式の解析が、値の割り当てられていない<termref def="dt-static-context">静的文脈</termref>の構成要素に依存している。</p></error>

<error spec="XP" code="0002" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、式の評価が、値の割り当てられていない<termref def="dt-dynamic-context">動的文脈</termref>の部分に依存している。</p></error>

<error spec="XP" code="0003" class="ST" type="static">
<p>
<termref def="dt-static-error">静的エラー</termref>であり、式が<specref ref="id-grammar"/>で定義されている文法の正しいインスタンスではない。</p></error>

<error spec="XP" code="0004" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、<termref def="dt-static-analysis">静的解析相</termref>において、式が、その式の出現する文脈に適さない<termref def="dt-static-type">静的型</termref>を持っていると分かったり、<termref def="dt-dynamic-evaluation">動的評価相</termref>において、値の<termref def="dt-dynamic-type">動的型</termref>が<specref ref="id-sequencetype-matching"/>の照合ルールで指定された要求型と照合されない。</p></error>

<error spec="XP" code="0005" class="ST" type="static">
<p>静的解析における<termref def="dt-static-error">型エラー</termref>であり、<code>()</code>または<code>data(())</code>以外の式に割り当てられた<termref def="dt-static-type">静的型</termref>が<code>empty-sequence()</code>である。</p></error>

<error spec="XP" code="0006" class="TY" type="type">
<p>(現在は使われていない。)</p></error>

<error spec="XP" code="0007" class="TY" type="type">
<p>(現在は使われていない。)</p>
</error>

<error spec="XP" code="0008" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、式が<termref def="dt-static-context">静的文脈</termref>で定義されていない要素名、属性名、スキーマ型名、名前空間接頭辞、変数名を参照している。ただし、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-ElementTest" xlink:type="simple">ElementTest</nt>や<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AttributeTest" xlink:type="simple">AttributeTest</nt>の中での参照を除く。</p>
</error>

<error spec="XQ" role="xquery" code="0009" class="ST" type="static">
<p>
スキーマ輸入機能を支援しない実装は、前書きにスキーマ輸入が含まれていれば<termref def="dt-static-error">静的エラー</termref>を発生させなければならない。</p>
</error>





<error spec="XP" code="0010" class="ST" type="static">
<p>実装は、その実装が支援しない軸の参照に出会うと、<termref def="dt-static-error">静的エラー</termref>を発生しなければならない。</p>
</error>

<error spec="XQ" role="xquery" code="0012" class="ST" type="static">
<p>
前書きによって輸入されるすべてのスキーマに含まれる定義集合が、<bibref ref="XMLSchema"/> Part 1, 3章と5章に指定されているスキーマ妥当性の条件、すなわち各定義は正しく、完全で、一意でなければならないという条件を満たさないならば、<termref def="dt-static-error">静的エラー</termref>である。</p>
</error>

<error spec="XQ" role="xquery" code="0013" class="ST" type="static">
<p>実装が pragma を認識し、その内容が正しくないと決定した場合、<termref def="dt-static-error">静的エラー</termref>である。</p></error>

<error spec="XQ" role="xquery" code="0014" class="ST" type="static">
<p>(現在は使われていない。)</p></error>

<error spec="XQ" role="xquery" code="0015" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error>

<error spec="XQ" role="xquery" code="0016" class="ST" type="static">
<p>モジュール機能を支援しない実装は、<termref def="dt-module-declaration">モジュール宣言</termref>や<termref def="dt-module-import">モジュール輸入</termref>に出会うと<termref def="dt-static-error">静的エラー</termref>を発生させなければならない。</p>
</error>

<error spec="XP" code="0017" class="ST" type="static">
<p><phrase role="xquery"><termref def="dt-static-error">静的エラー</termref>
</phrase>であり、関数呼び出し中の引数の展開済QNameや引数の数が、<termref def="dt-static-context">静的文脈</termref>中の<termref def="dt-function-signature">関数シグネチャ</termref>の名前や次数と一致しない。</p>
</error>

<error spec="XP" code="0018" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、経路式の最後のステップの結果が節点も原子値も含んでいない。</p>
</error>

<error spec="XP" code="0019" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、経路式のステップ (最後のステップ以外) の結果が原子値を含んでいる。</p>
</error>

<error spec="XP" code="0020" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、軸ステップで文脈項目が節点ではない。</p>
</error>

<error spec="XP" code="0021" class="DY" type="dynamic">
<p>(現在は使われていない。)</p>
</error>

<error spec="XQ" role="xquery" code="0022" class="ST" type="static">
<p>
<termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-namespace-decl-attr">名前空間宣言属性</termref>の値が<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt>でない。</p>
</error>

<error spec="XQ" role="xquery" code="0023" class="TY" type="type">
<p>(現在は使われていない。)</p>
</error>

<error spec="XQ" role="xquery" code="0024" class="TY" type="type">
<p>
<termref def="dt-type-error">型エラー</termref>であり、要素構成子中の内容列に、属性節点でない節点が続く属性節点が含まれる。</p></error>

<error spec="XQ" role="xquery" code="0025" class="DY" type="dynamic">
<p>
<termref def="dt-dynamic-error">動的エラー</termref>であり、構成された要素の任意の属性が、その構成された要素の他の属性すべての名前と区別される名前を持たない。</p>
</error>

<error spec="XQ" role="xquery" code="0026" class="DY" type="dynamic">
<p>
<termref def="dt-dynamic-error">動的エラー</termref>であり、被計算処理命令構成子の内容式の結果が文字列 "<code>?&gt;</code>" を含む。</p>
</error>

<error spec="XQ" role="xquery" code="0027" class="DY" type="dynamic">
<p>
<termref def="dt-dynamic-error">動的エラー</termref>であり、妥当な式中で、妥当性検証の結果得られる PSVI 中の根要素情報項目が、期待される妥当性性質を持たない: 妥当性検証モードが <code>strict</code> であれば <code>valid</code>、妥当性検証モードが <code>lax</code> であれば <code>valid</code> か <code>notKnown</code> のいずれか。</p>
</error>

<error spec="XQ" role="xquery" code="0028" class="TY" type="type">
<p>
(現在は使われていない。)</p>
</error>

<error spec="XQ" code="0029" class="DY" type="dynamic" role="xquery">
<p>(現在は使われていない。)</p>
</error>


<error spec="XQ" role="xquery" code="0030" class="TY" type="type">
<p>
<termref def="dt-type-error">型エラー</termref>であり、<code>validate</code> 式の引数を評価すると、ただ1つの文書節点もしくは要素節点にならない。</p>
</error>

<error spec="XQ" role="xquery" code="0031" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、バージョン宣言中で指定されているバージョン番号が実装によって支援されていない。</p>
</error>

<error spec="XQ" role="xquery" code="0032" class="ST" type="static">
<p>前書き中に複数の<termref def="dt-base-uri-decl">基礎 URI 宣言</termref>が含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。
</p>
</error>

<error spec="XQ" role="xquery" code="0033" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、前書きに同じ名前空間接頭辞に対する宣言が複数含まれている。</p>
</error>



<error spec="XQ" role="xquery" code="0034" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-module">モジュール</termref>によって宣言もしくは輸入された複数の関数が同じ数の引数を持ち、かつそれらの展開済 QName が (<code>eq</code> 演算子で定義される意味で) 等しい。</p>
</error>
<error spec="XQ" role="xquery" code="0035" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、同じシンボル空間中かつ同じ有効範囲中に同じ名前で定義されている2つのスキーマ構成要素を輸入している。</p>
</error>


<error spec="XQ" role="xquery" code="0036" class="ST" type="type">

<p><termref def="dt-static-error">静的エラー</termref>であり、輸入しているモジュールの<termref def="dt-is-types">有効範囲内スキーマ型</termref>に含まれる定義の中に、輸入されるモジュール中に存在しかつ輸入するモジュールから参照される変数や関数 (引数の型や戻り値の型に関わらず) の宣言中に現れるスキーマ型名に対応するものがない。</p>
</error>

<error spec="XQ" role="xquery" code="0037" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error>

<error spec="XQ" role="xquery" code="0038" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、前書き中に<termref def="dt-default-collation-decl">デフォルト照合順序宣言</termref>が複数含まれていたり、デフォルト照合順序によって指定される値が<termref def="dt-static-collations">静的既知照合順序</termref>中にない。</p>
</error>

<error spec="XQ" role="xquery" code="0039" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、同一名の引数を2つ以上持つ関数宣言がある。</p>
</error>

<error spec="XQ" role="xquery" code="0040" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、直接要素構成子によって指定される属性の展開済 QName が区別されない。</p>
</error><error spec="XQ" role="xquery" code="0041" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、被計算処理命令構成子中の名前式の値が <code>xs:NCName</code> 型に型変換できない。</p>
</error>
<error spec="XQ" role="xquery" code="0042" class="ST" type="static">
<p>
(現在は使われていない。)</p></error>
<error spec="XQ" role="xquery" code="0043" class="ST" type="static">
<p>
(現在は使われていない。)</p></error>
<error spec="XQ" role="xquery" code="0044" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、被計算属性構成子によって構成される節点の <code>node-name</code> 性質が名前空間 <code>http://www.w3.org/2000/xmlns/</code> (名前空間接頭辞 <code>xmlns</code> に対応する) 中にある。もしくはどの名前空間にも属さず、局所名 <code>xmlns</code> を持つ。</p>
</error>
<error spec="XQ" role="xquery" code="0045" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、関数宣言中の関数名が以下の名前空間のいずれかに属している: <code>http://www.w3.org/XML/1998/namespace, http://www.w3.org/2001/XMLSchema, http://www.w3.org/2001/XMLSchema-instance, http://www.w3.org/2005/xpath-functions, http://www.w3.org/2005/xpath-datatypes</code>。</p></error>
<error spec="XQ" role="xquery" code="0046" class="ST" type="static">
<p><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-URILiteral" xlink:type="simple">URILiteral</nt> の値が長さ0ではなく、<code>xs:anyURI</code> の構文空間中にない、もしくは<bibref ref="RFC3986"/>で定義されている "相対参照" を表現する文字列であるとき、実装は<termref def="dt-static-error">静的エラー</termref>を発生させ<termref def="may">てもよい</termref>。</p></error>
<error spec="XQ" role="xquery" code="0047" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、複数のモジュールが同じ前書き中で同じ目的名前空間の指定を輸入している。</p></error>
<error spec="XQ" role="xquery" code="0048" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、ライブラリモジュール中で宣言されている関数や変数が、そのライブラリモジュールの目的名前空間中にない。</p></error>
<error spec="XQ" role="xquery" code="0049" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-module">モジュール</termref>で宣言もしくは輸入される2つ以上の変数が (<code>eq</code> 演算子で定義される意味で) 等しい展開済 QName を持つ。</p>
</error>

<error spec="XP" code="0050" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、<code>treat</code>式の演算数の<termref def="dt-dynamic-type">動的型</termref>が<code>treat</code>式で指定された<termref def="dt-sequence-type">静的型</termref>と一致しない。このエラーは、"<code>/</code>" や "<code>//</code>" で始まる経路式のうち、その文脈節点が文書節点を根とする木の中にないときも発生する。これは、経路式の先頭の "<code>/</code>" や "<code>//</code>" が、節<code>treat as document-node()</code>を含む初期ステップの省略形だからである。</p></error>
<error spec="XP" code="0051" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-SequenceType" xlink:type="simple">SequenceType</nt>中の<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xquery-AtomicType" xlink:type="simple">AtomicType</nt>として用いられるQNameが、<termref def="dt-is-types">有効範囲内スキーマ型</termref>中で原子型として定義されていない。</p></error>

<error spec="XQ" role="xquery" code="0052" class="DY" type="dynamic">
<p>(現在は使われていない。)</p>
</error>
<error spec="XQ" role="xquery" code="0053" class="ST" type="static">
<p>
(現在は使われていない。)</p></error>
<error spec="XQ" role="xquery" code="0054" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、変数宣言中の<termref def="dt-initializing-expression">初期化式</termref>が巡回性のために実行できない (例えば、その式がある関数に依存しており、その関数がさらに初期化される変数の値に依存している)。</p>
</error>
<error spec="XQ" code="0055" class="ST" type="static" role="xquery">
<p><termref def="dt-static-error">静的エラー</termref>であり、前書き中に<termref def="dt-copy-namespaces-decl">名前空間複製宣言</termref>が複数含まれている。</p></error>
<error spec="XQ" code="0056" class="ST" type="static" role="xquery">
<p>
(現在は使われていない。)</p></error>
<error spec="XQ" code="0057" class="ST" type="static" role="xquery">
<p><termref def="dt-static-error">静的エラー</termref>であり、スキーマ輸入が名前空間接頭辞を束縛しているが、長さ0の文字列以外で目的名前空間を指定していない。</p></error>
<error spec="XQ" code="0058" class="ST" type="static" role="xquery">
<p><termref def="dt-static-error">静的エラー</termref>であり、複数のスキーマ輸入が同じ目的名前空間を指定している。</p></error>
<error spec="XQ" code="0059" class="ST" type="static" role="xquery">
<p><termref def="dt-static-error">静的エラー</termref>であり、実装が、指定された目的名前空間をもつスキーマやモジュールを発見してスキーマ輸入やモジュール輸入を処理することができない。</p></error>
<error spec="XQ" code="0060" class="ST" type="static" role="xquery">
<p><termref def="dt-static-error">静的エラー</termref>であり、関数宣言中の関数名がどの名前空間にも属していない (展開済 QName が空の名前空間 URI を持つ)。</p></error>
<error spec="XQ" role="xquery" code="0061" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、validate 式の演算数が文書節点であり、その子がただ1つの要素節点、および0個以上のコメント節点と処理命令節点から構成されない。ただし順序は問わない。</p>
</error><error spec="XQ" role="xquery" code="0062" class="DY" type="dynamic">
<p>(現在は使われていない。)</p>
</error><error spec="XQ" code="0063" class="ST" type="static" role="xquery">
<p>
(現在は使われていない。)</p></error>
<error spec="XQ" role="xquery" code="0064" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、被計算処理命令構成子の名前式の値が "XML" に等しい (大文字小文字の組み合わせは任意)。</p></error>
<error spec="XQ" role="xquery" code="0065" class="ST" type="static">
<p>前書き中に<termref def="dt-ordering-mode-decl">順序付けモード宣言</termref>が複数含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0066" class="ST" type="static">
<p>前書き中にデフォルト要素/型名前空間宣言が複数含まれていたり、デフォルト関数名前空間宣言が複数含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0067" class="ST" type="static">
<p>前書き中に<termref def="dt-construction-decl">構成子宣言</termref>が複数含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0068" class="ST" type="static">
<p>前書き中に<termref def="dt-boundary-space-decl">境界空白宣言</termref>が複数含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0069" class="ST" type="static">
<p>前書き中に<termref def="dt-empty-order-decl">空順序宣言</termref>が複数含まれていれば、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0070" class="ST" type="static">
<p>既定義名前空間接頭辞 <code>xml</code> または <code>xmlns</code> が名前空間宣言や名前空間宣言属性によって再定義されたり、接頭辞 <code>xml</code> に束縛されている名前空間 URI に別の名前空間接頭辞が束縛されたりすると、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0071" class="ST" type="static">
<p>直接要素構成子の名前空間宣言属性が互いに区別されない名前を持つと、<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XQ" role="xquery" code="0072" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、被計算コメント構成子の内容式の結果が、2つの隣接するハイフンを含んでいたり、ハイフン1つで終わっている。</p>
</error>
<error spec="XQ" role="xquery" code="0073" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-module-import">モジュール輸入</termref>のグラフが巡回路を含んでいる (すなわちモジュール列 M<sub>1</sub> ... M<sub>n</sub> で M<sub>i</sub> が M<sub>i+1</sub> を輸入し、M<sub>n</sub> が M<sub>1</sub> を輸入しているようなものが存在する)。ただし、巡回路中のすべてのモジュールが共通の名前空間を共有する場合は除く。</p>
</error>
<error spec="XQ" role="xquery" code="0074" class="DY" type="dynamic">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、被計算要素構成子や被計算属性構成子中の名前式の値が<termref def="dt-expanded-qname">展開済 QName</termref>に変換できない (例えば、<termref def="dt-static-namespaces">静的既知名前空間</termref>にない名前空間接頭辞が含まれるなど)。</p></error>
<error spec="XQ" role="xquery" code="0075" class="ST" type="static">
<p>妥当性検証機能を支援しない実装は、<code>validate</code> 式に遭遇すると<termref def="dt-static-error">静的エラー</termref>を発生させなければならない。</p>
</error>
<error spec="XQ" role="xquery" code="0076" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、FLWOR 式の <code>order by</code> 節中の <code>collation</code> 部分節が<termref def="dt-static-collations">静的既知照合順序</termref>にある照合順序を識別しない。</p>
</error>
<error spec="XQ" role="xquery" code="0077" class="ST" type="static">
<p>
(現在は使われていない。)</p>
</error><error spec="XQ" role="xquery" code="0078" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error><error spec="XQ" role="xquery" code="0079" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、拡張式に、実装によって認識される <termref def="dt-pragma">pragma</termref> も波括弧で囲まれる式も含まれない。</p>
</error>

<error spec="XP" code="0080" class="ST" type="static">
<p><code>cast</code>式や<code>castable</code>式の目的型は原子型で、<termref def="dt-is-types">有効範囲内スキーマ型</termref>中になくてはならず、<code>xs:NOTATION</code>や<code>xs:anyAtomicType</code>であってはならない。後ろに出現標識 "<code>?</code>" が続いてもよい。そうでない場合は<termref def="dt-static-error">静的エラー</termref>が発生する。</p>
</error>
<error spec="XP" code="0081" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<phrase role="xquery">a query</phrase>で用いられているQNameが、<termref def="dt-static-namespaces">静的既知名前空間</termref>を用いても名前空間URIに展開できない名前空間接頭辞を含む。</p>
</error>

<error spec="XQ" role="xquery" code="0082" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error>

<error spec="XP" code="0083" class="ST" type="static">
<p>(現在は使われていない。)</p>
</error>

<error spec="XQ" code="0084" class="DY" type="dynamic" role="xquery">
<p><termref def="dt-dynamic-error">動的エラー</termref>であり、<code>validate</code> 文によって検証される要素が<termref def="dt-is-elems">有効範囲内要素宣言</termref>中の最上位要素宣言を持たない。ただし妥当性検証モードが <code>strict</code> の場合に限る。</p>
</error>
<error spec="XQ" role="xquery" code="0085" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、名前空間宣言属性中の名前空間 URI が長さ0の文字列であり、かつ実装が<bibref ref="XMLNAMES11"/>を支援しない。</p>
</error><error spec="XQ" role="xquery" code="0086" class="TY" type="type">
<p><termref def="dt-type-error">型エラー</termref>であり、複製された要素節点や属性節点の値が<termref def="dt-namespace-sensitive">名前空間に対して敏感</termref>である。ただし、<termref def="dt-construction-mode">構成モード</termref>が <code>preserve</code> で、<termref def="dt-copy-namespaces-mode">名前空間複製モード</termref>が <code>no-preserve</code> であるときに限る。</p>
</error>
<error spec="XQ" role="xquery" code="0087" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、バージョン宣言中で指定される文字符号化が<bibref ref="XML"/>で指定される <code>EncName</code> の定義に適合しない。</p>
</error>
<error spec="XQ" role="xquery" code="0088" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-module-import">モジュール輸入</termref>や<termref def="dt-module-declaration">モジュール宣言</termref>中で目的名前空間を指定するリテラルが長さ0のリテラルである。</p>
</error>
<error spec="XQ" role="xquery" code="0089" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、FLWOR 式の for 節中の変数束縛、およびそれに関連する位置変数が区別可能な名前 (展開済 QName) を持たない。</p>
</error>
<error spec="XQ" role="xquery" code="0090" class="ST" type="static">
<p><termref def="dt-static-error">静的エラー</termref>であり、<termref def="dt-character-reference">文字参照</termref>が、使われている XML のバージョン中で正しい文字を識別しない。</p>
</error>
</error-list>
</div1>

<div1 role="xquery" id="id-mime-type">
  <head><code>application/xquery</code> メディア型</head>

  <p>この附録では XQuery バージョン 1.0 に対するメディア型を指定する。XQuery は XML データ源からのデータコレクションに対して問合せを行うための言語である。このことについては、本文書の主部分で指定した通りである。このメディア型は現在、IANA (Internet Assigned Numbers Authority) での査読、承認、登録のために IESG (Internet Engineering Steering Group) に提案中である。</p>

  <div2 id="id-mime-type-intro">
    <head>はじめに</head>
    <p>この文書は、その規範的参照も含め、XQuery バージョン 1.0 という言語を定義する。この附録では、<code>application/xquery</code> メディア型についての情報を提供する。これは、XQuery 言語で書かれた問合せを転送するのに用いることを意図している。</p>
    <p>この文書は W3C XML Query Working Group のメンバーによって用意された。コメントは public-qt-comments@w3.org に送ってほしい。これは公開メーリングリストであり、そのアーカイブは<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments</loc>にある。</p></div2>

  <div2 id="id-registration-of-mime-type">
    <head>MIME メディア型 <code>application/xquery</code> の登録</head>

    <p>MIME メディア型名:  <code>application</code></p>
    <p>MIME 部分型名:    <code>xquery</code></p>
    <p>必要とされる引数: なし</p>
    <p>省略可能な引数: なし</p>
    <p>XQuery の構文は Unicode で表現されているが、UTF-8 や UTF-16 など、Unicode 互換の文字符号化を用いて書かれていてもよい。また、与えられた符号化の範囲外にある Unicode 文字を XML 形式の <code>&amp;#xddd;</code> という構文で表現して、US-ASCII や Latin-1 として転送してもよい。</p>

      

      <div3 id="id-interoperability-considerations"><head>相互運用性に関する考慮</head>
	<p>何も知られていない。</p></div3>

      <div3 id="id-applications-of-media-type"><head>このメディア型を用いている応用</head>
	<p>公式の<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery Web ページ</loc>に XQuery 言語の実装が2ダース以上列挙されている。これらには商用のものもオープンソースのものもある。</p>

	<p>この新しいメディア型は World Wide Web 上で XQuery を展開することを許すために現在登録中である。</p></div3>

      <div3 id="id-file-extensions"><head>ファイルの拡張子</head>
	<p>XQuery に最も広く用いられるファイル拡張子は <code>.xq</code> と <code>.xquery</code> である。</p>

	<p>適切な Macintosh ファイル型コードは <code>TEXT</code> である。</p>
      </div3>

      

    <div3 id="id-intended-usage"><head>意図する用い方</head>
      <p>このメディア型の用い方として意図しているのは、XQuery 式の相互交換である。</p></div3>

    <div3 id="id-author-change-controller"><head>著者/変更の管理者</head>
      <p>XQuery は World Wide Web コンソーシアムの XML Query Working Group で作成され、また管理されている。W3C がこの仕様の変更を管理している。</p></div3></div2>

  <div2 id="xquery-mime-encoding"><head>符号化に関する考慮</head>

    <p>8-bit クリーンでない転送を用いるために、quoted-printable 符号化が推奨される。なぜなら XQuery の構文自体は US-ASCII 互換の Unicode 部分集合を用いているからである。</p>

  <p>XQuery の文書は<termref def="dt-version-declaration">バージョン宣言</termref>の一部として<termref def="dt-encoding-declaration">符号化宣言</termref>を含むかもしれない:</p>
  <eg xml:space="preserve">xquery version "1.0" encoding "utf-8";</eg>

  </div2>

<div2 id="xquery-mime-recognizing">
  <head>XQuery ファイルの認識</head>

  <p>XQuery ファイルは文字列 <code>xquery version "V.V"</code> を文書の先頭付近に持っているかもしれない。ここで <code>"V.V"</code> はバージョン番号である。現在のところ、バージョン番号は、もし存在するなら、<code>"1.0"</code> でなければならない。</p></div2>

<div2 id="id-charset-default-rules"><head>文字集合デフォルトルール</head>

  <p>XQuery 文書は Unicode 文字集合、およびデフォルトでは UTF-8 文字符号化を用いる。</p></div2>

<div2 id="id-security-considerations"><head>セキュリティに関する考慮</head>

  <p>XQuery で書かれた問合せでは、結果として、任意の URI や IRI を逆参照するかもしれない。したがって、<bibref ref="RFC3987"/> 8章のセキュリティの問題を考慮するべきである。加えて、場合によっては <code>file:</code> URI の内容にアクセスしたり、処理したり、結果として返したりすることができる。</p>

  <p>さらに、XQuery 言語は拡張を許しているため、<code>application/xquery</code> はセキュリティに関してここで記述されている以上の意味を持つ内容を記述しても良い。</p>

  

  <p>XML Query Workign Group は XQuery 式を永続的データを生成したり更新したりするのに用いることができるような機能について、作業中である。信頼できない問合せはデータに対する書き込みアクセスを与えられるべきではない。</p></div2>

  

  
  </div1>

<inform-div1 id="id-glossary"><head>用語集</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>

<inform-div1 role="xquery" id="id-example-applications">
	<head>応用例</head> 

	<p>この節は、XQuery を用いて表現できる問合せのうち、いくつかの重要なクラスの例を含む。ここで記述されている応用は、複数のデータ源にまたがる結合、グループ化と集計、順序関連に基づく問合せ、再帰的変換、区別可能な値の組の選択である。</p>

	
	<div2 id="id-joins">
		<head>結合</head>
		<p>結合は、複数のデータ源からのデータを1つの結果にまとめるものであり、非常に重要な種類の問合せである。この節では、さまざまな種類の結合を XQuery でどのように表現できるかについて示す。この例は次の3つの文書に基づいている:</p>
		<olist>
			<item>
				<p><code>parts.xml</code> という名前の文書。これには多くの <code>part</code> 要素が含まれる。さらに、それぞれの <code>part</code> 要素には子要素として <code>partno</code> と <code>description</code> が含まれる。</p>
			</item>
			<item>
				<p><code>suppliers.xml</code> という名前の文書。これには多くの <code>supplier</code> 要素が含まれる。さらに、それぞれの <code>supplier</code> 要素には子要素として <code>suppno</code> と <code>suppname</code> が含まれる。</p>
			</item>
			<item>
				<p><code>catalog.xml</code> という名前の文書。これには supplier と part の関連に関する情報が含まれる。catalog 文書には多くの <code>item</code> 要素が含まれている。さらに、それぞれの <code>item</code> 要素には子要素として <code>partno</code>, <code>suppno</code>, および <code>price</code> が含まれる。</p>
			</item>
		</olist>
		<p>よくある ("内部") 結合は、以下の例に示すように、2つ以上の関連するデータ源からの情報を返す。以下の例では、3つの文書からの情報をまとめている。この例では、カタログ文書から導出される "記述的なカタログ" を生成している。しかし、part 番号の代わりに part の記述を、supplier 番号の代わりに supplier の名前を含んでいる。新しいカタログは part の記述のアルファベット順に整列され、次いで supplier の名前のアルファベット順に整列される。</p>
		<eg role="parse-test" xml:space="preserve">&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;</eg>
		<p>前の問合せでは、supplier を持つ part と part を持つ supplier に関する情報しか返さない。<term>外部結合</term>は、問合せに用いる1つ以上のデータ源からの情報を保存し、他方のデータ源に対応する要素がない要素も結果に含む。例えば、supplier と part の<term>左外部結合</term>は、対応する part を持たない supplier に関する情報を返す。</p>
		<p>以下の問合せは、左外部結合を示している。これは、すべての supplier の名前をアルファベット順に返す。これには、part を何も供給しない supplier も含まれる。結果では、各 supplier 要素は、それが供給するすべての part の記述をアルファベット順に含む。</p>
		<eg role="parse-test" xml:space="preserve">for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/pno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;</eg>

		<p>前の問合せでは、part を供給しない supplier に関する情報が保存される。もう一つの種類の結合は<term>完全外部結合</term>と呼ばれ、part を供給しない supplier に関する情報も、supplier のない part に関する情報も保存するのに用いられる。完全外部結合の結果はいくつかの方法で構成することができる。以下の問合せでは、まず<code>supplier</code> 要素のリストを生成している。各要素には、それが供給する (もしあるなら) 入れ子になった <code>part</code> 要素が含まれている。これに続いて、supplier のない <code>part</code> 要素のリストが生成される。これは "supplier を中心とする" 完全外部結合と考えられる。他の形式の完全結合問合せも可能である。</p>

		<eg role="parse-test" xml:space="preserve">&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;</eg>

		<p>前の問合せでは、要素構成子を用いて出力を <code>master-list</code> 要素の内部に囲んでいる。連接演算子 (",") を用いて、問合せの2つの主な部分をまとめている。結果は、<code>supplier</code> 要素の順序付き列に、supplier を持たない part すべての記述を含む <code>orphan-parts</code> 要素1つが続くようなものになる。</p>
	</div2>
	<div2 id="id-grouping">
		<head>グループ化</head>
		<p>多くの問合せでは、データをグループ化し、各グループに <code>fn:count</code> や <code>fn:avg</code> のような集計関数を適用することを必要とする。以下の例では、このような問合せを XQuery でどのように表現するかを示す。ここでは前節で定義した catalog 文書を用いる。</p>
		<p>この問合せでは、3 つ以上の supplier を持つ part について、その part の番号と平均価格を求めている。</p>
		<eg role="parse-test" xml:space="preserve">for $pn in fn:distinct-values(
      fn:doc("catalog.xml")/items/item/partno)
let $i := fn:doc("catalog.xml")/items/item[partno = $pn]
where fn:count($i) &gt;= 3
order by $pn
return 
   &lt;well-supplied-item&gt;
      &lt;partno&gt; {$p} &lt;/partno&gt;
      &lt;avgprice&gt; {fn:avg($i/price)} &lt;/avgprice&gt;
   &lt;/well-supplied-item&gt;</eg>
		<p>この問合せ中、<code>fn:distinct-values</code> 関数は catalog 文書中のすべての part の番号の集合から重複する part 番号を取り除いている。<code>fn:distinct-values</code> の結果は、順序に意味を持たない列である。</p>
		<p>注意しておいてほしいのだが、for 節で束縛されている <code>$pn</code> は個々の part の番号を表している一方、let 節で束縛されている <code>$i</code> は集計関数 <code>fn:count($i)</code> と <code role="parse-test">fn:avg($i/price)</code> への引数として働いている。この問合せでは、要素構成子を用いて、各 part の番号と平均価格を <code>well-supplied-item</code> という要素の中に囲んでいる。</p>
<p>上で示した方法は、容易に、2つ以上のデータ値によるグループ化に一般化される。例えば、<code>person</code> 要素の列を含む census 文書を考える。それぞれの <code>person</code> 要素は <code>state</code>, <code>job</code>, および <code>income</code> という子要素を持つ。census アナリストは、<code>state</code> と <code>job</code> の組み合わせそれぞれについて平均の <code>income</code> を列挙したようなレポートを準備する必要があるとする。このレポートは、以下のような問合せを用いて生成される:</p>
	<eg role="parse-test" xml:space="preserve">for $s in fn:distinct-values(
        fn:doc("census.xml")/census/person/state),
    $j in fn:distinct-values(
        fn:doc("census.xml")/census/person/job)
let $p := fn:doc("census.xml")/census/person
        [state = $s and job = $j]
order by $s, $j
return 
   if (fn:exists($p)) then
      &lt;group&gt;
         &lt;state&gt; {$s} &lt;/state&gt;
         &lt;job&gt; {$j} &lt;/job&gt;
         &lt;avgincome&gt; {fn:avg($p/income)} &lt;/avgincome&gt;
      &lt;/group&gt;
   else ()</eg>
<p>上の例で、<code>if-then-else</code> 式はデータを含まないグループを生成することを防いでいる。例えば、census データにはネブラスカ州に済む人や仕事が Deep Sea Fisherman であるような人は含まれるが、ネブラスカ州に住みかつ仕事が Deep Sea Fisherman であるような人はいないかもしれない。出力となるグループが、州と仕事の可能な組み合わせすべてについて要求されるのであれば、<code>if-then-else</code> 式は問合せから省略することができる。この場合、出力には次のような "空の" グループが含まれるかもしれない:</p><eg role="parse-test" xml:space="preserve">&lt;group&gt;
   &lt;state&gt;Nebraska&lt;/state&gt;
   &lt;job&gt;Deep Sea Fisherman&lt;/state&gt;
   &lt;avgincome/&gt;
&lt;/group&gt;</eg></div2>
	<div2 id="id-queries-on-sequence">
		<head>列への問合せ</head>
 <p>XQuery では、<code>&lt;&lt;</code> 演算子や <code>&gt;&gt;</code> 演算子を用いて文書順に基づく節点の比較を行う。これらの演算子は非常に単純であるが、順序に意味を持つ XML 文書に対する複雑な問合せを表現するのに用いることができる。この節の最初の2つの問合せは、<code>procedure</code>, <code>incision</code>, <code>instrument</code>, <code>action</code>, および <code>anesthesia</code> の各要素を含む外科レポートを意味する。</p>
<p>次の問合せは <code>action</code> 要素のうち、最初の procedure の内部にある最初と2番目の <code>incision</code> の間に出現するものすべてを返す。これらの節点間の元々の文書順が問合せの結果に保存される。</p>
 <eg role="parse-test" xml:space="preserve">let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i</eg>

		<p>ここでは、文書順の定義について、ある節点がその子孫よりも文書順で前にあるとみなすという方法は何の価値もない。この外科レポートでは、<code>action</code> が <code>incision</code> の部分であることは決してないが、<code>instrument</code> は <code>incision</code> の部分である。<code>&gt;&gt;</code> 演算子は文書順に基づいているので、述語 <code>$i &gt;&gt;	($proc//incision)[1]</code> は <code>instrument</code> 要素のうち最初の procedure 中の1つ目の <code>incision</code> 要素の子孫であるものに対して真である。</p>
<p>問合せによっては、ある節点が他の節点より前にあり、かつその節点の先祖ではないことを検査できる関数を定義することは有用かもしれない。以下の関数は、1つ目の演算数が2つ目の演算数より前にあるが、2つ目の演算数の先祖ではないときに <code>true</code> を返す。それ以外の場合には <code>false</code> を返す:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</eg>


<p>同様に、<code>local:follows</code> 関数は次のように書けるだろう:</p>

<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</eg>

<p><code>local:precedes</code> 関数を用いると、最初の2つの incision の間にある <code>instrument</code> 要素を見つける問合せを書くことができる。ただし、問合せの結果から、最初の <code>incision</code> の子孫である <code>instrument</code> は除かれる:</p>

<eg role="parse-test" xml:space="preserve">let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i</eg>

<p>以下の問合せは、過去に外科レポートに anesthesia の記録がない incision を報告する。<code>anesthesia</code> は <code>incision</code> の部分では決してないため、効率の悪い <code>local:precedes</code> 関数の代わりに <code>&lt;&lt;</code> を用いることができる:</p>

		<eg role="parse-test" xml:space="preserve">for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc</eg>
		<p>文書によっては、特定の要素列が論理的な階層を表しているかもしれない。これは HTML では特に広く見られる。以下の問合せでは、XHTML 文書のまえがきを <code>div</code> 要素で囲んで返す。この例では、テキスト "Introduction" を含む <code>h2</code> 要素がまえがきの始まりの目印となっており、次の <code>h2</code>
要素か <code>h1</code> 要素、あるいは文書の終わりのいずれかが最初に出現するところまでまえがきが続く、と仮定している。</p>
		<eg role="parse-test" xml:space="preserve">let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;</eg>
		<p>注意してほしいのだが、上の問合せでは元の文書中では暗黙的であった階層を明示的にしている。この例では、テキスト "Instroduction" を含む <code>h2</code> 要素は部分要素を持たないと仮定している。</p>
	</div2>
<div2 id="id-recursive-transformations"><head>再帰的変換</head>
<p>要素の階層を走査し、階層の各レベルで何らかの変換を適用する必要があることが時々ある。XQuery では、これは再帰関数を定義することで遂行することができる。この切では、このような再帰関数の例を2つ示す。</p>
<p>ある文書に対して、目次を計算する必要があるとしよう。これは、文書を走査し、<code>section</code> もしくは <code>title</code> という名前の要素のみ残し、これらの間の階層関係を残すことで行える。<code>section</code> それぞれについて、<code>section</code> か <code>title</code> という名前の部分要素をそのまま保つ。しかし <code>title</code> に対しては、要素の内容を全部保つ。これは以下のような再帰関数によって遂行される:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };</eg>
<p>与えられた文書の "骨格" 、これはすなわち文書の section と title のみから構成されているのだが、<code>local:sections-and-titles</code> 関数を文書の根要素に対して実行することで、以下のように得られる:</p>
<eg role="parse-test" xml:space="preserve">local:sections-and-titles(fn:doc("cookbook.xml"))</eg>
<p>再帰的変換のもう1つの例として、文書を走査し、<code>color</code> という名前の属性をそれぞれ <code>color</code> という名前の要素に、<code>size</code> という名前の要素を <code>size</code> という名前の属性にそれぞれ変換したいとする。これは以下のような再帰関数によって遂行される:</p>
<eg role="frag-prolog-parse-test" xml:space="preserve">declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in $e/(* | @*) return local:swizzle($c) } 
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };</eg>
<p>この変換は、<code>local:swizzle</code> 関数を文書の根要素に以下のように実行することで、文書全体に適用することができる:</p>
<eg role="parse-test" xml:space="preserve">local:swizzle(fn:doc("plans.xml"))</eg>
</div2>
<div2 id="id-select-distinct"><head>区別可能な組み合わせの選択</head>
<p>ときにはデータの集合を探索して、ある性質のリストの区別可能な組み合わせをすべて求める必要がある。例えば、入力データ集合が <code>order</code> 要素からなる大きな集合からなり、それぞれの要素は、以下の例のように、同じ基本的な構造をしているものとする:</p>
<eg xml:space="preserve">&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;</eg>
<p>このデータ集合から、1つの <code>order</code> にともに出現する <code>product</code>, <code>size</code>, および <code>color</code> の区別可能な組み合わせをすべて見つけたいとする。以下の問合せはこのリストを返す。このとき、区別可能な組み合わせをそれぞれ <code>option</code> という名前の新たな要素で囲む:</p>
<eg role="parse-test" xml:space="preserve">for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()</eg></div2></inform-div1>








<inform-div1 id="id-revisions-log" role="xquery"><head>Revision
Log</head>

<p>This log records the substantive and significant editorial changes that have been made to this document since the Candidate Recommendation Draft of 03 November 2005. Minor editorial changes are not included in this log.</p><div2 id="id-log-050707"><head>10 May 2006</head><olist><item><p>Deleted all references to the namespace <code>http://www.w3.org/2005/xpath-datatypes</code>, formerly known by the prefix <code>xdt:</code>, and moved all the schema types defined in this namespace to the namespace <code>http://www.w3.org/2001/XMLSchema</code>, known in this document by the prefix <code>xs:</code>. All built-in schema types used by XPath and XQuery are now consolidated in the <code>xs:</code> namespace.</p><p>This change closes Bugzilla entry 2548. It affects many sections throughout this document and other XPath and XQuery specifications.</p></item><item><p>Deleted a paragraph requiring the functions <code>fn:doc</code> and <code>fn:collection</code> to be stable (returning the same results when called repeatedly.) Stability of these functions is now covered in the Functions and Operators specification. The functions are stable by default but an implementation may provide a user option to relax this requirement.</p><p>This change closes Bugzilla entry 2553. Section affected: <specref ref="id-input-sources"/></p></item><item><p>A cast expression or constructor function whose target type is <code>xs:QName</code> or is derived from <code>xs:QName</code> or <code>xs:NOTATION</code> formerly required its operand to be a literal string. Now it accepts either a literal string or an expression whose base type is the same as the base type of the target type. For example, it is now possible to cast a value of type <code>xs:QName</code> to <code>my:BigQName</code> which is derived from <code>xs:QName</code>.</p><p>This change closes Bugzilla entry 2678. Sections affected:</p><olist><item><p><specref ref="id-cast"/></p></item><item><p><specref ref="id-constructor-functions"/></p></item><item><p>Error code XPST0083 is eliminated (all casts and calls to constructor functions with invalid operands raise XPTY0004.)</p></item></olist></item><item role="xquery"><p>
It is now a <termref def="dt-static-error">static
error</termref>
if a variable bound in a for clause of a FLWOR expression, and its associated positional variable, do not have distinct names (expanded QNames).</p><p>This change closes Bugzilla entry 2692. Sections affected:</p><olist><item><p><specref ref="id-for-let"/></p></item><item><p>New error code XQST0089.</p></item></olist></item><item><p>Modified the definition of Effective Boolean Value to specify that a value of type <code>xs:anyURI</code> is treated the same as a value of type <code>xs:string</code> (a consequence of placing <code>xs:anyURI</code> and <code>xs:string</code> in the same promotion hierarchy).</p><p>This change closes Bugzilla entry 2545. Section affected: <specref ref="id-ebv"/></p></item><item role="xquery"><p>
It is now a <termref def="dt-static-error">static
error</termref>
if the target namespace in a module declaration is of zero length.</p><p>Sections affected:</p><olist><item><p><specref ref="id-module-declaration"/></p></item><item><p>Definition of error code XQST0088. (Formerly applied only to module import; now applies to module declaration as well.)</p></item></olist></item><item role="xquery"><p>
The rules for whitespace normalization of URI Literals have been made more specific.</p><p>Section affected: <specref ref="id-uri-literals"/></p></item><item><p>When a namespace prefix cannot be resolved, error code XPST0081 is raised rather than the more generic error XPST0008.</p><p>This change closes Bugzilla entry 2447. Sections affected: </p><olist><item><p><specref ref="node-tests"/></p></item><item role="xquery"><p><specref ref="id-namespaces"/></p></item><item role="xquery"><p><specref ref="id-namespace-decls"/></p></item></olist></item><item><p>When the axis name is omitted from an axis step containing a SchemaAttributeTest, the default axis is <code>attribute</code>. Example: <code>part/schema-attribute(color)</code>.</p><p>This change closes Bugzilla entry 2527. Section affected: <specref ref="abbrev"/></p></item><item role="xquery"><p>When ordering mode is <code>unordered</code>, XQuery does not require the results of <code>fn:id</code> and <code>fn:idref</code> to be returned in document order. This is a feature of XQuery rather than of the functions themselves.</p><p>This change closes Bugzilla entry 2542. Section affected: <specref ref="id-unordered-expressions"/></p></item><item role="xquery"><p>In an extension expression (pragma), whitespace is required between the pragma name and pragma content.</p><p>This change closes Bugzilla entry 2710. Section affected: <specref ref="id-extension-expressions"/></p></item><item role="xquery"><p>When importing a module, an error is not raised if the importing module contains functions or variables that use unknown types unless such a function or variable is actually referenced in the importing module.</p><p>This change closes Bugzilla entry 2546. Section affected: <specref ref="id-module-imports"/> and the definition of error XQST0036.</p></item><item role="xquery"><p>A static error is now raised if a character reference is syntactically valid but does not identify a valid character.</p><p>This change closes Bugzilla entry 2610. Section affected: <specref ref="id-literals"/> and new error code XQST0090.</p></item><item><p>Equality of QNames is defined by the <code>eq</code> operator, which performs codepoint-comparisons of the namespace URIs and the local names, ignoring the namespace prefixes. This is not a change, but some editorial clarifications have been made in the XPath, XQuery, and Functions and Operators documents. For example, phrases such as "QNames are the same" have been replaced by "QNames are equal as defined by the <code>eq</code> operator", and a new example has been added to the section on Value Comparisons.</p><p>This change closes Bugzilla entry 2634. Sections affected: Minor editorial changes to various sections and to the definitions of error codes  XQST0034 and XQST0049.</p></item><item><p>An implementation is not required to enforce cardinality constraints on operands that are not evaluated.</p><p>This change closes Bugzilla entry 2708. Section affected: <specref ref="id-errors-and-opt"/></p></item><item><p>Entries for the <code>eq</code> and <code>ne</code> operators on the types <code>xs:yearMonthDuration</code> and <code>xs:dateTimeDuration</code> have been removed from the operator mapping table. These operators are now handled by promotion to <code>xs:duration</code>.</p><p>This change closes Bugzilla entry 2789. Section affected: <specref ref="mapping"/></p></item><item><p>Editorial changes have been made to clarify that type promotions and subtype substitutions may be performed on the operands of all operators, including value comparisons. This is not a substantive change.</p><p>This change closes Bugzilla entries 2324 and 2631. Sections affected: <specref ref="id-value-comparisons"/> and <specref ref="mapping"/>.</p></item><item><p>Editorial changes have been made to clarify that a sequence of adjacent predicates is processed from left to right, and to clarify the assignment of context positions on reverse axes. This is not a substantive change.</p><p>This change closes Bugzilla entry 2500. Sections affected: <specref ref="id-steps"/>, <specref ref="axes"/>, <specref ref="id-predicates"/>, and <specref ref="id-filter-expr"/>.</p></item><item role="xquery"><p>The namespace prefix specified in a module declaration, schema import, or module import must not be <code>xml</code> or <code>xmlns</code>.</p><p>This change closes Bugzilla entry 2950. Sections affected: <specref ref="id-module-declaration"/>, <specref ref="id-schema-imports"/>, <specref ref="id-module-imports"/>, and error code XQST0070.</p></item><item role="xquery"><p>An external function must either return a value of the type declared in its function declaration or raise an implementation-defined error.</p><p>This change closes Bugzilla entry 2977. Sections affected: <specref ref="id-consistency-constraints"/>, <specref ref="id-function-calls"/>, and <specref ref="id-impl-defined-items"/>.</p></item><item><p>If multiple errors are detected, an implementation may report any non-empty subset of the detected errors.</p><p>This change closes Bugzilla entry 3122. Section affected: <specref ref="id-kinds-of-errors"/>.</p></item></olist></div2></inform-div1>

</back>

</spec>