<!-- <?xml-stylesheet type="text/xsl" href="xmlspec.xsl"?> --><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="cr">
  <header id="spec-header">
    <title>XML Syntax for XQuery 1.0 (XQueryX)</title>
    <w3c-designation>CR-xqueryx</w3c-designation>
    <w3c-doctype>W3C Candidate Recommendation</w3c-doctype>
    <pubdate>
      <day>8</day>
      <month>June</month>
      <year>2006</year>
    </pubdate>
    <publoc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xqueryx-20060608" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2006/CR-xqueryx-20060608</loc>
    </publoc>
    <altlocs>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xqueryx-20060608/xqueryx.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/CR-xqueryx-20060608/diff-from-20051103.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Revisions to prior Working Draft</loc>
    </altlocs>
    <latestloc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xqueryx" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xqueryx</loc>
    </latestloc>
    <prevlocs>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xqueryx-20051103" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/CR-xqueryx-20051103</loc>
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/WD-xqueryx-20050915" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2005/WD-xqueryx-20050915</loc>
    </prevlocs>
    <authlist>
      <author>
        <name>Jim Melton</name>
        <affiliation>Oracle</affiliation>
        <email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jim.melton@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jim.melton@oracle.com</email>
      </author>
      <author>
        <name>Subramanian Muralidhar</name>
        <affiliation>Microsoft</affiliation>
<!--        <email href="mailto:smurali@microsoft.com">smurali@microsoft.com</email> -->
      </author>
    </authlist>

    <abstract>
      <p>This document defines an XML Syntax for <bibref ref="xquery"/>.</p>
    </abstract>

    <status id="id-status">

<p><emph>This section describes the status of this document at the time of 
its publication. Other documents may supersede this document. A list of 
current W3C publications and the latest revision of this technical report 
can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C
technical reports index</loc> at http://www.w3.org/TR/.</emph></p>

<p>On 3 November 2005, this specification
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xquery-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">was published</loc> as a
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc>,
and a Call for Implementations was announced. 
This revision is published in order to give visibility to the
technical decisions that have been made so far during this
phase of the process and to allow review by W3C Members and other interested parties. 
The maturity level of the specification remains unchanged,
and the work is on track to move forward to the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Proposed Recommendation</loc>
stage when the exit criteria for the current phase have been met.
Publication as a Candidate Recommendation does not imply endorsement by the W3C Membership. 
This is a draft document and may be updated, replaced or obsoleted by other documents at any time. 
It is inappropriate to cite this document as other than work in progress.
This specification will remain a Candidate Recommendation until at least 28 February 2006.
</p>

<p>This document was produced by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>, part of the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</p>

<p>On 03 November 2005, this specification
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xqueryx-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">was published</loc>
as a
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate
Recommendation</loc>,
and a Call for Implementations was announced. 
This revised document is published in order to give visibility to the technical decisions
that have been made so far during this phase of the process. 
The maturity level of the specification remains unchanged, and the work is on track to
move forward to the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C
Proposed Recommendation</loc> stage when the exit criteria for the current phase have been met. 
</p>

<p>This draft includes corrections and changes based on
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=XQueryX&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=2005-04-04&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public
comments</loc> recorded in the W3C public Bugzilla repository (<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/Bugs/Public/</loc>) 
used for Last Call issues tracking. A list of substantive changes since the 
publication of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2005/CR-xqueryx-20051103/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Candidate Recommendation</loc>
of 03 November 2005 can be found in <specref ref="changelog"/>.</p>

<p>Comments on this document are invited and should be made in W3C's <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc> 
(instructions can be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>). 
If access to that system is not feasible, you may send your comments to the 
W3C XSLT/XPath/XQuery mailing list, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. It 
will be very helpful if you include the string [XQueryX] in the subject 
line of your comment, whether made in Bugzilla or in email. Each Bugzilla 
entry and email message should contain only one comment.  Archives of the 
comments and responses are available at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/ 
</loc>.</p>

<p>The <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query and XPath Test Suite</loc> is under development. 
Implementors are encouraged to run this test suite and report their results.
A <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query/test-suite/XQTSReport.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">preliminary XQuery Test Suite Result Summary</loc>
has been prepared that contains information submitted for several implementations.
</p>

<p>This document was produced by a group operating under the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February
2004 W3C Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="disclosure" href="http://www.w3.org/2002/08/xmlquery-IPR-statements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent
disclosures</loc> made in connection with the deliverables of the group;
that page also includes instructions for disclosing a patent. An
individual who has actual knowledge of a patent which the individual
believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential
Claim(s)</loc> must disclose the information in accordance with <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section
6 of the W3C Patent Policy</loc>.</p>

    </status>

    <langusage>
      <language id="EN">English</language>
    </langusage>

    <revisiondesc>
      <p>This is the Candidate Recommendation of this specification. 
      It is aligned with the XQuery grammar as published in <bibref ref="xquery"/>.</p>
    </revisiondesc>
  </header>

  <body>

    <div1 id="Introduction">
      <head>Introduction</head>

      <p>The <bibref ref="xquery-requirements"/> states that <quote>The XML Query Language MAY have
more than one syntax binding. One query language syntax MUST be convenient for
humans to read and write. One query language syntax MUST be expressed in XML in
a way that reflects the underlying structure of the query.</quote></p>

      <p>XQueryX is an XML representation of an XQuery. It was created by mapping
the productions of the XQuery grammar into XML productions.
The result is not particularly convenient for humans to read and write, but it
is easy for programs to parse, and because XQueryX is represented in XML, standard
XML tools can be used to create, interpret, or modify queries.</p>

<!-- 2005-10-05 JM: Add informative note clarifying that the
     XQueryX static/dynamic contexts are the same as the XQuery contexts -->
      <note><p>
        Because the two syntaxes are merely different grammars that express the same query semantics,
        they share all aspects of an XQuery processing system except for the component that recognizes
        and translates the source representation of a query (that is, the parser).  The aspects
        that are shared include both the static context and the dynamic context that are defined in
        <bibref ref="xquery"/>. 
      </p></note>

      <p>There are several environments in which XQueryX may be useful:</p>

      <ulist>
        <item>
          <p>
            <emph>Parser Reuse.</emph> In heterogeneous environments, a
variety of systems may be used to execute a query. One parser can generate XQueryX
for all of these systems.</p>
        </item>

        <item>
          <p>
            <emph>Queries on Queries.</emph> Because XQueryX is represented in XML, queries                         can be
queried and can be transformed into new queries. For instance, a query can
be performed against a set of XQueryX queries to determine which queries use
FLWOR expressions to range over a set of invoices.</p>
        </item>

        <item>
          <p>
            <emph>Generating Queries.</emph> In some XML-oriented programming
environments, it may be more convenient to build a query in its XQueryX
representation than in the corresponding XQuery representation, since ordinary
XML tools can be used.</p>
        </item>

        <item>
          <p>
            <emph>Embedding Queries in XML.</emph> XQueryX can be embedded
directly in an XML document.</p>
        </item>

      </ulist>

    </div1>

    <div1 id="Mapping">
      <head>Mapping the XQuery Syntax</head>

      <p>XQueryX is an XML representation of the abstract syntax found in
Appendix A of <bibref ref="xquery"/>. The XQueryX syntax is defined by
the XQueryX Schema, which is specified in <specref ref="Schema"/>. The XQueryX semantics are
defined by a stylesheet that maps an instance of XQueryX to an instance of
XQuery; see <specref ref="Stylesheet"/>.</p>

      <p>The main data structure in the XQueryX Schema is the set of types that describe
expressions. We have chosen to model expressions using substitution groups,
with an "expr" abstract base class and a number of intermediate abstract classes. </p>

      <p>Consider the following productions from the abstract syntax:</p>

      <!-- insert grammar snippet here -->
      <eg xml:space="preserve"><!-- Checked 2004-12-28, Jim Melton; updated WhereClause from "Expr" to "ExprSingle" -->

FLWORExpr    ::=    (ForClause  | LetClause)+ WhereClause? OrderByClause? "return" ExprSingle 
ForClause    ::=    "for" "$" VarName TypeDeclaration? PositionalVar? "in" 
                    ExprSingle ("," "$" VarName TypeDeclaration? PositionalVar? 
                    "in" ExprSingle)* 
LetClause    ::=    "let" "$" VarName TypeDeclaration? ":=" ExprSingle
                    ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
WhereClause  ::=    "where" ExprSingle
</eg>

      <p>The following XQueryX Schema definitions reflect the structure of those
productions from that abstract syntax:</p>

      <!-- insert schema snippet here -->
      <eg xml:space="preserve"><!-- Corrected 2004-12-30, Subramanian Muralidhar, edited by Jim Melton -->
<!-- Further updates 2005-02-17, Subramanian Muralidhar, edited by Jim Melton -->
<!-- Still more updates 2005-06-27, Jim Melton to represent new schema -->
  
&lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;
  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;
  
  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice maxOccurs="unbounded"&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="whereClause" minOccurs="0"/&gt;
          &lt;xsd:element name="orderByClause" minOccurs="0"/&gt;
          &lt;xsd:element name="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:element name="forClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="forClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="forClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element ref="positionalVariableBinding" minOccurs="0"/&gt;
        &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;

  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;
</eg>

      <p>Since XQuery uses the expression production liberally to allow
expressions to be flexibly combined, XQueryX uses the exprWrapper type
in embedded contexts to allow all expression types to occur.</p>

    </div1>


    <div1 id="Examples">
      <head>Examples from the XML Query Use Cases in XML Syntax</head>

      <p>Three of following examples are based on the data and queries in the XMP
(Experiences and Exemplars) use case in <bibref ref="xquery-use-cases"/>,
while a fourth example is based on the data and queries in the
NS (Queries Using Namespaces) use case. 
For each example we show the English description of the query,
the XQuery solution given in <bibref ref="xquery-use-cases"/>,
an XQueryX solution, and the XQuery that results from applying the XQueryX-to-XQuery transformation
defined by the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution.
That produced XQuery is presented only as a sanity-check —
the intent of the stylesheet is not to create the identical
XQuery expression given in <bibref ref="xquery-use-cases"/>, but to produce <emph>a</emph> valid
XQuery expression with the same semantics. 
The semantics of the XQueryX solution are determined by the semantics of the XQuery expression that
results from that transformation.  The "correctness" of that transformation is determined by
asking the following the question:
Can some XQueryX processor QX process some XQueryX document D1 to produce results R1,
after which the stylesheet is used to translate D1 into an XQuery expression E1 that,
when processed by some XQuery processor Q, produces results R2 that are equivalent
(under some meaningful definition of "equivalent") to results R1?
</p>

<p>Comparison of the results of the XQueryX-to-XQuery transformation given in this document
with the XQuery solutions in the <bibref ref="xquery-use-cases"/> may be helpful in evaluating
the correctness of the XQueryX solution in each example. </p>

<p>The XQuery Use Cases solution given for each example is provided only to assist readers of this
document in understanding the XQueryX solution.  There is no intent to imply that this
document specifies a "compilation" or "transformation" of XQuery syntax into XQueryX syntax. 
</p>

      <p>In the following examples, note that path expressions are expanded to show their
structure. Also, note that the prefix syntax for binary operators like "and" makes the
precedence explicit. In general, humans find it easier to read an XML representation
that does not expand path expressions, but it is less convenient for programmatic
representation and manipulation.  XQueryX is designed as a language that is convenient
for production and modification by software, and not as a convenient syntax for humans to
read and write. </p>

      <p>Finally, please note that white space, including new lines, have been added to
some of the XQueryX documents and XQuery expressions for readability.  That additional white space
is not produced by the XQueryX-to-XQuery transformation. </p>

      <div2 id="Example1">
        <head>Example 1</head>

        <p>Here is Q1 from the <bibref ref="xquery-use-cases"/>, use case XMP
(Experiences and Exemplars): "List books published by Addison-Wesley after 1991,
including their year and title."</p>

        <div3 id="Example1-XQuery">
          <head>XQuery solution in XQuery Use Cases:</head>

          <eg xml:space="preserve">
&lt;bib&gt;
 {
  for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
  where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
  return
    &lt;book year="{ $b/@year }"&gt;
     { $b/title }
    &lt;/book&gt;
 }
&lt;/bib&gt;
</eg>

        </div3>

        <div3 id="Example1-XQueryX">
          <head>A Solution in XQueryX:</head>

          <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;

                    &lt;xqx:stepExpr&gt;
					  &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
					  &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
						  &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
						  &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
                &lt;xqx:attributeList&gt;
                  &lt;xqx:attributeConstructor&gt;
                    &lt;xqx:attributeName&gt;year&lt;/xqx:attributeName&gt;
                    &lt;xqx:attributeValueExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
						  &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:attributeValueExpr&gt;
                  &lt;/xqx:attributeConstructor&gt;
                &lt;/xqx:attributeList&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
				      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
					  &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg>

        </div3>

        <div3 id="Example1-Transformation">
          <head>Transformation of XQueryX Solution into XQuery</head>

          <p>Application of the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution results in:</p>

          <eg xml:space="preserve">  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 return &lt;book year="{$b/attribute::year}"&gt;{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</eg>

        </div3>

        <div3 id="Example1-Abstract">
          <head>Corresponding Grammar Abstract Parse Tree</head>

<!-- JM 2005-08-23: URL for applets no longer use month; different directory than before -->
          <p>For comparison, here is the abstract parse tree corresponding to the
XQuery for Example 1, as produced by the XQuery grammar applets found at
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/qt-applets/xqueryApplet.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2005/qt-applets/xqueryApplet.html</loc>. 
</p>

          <eg xml:space="preserve">
XPath2
  QueryList
    Module
      MainModule
        Prolog
        QueryBody
          Expr
            PathExpr
              Constructor
                DirectConstructor
                  DirElemConstructor &gt;
                    LessThanOpOrTagO &lt;
                    TagQName bib
                    DirAttributeList
                    StartTagClose &gt;
                    DirElemContent
                      ElementContentChar 
                    DirElemContent
                      ElementContentChar  
                    DirElemContent
                      CommonContent
                        EnclosedExpr
                          Lbrace {
                          Expr
                            FLWORExpr
                              ForClause
                                VarName
                                  QName b
                                PathExpr
                                  FunctionCall
                                    FunctionQName doc
                                    PathExpr
                                      StringLiteral "http://bstore1.example.com/bib.xml"
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName bib
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName book
                              WhereClause
                                AndExpr and
                                  ComparisonExpr =
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep
                                          NodeTest
                                            NameTest
                                              QName publisher
                                    PathExpr
                                      StringLiteral "Addison-Wesley"
                                  ComparisonExpr &gt;
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep @
                                          NodeTest
                                            NameTest
                                              QName year
                                    PathExpr
                                      IntegerLiteral 1991
                              PathExpr
                                Constructor
                                  DirectConstructor
                                    DirElemConstructor &gt;
                                      LessThanOpOrTagO &lt;
                                      TagQName book
                                      DirAttributeList
                                        S  
                                        TagQName year
                                        ValueIndicator =
                                        DirAttributeValue
                                          OpenQuot "
                                          QuotAttrValueContent
                                            CommonContent
                                              EnclosedExpr
                                                Lbrace {
                                                Expr
                                                  PathExpr
                                                    VarName
                                                      QName b
                                                    StepExpr
                                                      AbbrevForwardStep @
                                                        NodeTest
                                                          NameTest
                                                            QName year
                                                Rbrace }
                                          CloseQuot "
                                      StartTagClose &gt;
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        CommonContent
                                          EnclosedExpr
                                            Lbrace {
                                            Expr
                                              PathExpr
                                                VarName
                                                  QName b
                                                StepExpr
                                                  AbbrevForwardStep
                                                    NodeTest
                                                      NameTest
                                                        QName title
                                            Rbrace }
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent &lt;/
                                        ElementContentChar  
                          Rbrace }
                    DirElemContent &lt;/
                      ElementContentChar 
</eg>

        </div3>

      </div2>

      <div2 id="Example2">
        <head>Example 2</head>

        <p>Here is Q4 from the <bibref ref="xquery-use-cases"/>, use case XMP
(Experiences and Exemplars): "For each author in the bibliography, list the
author's name and the titles of all books by that author, grouped inside a "result" element."</p>

        <div3 id="Example2-XQuery">
          <head>XQuery solution in XQuery Use Cases:</head>

          <eg xml:space="preserve">
&lt;results&gt;
  {
    let $a := doc("http://bstore1.example.com/bib/bib.xml")//author
    for $last in distinct-values($a/last),
        $first in distinct-values($a[last=$last]/first)
    order by $last, $first
    return
        &lt;result&gt;
            &lt;author&gt;
               &lt;last&gt;{ $last }&lt;/last&gt;
               &lt;first&gt;{ $first }&lt;/first&gt;
            &lt;/author&gt;
            {
                for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
                where some $ba in $b/author 
                      satisfies ($ba/last = $last and $ba/first=$first)
                return $b/title
            }
        &lt;/result&gt;
  }
&lt;/results&gt; 
</eg>

        </div3>

        <div3 id="Example2-XQueryX">
          <head>A solution in XQueryX:</head>

          <!-- insert exmpl2 here -->
          <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
			                    http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;results&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:letClause&gt;
              &lt;xqx:letClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;a&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:letExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
				     &lt;xqx:filterExpr&gt;
                       &lt;xqx:functionCallExpr&gt;
                         &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                         &lt;xqx:arguments&gt;
                           &lt;xqx:stringConstantExpr&gt;
                             &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                           &lt;/xqx:stringConstantExpr&gt;
                         &lt;/xqx:arguments&gt;
                       &lt;/xqx:functionCallExpr&gt;
					 &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:anyKindTest/&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                &lt;/xqx:letExpr&gt;
              &lt;/xqx:letClauseItem&gt;
            &lt;/xqx:letClause&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;last&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;first&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                          &lt;xqx:predicates&gt;
                            &lt;xqx:equalOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:pathExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:filterExpr&gt;
                                      &lt;xqx:contextItemExpr/&gt;
							        &lt;/xqx:filterExpr&gt;
                                  &lt;/xqx:stepExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                    &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                  &lt;/xqx:stepExpr&gt;
                                &lt;/xqx:pathExpr&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:equalOp&gt;
                          &lt;/xqx:predicates&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;result&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;author&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;last&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;first&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                    &lt;xqx:flworExpr&gt;
                      &lt;xqx:forClause&gt;
                        &lt;xqx:forClauseItem&gt;
                          &lt;xqx:typedVariableBinding&gt;
                            &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                          &lt;/xqx:typedVariableBinding&gt;
                          &lt;xqx:forExpr&gt;
                            &lt;xqx:pathExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:filterExpr&gt;
                                  &lt;xqx:functionCallExpr&gt;
                                    &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                                    &lt;xqx:arguments&gt;
                                      &lt;xqx:stringConstantExpr&gt;
                                        &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                                      &lt;/xqx:stringConstantExpr&gt;
                                    &lt;/xqx:arguments&gt;
                                  &lt;/xqx:functionCallExpr&gt;
								&lt;/xqx:filterExpr&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                            &lt;/xqx:pathExpr&gt;
                          &lt;/xqx:forExpr&gt;
                        &lt;/xqx:forClauseItem&gt;
                      &lt;/xqx:forClause&gt;
                      &lt;xqx:whereClause&gt;
                        &lt;xqx:quantifiedExpr&gt;
                          &lt;xqx:quantifier&gt;some&lt;/xqx:quantifier&gt;
                          &lt;xqx:quantifiedExprInClause&gt;
                            &lt;xqx:typedVariableBinding&gt;
                              &lt;xqx:varName&gt;ba&lt;/xqx:varName&gt;
                            &lt;/xqx:typedVariableBinding&gt;
                            &lt;xqx:sourceExpr&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:filterExpr&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
								  &lt;/xqx:filterExpr&gt;
                                &lt;/xqx:stepExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:sourceExpr&gt;
                          &lt;/xqx:quantifiedExprInClause&gt;
                          &lt;xqx:predicateExpr&gt;
                            &lt;xqx:andOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
										&lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
										&lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:andOp&gt;
                          &lt;/xqx:predicateExpr&gt;
                        &lt;/xqx:quantifiedExpr&gt;
                      &lt;/xqx:whereClause&gt;
                      &lt;xqx:returnClause&gt;
                        &lt;xqx:pathExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:filterExpr&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
							&lt;/xqx:filterExpr&gt;
                          &lt;/xqx:stepExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                            &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                          &lt;/xqx:stepExpr&gt;
                        &lt;/xqx:pathExpr&gt;
                      &lt;/xqx:returnClause&gt;
                    &lt;/xqx:flworExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg>

        </div3>

        <div3 id="Example2-Transformation">
          <head>Transformation of XQueryX Solution into XQuery</head>

          <p>Application of the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution results in:</p>

          <eg xml:space="preserve">  
&lt;results&gt;{
 let $a:=doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::author
 for $last in distinct-values($a/child::last), $first in distinct-values($a[(./child::last = $last)]/child::first)
 order by $last , $first 
 return &lt;result&gt;&lt;author&gt;&lt;last&gt;{$last}&lt;/last&gt;&lt;first&gt;{$first}&lt;/first&gt;&lt;/author&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (some $ba in $b/child::author satisfies (($ba/child::last = $last) and ($ba/child::first = $first)))
 return $b/child::title
}&lt;/result&gt;
}&lt;/results&gt;
</eg>

        </div3>

      </div2>

      <div2 id="Example3">
        <head>Example 3</head>

        <p>Here is Q7 from the <bibref ref="xquery-use-cases"/>, use case XMP
(Experiences and Exemplars): "List the titles and years of all books published by
Addison-Wesley after 1991, in alphabetic order."</p>
 
        <div3 id="Example3-XQuery">
          <head>XQuery solution in XQuery Use Cases:</head>
 
          <eg xml:space="preserve">
&lt;bib&gt;
  {
    for $b in doc("http://bstore1.example.com/bib.xml")//book
    where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
    order by $b/title
    return
        &lt;book&gt;
            { $b/@year }
            { $b/title }
        &lt;/book&gt;
  }
&lt;/bib&gt; 
</eg>

        </div3>

        <div3 id="Example3-XQueryX">
          <head>A solution in XQueryX:</head>

          <!-- insert exmpl3 here -->
          <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
				     &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
					  &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
						  &lt;/xqx:filterExpr&gt;
						&lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
					  &lt;/xqx:filterExpr&gt;
					&lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
             &lt;xqx:elementConstructor&gt;
               &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
               &lt;xqx:elementContent&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
					 &lt;/xqx:filterExpr&gt;
				   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
					 &lt;/xqx:filterExpr&gt;
				   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
               &lt;/xqx:elementContent&gt;
             &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg>

        </div3>

        <div3 id="Example3-Transformation">
          <head>Transformation of XQueryX Solution into XQuery</head>

          <p>Application of the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution,
we get:</p>

          <eg xml:space="preserve">  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 order by $b/child::title 
 return &lt;book&gt;{$b/attribute::year}{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</eg>

        </div3>

      </div2>

      <div2 id="Example4">
        <head>Example 4</head>

        <p>Here is Q8 from the <bibref ref="xquery-use-cases"/>, use case NS
(Queries Using Namespaces):
"Select all traders (either seller or high bidder) without negative comments."</p>
 
        <div3 id="Example4-XQuery">
          <head>XQuery solution in XQuery Use Cases:</head>
 
          <eg xml:space="preserve">
declare namespace ma = "http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay" 
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  {
    for $s in doc("auction.xml")//ma:Trading_Partners/(ma:Seller | ma:High_Bidder)
    where $s/*:NegativeComments = 0
    return $s
  }
&lt;/Q8&gt;
</eg>

        </div3>

        <div3 id="Example4-XQueryX">
          <head>A solution in XQueryX:</head>

          <!-- insert exmpl4 here -->
          <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
			                    http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:namespaceDecl&gt;
        &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
        &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
      &lt;/xqx:namespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;Q8&lt;/xqx:tagName&gt;
        &lt;xqx:attributeList&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;eachbay&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/auctioneers#eachbay&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;xlink&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.w3.org/1999/xlink&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
        &lt;/xqx:attributeList&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;s&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
	 			      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;auction.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
					  &lt;/xqx:filterExpr&gt;
				    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest xqx:prefix="ma"&gt;Trading_Partners&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:parenthesizedExpr&gt;
                          &lt;xqx:unionOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
 								  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;Seller&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
 								  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;High_Bidder&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:unionOp&gt;
                        &lt;/xqx:parenthesizedExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:equalOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
				      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;s&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
					  &lt;/xqx:filterExpr&gt;
					&lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:Wildcard&gt;
                        &lt;xqx:star/&gt;
                        &lt;xqx:NCName&gt;NegativeComments&lt;/xqx:NCName&gt;
                      &lt;/xqx:Wildcard&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:integerConstantExpr&gt;
                    &lt;xqx:value&gt;0&lt;/xqx:value&gt;
                  &lt;/xqx:integerConstantExpr&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:equalOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;s&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</eg>

        </div3>

        <div3 id="Example4-Transformation">
          <head>Transformation of XQueryX Solution into XQuery</head>

          <p>Application of the stylesheet in <specref ref="Stylesheet"/> to the XQueryX solution results in:</p>

          <eg xml:space="preserve">  
declare namespace ma="http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch" xmlns:eachbay="http://www.example.com/auctioneers#eachbay" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;{
 for $s in fn:doc("auction.xml")/descendant-or-self::node()/child::ma:Trading_Partners/((child::ma:Seller union child::ma:High_Bidder))
 where ($s/child::*:NegativeComments = 0)
 return $s
}&lt;/Q8&gt;
</eg>

        </div3>

      </div2>

    </div1>

    <div1 id="Schema">
      <head>An XML Schema for the XQuery XML Syntax</head>

      <p>Here is the XML Schema for the proposed syntax.</p>

      <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;!--  Readers of this schema are reminded that the default value for both
  minOccurs and maxOccurs is 1. --&gt;
&lt;xsd:schema xmlns="http://www.w3.org/2005/XQueryX"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.w3.org/2005/XQueryX"
            elementFormDefault="qualified" attributeFormDefault="qualified"&gt;

  &lt;!-- A few helper declarations --&gt;
  &lt;xsd:complexType name="emptyContent"/&gt;

  &lt;xsd:element name="NCName" type="xsd:NCName"/&gt;

  &lt;xsd:complexType name="QName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;

  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;

  &lt;!-- A list of expressions --&gt;
  &lt;xsd:complexType name="exprList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="exprWrapperOptional"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- constant expressions. We have 4 different subclasses for this --&gt;
  &lt;xsd:complexType name="constantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:anyType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constantExpr" type="constantExpr" abstract="true" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="integerConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:integer"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="decimalConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:decimal"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalConstantExpr" type="decimalConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="doubleConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:double"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="doubleConstantExpr" type="doubleConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="stringConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stringConstantExpr" type="stringConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;!-- Variables --&gt;
  &lt;xsd:complexType name="varRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="name" type="QName"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varRef" type="varRef" substitutionGroup="expr"/&gt;

  &lt;!-- root and context-item expressions --&gt;
  &lt;!-- rootExpr deleted per Bugzilla Bug #2523 --&gt;
  &lt;xsd:complexType name="contextItemExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemExpr" type="contextItemExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Pragmas and extension expressions --&gt;
  &lt;xsd:element name="pragma"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="pragmaName" type="QName"/&gt;
        &lt;xsd:element name="pragmaContents" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="extensionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="pragma" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="extensionExpr" type="extensionExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="functionCallExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionName" type="QName"/&gt;
          &lt;xsd:element name="arguments" type="exprList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionCallExpr" type="functionCallExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Constructor functions --&gt;
  &lt;xsd:complexType name="constructorFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="typeName" type="QName"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constructorFunctionExpr" type="constructorFunctionExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="sequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="rangeSequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="startExpr" type="exprWrapper"/&gt;
          &lt;xsd:element name="endExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Builtin operator expressions --&gt;
  &lt;xsd:complexType name="operatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="unaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="operand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="firstOperand" type="exprWrapper"/&gt;
          &lt;xsd:element name="secondOperand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="operatorExpr" type="operatorExpr" abstract="true" substitutionGroup="expr"/&gt;

  &lt;xsd:element name="arithmeticOp" type="operatorExpr" abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="addOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="subtractOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="multiplyOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="divOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="idivOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="modOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryMinusOp" type="unaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryPlusOp" type="unaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="valueComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="eqOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="neOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="gtOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="geOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="ltOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="leOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="generalComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="equalOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="notEqualOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="nodeComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="isOp" type="binaryOperatorExpr" substitutionGroup="nodeComparisonOp"/&gt;

  &lt;xsd:element name="orderComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="nodeBeforeOp" type="binaryOperatorExpr" substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="nodeAfterOp" type="binaryOperatorExpr" substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="logicalOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="andOp" type="binaryOperatorExpr" substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="orOp" type="binaryOperatorExpr" substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="setOp" type="binaryOperatorExpr" abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="unionOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="intersectOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="exceptOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;!-- Basic typenames --&gt;
  &lt;xsd:element name="atomicType" type="QName" substitutionGroup="itemType"/&gt;

  &lt;!-- Used in castable expression --&gt;
  &lt;xsd:element name="singleType"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="atomicType"/&gt;
        &lt;xsd:element name="optional" type="emptyContent" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="itemType" abstract="true"/&gt;

  &lt;xsd:complexType name="emptyItemTypeContent"/&gt;

  &lt;xsd:element name="anyItemType" type="emptyItemTypeContent" substitutionGroup="itemType"/&gt;

  &lt;xsd:simpleType name="occurrenceIndicator"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="?"/&gt;
      &lt;xsd:enumeration value="*"/&gt;
      &lt;xsd:enumeration value="+"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="sequenceType"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="voidSequenceType" type="emptyContent"/&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="itemType"/&gt;
        &lt;xsd:element name="occurrenceIndicator" type="occurrenceIndicator" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceType" type="sequenceType"/&gt;

  &lt;xsd:element name="typeDeclaration" type="sequenceType"/&gt;

  &lt;!-- Represents a "typed" variable (for clause, let clause etc) --&gt;
  &lt;xsd:element name="typedVariableBinding"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="positionalVariableBinding" type="QName"/&gt;

  &lt;xsd:element name="variableBinding" type="QName"/&gt;

  &lt;xsd:element name="forClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element ref="positionalVariableBinding" minOccurs="0"/&gt;
        &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="forClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="forClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;

  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;

  &lt;xsd:simpleType name="emptyOrderingMode"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="empty greatest"/&gt;
      &lt;xsd:enumeration value="empty least"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:simpleType name="orderingKind"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="ascending"/&gt;
      &lt;xsd:enumeration value="descending"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="orderModifier"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="orderingKind" type="orderingKind" minOccurs="0"/&gt;
        &lt;xsd:element name="emptyOrderingMode" type="emptyOrderingMode" minOccurs="0"/&gt;
        &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="orderBySpec"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="orderByExpr" type="exprWrapper"/&gt;
        &lt;xsd:element ref="orderModifier" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="orderByClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="stable" type="emptyContent" minOccurs="0"/&gt;
        &lt;xsd:element ref="orderBySpec" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- This is the flwor expression --&gt;
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice maxOccurs="unbounded"&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element ref="whereClause" minOccurs="0"/&gt;
          &lt;xsd:element ref="orderByClause" minOccurs="0"/&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;!-- conditional expressions --&gt;
  &lt;xsd:complexType name="ifThenElseExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ifClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="thenClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="elseClause" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ifThenElseExpr" type="ifThenElseExpr" substitutionGroup="expr"/&gt;

  &lt;!-- The following clauses describe quantified expressions --&gt;
  &lt;xsd:simpleType name="quantifier"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="some"/&gt;
      &lt;xsd:enumeration value="every"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="quantifiedExprInClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element name="sourceExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="quantifiedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="quantifier" type="quantifier"/&gt;
          &lt;xsd:element ref="quantifiedExprInClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="predicateExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExpr" type="quantifiedExpr" substitutionGroup="expr"/&gt;

  &lt;!-- handle the typeswitch construct --&gt;
  &lt;!-- Note: no substitutionGroup as we cannot use this anywhere --&gt;
  &lt;xsd:element name="typeswitchExprCaseClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="expr"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
            &lt;xsd:element ref="typeDeclaration"/&gt;
            &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- Note: no substitutionGroup as we cannot use this anywhere --&gt;
  &lt;xsd:element name="typeswitchExprDefaultClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="expr"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
            &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="typeswitchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="typeswitchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="typeswitchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExpr" type="typeswitchExpr" substitutionGroup="expr"/&gt;

  &lt;!-- instance-of expressions --&gt;
  &lt;xsd:complexType name="instanceOfExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="instanceOfExpr" type="instanceOfExpr" substitutionGroup="expr"/&gt;

  &lt;!-- treat-as expressions --&gt;
  &lt;xsd:complexType name="treatExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="treatExpr" type="treatExpr" substitutionGroup="expr"/&gt;

  &lt;!-- castable and cast expressions --&gt;
  &lt;xsd:complexType name="castableExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castableExpr" type="castableExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="castExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castExpr" type="castExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Validate expressions --&gt;
  &lt;xsd:simpleType name="validationMode"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="lax"/&gt;
      &lt;xsd:enumeration value="strict"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="validateExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="validationMode" type="validationMode" minOccurs="0"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="validateExpr" type="validateExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Direct constructors. Only elementConstructor for now --&gt;
  &lt;!-- Note the absence of constructors corresponding to
       the directCommentConstructor and the directPIConstructor
       productions in the XQuery grammar. This is because they are
       trivially identical to the computed variants
    --&gt;

  &lt;!-- attributeConstructor is no longer a subclass of expr --&gt;
  &lt;xsd:complexType name="attributeConstructor"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="attributeName" type="QName"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="attributeValueExpr" type="exprList"/&gt;
        &lt;xsd:element name="attributeValue" type="xsd:string"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="namespaceDeclaration"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeList"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice maxOccurs="unbounded"&gt;
          &lt;xsd:element name="attributeConstructor" type="attributeConstructor"/&gt;
          &lt;xsd:element name="namespaceDeclaration" type="namespaceDeclaration"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="elementContent" type="exprList"/&gt;

  &lt;xsd:complexType name="elementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tagName" type="QName"/&gt;
          &lt;xsd:element ref="attributeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="elementContent" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementConstructor" type="elementConstructor" substitutionGroup="expr"/&gt;

  &lt;!-- computed constructors --&gt;
  &lt;xsd:complexType name="computedElementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="QName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="contentExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedElementConstructor" type="computedElementConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedAttributeConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="QName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="valueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedAttributeConstructor" type="computedAttributeConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedDocumentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedDocumentConstructor" type="computedDocumentConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedTextConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedTextConstructor" type="computedTextConstructor" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedCommentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedCommentConstructor" type="computedCommentConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedPIConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName"/&gt;
            &lt;xsd:element name="piTargetExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="piValueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedPIConstructor" type="computedPIConstructor" substitutionGroup="expr"/&gt;

  &lt;!-- ordered and unordered expressions --&gt;
  &lt;xsd:complexType name="unorderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="unorderedExpr" type="unorderedExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="orderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderedExpr" type="orderedExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="simpleWildcard"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="QName" type="QName"/&gt;
      &lt;xsd:element name="star" type="emptyContent"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="Wildcard"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:all&gt;
        &lt;xsd:element name="star" type="emptyContent" minOccurs="0"/&gt;
        &lt;xsd:element ref="NCName" minOccurs="0"/&gt;
      &lt;/xsd:all&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="schemaAttributeTest" type="QName" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="attributeTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
         &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
            &lt;xsd:element name="attributeName" type="simpleWildcard"/&gt;
            &lt;xsd:element name="typeName" type="QName" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
         &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="anyElementTest" abstract="true" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="schemaElementTest" type="QName" substitutionGroup="anyElementTest"/&gt;

  &lt;xsd:element name="elementTest" substitutionGroup="anyElementTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
            &lt;xsd:element name="elementName" type="simpleWildcard"/&gt;
            &lt;xsd:sequence minOccurs="0"&gt;
              &lt;xsd:element name="typeName" type="QName"/&gt;
              &lt;xsd:element name="nillable" type="emptyContent" minOccurs="0"/&gt;
            &lt;/xsd:sequence&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="documentTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence&gt;
             &lt;xsd:element ref="anyElementTest" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="piTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;xsd:element name="nameTest" type="QName"/&gt;

  &lt;xsd:element name="kindTest" substitutionGroup="itemType"/&gt;

  &lt;xsd:element name="textTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="commentTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="anyKindTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="xpathAxis"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="child"/&gt;
        &lt;xsd:enumeration value="attribute"/&gt;
        &lt;xsd:enumeration value="self"/&gt;
        &lt;xsd:enumeration value="parent"/&gt;
        &lt;xsd:enumeration value="descendant-or-self"/&gt;
        &lt;xsd:enumeration value="descendant"/&gt;
        &lt;xsd:enumeration value="following"/&gt;
        &lt;xsd:enumeration value="following-sibling"/&gt;
        &lt;xsd:enumeration value="ancestor"/&gt;
        &lt;xsd:enumeration value="ancestor-or-self"/&gt;
        &lt;xsd:enumeration value="preceding"/&gt;
        &lt;xsd:enumeration value="preceding-sibling"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="parenthesizedExpr" type="exprWrapperOptional"/&gt;


  &lt;xsd:group name="filterExpr"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="constantExpr"/&gt;
      &lt;xsd:element ref="varRef"/&gt;
      &lt;xsd:element ref="contextItemExpr"/&gt;
      &lt;xsd:element ref="functionCallExpr"/&gt;
      &lt;xsd:element ref="parenthesizedExpr"/&gt;
      &lt;xsd:element ref="elementConstructor"/&gt;
      &lt;xsd:element ref="computedElementConstructor"/&gt;
      &lt;xsd:element ref="computedAttributeConstructor"/&gt;
      &lt;xsd:element ref="computedDocumentConstructor"/&gt;
      &lt;xsd:element ref="computedTextConstructor"/&gt;
      &lt;xsd:element ref="computedCommentConstructor"/&gt;
      &lt;xsd:element ref="computedPIConstructor"/&gt;
      &lt;xsd:element ref="orderedExpr"/&gt;
      &lt;xsd:element ref="unorderedExpr"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;

  &lt;!-- removed nameTest and Wildcard outer choices per Bugzilla Bug #2523 --&gt;
  &lt;xsd:element name="stepExpr"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="xpathAxis"/&gt;
            &lt;xsd:choice&gt;
              &lt;xsd:element ref="kindTest"/&gt;
              &lt;xsd:element ref="nameTest"/&gt;
              &lt;xsd:element ref="Wildcard"/&gt;
             &lt;/xsd:choice&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element name="filterExpr"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:group ref="filterExpr"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- rewrote pathExpr definition per Bugzilla Bug #2523 --&gt;
  &lt;xsd:complexType name="pathExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="rootExpr" type="emptyContent"/&gt;
            &lt;xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element ref="stepExpr" maxOccurs="unbounded"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/&gt;

  &lt;!-- The following constructs deal with the query prolog --&gt;
  &lt;xsd:element name="module"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="versionDecl" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element ref="mainModule"/&gt;
          &lt;xsd:element ref="libraryModule"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="mainModule"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
        &lt;xsd:element name="queryBody" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="namespaceDeclType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namespaceDecl" type="namespaceDeclType"/&gt;

  &lt;xsd:element name="moduleDecl" type="namespaceDeclType"/&gt;

  &lt;xsd:element name="libraryModule"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="moduleDecl"/&gt;
        &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="versionDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="version" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="prolog"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="defaultCollationDecl"/&gt;
          &lt;xsd:element ref="baseUriDecl"/&gt;
          &lt;xsd:element ref="constructionDecl"/&gt;
          &lt;xsd:element ref="orderingModeDecl"/&gt;
          &lt;xsd:element ref="emptyOrderingDecl"/&gt;
          &lt;xsd:element ref="copyNamespacesDecl"/&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="defaultNamespaceDecl"/&gt;
          &lt;xsd:element ref="namespaceDecl"/&gt;
          &lt;xsd:element ref="schemaImport"/&gt;
          &lt;xsd:element ref="moduleImport"/&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="varDecl"/&gt;
          &lt;xsd:element ref="functionDecl"/&gt;
          &lt;xsd:element ref="optionDecl"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="defaultCollationDecl" type="xsd:string"/&gt;

  &lt;xsd:element name="baseUriDecl" type="xsd:string"/&gt;

  &lt;xsd:element name="orderingModeDecl"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="ordered"/&gt;
        &lt;xsd:enumeration value="unordered"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="emptyOrderingDecl" type="emptyOrderingMode"/&gt;

  &lt;xsd:element name="constructionDecl"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="strip"/&gt;
        &lt;xsd:enumeration value="preserve"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="copyNamespacesDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="preserveMode"&gt;
          &lt;xsd:simpleType&gt;
            &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
              &lt;xsd:enumeration value="preserve"/&gt;
              &lt;xsd:enumeration value="no-preserve"/&gt;
            &lt;/xsd:restriction&gt;
          &lt;/xsd:simpleType&gt;
        &lt;/xsd:element&gt;
        &lt;xsd:element name="inheritMode"&gt;
          &lt;xsd:simpleType&gt;
            &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
              &lt;xsd:enumeration value="inherit"/&gt;
              &lt;xsd:enumeration value="no-inherit"/&gt;
            &lt;/xsd:restriction&gt;
          &lt;/xsd:simpleType&gt;
        &lt;/xsd:element&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:simpleType name="defaultNamespaceCategory"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="function"/&gt;
      &lt;xsd:enumeration value="element"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="defaultNamespaceDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="defaultNamespaceCategory" type="defaultNamespaceCategory"/&gt;
        &lt;xsd:element name="uri" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="varDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
          &lt;xsd:element name="external" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="optionDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="optionName" type="QName"/&gt;
        &lt;xsd:element name="optionContents" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="param"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="paramList"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="param" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="functionDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="functionName" type="QName"/&gt;
        &lt;xsd:element ref="paramList"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
          &lt;xsd:element name="externalDefinition" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="moduleImport"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="namespacePrefix" type="xsd:NCName" minOccurs="0"/&gt;
        &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
        &lt;xsd:element name="targetLocation" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="schemaImport"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0"&gt;
          &lt;xsd:element name="namespacePrefix" type="xsd:NCName"/&gt;
          &lt;xsd:element name="defaultElementNamespace" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
        &lt;xsd:element name="targetLocation" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- The element below handles the trivial XQuery embedding --&gt;
  &lt;xsd:element name="xquery" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;
</eg>

    </div1>

    <div1 id="TrivialEmbedding">
      <head>A Trivial Embedding of XQuery</head>
      <p>
        <specref ref="Introduction"/> observed that the
<bibref ref="xquery-requirements"/> says <quote>The XML Query Language MAY have
more than one syntax binding. One query language syntax MUST be convenient for
humans to read and write. One query language syntax MUST be expressed in XML in
a way that reflects the underlying structure of the query.</quote>
There are many possible ways to define an XML syntax for XQuery. 
This document specifies two XML Syntaxes for XQuery: 
the one in <specref ref="Schema"/> and the <quote>trivial embedding</quote>
defined in this section. 
Of course, XQueries could be expressed in XML Syntax in other ways.</p>

      <p>The trivial embedding specified here can be used when an
      XQuery is exchanged with other entities as XML or embedded
      in an XML document, and when it is not necessary to communicate
      the underlying structure of the query. 
      When this alternative is chosen, the XQuery expression is treated
      as though it were ordinary text. </p>

      <p>The trivial embedding defined in this specification requires that the
entire query be enclosed within an element named "xquery" in the XQueryX namespace
(the "xqx:" namespace prefix is used here only for the purposes of this example),
as illustrated here:</p>

      <eg xml:space="preserve">&lt;xqx:xquery&gt;for $i... let $j...where $x = $y...return...&lt;/xqx:xquery&gt;</eg>

<!-- Response to Bugzilla bug #2611 -->
<p>
XQuery expressions are, for the purposes of this trivial embedding, treated 
as literal text. Therefore, if the XQuery contains characters that are 
prohibited in XML text (specifically &lt; and &amp;), they must be "escaped" as 
character entity references (&amp;lt; and &amp;amp;, respectively) or as numeric 
character references (for example, &amp;#x3C; and &amp;#x26;, respectively), or 
they must be enclosed in a CDATA section (for example, &lt;![CDATA[&lt;]] or 
&lt;![CDATA[&amp;]]).  Note that this includes the leading "&lt;" of a CDATA section 
that appears in the original XQuery expression.  In addition, because the 
sequence of characters "]]&gt;" is always prohibited within element content,
it is recommended that instances of &gt; in the original XQuery always be 
"escaped" (for example, as &amp;gt;, &amp;#x3E;, or &lt;![CDATA[&gt;]]).
</p>

      <eg xml:space="preserve">&lt;xqx:xquery&gt;for $i... let $j...where $x &amp;lt; $y...return...&lt;/xqx:xquery&gt;</eg>

      <p>or</p>

      <eg xml:space="preserve">&lt;xqx:xquery&gt;for $i... let $j...where $x &amp;x003C; $y...return...&lt;/xqx:xquery&gt;</eg>

      <p>This limitation may require that user agents scan the XQuery text, escaping such
prohibited characters, before transmitting or embedding the XQuery as XML. </p>

<!-- Response to Bugzilla bug #2611 -->
<!-- Response to Bugzilla bug #3056 -->
      <p>The following two more complete examples (which are equivalent to one another
      and to "<code>for $i in (1 to 5) let $j := 4 where $i &lt; $j return
  &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;</code>") further illustrate the use of the
         XQueryX trivial embedding. </p>

      <eg xml:space="preserve">&lt;xqx:xquery&gt;for $i in (1 to 5) let $j := 4 where $i &amp;lt; $j return
  &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;&lt;/xqx:xquery&gt;

&lt;xqx:xquery&gt;&lt;![CDATA[for $i in (1 to 5) let $j := 4 where $i &lt; $j
  return &lt;x&gt;&lt;i&gt;{$i}&lt;/i&gt;&lt;/x&gt;]]&gt;&lt;/xqx:xquery&gt;</eg>

    </div1>

    <div1 id="xqx_conformance">
      <head>Conformance</head>

      <p>This section defines the conformance criteria for an XQueryX processor
         (see Figure 1, "Processing Model Overview", in <bibref ref="xquery"/>,
         <xspecref spec="XQ" ref="id-processing-model"/>. 
      </p>

      <p>In this section, the following terms are used to indicate the
         requirement levels defined in <bibref ref="RFC2119"/>. 
         [Definition: MUST means that the item is an absolute requirement of the specification.]
         [Definition: SHOULD means that there may exist valid reasons in particular
         circumstances to ignore a particular item, but the full implications
         must be understood and carefully weighed before choosing a different course.]
         [Definition: MAY means that an item is truly optional.] </p>

      <p>An XQueryX processor that claims to conform to this specification MUST
         implement the XQueryX syntax as defined in <specref ref="Schema"/> of this
         specification and include a claim of Minimal Conformance as defined in
         <bibref ref="xquery"/>, <xspecref spec="XQ" ref="id-minimal-conformance"/>. 
         In addition to a claim of Minimal Conformance, it MAY claim conformance to
         one or more optional features defined in
         <bibref ref="xquery"/>, <xspecref spec="XQ" ref="id-conform-optional-features"/>. </p>

    </div1>

  </body>

  <back>

    <div1 id="biblio">
      <head>References</head>

<!-- Checked 2004-12-28, Jim Melton; updated dates of XQuery and Formal Semantics -->
<!-- RFC refs changed per re-opened Bugzilla bug #1345 -->
      <blist>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-requirements" key="XML Query 1.0 Requirements" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery" key="XQuery 1.0: An XML Query Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-use-cases" key="XML Query Use Cases" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-semantics" key="XQuery 1.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. 
		  <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. 
		  See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3023" key="RFC 3023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Murata, S. St. Laurent, and D. Kohn. 
		  <emph>XML Media Types</emph> IETF RFC 3023 or its successors. 
		  See <loc href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3023.txt</loc>.</bibl>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC 3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and L. Masinter. 
		  <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986. 
		  See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>
      </blist>

    </div1>

    <div1 id="Stylesheet">

      <head>Transforming XQueryX to XQuery</head>

      <p>The following stylesheet converts from XQueryX syntax to XML Query syntax. 
Note the intent of the stylesheet is to produce <emph>a</emph> valid XQuery with the
same semantics as the input XQueryX.</p>

      <eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Note that this stylesheet frequently invokes templates for
     specified elements, even when there are no templates in the
     stylesheet whose match="" attribute identifies those elements.
     In such case, the default template's element matching template
     is invoked, which merely invokes xsl:apply-templates --&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:preserve-space elements="xqx:value xqx:attributeValue xqx:piValue xqx:pragmaContents xqx:collation
                                xqx:uri xqx:defaultCollationDecl xqx:baseUriDecl xqx:optionContents
                                xqx:targetNamespace xqx:targetLocation xqx:xquery"/&gt;

  &lt;xsl:variable name="DOT" select="'.'"/&gt;
  &lt;xsl:variable name="SPACE" select="' '"/&gt;
  &lt;xsl:variable name="SLASH" select="'/'"/&gt;
  &lt;xsl:variable name="SLASH_SLASH" select="'//'"/&gt;
  &lt;xsl:variable name="LESSTHAN" select="'&amp;lt;'"/&gt;
  &lt;xsl:variable name="GREATERTHAN" select="'&amp;gt;'"/&gt;
  &lt;xsl:variable name="LPAREN" select="'('"/&gt;
  &lt;xsl:variable name="RPAREN" select="')'"/&gt;
  &lt;xsl:variable name="NEWLINE"&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="COMMA" select="','"/&gt;
  &lt;xsl:variable name="COMMA_SPACE" select="', '"/&gt;
  &lt;xsl:variable name="COMMA_NEWLINE"&gt;&lt;xsl:text&gt;,
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="QUOTE"&gt;&lt;xsl:text&gt;'&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="DOUBLEQUOTE"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="TO" select="' to '"/&gt;
  &lt;xsl:variable name="LBRACE" select="'{'"/&gt;
  &lt;xsl:variable name="RBRACE" select="'}'"/&gt;
  &lt;xsl:variable name="LBRACKET" select="'['"/&gt;
  &lt;xsl:variable name="RBRACKET" select="']'"/&gt;
  &lt;xsl:variable name="DOLLAR" select="'$'"/&gt;
  &lt;xsl:variable name="MINUS" select="'-'"/&gt;
  &lt;xsl:variable name="PLUS" select="'+'"/&gt;
  &lt;xsl:variable name="EQUAL" select="'='"/&gt;
  &lt;xsl:variable name="COLON" select="':'"/&gt;
  &lt;xsl:variable name="DOUBLE_COLON" select="'::'"/&gt;
  &lt;xsl:variable name="SEMICOLON" select="';'"/&gt;
  &lt;xsl:variable name="AT" select="'@'"/&gt;
  &lt;xsl:variable name="STAR" select="'*'"/&gt;
  &lt;xsl:variable name="QUESTIONMARK" select="'?'"/&gt;
  &lt;xsl:variable name="ASSIGN" select="':='"/&gt;
  &lt;xsl:variable name="SEPARATOR" select="';'"/&gt;
  &lt;xsl:variable name="PRAGMA_BEGIN" select="'(# '"/&gt;
  &lt;xsl:variable name="PRAGMA_END" select="' #)'"/&gt;


  &lt;xsl:template name="delimitedList"&gt;
    &lt;xsl:param name="delimiter" /&gt;
    &lt;xsl:param name="leftEncloser"/&gt;
    &lt;xsl:param name="rightEncloser" /&gt;
    &lt;xsl:param name="selector"&gt;&lt;/xsl:param&gt;

    &lt;xsl:value-of select="$leftEncloser"/&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not (position()=last())"&gt;         
        &lt;xsl:value-of select="$delimiter"/&gt;
      &lt;/xsl:if&gt;        
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$rightEncloser"/&gt;
  &lt;/xsl:template&gt;    


  &lt;xsl:template name="parenthesizedList"&gt;
    &lt;xsl:param name="delimiter" select="$COMMA_SPACE"/&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter" select="$delimiter" /&gt;
      &lt;xsl:with-param name="leftEncloser" select="$LPAREN"/&gt;
      &lt;xsl:with-param name="rightEncloser" select="$RPAREN"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="commaSeparatedList"&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter"&gt;
        &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="quote"&gt;
    &lt;xsl:param name="item"/&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
    &lt;xsl:call-template name="globalReplace"&gt;
      &lt;xsl:with-param name="stringToBeFixed"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:value-of select="$item"/&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced"&gt;&amp;amp;&lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;amp;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;""&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="globalReplace"&gt;
    &lt;xsl:param name="stringToBeFixed"/&gt;
    &lt;xsl:param name="toBeReplaced"/&gt;
    &lt;xsl:param name="replacement"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="contains($stringToBeFixed, $toBeReplaced)"&gt;
        &lt;xsl:value-of select="concat(substring-before($stringToBeFixed, $toBeReplaced), $replacement)"/&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed" select="substring-after($stringToBeFixed, $toBeReplaced)"/&gt;
          &lt;xsl:with-param name="toBeReplaced" select="$toBeReplaced"/&gt;
          &lt;xsl:with-param name="replacement" select="$replacement"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$stringToBeFixed"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:QName | xqx:pragmaName | xqx:typeName | xqx:varName |
                       xqx:functionName | xqx:optionName |
                       xqx:atomicType | xqx:tagName"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@xqx:prefix='xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to have prefix 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@xqx:prefix"&gt;
        &lt;xsl:value-of select="@xqx:prefix"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test=". = 'xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to be 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:NCName"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rootExpr"&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:contextItemExpr"&gt;
    &lt;xsl:value-of select="$DOT"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stringConstantExpr"&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:value"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:integerConstantExpr
      | xqx:decimalConstantExpr
      | xqx:doubleConstantExpr"&gt;
    &lt;xsl:value-of select="xqx:value"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varRef"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="xqx:name/@xqx:prefix"&gt;
      &lt;xsl:value-of select="xqx:name/@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="xqx:name"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:pragma"&gt;
    &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
    &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
    &lt;xsl:value-of select="$PRAGMA_END"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:extensionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:pragma"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;

&lt;!-- Response to Bugzilla bug #2528 --&gt;
   &lt;xsl:template match="xqx:functionCallExpr"&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="xqx:functionName/@xqx:prefix"&gt;
         &lt;xsl:value-of select="xqx:functionName/@xqx:prefix"/&gt;
         &lt;xsl:value-of select="$COLON"/&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
         &lt;xsl:if test="xqx:functionName = 'node' or
                       xqx:functionName = 'document-node' or
                       xqx:functionName = 'element' or
                       xqx:functionName = 'attribute' or
                       xqx:functionName = 'schema-element' or
                       xqx:functionName = 'schema-attribute' or
                       xqx:functionName = 'processing-instruction' or
                       xqx:functionName = 'comment' or
                       xqx:functionName = 'text' or
                       xqx:functionName = 'item' or
                       xqx:functionName = 'if' or
                       xqx:functionName = 'typeswitch' or
                       xqx:functionName = 'empty-sequence'"&gt;
           &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
           &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
         &lt;/xsl:if&gt;
       &lt;/xsl:otherwise&gt;
     &lt;/xsl:choose&gt;
     &lt;xsl:value-of select="xqx:functionName"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="xqx:arguments"&gt;
         &lt;xsl:for-each select="xqx:arguments"&gt;
           &lt;xsl:call-template name="parenthesizedList"/&gt;
         &lt;/xsl:for-each&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
         &lt;xsl:value-of select="$LPAREN"/&gt;
         &lt;xsl:value-of select="$RPAREN"/&gt;
       &lt;/xsl:otherwise&gt;
     &lt;/xsl:choose&gt;
   &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:constructorFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;xsl:for-each select="xqx:argExpr"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unaryMinusOp | xqx:unaryPlusOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unaryPlusOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:unaryMinusOp"&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:operand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:addOp | xqx:subtractOp | xqx:multiplyOp
                     | xqx:divOp | xqx:idivOp | xqx:modOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:addOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:subtractOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:multiplyOp"&gt;&lt;xsl:value-of select="$STAR"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:divOp"&gt;&lt;xsl:text&gt; div &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:idivOp"&gt;&lt;xsl:text&gt; idiv &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:modOp"&gt;&lt;xsl:text&gt; mod &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:eqOp | xqx:neOp | xqx:ltOp
                     | xqx:gtOp | xqx:leOp | xqx:geOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:eqOp"&gt;&lt;xsl:text&gt; eq &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:neOp"&gt;&lt;xsl:text&gt; ne &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:ltOp"&gt;&lt;xsl:text&gt; lt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:gtOp"&gt;&lt;xsl:text&gt; gt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:leOp"&gt;&lt;xsl:text&gt; le &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:geOp"&gt;&lt;xsl:text&gt; ge &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:equalOp | xqx:notEqualOp | xqx:lessThanOp
                     | xqx:greaterThanOp | xqx:lessThanOrEqualOp | xqx:greaterThanOrEqualOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:equalOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:notEqualOp"&gt;
         &lt;xsl:text&gt; !&lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:isOp | xqx:nodeBeforeOp | xqx:nodeAfterOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:isOp"&gt;&lt;xsl:text&gt; is &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeBeforeOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeAfterOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:andOp | xqx:orOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:andOp"&gt;&lt;xsl:text&gt; and &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:orOp"&gt;&lt;xsl:text&gt; or &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unionOp | xqx:intersectOp | xqx:exceptOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unionOp"&gt;&lt;xsl:text&gt; union &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:intersectOp"&gt;&lt;xsl:text&gt; intersect &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:exceptOp"&gt;&lt;xsl:text&gt; except &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceExpr"&gt;
    &lt;xsl:for-each select="."&gt;
      &lt;xsl:call-template name="parenthesizedList"&gt;
        &lt;xsl:with-param name="delimiter" select="$COMMA_NEWLINE"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rangeSequenceExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:startExpr"/&gt;
    &lt;xsl:value-of select="$TO"/&gt;
    &lt;xsl:apply-templates select="xqx:endExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:forClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:forClauseItem"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:positionalVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:forExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:letClauseItem"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:apply-templates select="xqx:letExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:letClause"&gt;
    &lt;xsl:text&gt; let &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:returnClause"&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:whereClause"&gt;
    &lt;xsl:text&gt; where &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:collation"&gt;
    &lt;xsl:text&gt; collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingMode"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingKind"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderModifier"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderBySpec"&gt;
    &lt;xsl:apply-templates select="xqx:orderByExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:orderModifier"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderByClause"&gt;
    &lt;xsl:if test="xqx:stable"&gt;
      &lt;xsl:text&gt; stable&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt; order by &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:orderBySpec[1]"/&gt;
    &lt;xsl:for-each select="xqx:orderBySpec[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:flworExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:ifThenElseExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; if &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:ifClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:text&gt; then &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:thenClause"/&gt;
    &lt;xsl:text&gt; else &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:elseClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:positionalVariableBinding"&gt;
    &lt;xsl:text&gt; at &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:variableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typedVariableBinding" name="typedVariableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExprInClause"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sourceExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="xqx:quantifier"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:quantifiedExprInClause[1]"/&gt;
    &lt;xsl:for-each select="xqx:quantifiedExprInClause[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:text&gt; satisfies &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:predicateExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:instanceOfExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; instance of &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; cast as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castableExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; castable as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:treatExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; treat as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprCaseClause"&gt;
    &lt;xsl:text&gt; case &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprDefaultClause"&gt;
    &lt;xsl:text&gt; default &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;typeswitch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:validateExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; validate &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:validationMode"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:xpathAxis"&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$DOUBLE_COLON"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:predicates"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:value-of select="$LBRACKET"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$RBRACKET"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:star"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[*]"&gt;
    &lt;xsl:apply-templates select="*[1]"/&gt;
    &lt;xsl:if test="*[2]"&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
      &lt;xsl:apply-templates select="*[2]"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[not(*)]"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="simpleWildcard" match="xqx:simpleWildcard"&gt;
    &lt;xsl:apply-templates select="xqx:star"/&gt;
    &lt;xsl:apply-templates select="xqx:QName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:textTest"&gt;
    &lt;xsl:text&gt;text()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:commentTest"&gt;
    &lt;xsl:text&gt;comment()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyKindTest"&gt;
    &lt;xsl:text&gt;node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTest"&gt;
    &lt;xsl:text&gt;processing-instruction&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:documentTest"&gt;
    &lt;xsl:text&gt;document-node&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:nameTest"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeTest"&gt;
    &lt;xsl:text&gt;attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:attributeName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementTest"&gt;
    &lt;xsl:text&gt;element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:elementName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:nillable"&gt;
      &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaElementTest"&gt;
    &lt;xsl:text&gt;schema-element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaAttributeTest"&gt;
    &lt;xsl:text&gt;schema-attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- rewrote test expression per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:stepExpr"&gt;
    &lt;xsl:if test="preceding-sibling::xqx:stepExpr"&gt;
      &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:parenthesizedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;&lt;xsl:apply-templates/&gt;&lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:filterExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- rewrote pathExpr template per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:pathExpr"&gt;
    &lt;xsl:apply-templates select="xqx:rootExpr | xqx:stepExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeConstructor"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeName"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:attributeValue"&gt;
        &lt;xsl:call-template name="quote"&gt;
          &lt;xsl:with-param name="item"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="globalReplace"&gt;
                  &lt;xsl:with-param name="stringToBeFixed"&gt;
                    &lt;xsl:value-of select="xqx:attributeValue"/&gt;
                  &lt;/xsl:with-param&gt;
                  &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                  &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;{{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;}}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
        &lt;xsl:for-each select="./xqx:attributeValueExpr/xqx:*"&gt;
          &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:namespaceDeclaration"&gt;
    &lt;xsl:text&gt; xmlns&lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:prefix"&gt;
      &lt;xsl:text&gt;:&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:attributeList"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementContent"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
         &lt;xsl:value-of select="$LBRACE"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
         &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementConstructor"&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeList"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:elementContent"/&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tagNameExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedElementConstructor"&gt;
    &lt;xsl:text&gt; element &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:contentExpr"/&gt;     
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedAttributeConstructor"&gt;
    &lt;xsl:text&gt; attribute &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:valueExpr"/&gt;     
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedDocumentConstructor"&gt;
    &lt;xsl:text&gt; document {&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; }&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedTextConstructor"&gt;
    &lt;xsl:text&gt; text&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedCommentConstructor"&gt;
    &lt;xsl:text&gt; comment&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTargetExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piValueExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedPIConstructor"&gt;
    &lt;xsl:text&gt; processing-instruction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:piTarget"/&gt;
    &lt;xsl:apply-templates select="xqx:piTargetExpr"/&gt;
    &lt;xsl:apply-templates select="xqx:piValueExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unorderedExpr"&gt;
    &lt;xsl:text&gt; unordered&lt;/xsl:text&gt;
	&lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderedExpr"&gt;
    &lt;xsl:text&gt; ordered&lt;/xsl:text&gt;
	&lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:versionDecl"&gt;
    &lt;xsl:text&gt; xquery version &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:version"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDecl"&gt;
    &lt;xsl:text&gt;declare namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultNamespaceDecl"&gt;
    &lt;xsl:text&gt; declare default &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:defaultNamespaceCategory"/&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultCollationDecl"&gt;
    &lt;xsl:text&gt; declare default collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:baseUriDecl"&gt;
    &lt;xsl:text&gt; declare base-uri &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:constructionDecl"&gt;
    &lt;xsl:text&gt; declare construction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingModeDecl"&gt;
    &lt;xsl:text&gt; declare ordering &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingDecl"&gt;
    &lt;xsl:text&gt; declare default order &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:copyNamespacesDecl"&gt;
    &lt;xsl:text&gt; declare copy-namespaces &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:preserveMode"/&gt;
    &lt;xsl:value-of select="$COMMA"/&gt;
    &lt;xsl:value-of select="xqx:inheritMode"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:optionDecl"&gt;
    &lt;xsl:text&gt; declare option &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:optionName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:optionContents"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:voidSequenceType"&gt;
    &lt;xsl:text&gt;empty-sequence()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:occurrenceIndicator"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyItemType"&gt;
    &lt;xsl:text&gt;item()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceType"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:singleType"&gt;
    &lt;xsl:apply-templates select="xqx:atomicType"/&gt;
    &lt;xsl:if test="xqx:optional"&gt;
      &lt;xsl:text&gt;?&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeDeclaration"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varDecl"&gt;
    &lt;xsl:text&gt; declare variable &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaImport"&gt;
    &lt;xsl:text&gt; import schema &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:defaultElementNamespace"&gt;
      &lt;xsl:text&gt; default element namespace &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:if test="xqx:targetLocation"&gt;
      &lt;xsl:text&gt; at &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:targetLocation"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:moduleImport"&gt;
    &lt;xsl:text&gt; import module &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:if test="xqx:targetLocation"&gt;
      &lt;xsl:text&gt; at &lt;/xsl:text&gt;
      &lt;xsl:call-template name="quote"&gt;
        &lt;xsl:with-param name="item" select="xqx:targetLocation"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:param"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionBody"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionDecl"&gt;
    &lt;xsl:text&gt; declare function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
    &lt;xsl:if test="xqx:externalDefinition"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:queryBody"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:moduleDecl"&gt;
    &lt;xsl:text&gt; module namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri" /&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:prolog"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SEPARATOR"/&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:libraryModule"&gt;
    &lt;xsl:apply-templates select="xqx:moduleDecl"/&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:mainModule"&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
    &lt;xsl:apply-templates select="xqx:queryBody"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:module" priority="2"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="/xqx:*"&gt;
   &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: The only top-level element permitted is xqx:module&lt;/xsl:message&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</eg>

    </div1>

<!-- Insert the appendix for the MIME type for XQueryX here -->


<div1 role="xqueryx" id="xqueryx-id-mime-type">
  <head>The <code>application/xquery+xml</code> Media Type</head>

  <p>This Appendix specifies the media type for XQueryX Version 1.0.  XQueryX is
    the XML syntax of a language, XQuery, for querying over
    data from XML data sources, as specified in <bibref ref="xquery"/>.</p>


  <div2 id="xqueryx-mime-introduction">
    <head>Introduction</head>

    <p>
      This document, together with its normative references, defines the
      XML syntax for the XML Query language XQuery Version 1.0. 
      This Appendix specifies the <code>application/xquery+xml</code> media type,
      which is intended to be used for transmitting queries expressed in the
      XQueryX syntax.</p>

<!-- Changed "document" to "media type" per Liam Quin -->
	<p>
	  This media type is being submitted to the IESG for review, approval, and registration with IANA. </p>

    <p>This document was prepared by members of the W3C XML Query Working
      Group.  Please send comments to public-qt-comments@w3.org,
      a public mailing list with archives at
      <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments</loc>.</p></div2>


  <div2 id="xqueryx-mime-registration">
    <head>Registration of MIME Media Type <code>application/xquery+xml</code></head>

    <p>MIME media type name:  <code>application</code></p>

    <p>MIME subtype name:    <code>xquery+xml</code></p>

    <p>Required parameters:  none</p>

    <p>Optional parameters: <code>charset</code></p>

    <p>This parameter has identical semantics to the
    charset parameter of the application/xml media type as specified in [RFC 3023].</p>


    <div3 id="xqueryx-mime-encoding">
      <head>Encoding Considerations</head>

      <p>The considerations as specified in [RFC 3023] also
      hold for 'application/xquery+xml'. </p>

    </div3>


    <div3 id="xqueryx-mime-security">
      <head>Security Considerations</head>

      <p>Queries written in XQueryX may cause arbitrary URIs to be
      dereferenced.  Therefore, the security issues of [RFC 3023]
      Section 6 should be considered. 
      In addition, the contents of <code>file:</code> URIs can in some cases be
      accessed, processed and returned as results.</p>

      <p>Furthermore, because the XQuery language (and thus the XQueryX language) permits extensions, 
      it is possible that <code>application/xquery+xml</code>
      may describe content that has security implications beyond those described here. 
      However, if the processor follows only the normative semantics of this
      specification, this content will be ignored. Only in the case
      where the processor recognizes and processes the additional
      content, or where further processing of that content is dispatched
      to other processors, would security issues arise. </p>

      <p>The XML Query Working group is working on a facility to
      allow XQuery (and thus XQueryX) expressions to be used to create and update 
      persistent data.  Untrusted queries should not be given write
      access to data.</p>

    </div3>
 

    <div3 id="xqueryx-mime-interoperability">
      <head>Interoperability Considerations</head>

	    <p>See <xspecref spec="XQ" ref="id-xquery-conformance"/>. </p>

    </div3>


    <div3 id="xqueryx-mime-applications">
      <head>Applications That Use This Media Type</head>

    	<p>The public
	    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery Web page</loc>
	    lists more than two dozen implementations of the XQuery language,
	    both proprietary and open source.  Some of these are known to
      support XQueryX. </p>

  	  <p>This new media type is being registered to allow for deployment
	    of XQueryX on the World Wide Web.</p>

      <p>There is no experimental, vendor specific, or personal tree
      predecessor to "application/xquery+xml", reflecting the fact
      that no applications currently recognize it. This new type is
      being registered in order to allow for the expected deployment
      of XQueryX 1.0 on the World Wide Web, as a first class XML application.</p>

    </div3>


    <div3 id="xqueryx-mime-additional">
      <head>Additional Information</head>

      <div4 id="xqueryx-mime-recognizing">
        <head>Recognizing XQuery Files ("Magic Numbers")</head>

        <p>Although no byte sequences can be counted on to consistently
        identify XQueryX, XQueryX documents will have the sequence
        "http://www.w3.org/2005/XQueryX" to identify the XQueryX
        namespace. 
        This sequence will normally be found in a namespace attribute
        of the first element in the document.</p>

      </div4>


      <div4 id="xqueryx-mime-extensions">
        <head>File Extensions</head>

      	<p>The most common file extension in use for XQueryX is
	      <code>.xqx</code>. </p>

      </div4>


      <div4 id="xqueryx-mime-macfiletype">
        <head>Macintosh File Type Code(s)</head>

      	<p>The appropriate Macintosh file type code is <code>TEXT</code>.</p>

      </div4>

    </div3>


    <div3 id="xqueryx-mime-author">
      <head>Person and Email Address to Contact For Further Information</head>

      <p>Jim Melton, Oracle Corp.,
          <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jim.melton@oracle.com" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">jim.melton@oracle.com</loc></p>

    </div3>


    <div3 id="xqueryx-mime-intended-usage">
      <head>Intended Usage</head>

      <p>COMMON</p>

    </div3>


    <div3 id="xqueryx-mime-restrictions">
      <head>Restrictions on usage</head>

      <p>The intended usage of this media type is for interchange
	of XQueryX expressions.</p>

    </div3>


    <div3 id="xqueryx-mime-owner">
      <head>Author/Change Controller</head>

      <p>XQuery was produced by, and is maintained by, the World Wide Web
	Consortium's XML Query Working Group.  The W3C has change
	control over this specification.</p>

    </div3>

    <div3 id="xqueryx-mime-fragments">
      <head>Fragment Identifiers</head>

      <p>For documents labeled as 'application/xquery+xml', fragment identifiers
      are handled as specified in [RFC 3023].</p>

    </div3>


  </div2>

</div1>



    <inform-div1 id="changelog">
      <head>Change log</head>

      <p>This appendix lists the changes that have been made to this specification
      since the publication of the Candidate Recommendation Draft on 2005-11-03. </p>

      <ulist>

        <item>
		  <p>In response to Bugzilla bug #2611, the text of Section 5 was rewritten to clarify
		     the way in which XQuery is trivially embedded in XQueryX documents. 
		  </p>
		</item>

        <item>
		  <p>In response to Bugzilla bug #2523, changes have been made to both the XML Schema
		     for XQueryX and to the XSLT stylesheet for XQueryX.  The changes to the XML Schema
             eliminated xqx:rootExpr as a top-level element (it can now appear only as a component
			 of an xqx:pathExpr) and refined the content model for xqx:stepExpr (to make the use
			 of xqx:xpathAxis required in each step) and xqx:pathExpr (to more closely match the
			 XQuery surface syntax).  The changes to the XSLT stylesheet simply align the stylesheet
			 with the revised Schema. 
		  </p>
		</item>

		<item>
		  <p>In response to Bugzilla bug #3022, a change was made to the XSLT stylesheet for XQueryX.
		     The change fixed the handling of an empty xqx:Wildcard element so that it properly
			 generates the "*" required by XQuery surface syntax. 
		  </p>
		</item>

      </ulist>


    </inform-div1>

  </back>

</spec>